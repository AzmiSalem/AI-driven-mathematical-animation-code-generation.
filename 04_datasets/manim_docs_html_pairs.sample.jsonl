{"url": "https://docs.manim.community/en/stable/examples.html", "depth": 0, "instruction": "A logo composed of a black \"M\" (MathTex) is centered, surrounded by a green circle (left), a blue square (top), and a red triangle (right), all with full opacity. The background is light beige, creating a visually appealing contrast.", "code": "from manim import *\n\nclass ManimCELogo(Scene):\n    def construct(self):\n        self.camera.background_color = \"#ece6e2\"\n        logo_green = \"#87c2a5\"\n        logo_blue = \"#525893\"\n        logo_red = \"#e07a5f\"\n        logo_black = \"#343434\"\n        ds_m = MathTex(r\"\\mathbb{M}\", fill_color=logo_black).scale(7)\n        ds_m.shift(2.25 * LEFT + 1.5 * UP)\n        circle = Circle(color=logo_green, fill_opacity=1).shift(LEFT)\n        square = Square(color=logo_blue, fill_opacity=1).shift(UP)\n        triangle = Triangle(color=logo_red, fill_opacity=1).shift(RIGHT)\n        logo = VGroup(triangle, square, circle, ds_m)  # order matters\n        logo.move_to(ORIGIN)\n        self.add(logo)"}
{"url": "https://docs.manim.community/en/stable/examples.html", "depth": 0, "instruction": "The scene displays two colored dots positioned at (-2, -1) and (2, 1), connected by an orange line. Two braces annotate the line: one horizontal with the text \"Horizontal distance\" and one vertical with the text \"x-x‚ÇÅ\". All elements are added simultaneously without animations.", "code": "from manim import *\n\nclass BraceAnnotation(Scene):\n    def construct(self):\n        dot = Dot([-2, -1, 0])\n        dot2 = Dot([2, 1, 0])\n        line = Line(dot.get_center(), dot2.get_center()).set_color(ORANGE)\n        b1 = Brace(line)\n        b1text = b1.get_text(\"Horizontal distance\")\n        b2 = Brace(line, direction=line.copy().rotate(PI / 2).get_unit_vector())\n        b2text = b2.get_tex(\"x-x_1\")\n        self.add(line, dot, dot2, b1, b2, b1text, b2text)"}
{"url": "https://docs.manim.community/en/stable/examples.html", "depth": 0, "instruction": "The scene displays a 2D number plane with a blue dot at the origin (0, 0) and a green arrow pointing to (2, 2). Text labels for the origin and arrow tip are positioned below and to the right of their respective objects.", "code": "from manim import *\n\nclass VectorArrow(Scene):\n    def construct(self):\n        dot = Dot(ORIGIN)\n        arrow = Arrow(ORIGIN, [2, 2, 0], buff=0)\n        numberplane = NumberPlane()\n        origin_text = Text('(0, 0)').next_to(dot, DOWN)\n        tip_text = Text('(2, 2)').next_to(arrow.get_end(), RIGHT)\n        self.add(numberplane, dot, arrow, origin_text, tip_text)"}
{"url": "https://docs.manim.community/en/stable/examples.html", "depth": 0, "instruction": "A green SurroundingRectangle outlines a scaled-up gradient image transitioning from black to white, displayed prominently in the center of the scene. The image is created from a 256x256 array, with the rectangle appearing simultaneously as the image is added.", "code": "from manim import *\n\nclass GradientImageFromArray(Scene):\n    def construct(self):\n        n = 256\n        imageArray = np.uint8(\n            [[i * 256 / n for i in range(0, n)] for _ in range(0, n)]\n        )\n        image = ImageMobject(imageArray).scale(2)\n        image.background_rectangle = SurroundingRectangle(image, color=GREEN)\n        self.add(image, image.background_rectangle)"}
{"url": "https://docs.manim.community/en/stable/examples.html", "depth": 0, "instruction": "The scene displays two overlapping ellipses (one blue, one red) with a title above. Four shapes representing Boolean operations (intersection in green, union in orange, exclusion in yellow, difference in pink) animate into view, each accompanied by a label, with the camera focused on the center of the ellipses throughout.", "code": "from manim import *\n\nclass BooleanOperations(Scene):\n    def construct(self):\n        ellipse1 = Ellipse(\n            width=4.0, height=5.0, fill_opacity=0.5, color=BLUE, stroke_width=10\n        ).move_to(LEFT)\n        ellipse2 = ellipse1.copy().set_color(color=RED).move_to(RIGHT)\n        bool_ops_text = MarkupText(\"<u>Boolean Operation</u>\").next_to(ellipse1, UP * 3)\n        ellipse_group = Group(bool_ops_text, ellipse1, ellipse2).move_to(LEFT * 3)\n        self.play(FadeIn(ellipse_group))\n\n        i = Intersection(ellipse1, ellipse2, color=GREEN, fill_opacity=0.5)\n        self.play(i.animate.scale(0.25).move_to(RIGHT * 5 + UP * 2.5))\n        intersection_text = Text(\"Intersection\", font_size=23).next_to(i, UP)\n        self.play(FadeIn(intersection_text))\n\n        u = Union(ellipse1, ellipse2, color=ORANGE, fill_opacity=0.5)\n        union_text = Text(\"Union\", font_size=23)\n        self.play(u.animate.scale(0.3).next_to(i, DOWN, buff=union_text.height * 3))\n        union_text.next_to(u, UP)\n        self.play(FadeIn(union_text))\n\n        e = Exclusion(ellipse1, ellipse2, color=YELLOW, fill_opacity=0.5)\n        exclusion_text = Text(\"Exclusion\", font_size=23)\n        self.play(e.animate.scale(0.3).next_to(u, DOWN, buff=exclusion_text.height * 3.5))\n        exclusion_text.next_to(e, UP)\n        self.play(FadeIn(exclusion_text))\n\n        d = Difference(ellipse1, ellipse2, color=PINK, fill_opacity=0.5)\n        difference_text = Text(\"Difference\", font_size=23)\n        self.play(d.animate.scale(0.3).next_to(u, LEFT, buff=difference_text.height * 3.5))\n        difference_text.next_to(d, UP)\n        self.play(FadeIn(difference_text))"}
{"url": "https://docs.manim.community/en/stable/examples.html", "depth": 0, "instruction": "A blue circle grows from the center, while a dot moves along its perimeter for 2 seconds, then rotates around a point on a line for 1.5 seconds, with a second dot appearing to the right. The scene features smooth animations and a clear linear motion path.", "code": "from manim import *\n\nclass PointMovingOnShapes(Scene):\n    def construct(self):\n        circle = Circle(radius=1, color=BLUE)\n        dot = Dot()\n        dot2 = dot.copy().shift(RIGHT)\n        self.add(dot)\n\n        line = Line([3, 0, 0], [5, 0, 0])\n        self.add(line)\n\n        self.play(GrowFromCenter(circle))\n        self.play(Transform(dot, dot2))\n        self.play(MoveAlongPath(dot, circle), run_time=2, rate_func=linear)\n        self.play(Rotating(dot, about_point=[2, 0, 0]), run_time=1.5)\n        self.wait()"}
{"url": "https://docs.manim.community/en/stable/examples.html", "depth": 0, "instruction": "A blue square shifts left, changes to orange, scales down to 30% of its size, and rotates by 0.4 radians, with each transformation animated sequentially.", "code": "from manim import *\n\nclass MovingAround(Scene):\n    def construct(self):\n        square = Square(color=BLUE, fill_opacity=1)\n\n        self.play(square.animate.shift(LEFT))\n        self.play(square.animate.set_fill(ORANGE))\n        self.play(square.animate.scale(0.3))\n        self.play(square.animate.rotate(0.4))"}
{"url": "https://docs.manim.community/en/stable/examples.html", "depth": 0, "instruction": "A horizontal line rotates around the left point, forming an angle with a static line. The angle dynamically updates as the rotation progresses, with a label for theta that changes color to red during the animation. The scene includes smooth transitions over time, showcasing the angle's transformation from 110 to 350 degrees.", "code": "from manim import *\n\nclass MovingAngle(Scene):\n    def construct(self):\n        rotation_center = LEFT\n\n        theta_tracker = ValueTracker(110)\n        line1 = Line(LEFT, RIGHT)\n        line_moving = Line(LEFT, RIGHT)\n        line_ref = line_moving.copy()\n        line_moving.rotate(\n            theta_tracker.get_value() * DEGREES, about_point=rotation_center\n        )\n        a = Angle(line1, line_moving, radius=0.5, other_angle=False)\n        tex = MathTex(r\"\\theta\").move_to(\n            Angle(\n                line1, line_moving, radius=0.5 + 3 * SMALL_BUFF, other_angle=False\n            ).point_from_proportion(0.5)\n        )\n\n        self.add(line1, line_moving, a, tex)\n        self.wait()\n\n        line_moving.add_updater(\n            lambda x: x.become(line_ref.copy()).rotate(\n                theta_tracker.get_value() * DEGREES, about_point=rotation_center\n            )\n        )\n\n        a.add_updater(\n            lambda x: x.become(Angle(line1, line_moving, radius=0.5, other_angle=False))\n        )\n        tex.add_updater(\n            lambda x: x.move_to(\n                Angle(\n                    line1, line_moving, radius=0.5 + 3 * SMALL_BUFF, other_angle=False\n                ).point_from_proportion(0.5)\n            )\n        )\n\n        self.play(theta_tracker.animate.set_value(40))\n        self.play(theta_tracker.animate.increment_value(140))\n        self.play(tex.animate.set_color(RED), run_time=0.5)\n        self.play(theta_tracker.animate.set_value(350))"}
{"url": "https://docs.manim.community/en/stable/examples.html", "depth": 0, "instruction": "Two dots, one blue and one green, move horizontally and vertically to positions (5,0) and (0,4) respectively, connected by a red line that updates dynamically. The blue dot shifts right while the green dot shifts up, with both movements animated sequentially. The scene concludes with a brief pause.", "code": "from manim import *\n\nclass MovingDots(Scene):\n    def construct(self):\n        d1,d2=Dot(color=BLUE),Dot(color=GREEN)\n        dg=VGroup(d1,d2).arrange(RIGHT,buff=1)\n        l1=Line(d1.get_center(),d2.get_center()).set_color(RED)\n        x=ValueTracker(0)\n        y=ValueTracker(0)\n        d1.add_updater(lambda z: z.set_x(x.get_value()))\n        d2.add_updater(lambda z: z.set_y(y.get_value()))\n        l1.add_updater(lambda z: z.become(Line(d1.get_center(),d2.get_center())))\n        self.add(d1,d2,l1)\n        self.play(x.animate.set_value(5))\n        self.play(y.animate.set_value(4))\n        self.wait()"}
{"url": "https://docs.manim.community/en/stable/examples.html", "depth": 0, "instruction": "Four dots in a group (one red) scale to 1.4, positioned at left, center, right, and far right, animate shifting to a yellow dot at (4, 3, 0), with a 0.5-second pause afterward.", "code": "from manim import *\n\nclass MovingGroupToDestination(Scene):\n    def construct(self):\n        group = VGroup(Dot(LEFT), Dot(ORIGIN), Dot(RIGHT, color=RED), Dot(2 * RIGHT)).scale(1.4)\n        dest = Dot([4, 3, 0], color=YELLOW)\n        self.add(group, dest)\n        self.play(group.animate.shift(dest.get_center() - group[2].get_center()))\n        self.wait(0.5)"}
{"url": "https://docs.manim.community/en/stable/examples.html", "depth": 0, "instruction": "The scene displays a mathematical expression with a focus on two specific terms, highlighted by surrounding rectangles. Initially, the first rectangle appears around the second term, then smoothly transforms into a rectangle around the fourth term, with pauses between animations for emphasis. The background remains static throughout.", "code": "from manim import *\n\nclass MovingFrameBox(Scene):\n    def construct(self):\n        text=MathTex(\n            \"\\\\frac{d}{dx}f(x)g(x)=\",\"f(x)\\\\frac{d}{dx}g(x)\",\"+\",\n            \"g(x)\\\\frac{d}{dx}f(x)\"\n        )\n        self.play(Write(text))\n        framebox1 = SurroundingRectangle(text[1], buff = .1)\n        framebox2 = SurroundingRectangle(text[3], buff = .1)\n        self.play(\n            Create(framebox1),\n        )\n        self.wait()\n        self.play(\n            ReplacementTransform(framebox1,framebox2),\n        )\n        self.wait()"}
{"url": "https://docs.manim.community/en/stable/examples.html", "depth": 0, "instruction": "A white reference line and a yellow line rotate around the origin. The yellow line rotates clockwise for 2 seconds, then counterclockwise for another 2 seconds, before pausing for 0.5 seconds.", "code": "from manim import *\n\nclass RotationUpdater(Scene):\n    def construct(self):\n        def updater_forth(mobj, dt):\n            mobj.rotate_about_origin(dt)\n        def updater_back(mobj, dt):\n            mobj.rotate_about_origin(-dt)\n        line_reference = Line(ORIGIN, LEFT).set_color(WHITE)\n        line_moving = Line(ORIGIN, LEFT).set_color(YELLOW)\n        line_moving.add_updater(updater_forth)\n        self.add(line_reference, line_moving)\n        self.wait(2)\n        line_moving.remove_updater(updater_forth)\n        line_moving.add_updater(updater_back)\n        self.wait(2)\n        line_moving.remove_updater(updater_back)\n        self.wait(0.5)"}
{"url": "https://docs.manim.community/en/stable/examples.html", "depth": 0, "instruction": "A rotating dot traces a path in real-time, moving counterclockwise around the point (1,0) for 2 seconds, then shifts upward and left, with the path dynamically updating to reflect its movement. The scene concludes with a brief pause.", "code": "from manim import *\n\nclass PointWithTrace(Scene):\n    def construct(self):\n        path = VMobject()\n        dot = Dot()\n        path.set_points_as_corners([dot.get_center(), dot.get_center()])\n        def update_path(path):\n            previous_path = path.copy()\n            previous_path.add_points_as_corners([dot.get_center()])\n            path.become(previous_path)\n        path.add_updater(update_path)\n        self.add(path, dot)\n        self.play(Rotating(dot, radians=PI, about_point=RIGHT, run_time=2))\n        self.wait()\n        self.play(dot.animate.shift(UP))\n        self.play(dot.animate.shift(LEFT))\n        self.wait()"}
{"url": "https://docs.manim.community/en/stable/examples.html", "depth": 0, "instruction": "The scene displays a set of axes with a green color scheme, featuring blue sine and red cosine graphs. A yellow vertical line intersects the cosine graph at \\(x=2\\pi\\), labeled in white. The axes are annotated with labels for sine and cosine functions, while the overall composition is neatly grouped for clarity.", "code": "from manim import *\n\nclass SinAndCosFunctionPlot(Scene):\n    def construct(self):\n        axes = Axes(\n            x_range=[-10, 10.3, 1],\n            y_range=[-1.5, 1.5, 1],\n            x_length=10,\n            axis_config={\"color\": GREEN},\n            x_axis_config={\n                \"numbers_to_include\": np.arange(-10, 10.01, 2),\n                \"numbers_with_elongated_ticks\": np.arange(-10, 10.01, 2),\n            },\n            tips=False,\n        )\n        axes_labels = axes.get_axis_labels()\n        sin_graph = axes.plot(lambda x: np.sin(x), color=BLUE)\n        cos_graph = axes.plot(lambda x: np.cos(x), color=RED)\n\n        sin_label = axes.get_graph_label(\n            sin_graph, \"\\\\sin(x)\", x_val=-10, direction=UP / 2\n        )\n        cos_label = axes.get_graph_label(cos_graph, label=\"\\\\cos(x)\")\n\n        vert_line = axes.get_vertical_line(\n            axes.i2gp(TAU, cos_graph), color=YELLOW, line_func=Line\n        )\n        line_label = axes.get_graph_label(\n            cos_graph, r\"x=2\\pi\", x_val=TAU, direction=UR, color=WHITE\n        )\n\n        plot = VGroup(axes, sin_graph, cos_graph, vert_line)\n        labels = VGroup(axes_labels, sin_label, cos_label, line_label)\n        self.add(plot, labels)"}
{"url": "https://docs.manim.community/en/stable/examples.html", "depth": 0, "instruction": "The scene features a coordinate system with axes labeled \"x\" and \"f(x)\", a maroon quadratic graph, and a moving dot that traces the graph's minimum point. The dot animates to the minimum x-value, highlighting the minimum visually, followed by a brief pause.", "code": "from manim import *\n\nclass ArgMinExample(Scene):\n    def construct(self):\n        ax = Axes(\n            x_range=[0, 10], y_range=[0, 100, 10], axis_config={\"include_tip\": False}\n        )\n        labels = ax.get_axis_labels(x_label=\"x\", y_label=\"f(x)\")\n\n        t = ValueTracker(0)\n\n        def func(x):\n            return 2 * (x - 5) ** 2\n        graph = ax.plot(func, color=MAROON)\n\n        initial_point = [ax.coords_to_point(t.get_value(), func(t.get_value()))]\n        dot = Dot(point=initial_point)\n\n        dot.add_updater(lambda x: x.move_to(ax.c2p(t.get_value(), func(t.get_value()))))\n        x_space = np.linspace(*ax.x_range[:2],200)\n        minimum_index = func(x_space).argmin()\n\n        self.add(ax, labels, graph, dot)\n        self.play(t.animate.set_value(x_space[minimum_index]))\n        self.wait()"}
{"url": "https://docs.manim.community/en/stable/examples.html", "depth": 0, "instruction": "The scene displays a coordinate system with labeled axes, featuring two curves (one blue and one green), vertical yellow lines at specific x-values, a semi-transparent blue Riemann rectangle area under the first curve, and a grey shaded area between the two curves, all arranged within a defined x and y range.", "code": "from manim import *\n\nclass GraphAreaPlot(Scene):\n    def construct(self):\n        ax = Axes(\n            x_range=[0, 5],\n            y_range=[0, 6],\n            x_axis_config={\"numbers_to_include\": [2, 3]},\n            tips=False,\n        )\n\n        labels = ax.get_axis_labels()\n\n        curve_1 = ax.plot(lambda x: 4 * x - x ** 2, x_range=[0, 4], color=BLUE_C)\n        curve_2 = ax.plot(\n            lambda x: 0.8 * x ** 2 - 3 * x + 4,\n            x_range=[0, 4],\n            color=GREEN_B,\n        )\n\n        line_1 = ax.get_vertical_line(ax.input_to_graph_point(2, curve_1), color=YELLOW)\n        line_2 = ax.get_vertical_line(ax.i2gp(3, curve_1), color=YELLOW)\n\n        riemann_area = ax.get_riemann_rectangles(curve_1, x_range=[0.3, 0.6], dx=0.03, color=BLUE, fill_opacity=0.5)\n        area = ax.get_area(curve_2, [2, 3], bounded_graph=curve_1, color=GREY, opacity=0.5)\n\n        self.add(ax, labels, curve_1, curve_2, line_1, line_2, riemann_area, area)"}
{"url": "https://docs.manim.community/en/stable/examples.html", "depth": 0, "instruction": "The scene features a 2D coordinate system with axes, a yellow hyperbolic graph, and a blue semi-transparent polygon that dynamically adjusts its shape. A dot moves along the graph, updating its position as a value tracker animates from 10 to 0.5 and back to 5, with smooth transitions and a focus on the polygon's creation.", "code": "from manim import *\n\nclass PolygonOnAxes(Scene):\n    def get_rectangle_corners(self, bottom_left, top_right):\n        return [\n            (top_right[0], top_right[1]),\n            (bottom_left[0], top_right[1]),\n            (bottom_left[0], bottom_left[1]),\n            (top_right[0], bottom_left[1]),\n        ]\n\n    def construct(self):\n        ax = Axes(\n            x_range=[0, 10],\n            y_range=[0, 10],\n            x_length=6,\n            y_length=6,\n            axis_config={\"include_tip\": False},\n        )\n\n        t = ValueTracker(5)\n        k = 25\n\n        graph = ax.plot(\n            lambda x: k / x,\n            color=YELLOW_D,\n            x_range=[k / 10, 10.0, 0.01],\n            use_smoothing=False,\n        )\n\n        def get_rectangle():\n            polygon = Polygon(\n                *[\n                    ax.c2p(*i)\n                    for i in self.get_rectangle_corners(\n                        (0, 0), (t.get_value(), k / t.get_value())\n                    )\n                ]\n            )\n            polygon.stroke_width = 1\n            polygon.set_fill(BLUE, opacity=0.5)\n            polygon.set_stroke(YELLOW_B)\n            return polygon\n\n        polygon = always_redraw(get_rectangle)\n\n        dot = Dot()\n        dot.add_updater(lambda x: x.move_to(ax.c2p(t.get_value(), k / t.get_value())))\n        dot.set_z_index(10)\n\n        self.add(ax, graph, dot)\n        self.play(Create(polygon))\n        self.play(t.animate.set_value(10))\n        self.play(t.animate.set_value(k / 10))\n        self.play(t.animate.set_value(5))"}
{"url": "https://docs.manim.community/en/stable/examples.html", "depth": 0, "instruction": "The scene displays a 2D coordinate system with labeled axes, featuring a line graph plotted with points at (0, 20), (8, 0), (38, 0), and (39, -5). The axes are 9 units long horizontally and 6 units vertically, with specific tick marks and labels for both axes.", "code": "from manim import *\n\nclass HeatDiagramPlot(Scene):\n    def construct(self):\n        ax = Axes(\n            x_range=[0, 40, 5],\n            y_range=[-8, 32, 5],\n            x_length=9,\n            y_length=6,\n            x_axis_config={\"numbers_to_include\": np.arange(0, 40, 5)},\n            y_axis_config={\"numbers_to_include\": np.arange(-5, 34, 5)},\n            tips=False,\n        )\n        labels = ax.get_axis_labels(\n            x_label=Tex(r\"$\\Delta Q$\"), y_label=Tex(r\"T[$^\\circ C$]\")\n        )\n\n        x_vals = [0, 8, 38, 39]\n        y_vals = [20, 0, 0, -5]\n        graph = ax.plot_line_graph(x_values=x_vals, y_values=y_vals)\n\n        self.add(ax, labels, graph)"}
{"url": "https://docs.manim.community/en/stable/examples.html", "depth": 0, "instruction": "A blue sine wave graph is displayed on a grid of axes, with two static dots at the endpoints and an orange dot moving along the curve. The camera smoothly zooms in and follows the orange dot's path, then restores to its original position after the animation.", "code": "from manim import *\n\nclass FollowingGraphCamera(MovingCameraScene):\n    def construct(self):\n        self.camera.frame.save_state()\n\n        # create the axes and the curve\n        ax = Axes(x_range=[-1, 10], y_range=[-1, 10])\n        graph = ax.plot(lambda x: np.sin(x), color=BLUE, x_range=[0, 3 * PI])\n\n        # create dots based on the graph\n        moving_dot = Dot(ax.i2gp(graph.t_min, graph), color=ORANGE)\n        dot_1 = Dot(ax.i2gp(graph.t_min, graph))\n        dot_2 = Dot(ax.i2gp(graph.t_max, graph))\n\n        self.add(ax, graph, dot_1, dot_2, moving_dot)\n        self.play(self.camera.frame.animate.scale(0.5).move_to(moving_dot))\n\n        def update_curve(mob):\n            mob.move_to(moving_dot.get_center())\n\n        self.camera.frame.add_updater(update_curve)\n        self.play(MoveAlongPath(moving_dot, graph, rate_func=linear))\n        self.camera.frame.remove_updater(update_curve)\n\n        self.play(Restore(self.camera.frame))"}
{"url": "https://docs.manim.community/en/stable/examples.html", "depth": 0, "instruction": "The scene features a zoomed camera effect on a colorful image with a purple frame and a dot positioned at the upper left. Text labels appear and fade in/out, while the frame and zoomed display scale and shift dynamically. A background rectangle updates to match the zoomed display, enhancing the visual focus on the zoomed area.", "code": "from manim import *\n\nclass MovingZoomedSceneAround(ZoomedScene):\n# contributed by TheoremofBeethoven, www.youtube.com/c/TheoremofBeethoven\n    def __init__(self, **kwargs):\n        ZoomedScene.__init__(\n            self,\n            zoom_factor=0.3,\n            zoomed_display_height=1,\n            zoomed_display_width=6,\n            image_frame_stroke_width=20,\n            zoomed_camera_config={\n                \"default_frame_stroke_width\": 3,\n                },\n            **kwargs\n        )\n\n    def construct(self):\n        dot = Dot().shift(UL * 2)\n        image = ImageMobject(np.uint8([[0, 100, 30, 200],\n                                       [255, 0, 5, 33]]))\n        image.height = 7\n        frame_text = Text(\"Frame\", color=PURPLE, font_size=67)\n        zoomed_camera_text = Text(\"Zoomed camera\", color=RED, font_size=67)\n\n        self.add(image, dot)\n        zoomed_camera = self.zoomed_camera\n        zoomed_display = self.zoomed_display\n        frame = zoomed_camera.frame\n        zoomed_display_frame = zoomed_display.display_frame\n\n        frame.move_to(dot)\n        frame.set_color(PURPLE)\n        zoomed_display_frame.set_color(RED)\n        zoomed_display.shift(DOWN)\n\n        zd_rect = BackgroundRectangle(zoomed_display, fill_opacity=0, buff=MED_SMALL_BUFF)\n        self.add_foreground_mobject(zd_rect)\n\n        unfold_camera = UpdateFromFunc(zd_rect, lambda rect: rect.replace(zoomed_display))\n\n        frame_text.next_to(frame, DOWN)\n\n        self.play(Create(frame), FadeIn(frame_text, shift=UP))\n        self.activate_zooming()\n\n        self.play(self.get_zoomed_display_pop_out_animation(), unfold_camera)\n        zoomed_camera_text.next_to(zoomed_display_frame, DOWN)\n        self.play(FadeIn(zoomed_camera_text, shift=UP))\n        # Scale in        x   y  z\n        scale_factor = [0.5, 1.5, 0]\n        self.play(\n            frame.animate.scale(scale_factor),\n            zoomed_display.animate.scale(scale_factor),\n            FadeOut(zoomed_camera_text),\n            FadeOut(frame_text)\n        )\n        self.wait()\n        self.play(ScaleInPlace(zoomed_display, 2))\n        self.wait()\n        self.play(frame.animate.shift(2.5 * DOWN))\n        self.wait()\n        self.play(self.get_zoomed_display_pop_out_animation(), unfold_camera, rate_func=lambda t: smooth(1 - t))\n        self.play(Uncreate(zoomed_display_frame), FadeOut(frame))\n        self.wait()"}
