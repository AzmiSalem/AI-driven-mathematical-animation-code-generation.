{"url": "https://docs.manim.community/en/stable/examples.html", "depth": 0, "instruction": "A logo composed of a black \"M\" in the center, surrounded by a green circle, blue square, and red triangle, all on a light beige background. The logo is centered in the scene, with each shape fully opaque and positioned around the \"M\".", "code": "from manim import *\n\nclass ManimCELogo(Scene):\n    def construct(self):\n        self.camera.background_color = \"#ece6e2\"\n        logo_green = \"#87c2a5\"\n        logo_blue = \"#525893\"\n        logo_red = \"#e07a5f\"\n        logo_black = \"#343434\"\n        ds_m = MathTex(r\"\\mathbb{M}\", fill_color=logo_black).scale(7)\n        ds_m.shift(2.25 * LEFT + 1.5 * UP)\n        circle = Circle(color=logo_green, fill_opacity=1).shift(LEFT)\n        square = Square(color=logo_blue, fill_opacity=1).shift(UP)\n        triangle = Triangle(color=logo_red, fill_opacity=1).shift(RIGHT)\n        logo = VGroup(triangle, square, circle, ds_m)  # order matters\n        logo.move_to(ORIGIN)\n        self.add(logo)", "code_sha1": "4b062be49d23cb07402ff5bb3c3ab29d21ad7035"}
{"url": "https://docs.manim.community/en/stable/examples.html", "depth": 0, "instruction": "The scene displays two dots positioned at (-2, -1) and (2, 1), connected by an orange line. Two braces annotate the line: one labeled \"Horizontal distance\" and the other labeled \"x-x_1\", both positioned appropriately.", "code": "from manim import *\n\nclass BraceAnnotation(Scene):\n    def construct(self):\n        dot = Dot([-2, -1, 0])\n        dot2 = Dot([2, 1, 0])\n        line = Line(dot.get_center(), dot2.get_center()).set_color(ORANGE)\n        b1 = Brace(line)\n        b1text = b1.get_text(\"Horizontal distance\")\n        b2 = Brace(line, direction=line.copy().rotate(PI / 2).get_unit_vector())\n        b2text = b2.get_tex(\"x-x_1\")\n        self.add(line, dot, dot2, b1, b2, b1text, b2text)", "code_sha1": "e7c18a774792f6d280c97b2dd2f809d8af7e4b78"}
{"url": "https://docs.manim.community/en/stable/examples.html", "depth": 0, "instruction": "A scene displays a NumberPlane with a blue Dot at the origin (0, 0) and a green Arrow pointing to (2, 2). Text labels '(0, 0)' and '(2, 2)' are positioned below the Dot and to the right of the Arrow's tip, respectively.", "code": "from manim import *\n\nclass VectorArrow(Scene):\n    def construct(self):\n        dot = Dot(ORIGIN)\n        arrow = Arrow(ORIGIN, [2, 2, 0], buff=0)\n        numberplane = NumberPlane()\n        origin_text = Text('(0, 0)').next_to(dot, DOWN)\n        tip_text = Text('(2, 2)').next_to(arrow.get_end(), RIGHT)\n        self.add(numberplane, dot, arrow, origin_text, tip_text)", "code_sha1": "9ff596ebef4b7685f2e06576b830cfed767127bb"}
{"url": "https://docs.manim.community/en/stable/examples.html", "depth": 0, "instruction": "A green SurroundingRectangle highlights a scaled-up gradient image transitioning from black to white, occupying the center of the scene. The image is composed of a 256x256 pixel array, with the rectangle appearing behind the image, emphasizing its edges.", "code": "from manim import *\n\nclass GradientImageFromArray(Scene):\n    def construct(self):\n        n = 256\n        imageArray = np.uint8(\n            [[i * 256 / n for i in range(0, n)] for _ in range(0, n)]\n        )\n        image = ImageMobject(imageArray).scale(2)\n        image.background_rectangle = SurroundingRectangle(image, color=GREEN)\n        self.add(image, image.background_rectangle)", "code_sha1": "8aa74c030c6d2a7cc58afcfaf20b495175005cb4"}
{"url": "https://docs.manim.community/en/stable/examples.html", "depth": 0, "instruction": "The scene displays two overlapping ellipses (blue and red) with a title above. Four colored shapes (green, orange, yellow, pink) representing intersection, union, exclusion, and difference animate into position with fade-ins and scaling, each accompanied by labeled text. The entire group is initially positioned left, with the camera focused on the center.", "code": "from manim import *\n\nclass BooleanOperations(Scene):\n    def construct(self):\n        ellipse1 = Ellipse(\n            width=4.0, height=5.0, fill_opacity=0.5, color=BLUE, stroke_width=10\n        ).move_to(LEFT)\n        ellipse2 = ellipse1.copy().set_color(color=RED).move_to(RIGHT)\n        bool_ops_text = MarkupText(\"<u>Boolean Operation</u>\").next_to(ellipse1, UP * 3)\n        ellipse_group = Group(bool_ops_text, ellipse1, ellipse2).move_to(LEFT * 3)\n        self.play(FadeIn(ellipse_group))\n\n        i = Intersection(ellipse1, ellipse2, color=GREEN, fill_opacity=0.5)\n        self.play(i.animate.scale(0.25).move_to(RIGHT * 5 + UP * 2.5))\n        intersection_text = Text(\"Intersection\", font_size=23).next_to(i, UP)\n        self.play(FadeIn(intersection_text))\n\n        u = Union(ellipse1, ellipse2, color=ORANGE, fill_opacity=0.5)\n        union_text = Text(\"Union\", font_size=23)\n        self.play(u.animate.scale(0.3).next_to(i, DOWN, buff=union_text.height * 3))\n        union_text.next_to(u, UP)\n        self.play(FadeIn(union_text))\n\n        e = Exclusion(ellipse1, ellipse2, color=YELLOW, fill_opacity=0.5)\n        exclusion_text = Text(\"Exclusion\", font_size=23)\n        self.play(e.animate.scale(0.3).next_to(u, DOWN, buff=exclusion_text.height * 3.5))\n        exclusion_text.next_to(e, UP)\n        self.play(FadeIn(exclusion_text))\n\n        d = Difference(ellipse1, ellipse2, color=PINK, fill_opacity=0.5)\n        difference_text = Text(\"Difference\", font_size=23)\n        self.play(d.animate.scale(0.3).next_to(u, LEFT, buff=difference_text.height * 3.5))\n        difference_text.next_to(d, UP)\n        self.play(FadeIn(difference_text))", "code_sha1": "43a5b2731cea0e4e13aa1ee96695555ebcd018f6"}
{"url": "https://docs.manim.community/en/stable/examples.html", "depth": 0, "instruction": "A blue circle grows from the center, while a dot moves along its perimeter for 2 seconds, then rotates around a point on a line for 1.5 seconds, with a second dot initially positioned to the right. The scene includes a horizontal line and a waiting period at the end.", "code": "from manim import *\n\nclass PointMovingOnShapes(Scene):\n    def construct(self):\n        circle = Circle(radius=1, color=BLUE)\n        dot = Dot()\n        dot2 = dot.copy().shift(RIGHT)\n        self.add(dot)\n\n        line = Line([3, 0, 0], [5, 0, 0])\n        self.add(line)\n\n        self.play(GrowFromCenter(circle))\n        self.play(Transform(dot, dot2))\n        self.play(MoveAlongPath(dot, circle), run_time=2, rate_func=linear)\n        self.play(Rotating(dot, about_point=[2, 0, 0]), run_time=1.5)\n        self.wait()", "code_sha1": "35f0787366f72edc803bf941e4366d9243e13574"}
{"url": "https://docs.manim.community/en/stable/examples.html", "depth": 0, "instruction": "A blue square shifts left, changes to orange, scales down to 30% of its size, and rotates by 0.4 radians, with each transformation animated sequentially.", "code": "from manim import *\n\nclass MovingAround(Scene):\n    def construct(self):\n        square = Square(color=BLUE, fill_opacity=1)\n\n        self.play(square.animate.shift(LEFT))\n        self.play(square.animate.set_fill(ORANGE))\n        self.play(square.animate.scale(0.3))\n        self.play(square.animate.rotate(0.4))", "code_sha1": "27350e0b66e9fa75b409f3d201217c0661e15df5"}
{"url": "https://docs.manim.community/en/stable/examples.html", "depth": 0, "instruction": "A horizontal line rotates around the left point, forming an angle with a static line. The angle dynamically updates as the rotation progresses, with a label moving to its midpoint. The label briefly turns red during the animation, which transitions from 110° to 350° over time, showcasing smooth motion and real-time updates.", "code": "from manim import *\n\nclass MovingAngle(Scene):\n    def construct(self):\n        rotation_center = LEFT\n\n        theta_tracker = ValueTracker(110)\n        line1 = Line(LEFT, RIGHT)\n        line_moving = Line(LEFT, RIGHT)\n        line_ref = line_moving.copy()\n        line_moving.rotate(\n            theta_tracker.get_value() * DEGREES, about_point=rotation_center\n        )\n        a = Angle(line1, line_moving, radius=0.5, other_angle=False)\n        tex = MathTex(r\"\\theta\").move_to(\n            Angle(\n                line1, line_moving, radius=0.5 + 3 * SMALL_BUFF, other_angle=False\n            ).point_from_proportion(0.5)\n        )\n\n        self.add(line1, line_moving, a, tex)\n        self.wait()\n\n        line_moving.add_updater(\n            lambda x: x.become(line_ref.copy()).rotate(\n                theta_tracker.get_value() * DEGREES, about_point=rotation_center\n            )\n        )\n\n        a.add_updater(\n            lambda x: x.become(Angle(line1, line_moving, radius=0.5, other_angle=False))\n        )\n        tex.add_updater(\n            lambda x: x.move_to(\n                Angle(\n                    line1, line_moving, radius=0.5 + 3 * SMALL_BUFF, other_angle=False\n                ).point_from_proportion(0.5)\n            )\n        )\n\n        self.play(theta_tracker.animate.set_value(40))\n        self.play(theta_tracker.animate.increment_value(140))\n        self.play(tex.animate.set_color(RED), run_time=0.5)\n        self.play(theta_tracker.animate.set_value(350))", "code_sha1": "097a24d61c557693c32f8c736f1c3906b032c845"}
{"url": "https://docs.manim.community/en/stable/examples.html", "depth": 0, "instruction": "Two dots, one blue and one green, move horizontally and vertically to positions (5, 0) and (0, 4) respectively, connected by a red line that updates dynamically. The animation progresses smoothly, with the dots moving simultaneously, followed by a brief pause.", "code": "from manim import *\n\nclass MovingDots(Scene):\n    def construct(self):\n        d1,d2=Dot(color=BLUE),Dot(color=GREEN)\n        dg=VGroup(d1,d2).arrange(RIGHT,buff=1)\n        l1=Line(d1.get_center(),d2.get_center()).set_color(RED)\n        x=ValueTracker(0)\n        y=ValueTracker(0)\n        d1.add_updater(lambda z: z.set_x(x.get_value()))\n        d2.add_updater(lambda z: z.set_y(y.get_value()))\n        l1.add_updater(lambda z: z.become(Line(d1.get_center(),d2.get_center())))\n        self.add(d1,d2,l1)\n        self.play(x.animate.set_value(5))\n        self.play(y.animate.set_value(4))\n        self.wait()", "code_sha1": "4185ced68dfb1657bfd19c72cefae1bab4202fb5"}
{"url": "https://docs.manim.community/en/stable/examples.html", "depth": 0, "instruction": "A group of four dots, scaled to 1.4 times their original size, moves from their initial positions to a yellow destination dot at (4, 3, 0), with the red dot leading the movement. The animation lasts briefly, followed by a 0.5-second pause.", "code": "from manim import *\n\nclass MovingGroupToDestination(Scene):\n    def construct(self):\n        group = VGroup(Dot(LEFT), Dot(ORIGIN), Dot(RIGHT, color=RED), Dot(2 * RIGHT)).scale(1.4)\n        dest = Dot([4, 3, 0], color=YELLOW)\n        self.add(group, dest)\n        self.play(group.animate.shift(dest.get_center() - group[2].get_center()))\n        self.wait(0.5)", "code_sha1": "9ad10f3b24540ea15e56a8716c8045083b163978"}
{"url": "https://docs.manim.community/en/stable/examples.html", "depth": 0, "instruction": "The scene features a MathTex equation displayed in white, with two surrounding rectangles appearing sequentially around specific terms. The first rectangle is created around the second term, then smoothly transforms into a rectangle around the fourth term, with pauses in between for emphasis. The background remains black throughout.", "code": "from manim import *\n\nclass MovingFrameBox(Scene):\n    def construct(self):\n        text=MathTex(\n            \"\\\\frac{d}{dx}f(x)g(x)=\",\"f(x)\\\\frac{d}{dx}g(x)\",\"+\",\n            \"g(x)\\\\frac{d}{dx}f(x)\"\n        )\n        self.play(Write(text))\n        framebox1 = SurroundingRectangle(text[1], buff = .1)\n        framebox2 = SurroundingRectangle(text[3], buff = .1)\n        self.play(\n            Create(framebox1),\n        )\n        self.wait()\n        self.play(\n            ReplacementTransform(framebox1,framebox2),\n        )\n        self.wait()", "code_sha1": "5f7bada6ab1efad79d53eda528ae680bc1b2a476"}
{"url": "https://docs.manim.community/en/stable/examples.html", "depth": 0, "instruction": "A white reference line and a yellow line rotate around the origin. The yellow line rotates clockwise for 2 seconds, then counterclockwise for another 2 seconds, before stopping. The scene has a dark background, emphasizing the lines' colors and movements.", "code": "from manim import *\n\nclass RotationUpdater(Scene):\n    def construct(self):\n        def updater_forth(mobj, dt):\n            mobj.rotate_about_origin(dt)\n        def updater_back(mobj, dt):\n            mobj.rotate_about_origin(-dt)\n        line_reference = Line(ORIGIN, LEFT).set_color(WHITE)\n        line_moving = Line(ORIGIN, LEFT).set_color(YELLOW)\n        line_moving.add_updater(updater_forth)\n        self.add(line_reference, line_moving)\n        self.wait(2)\n        line_moving.remove_updater(updater_forth)\n        line_moving.add_updater(updater_back)\n        self.wait(2)\n        line_moving.remove_updater(updater_back)\n        self.wait(0.5)", "code_sha1": "50a69defe87e7815f57bd88e65afff82e31eed38"}
{"url": "https://docs.manim.community/en/stable/examples.html", "depth": 0, "instruction": "A rotating dot traces a path in a circular motion, followed by upward and leftward shifts, with the path dynamically updating to reflect the dot's movement. The scene features a black background, and the dot is colored blue, while the path is a light blue line.", "code": "from manim import *\n\nclass PointWithTrace(Scene):\n    def construct(self):\n        path = VMobject()\n        dot = Dot()\n        path.set_points_as_corners([dot.get_center(), dot.get_center()])\n        def update_path(path):\n            previous_path = path.copy()\n            previous_path.add_points_as_corners([dot.get_center()])\n            path.become(previous_path)\n        path.add_updater(update_path)\n        self.add(path, dot)\n        self.play(Rotating(dot, radians=PI, about_point=RIGHT, run_time=2))\n        self.wait()\n        self.play(dot.animate.shift(UP))\n        self.play(dot.animate.shift(LEFT))\n        self.wait()", "code_sha1": "892ad1fae4154f591a922fd0026f1de575a2215b"}
{"url": "https://docs.manim.community/en/stable/examples.html", "depth": 0, "instruction": "The scene displays a green coordinate axes with blue sine and red cosine graphs plotted. A yellow vertical line intersects the cosine graph at \\(x = 2\\pi\\), labeled in white. The axes include labeled ticks, and the sine and cosine functions are annotated with their respective labels. All elements are grouped and added to the scene.", "code": "from manim import *\n\nclass SinAndCosFunctionPlot(Scene):\n    def construct(self):\n        axes = Axes(\n            x_range=[-10, 10.3, 1],\n            y_range=[-1.5, 1.5, 1],\n            x_length=10,\n            axis_config={\"color\": GREEN},\n            x_axis_config={\n                \"numbers_to_include\": np.arange(-10, 10.01, 2),\n                \"numbers_with_elongated_ticks\": np.arange(-10, 10.01, 2),\n            },\n            tips=False,\n        )\n        axes_labels = axes.get_axis_labels()\n        sin_graph = axes.plot(lambda x: np.sin(x), color=BLUE)\n        cos_graph = axes.plot(lambda x: np.cos(x), color=RED)\n\n        sin_label = axes.get_graph_label(\n            sin_graph, \"\\\\sin(x)\", x_val=-10, direction=UP / 2\n        )\n        cos_label = axes.get_graph_label(cos_graph, label=\"\\\\cos(x)\")\n\n        vert_line = axes.get_vertical_line(\n            axes.i2gp(TAU, cos_graph), color=YELLOW, line_func=Line\n        )\n        line_label = axes.get_graph_label(\n            cos_graph, r\"x=2\\pi\", x_val=TAU, direction=UR, color=WHITE\n        )\n\n        plot = VGroup(axes, sin_graph, cos_graph, vert_line)\n        labels = VGroup(axes_labels, sin_label, cos_label, line_label)\n        self.add(plot, labels)", "code_sha1": "c76f32b92282146a1f3334e81a98c9b2882fb8c0"}
{"url": "https://docs.manim.community/en/stable/examples.html", "depth": 0, "instruction": "The scene displays a coordinate system with axes labeled \"x\" and \"f(x)\", a maroon quadratic graph, and a moving dot that traces the graph. The dot animates to the minimum point of the function, highlighting the minimum value visually. The animation concludes with a pause, emphasizing the final position of the dot.", "code": "from manim import *\n\nclass ArgMinExample(Scene):\n    def construct(self):\n        ax = Axes(\n            x_range=[0, 10], y_range=[0, 100, 10], axis_config={\"include_tip\": False}\n        )\n        labels = ax.get_axis_labels(x_label=\"x\", y_label=\"f(x)\")\n\n        t = ValueTracker(0)\n\n        def func(x):\n            return 2 * (x - 5) ** 2\n        graph = ax.plot(func, color=MAROON)\n\n        initial_point = [ax.coords_to_point(t.get_value(), func(t.get_value()))]\n        dot = Dot(point=initial_point)\n\n        dot.add_updater(lambda x: x.move_to(ax.c2p(t.get_value(), func(t.get_value()))))\n        x_space = np.linspace(*ax.x_range[:2],200)\n        minimum_index = func(x_space).argmin()\n\n        self.add(ax, labels, graph, dot)\n        self.play(t.animate.set_value(x_space[minimum_index]))\n        self.wait()", "code_sha1": "ada9b26c70db01f9e6364fc57d44f33b9516cade"}
{"url": "https://docs.manim.community/en/stable/examples.html", "depth": 0, "instruction": "The scene displays a coordinate system with labeled axes, two curves (one blue and one green), vertical yellow lines at x=2 and x=3, a semi-transparent blue Riemann rectangle between x=0.3 and x=0.6 under the blue curve, and a grey shaded area between the two curves from x=2 to x=3.", "code": "from manim import *\n\nclass GraphAreaPlot(Scene):\n    def construct(self):\n        ax = Axes(\n            x_range=[0, 5],\n            y_range=[0, 6],\n            x_axis_config={\"numbers_to_include\": [2, 3]},\n            tips=False,\n        )\n\n        labels = ax.get_axis_labels()\n\n        curve_1 = ax.plot(lambda x: 4 * x - x ** 2, x_range=[0, 4], color=BLUE_C)\n        curve_2 = ax.plot(\n            lambda x: 0.8 * x ** 2 - 3 * x + 4,\n            x_range=[0, 4],\n            color=GREEN_B,\n        )\n\n        line_1 = ax.get_vertical_line(ax.input_to_graph_point(2, curve_1), color=YELLOW)\n        line_2 = ax.get_vertical_line(ax.i2gp(3, curve_1), color=YELLOW)\n\n        riemann_area = ax.get_riemann_rectangles(curve_1, x_range=[0.3, 0.6], dx=0.03, color=BLUE, fill_opacity=0.5)\n        area = ax.get_area(curve_2, [2, 3], bounded_graph=curve_1, color=GREY, opacity=0.5)\n\n        self.add(ax, labels, curve_1, curve_2, line_1, line_2, riemann_area, area)", "code_sha1": "640db816ee0593218f9032585048f40cd653e4e4"}
{"url": "https://docs.manim.community/en/stable/examples.html", "depth": 0, "instruction": "The scene features a 6x6 axes grid with a yellow hyperbolic graph. A blue polygon with yellow edges dynamically updates its shape as a dot moves along the graph, representing the rectangle's area. The animation includes the polygon's creation, followed by the dot's movement from (5, 5) to (10, 2.5) and back to (5, 5).", "code": "from manim import *\n\nclass PolygonOnAxes(Scene):\n    def get_rectangle_corners(self, bottom_left, top_right):\n        return [\n            (top_right[0], top_right[1]),\n            (bottom_left[0], top_right[1]),\n            (bottom_left[0], bottom_left[1]),\n            (top_right[0], bottom_left[1]),\n        ]\n\n    def construct(self):\n        ax = Axes(\n            x_range=[0, 10],\n            y_range=[0, 10],\n            x_length=6,\n            y_length=6,\n            axis_config={\"include_tip\": False},\n        )\n\n        t = ValueTracker(5)\n        k = 25\n\n        graph = ax.plot(\n            lambda x: k / x,\n            color=YELLOW_D,\n            x_range=[k / 10, 10.0, 0.01],\n            use_smoothing=False,\n        )\n\n        def get_rectangle():\n            polygon = Polygon(\n                *[\n                    ax.c2p(*i)\n                    for i in self.get_rectangle_corners(\n                        (0, 0), (t.get_value(), k / t.get_value())\n                    )\n                ]\n            )\n            polygon.stroke_width = 1\n            polygon.set_fill(BLUE, opacity=0.5)\n            polygon.set_stroke(YELLOW_B)\n            return polygon\n\n        polygon = always_redraw(get_rectangle)\n\n        dot = Dot()\n        dot.add_updater(lambda x: x.move_to(ax.c2p(t.get_value(), k / t.get_value())))\n        dot.set_z_index(10)\n\n        self.add(ax, graph, dot)\n        self.play(Create(polygon))\n        self.play(t.animate.set_value(10))\n        self.play(t.animate.set_value(k / 10))\n        self.play(t.animate.set_value(5))", "code_sha1": "68cd449290805c52ea32579b507f02a45e7e10e8"}
{"url": "https://docs.manim.community/en/stable/examples.html", "depth": 0, "instruction": "A 2D coordinate system with labeled axes is displayed, featuring a line graph connecting points at (0, 20), (8, 0), (38, 0), and (39, -5). The axes range from 0 to 40 on the x-axis and -8 to 32 on the y-axis, with specific tick marks included.", "code": "from manim import *\n\nclass HeatDiagramPlot(Scene):\n    def construct(self):\n        ax = Axes(\n            x_range=[0, 40, 5],\n            y_range=[-8, 32, 5],\n            x_length=9,\n            y_length=6,\n            x_axis_config={\"numbers_to_include\": np.arange(0, 40, 5)},\n            y_axis_config={\"numbers_to_include\": np.arange(-5, 34, 5)},\n            tips=False,\n        )\n        labels = ax.get_axis_labels(\n            x_label=Tex(r\"$\\Delta Q$\"), y_label=Tex(r\"T[$^\\circ C$]\")\n        )\n\n        x_vals = [0, 8, 38, 39]\n        y_vals = [20, 0, 0, -5]\n        graph = ax.plot_line_graph(x_values=x_vals, y_values=y_vals)\n\n        self.add(ax, labels, graph)", "code_sha1": "20417b45885ab73234327e8e2f45d45f94a05ba7"}
{"url": "https://docs.manim.community/en/stable/examples.html", "depth": 0, "instruction": "The scene features a blue sine wave graph on a grid, with two static dots at the endpoints and an orange dot moving along the curve. The camera smoothly zooms in and follows the moving dot, then restores to its original position, creating a dynamic visual effect.", "code": "from manim import *\n\nclass FollowingGraphCamera(MovingCameraScene):\n    def construct(self):\n        self.camera.frame.save_state()\n\n        # create the axes and the curve\n        ax = Axes(x_range=[-1, 10], y_range=[-1, 10])\n        graph = ax.plot(lambda x: np.sin(x), color=BLUE, x_range=[0, 3 * PI])\n\n        # create dots based on the graph\n        moving_dot = Dot(ax.i2gp(graph.t_min, graph), color=ORANGE)\n        dot_1 = Dot(ax.i2gp(graph.t_min, graph))\n        dot_2 = Dot(ax.i2gp(graph.t_max, graph))\n\n        self.add(ax, graph, dot_1, dot_2, moving_dot)\n        self.play(self.camera.frame.animate.scale(0.5).move_to(moving_dot))\n\n        def update_curve(mob):\n            mob.move_to(moving_dot.get_center())\n\n        self.camera.frame.add_updater(update_curve)\n        self.play(MoveAlongPath(moving_dot, graph, rate_func=linear))\n        self.camera.frame.remove_updater(update_curve)\n\n        self.play(Restore(self.camera.frame))", "code_sha1": "534ca9b6897bc6425235a713ca3b2fe45b24fe41"}
{"url": "https://docs.manim.community/en/stable/examples.html", "depth": 0, "instruction": "The scene features a zoomed camera effect focusing on a dot and an image, with a purple frame and red display frame. Text labels appear and fade, followed by scaling animations. The zoomed display pops out, and the frame shifts down, concluding with the uncreation of the display frame and fading out of the main frame.", "code": "from manim import *\n\nclass MovingZoomedSceneAround(ZoomedScene):\n# contributed by TheoremofBeethoven, www.youtube.com/c/TheoremofBeethoven\n    def __init__(self, **kwargs):\n        ZoomedScene.__init__(\n            self,\n            zoom_factor=0.3,\n            zoomed_display_height=1,\n            zoomed_display_width=6,\n            image_frame_stroke_width=20,\n            zoomed_camera_config={\n                \"default_frame_stroke_width\": 3,\n                },\n            **kwargs\n        )\n\n    def construct(self):\n        dot = Dot().shift(UL * 2)\n        image = ImageMobject(np.uint8([[0, 100, 30, 200],\n                                       [255, 0, 5, 33]]))\n        image.height = 7\n        frame_text = Text(\"Frame\", color=PURPLE, font_size=67)\n        zoomed_camera_text = Text(\"Zoomed camera\", color=RED, font_size=67)\n\n        self.add(image, dot)\n        zoomed_camera = self.zoomed_camera\n        zoomed_display = self.zoomed_display\n        frame = zoomed_camera.frame\n        zoomed_display_frame = zoomed_display.display_frame\n\n        frame.move_to(dot)\n        frame.set_color(PURPLE)\n        zoomed_display_frame.set_color(RED)\n        zoomed_display.shift(DOWN)\n\n        zd_rect = BackgroundRectangle(zoomed_display, fill_opacity=0, buff=MED_SMALL_BUFF)\n        self.add_foreground_mobject(zd_rect)\n\n        unfold_camera = UpdateFromFunc(zd_rect, lambda rect: rect.replace(zoomed_display))\n\n        frame_text.next_to(frame, DOWN)\n\n        self.play(Create(frame), FadeIn(frame_text, shift=UP))\n        self.activate_zooming()\n\n        self.play(self.get_zoomed_display_pop_out_animation(), unfold_camera)\n        zoomed_camera_text.next_to(zoomed_display_frame, DOWN)\n        self.play(FadeIn(zoomed_camera_text, shift=UP))\n        # Scale in        x   y  z\n        scale_factor = [0.5, 1.5, 0]\n        self.play(\n            frame.animate.scale(scale_factor),\n            zoomed_display.animate.scale(scale_factor),\n            FadeOut(zoomed_camera_text),\n            FadeOut(frame_text)\n        )\n        self.wait()\n        self.play(ScaleInPlace(zoomed_display, 2))\n        self.wait()\n        self.play(frame.animate.shift(2.5 * DOWN))\n        self.wait()\n        self.play(self.get_zoomed_display_pop_out_animation(), unfold_camera, rate_func=lambda t: smooth(1 - t))\n        self.play(Uncreate(zoomed_display_frame), FadeOut(frame))\n        self.wait()", "code_sha1": "c27126faf9f6d862181eea6214dea9f47af35d99"}
{"url": "https://docs.manim.community/en/stable/examples.html", "depth": 0, "instruction": "A 3D scene displays a set of axes with a fixed 3D text \"This is a 3D text\" positioned in the upper left corner. The camera is oriented at a 75-degree elevation and -45-degree azimuth, creating a dynamic perspective. The scene remains static for a moment, allowing viewers to appreciate the layout.", "code": "from manim import *\n\nclass FixedInFrameMObjectTest(ThreeDScene):\n    def construct(self):\n        axes = ThreeDAxes()\n        self.set_camera_orientation(phi=75 * DEGREES, theta=-45 * DEGREES)\n        text3d = Text(\"This is a 3D text\")\n        self.add_fixed_in_frame_mobjects(text3d)\n        text3d.to_corner(UL)\n        self.add(axes)\n        self.wait()", "code_sha1": "139b8b339830ea5f7a3c35e1805207354a3c64a6"}
{"url": "https://docs.manim.community/en/stable/examples.html", "depth": 0, "instruction": "A 3D scene displays a checkerboard-patterned sphere in red hues, positioned at the origin, with axes extending from it. The camera is oriented at a 75-degree elevation and 30-degree azimuth, while the light source is positioned at (0, 0, -3), illuminating the sphere dynamically.", "code": "from manim import *\n\nclass ThreeDLightSourcePosition(ThreeDScene):\n    def construct(self):\n        axes = ThreeDAxes()\n        sphere = Surface(\n            lambda u, v: np.array([\n                1.5 * np.cos(u) * np.cos(v),\n                1.5 * np.cos(u) * np.sin(v),\n                1.5 * np.sin(u)\n            ]), v_range=[0, TAU], u_range=[-PI / 2, PI / 2],\n            checkerboard_colors=[RED_D, RED_E], resolution=(15, 32)\n        )\n        self.renderer.camera.light_source.move_to(3*IN) # changes the source of the light\n        self.set_camera_orientation(phi=75 * DEGREES, theta=30 * DEGREES)\n        self.add(axes, sphere)", "code_sha1": "3d6c85f0146c325c23eb38f3becc12d7176413ea"}
{"url": "https://docs.manim.community/en/stable/examples.html", "depth": 0, "instruction": "A 3D scene featuring a blue circle and axes, with the camera initially set at a 75-degree elevation and 30-degree azimuth. The camera rotates slowly around the scene, then stops, maintaining the same orientation before concluding with a brief pause.", "code": "from manim import *\n\nclass ThreeDCameraRotation(ThreeDScene):\n    def construct(self):\n        axes = ThreeDAxes()\n        circle=Circle()\n        self.set_camera_orientation(phi=75 * DEGREES, theta=30 * DEGREES)\n        self.add(circle,axes)\n        self.begin_ambient_camera_rotation(rate=0.1)\n        self.wait()\n        self.stop_ambient_camera_rotation()\n        self.move_camera(phi=75 * DEGREES, theta=30 * DEGREES)\n        self.wait()", "code_sha1": "039fdde89c35a1d4d343432577cc1cf753c29e77"}
{"url": "https://docs.manim.community/en/stable/examples.html", "depth": 0, "instruction": "A 3D scene displays a circle and axes, with the camera oriented at 75 degrees elevation and 30 degrees azimuth. The camera rotates in an illusionary manner at a rate of 2, pausing for 1.57 seconds before stopping, creating a dynamic visual effect.", "code": "from manim import *\n\nclass ThreeDCameraIllusionRotation(ThreeDScene):\n    def construct(self):\n        axes = ThreeDAxes()\n        circle=Circle()\n        self.set_camera_orientation(phi=75 * DEGREES, theta=30 * DEGREES)\n        self.add(circle,axes)\n        self.begin_3dillusion_camera_rotation(rate=2)\n        self.wait(PI/2)\n        self.stop_3dillusion_camera_rotation()", "code_sha1": "263cc7af59e74148b43e7747d9afbc512070b6e8"}
{"url": "https://docs.manim.community/en/stable/examples.html", "depth": 0, "instruction": "A 3D surface plot of a Gaussian function is displayed, colored with an orange and blue checkerboard pattern, and outlined in green. The camera is positioned at a 75-degree elevation and -30-degree azimuth, with a three-dimensional axes system in the background. The surface is scaled to twice its original size.", "code": "from manim import *\n\nclass ThreeDSurfacePlot(ThreeDScene):\n    def construct(self):\n        resolution_fa = 24\n        self.set_camera_orientation(phi=75 * DEGREES, theta=-30 * DEGREES)\n\n        def param_gauss(u, v):\n            x = u\n            y = v\n            sigma, mu = 0.4, [0.0, 0.0]\n            d = np.linalg.norm(np.array([x - mu[0], y - mu[1]]))\n            z = np.exp(-(d ** 2 / (2.0 * sigma ** 2)))\n            return np.array([x, y, z])\n\n        gauss_plane = Surface(\n            param_gauss,\n            resolution=(resolution_fa, resolution_fa),\n            v_range=[-2, +2],\n            u_range=[-2, +2]\n        )\n\n        gauss_plane.scale(2, about_point=ORIGIN)\n        gauss_plane.set_style(fill_opacity=1,stroke_color=GREEN)\n        gauss_plane.set_fill_by_checkerboard(ORANGE, BLUE, opacity=0.5)\n        axes = ThreeDAxes()\n        self.add(axes,gauss_plane)", "code_sha1": "0e3962b5a3b4bbd8b38d346d90e80bf29e1cfa98"}
{"url": "https://docs.manim.community/en/stable/examples.html", "depth": 0, "instruction": "The scene features a LaTeX title and a mathematical equation appearing sequentially, followed by a transformation of the title and fading out of the equation. A grid is created with a large title, then the grid undergoes a non-linear transformation while the title changes, concluding with a new title.", "code": "from manim import *\n\nclass OpeningManim(Scene):\n    def construct(self):\n        title = Tex(r\"This is some \\LaTeX\")\n        basel = MathTex(r\"\\sum_{n=1}^\\infty \\frac{1}{n^2} = \\frac{\\pi^2}{6}\")\n        VGroup(title, basel).arrange(DOWN)\n        self.play(\n            Write(title),\n            FadeIn(basel, shift=DOWN),\n        )\n        self.wait()\n\n        transform_title = Tex(\"That was a transform\")\n        transform_title.to_corner(UP + LEFT)\n        self.play(\n            Transform(title, transform_title),\n            LaggedStart(*[FadeOut(obj, shift=DOWN) for obj in basel]),\n        )\n        self.wait()\n\n        grid = NumberPlane()\n        grid_title = Tex(\"This is a grid\", font_size=72)\n        grid_title.move_to(transform_title)\n\n        self.add(grid, grid_title)  # Make sure title is on top of grid\n        self.play(\n            FadeOut(title),\n            FadeIn(grid_title, shift=UP),\n            Create(grid, run_time=3, lag_ratio=0.1),\n        )\n        self.wait()\n\n        grid_transform_title = Tex(\n            r\"That was a non-linear function \\\\ applied to the grid\"\n        )\n        grid_transform_title.move_to(grid_title, UL)\n        grid.prepare_for_nonlinear_transform()\n        self.play(\n            grid.animate.apply_function(\n                lambda p: p\n                          + np.array(\n                    [\n                        np.sin(p[1]),\n                        np.sin(p[0]),\n                        0,\n                    ]\n                )\n            ),\n            run_time=3,\n        )\n        self.wait()\n        self.play(Transform(grid_title, grid_transform_title))\n        self.wait()", "code_sha1": "995784dd13e7c44a3f8c734899162b8ccf0b6da0"}
{"url": "https://docs.manim.community/en/stable/examples.html", "depth": 0, "instruction": "A yellow dot orbits a blue circle while tracing a yellow sine curve, with a blue line connecting the dot to the circle's center and a yellow line extending from the dot to the curve. The scene includes labeled axes and lasts for 8.5 seconds, showcasing continuous motion and dynamic updates.", "code": "from manim import *\n\nclass SineCurveUnitCircle(Scene):\n    # contributed by heejin_park, https://infograph.tistory.com/230\n    def construct(self):\n        self.show_axis()\n        self.show_circle()\n        self.move_dot_and_draw_curve()\n        self.wait()\n\n    def show_axis(self):\n        x_start = np.array([-6,0,0])\n        x_end = np.array([6,0,0])\n\n        y_start = np.array([-4,-2,0])\n        y_end = np.array([-4,2,0])\n\n        x_axis = Line(x_start, x_end)\n        y_axis = Line(y_start, y_end)\n\n        self.add(x_axis, y_axis)\n        self.add_x_labels()\n\n        self.origin_point = np.array([-4,0,0])\n        self.curve_start = np.array([-3,0,0])\n\n    def add_x_labels(self):\n        x_labels = [\n            MathTex(r\"\\pi\"), MathTex(r\"2 \\pi\"),\n            MathTex(r\"3 \\pi\"), MathTex(r\"4 \\pi\"),\n        ]\n\n        for i in range(len(x_labels)):\n            x_labels[i].next_to(np.array([-1 + 2*i, 0, 0]), DOWN)\n            self.add(x_labels[i])\n\n    def show_circle(self):\n        circle = Circle(radius=1)\n        circle.move_to(self.origin_point)\n        self.add(circle)\n        self.circle = circle\n\n    def move_dot_and_draw_curve(self):\n        orbit = self.circle\n        origin_point = self.origin_point\n\n        dot = Dot(radius=0.08, color=YELLOW)\n        dot.move_to(orbit.point_from_proportion(0))\n        self.t_offset = 0\n        rate = 0.25\n\n        def go_around_circle(mob, dt):\n            self.t_offset += (dt * rate)\n            # print(self.t_offset)\n            mob.move_to(orbit.point_from_proportion(self.t_offset % 1))\n\n        def get_line_to_circle():\n            return Line(origin_point, dot.get_center(), color=BLUE)\n\n        def get_line_to_curve():\n            x = self.curve_start[0] + self.t_offset * 4\n            y = dot.get_center()[1]\n            return Line(dot.get_center(), np.array([x,y,0]), color=YELLOW_A, stroke_width=2 )\n\n\n        self.curve = VGroup()\n        self.curve.add(Line(self.curve_start,self.curve_start))\n        def get_curve():\n            last_line = self.curve[-1]\n            x = self.curve_start[0] + self.t_offset * 4\n            y = dot.get_center()[1]\n            new_line = Line(last_line.get_end(),np.array([x,y,0]), color=YELLOW_D)\n            self.curve.add(new_line)\n\n            return self.curve\n\n        dot.add_updater(go_around_circle)\n\n        origin_to_circle_line = always_redraw(get_line_to_circle)\n        dot_to_curve_line = always_redraw(get_line_to_curve)\n        sine_curve_line = always_redraw(get_curve)\n\n        self.add(dot)\n        self.add(orbit, origin_to_circle_line, dot_to_curve_line, sine_curve_line)\n        self.wait(8.5)\n\n        dot.remove_updater(go_around_circle)", "code_sha1": "2fe8a2e317288f4e6775354ad27ba37536c0b386"}
{"url": "https://docs.manim.community/en/stable/examples.html", "depth": 0, "instruction": "The scene features a light beige background with a large black \"M\" at the center, surrounded by a green circle on the left, a blue square above, and a red triangle on the right, all fully opaque and arranged in a visually balanced composition.", "code": "class ManimCELogo(Scene):\n    def construct(self):\n        self.camera.background_color = \"#ece6e2\"\n        logo_green = \"#87c2a5\"\n        logo_blue = \"#525893\"\n        logo_red = \"#e07a5f\"\n        logo_black = \"#343434\"\n        ds_m = MathTex(r\"\\mathbb{M}\", fill_color=logo_black).scale(7)\n        ds_m.shift(2.25 * LEFT + 1.5 * UP)\n        circle = Circle(color=logo_green, fill_opacity=1).shift(LEFT)\n        square = Square(color=logo_blue, fill_opacity=1).shift(UP)\n        triangle = Triangle(color=logo_red, fill_opacity=1).shift(RIGHT)\n        logo = VGroup(triangle, square, circle, ds_m)  # order matters\n        logo.move_to(ORIGIN)\n        self.add(logo)", "code_sha1": "fb983765680b90ecd8f11c6d4d010e78ea9986c4"}
{"url": "https://docs.manim.community/en/stable/examples.html", "depth": 0, "instruction": "The scene displays two dots positioned at (-2, -1) and (2, 1), connected by an orange line. Two braces annotate the line: one horizontal with the text \"Horizontal distance\" and one vertical with the text \"x-x_1\". All elements are added simultaneously without animations.", "code": "class BraceAnnotation(Scene):\n    def construct(self):\n        dot = Dot([-2, -1, 0])\n        dot2 = Dot([2, 1, 0])\n        line = Line(dot.get_center(), dot2.get_center()).set_color(ORANGE)\n        b1 = Brace(line)\n        b1text = b1.get_text(\"Horizontal distance\")\n        b2 = Brace(line, direction=line.copy().rotate(PI / 2).get_unit_vector())\n        b2text = b2.get_tex(\"x-x_1\")\n        self.add(line, dot, dot2, b1, b2, b1text, b2text)", "code_sha1": "6ef750c04594c44472a2b7d4aaf5d7355ce7cbfa"}
{"url": "https://docs.manim.community/en/stable/examples.html", "depth": 0, "instruction": "A 2D scene displays a number plane with a blue arrow from the origin (0,0) to (2,2), a dot at the origin, and text labels '(0, 0)' below the dot and '(2, 2)' to the right of the arrow's tip.", "code": "class VectorArrow(Scene):\n    def construct(self):\n        dot = Dot(ORIGIN)\n        arrow = Arrow(ORIGIN, [2, 2, 0], buff=0)\n        numberplane = NumberPlane()\n        origin_text = Text('(0, 0)').next_to(dot, DOWN)\n        tip_text = Text('(2, 2)').next_to(arrow.get_end(), RIGHT)\n        self.add(numberplane, dot, arrow, origin_text, tip_text)", "code_sha1": "d0e25c6cbc15ae4ed160793da3d20fe1f6f9a340"}
{"url": "https://docs.manim.community/en/stable/examples.html", "depth": 0, "instruction": "A gradient image scaled to twice its size is displayed, transitioning from black to white, surrounded by a green rectangle. Both the image and the rectangle are added simultaneously to the scene without any animations.", "code": "class GradientImageFromArray(Scene):\n    def construct(self):\n        n = 256\n        imageArray = np.uint8(\n            [[i * 256 / n for i in range(0, n)] for _ in range(0, n)]\n        )\n        image = ImageMobject(imageArray).scale(2)\n        image.background_rectangle = SurroundingRectangle(image, color=GREEN)\n        self.add(image, image.background_rectangle)", "code_sha1": "e8c1354ced37c7a14ad81b037925eb3c1b4363dc"}
{"url": "https://docs.manim.community/en/stable/examples.html", "depth": 0, "instruction": "The scene displays two overlapping ellipses (one blue, one red) with a title above. Four colored shapes (green, orange, yellow, pink) representing intersection, union, exclusion, and difference animate into position with fade-ins and scaling, each accompanied by labeled text, creating a visually engaging representation of Boolean operations.", "code": "class BooleanOperations(Scene):\n    def construct(self):\n        ellipse1 = Ellipse(\n            width=4.0, height=5.0, fill_opacity=0.5, color=BLUE, stroke_width=10\n        ).move_to(LEFT)\n        ellipse2 = ellipse1.copy().set_color(color=RED).move_to(RIGHT)\n        bool_ops_text = MarkupText(\"Boolean Operation\").next_to(ellipse1, UP * 3)\n        ellipse_group = Group(bool_ops_text, ellipse1, ellipse2).move_to(LEFT * 3)\n        self.play(FadeIn(ellipse_group))\n\n        i = Intersection(ellipse1, ellipse2, color=GREEN, fill_opacity=0.5)\n        self.play(i.animate.scale(0.25).move_to(RIGHT * 5 + UP * 2.5))\n        intersection_text = Text(\"Intersection\", font_size=23).next_to(i, UP)\n        self.play(FadeIn(intersection_text))\n\n        u = Union(ellipse1, ellipse2, color=ORANGE, fill_opacity=0.5)\n        union_text = Text(\"Union\", font_size=23)\n        self.play(u.animate.scale(0.3).next_to(i, DOWN, buff=union_text.height * 3))\n        union_text.next_to(u, UP)\n        self.play(FadeIn(union_text))\n\n        e = Exclusion(ellipse1, ellipse2, color=YELLOW, fill_opacity=0.5)\n        exclusion_text = Text(\"Exclusion\", font_size=23)\n        self.play(e.animate.scale(0.3).next_to(u, DOWN, buff=exclusion_text.height * 3.5))\n        exclusion_text.next_to(e, UP)\n        self.play(FadeIn(exclusion_text))\n\n        d = Difference(ellipse1, ellipse2, color=PINK, fill_opacity=0.5)\n        difference_text = Text(\"Difference\", font_size=23)\n        self.play(d.animate.scale(0.3).next_to(u, LEFT, buff=difference_text.height * 3.5))\n        difference_text.next_to(d, UP)\n        self.play(FadeIn(difference_text))", "code_sha1": "493b1d88886bed908fc7ea517e41a2d5fae17ec4"}
{"url": "https://docs.manim.community/en/stable/examples.html", "depth": 0, "instruction": "A blue circle grows from the center, while a dot moves along its perimeter for 2 seconds, then rotates around a point on a line for 1.5 seconds, with a second dot initially positioned to the right. The scene concludes with a brief pause.", "code": "class PointMovingOnShapes(Scene):\n    def construct(self):\n        circle = Circle(radius=1, color=BLUE)\n        dot = Dot()\n        dot2 = dot.copy().shift(RIGHT)\n        self.add(dot)\n\n        line = Line([3, 0, 0], [5, 0, 0])\n        self.add(line)\n\n        self.play(GrowFromCenter(circle))\n        self.play(Transform(dot, dot2))\n        self.play(MoveAlongPath(dot, circle), run_time=2, rate_func=linear)\n        self.play(Rotating(dot, about_point=[2, 0, 0]), run_time=1.5)\n        self.wait()", "code_sha1": "2b39f456e956c04be37b246bbcb931d3280431dc"}
{"url": "https://docs.manim.community/en/stable/examples.html", "depth": 0, "instruction": "A blue square shifts left, changes to orange, scales down to 30% of its size, and rotates by 0.4 radians, with each transformation animated sequentially.", "code": "class MovingAround(Scene):\n    def construct(self):\n        square = Square(color=BLUE, fill_opacity=1)\n\n        self.play(square.animate.shift(LEFT))\n        self.play(square.animate.set_fill(ORANGE))\n        self.play(square.animate.scale(0.3))\n        self.play(square.animate.rotate(0.4))", "code_sha1": "66fbe4d5cfc5d484cde972b6ebbdecdceaa8b839"}
{"url": "https://docs.manim.community/en/stable/examples.html", "depth": 0, "instruction": "A horizontal line rotates around the left point, forming an angle with a static line. The angle dynamically updates as the rotation progresses, with a label indicating the angle value that briefly turns red. The animation features smooth transitions, with the angle changing from 110° to 350° over time.", "code": "class MovingAngle(Scene):\n    def construct(self):\n        rotation_center = LEFT\n\n        theta_tracker = ValueTracker(110)\n        line1 = Line(LEFT, RIGHT)\n        line_moving = Line(LEFT, RIGHT)\n        line_ref = line_moving.copy()\n        line_moving.rotate(\n            theta_tracker.get_value() * DEGREES, about_point=rotation_center\n        )\n        a = Angle(line1, line_moving, radius=0.5, other_angle=False)\n        tex = MathTex(r\"\\theta\").move_to(\n            Angle(\n                line1, line_moving, radius=0.5 + 3 * SMALL_BUFF, other_angle=False\n            ).point_from_proportion(0.5)\n        )\n\n        self.add(line1, line_moving, a, tex)\n        self.wait()\n\n        line_moving.add_updater(\n            lambda x: x.become(line_ref.copy()).rotate(\n                theta_tracker.get_value() * DEGREES, about_point=rotation_center\n            )\n        )\n\n        a.add_updater(\n            lambda x: x.become(Angle(line1, line_moving, radius=0.5, other_angle=False))\n        )\n        tex.add_updater(\n            lambda x: x.move_to(\n                Angle(\n                    line1, line_moving, radius=0.5 + 3 * SMALL_BUFF, other_angle=False\n                ).point_from_proportion(0.5)\n            )\n        )\n\n        self.play(theta_tracker.animate.set_value(40))\n        self.play(theta_tracker.animate.increment_value(140))\n        self.play(tex.animate.set_color(RED), run_time=0.5)\n        self.play(theta_tracker.animate.set_value(350))", "code_sha1": "3871466716426bf08c30b03002065d6f9d2ef1c5"}
{"url": "https://docs.manim.community/en/stable/examples.html", "depth": 0, "instruction": "Two dots, one blue and one green, move horizontally and vertically to positions (5,0) and (0,4) respectively, connected by a red line that updates dynamically. The animation consists of a horizontal movement followed by a vertical movement, with a brief pause at the end.", "code": "class MovingDots(Scene):\n    def construct(self):\n        d1,d2=Dot(color=BLUE),Dot(color=GREEN)\n        dg=VGroup(d1,d2).arrange(RIGHT,buff=1)\n        l1=Line(d1.get_center(),d2.get_center()).set_color(RED)\n        x=ValueTracker(0)\n        y=ValueTracker(0)\n        d1.add_updater(lambda z: z.set_x(x.get_value()))\n        d2.add_updater(lambda z: z.set_y(y.get_value()))\n        l1.add_updater(lambda z: z.become(Line(d1.get_center(),d2.get_center())))\n        self.add(d1,d2,l1)\n        self.play(x.animate.set_value(5))\n        self.play(y.animate.set_value(4))\n        self.wait()", "code_sha1": "5578860859e05f79c853e6fd37921093b78598b5"}
{"url": "https://docs.manim.community/en/stable/examples.html", "depth": 0, "instruction": "A group of four dots, scaled to 1.4 times their original size, moves from their initial positions to a yellow destination dot at (4, 3, 0), with the red dot leading the movement. The animation lasts briefly, followed by a 0.5-second pause.", "code": "class MovingGroupToDestination(Scene):\n    def construct(self):\n        group = VGroup(Dot(LEFT), Dot(ORIGIN), Dot(RIGHT, color=RED), Dot(2 * RIGHT)).scale(1.4)\n        dest = Dot([4, 3, 0], color=YELLOW)\n        self.add(group, dest)\n        self.play(group.animate.shift(dest.get_center() - group[2].get_center()))\n        self.wait(0.5)", "code_sha1": "34f936ed3affff63b4fc17993c2e11977fd8d68c"}
{"url": "https://docs.manim.community/en/stable/examples.html", "depth": 0, "instruction": "The scene displays a mathematical equation written in LaTeX, with two surrounding rectangles highlighting specific terms. The first rectangle appears around the second term, then smoothly transforms into a rectangle around the fourth term, with pauses between animations for emphasis.", "code": "class MovingFrameBox(Scene):\n    def construct(self):\n        text=MathTex(\n            \"\\\\frac{d}{dx}f(x)g(x)=\",\"f(x)\\\\frac{d}{dx}g(x)\",\"+\",\n            \"g(x)\\\\frac{d}{dx}f(x)\"\n        )\n        self.play(Write(text))\n        framebox1 = SurroundingRectangle(text[1], buff = .1)\n        framebox2 = SurroundingRectangle(text[3], buff = .1)\n        self.play(\n            Create(framebox1),\n        )\n        self.wait()\n        self.play(\n            ReplacementTransform(framebox1,framebox2),\n        )\n        self.wait()", "code_sha1": "e793b19ff389d9dca2c7e607b72c2c8271afaa78"}
{"url": "https://docs.manim.community/en/stable/examples.html", "depth": 0, "instruction": "A white reference line and a yellow line rotate around the origin, first clockwise for 2 seconds, then counterclockwise for another 2 seconds, before pausing for 0.5 seconds.", "code": "class RotationUpdater(Scene):\n    def construct(self):\n        def updater_forth(mobj, dt):\n            mobj.rotate_about_origin(dt)\n        def updater_back(mobj, dt):\n            mobj.rotate_about_origin(-dt)\n        line_reference = Line(ORIGIN, LEFT).set_color(WHITE)\n        line_moving = Line(ORIGIN, LEFT).set_color(YELLOW)\n        line_moving.add_updater(updater_forth)\n        self.add(line_reference, line_moving)\n        self.wait(2)\n        line_moving.remove_updater(updater_forth)\n        line_moving.add_updater(updater_back)\n        self.wait(2)\n        line_moving.remove_updater(updater_back)\n        self.wait(0.5)", "code_sha1": "c637b8f64f255bf661c2c356ee6c81184e5f570d"}
{"url": "https://docs.manim.community/en/stable/examples.html", "depth": 0, "instruction": "A rotating dot traces a path as it spins around a point, then shifts upward and left, with the path dynamically updating to reflect its movement. The dot is small and colored, while the path is a continuous line that visually represents the dot's trajectory.", "code": "class PointWithTrace(Scene):\n    def construct(self):\n        path = VMobject()\n        dot = Dot()\n        path.set_points_as_corners([dot.get_center(), dot.get_center()])\n        def update_path(path):\n            previous_path = path.copy()\n            previous_path.add_points_as_corners([dot.get_center()])\n            path.become(previous_path)\n        path.add_updater(update_path)\n        self.add(path, dot)\n        self.play(Rotating(dot, radians=PI, about_point=RIGHT, run_time=2))\n        self.wait()\n        self.play(dot.animate.shift(UP))\n        self.play(dot.animate.shift(LEFT))\n        self.wait()", "code_sha1": "b8a041a957cd2b325e4af0700adbad4789c2c2e6"}
{"url": "https://docs.manim.community/en/stable/examples.html", "depth": 0, "instruction": "The scene displays a coordinate system with green axes, featuring blue sine and red cosine graphs. A yellow vertical line intersects the cosine graph at \\(x=2\\pi\\), labeled in white. The axes include labeled ticks, and the sine and cosine functions are annotated with their respective labels. All elements are grouped and added to the scene.", "code": "class SinAndCosFunctionPlot(Scene):\n    def construct(self):\n        axes = Axes(\n            x_range=[-10, 10.3, 1],\n            y_range=[-1.5, 1.5, 1],\n            x_length=10,\n            axis_config={\"color\": GREEN},\n            x_axis_config={\n                \"numbers_to_include\": np.arange(-10, 10.01, 2),\n                \"numbers_with_elongated_ticks\": np.arange(-10, 10.01, 2),\n            },\n            tips=False,\n        )\n        axes_labels = axes.get_axis_labels()\n        sin_graph = axes.plot(lambda x: np.sin(x), color=BLUE)\n        cos_graph = axes.plot(lambda x: np.cos(x), color=RED)\n\n        sin_label = axes.get_graph_label(\n            sin_graph, \"\\\\sin(x)\", x_val=-10, direction=UP / 2\n        )\n        cos_label = axes.get_graph_label(cos_graph, label=\"\\\\cos(x)\")\n\n        vert_line = axes.get_vertical_line(\n            axes.i2gp(TAU, cos_graph), color=YELLOW, line_func=Line\n        )\n        line_label = axes.get_graph_label(\n            cos_graph, r\"x=2\\pi\", x_val=TAU, direction=UR, color=WHITE\n        )\n\n        plot = VGroup(axes, sin_graph, cos_graph, vert_line)\n        labels = VGroup(axes_labels, sin_label, cos_label, line_label)\n        self.add(plot, labels)", "code_sha1": "ec2bd0c5b9ca1785dc5dd9e432085b30659039f8"}
{"url": "https://docs.manim.community/en/stable/examples.html", "depth": 0, "instruction": "The scene displays a coordinate system with axes labeled \"x\" and \"f(x)\", a maroon quadratic graph, and a moving dot that traces the graph to its minimum point, animating smoothly to the minimum value while the axes and labels remain static.", "code": "class ArgMinExample(Scene):\n    def construct(self):\n        ax = Axes(\n            x_range=[0, 10], y_range=[0, 100, 10], axis_config={\"include_tip\": False}\n        )\n        labels = ax.get_axis_labels(x_label=\"x\", y_label=\"f(x)\")\n\n        t = ValueTracker(0)\n\n        def func(x):\n            return 2 * (x - 5) ** 2\n        graph = ax.plot(func, color=MAROON)\n\n        initial_point = [ax.coords_to_point(t.get_value(), func(t.get_value()))]\n        dot = Dot(point=initial_point)\n\n        dot.add_updater(lambda x: x.move_to(ax.c2p(t.get_value(), func(t.get_value()))))\n        x_space = np.linspace(*ax.x_range[:2],200)\n        minimum_index = func(x_space).argmin()\n\n        self.add(ax, labels, graph, dot)\n        self.play(t.animate.set_value(x_space[minimum_index]))\n        self.wait()", "code_sha1": "004615cc8fd06e400c7f562336db05dd24275aba"}
{"url": "https://docs.manim.community/en/stable/examples.html", "depth": 0, "instruction": "The scene displays a coordinate system with labeled axes, two curves (one blue and one green), two vertical yellow lines at specific x-values, a semi-transparent blue Riemann rectangle between the curves, and a grey shaded area representing the region between the curves, all arranged within a defined x and y range.", "code": "class GraphAreaPlot(Scene):\n    def construct(self):\n        ax = Axes(\n            x_range=[0, 5],\n            y_range=[0, 6],\n            x_axis_config={\"numbers_to_include\": [2, 3]},\n            tips=False,\n        )\n\n        labels = ax.get_axis_labels()\n\n        curve_1 = ax.plot(lambda x: 4 * x - x ** 2, x_range=[0, 4], color=BLUE_C)\n        curve_2 = ax.plot(\n            lambda x: 0.8 * x ** 2 - 3 * x + 4,\n            x_range=[0, 4],\n            color=GREEN_B,\n        )\n\n        line_1 = ax.get_vertical_line(ax.input_to_graph_point(2, curve_1), color=YELLOW)\n        line_2 = ax.get_vertical_line(ax.i2gp(3, curve_1), color=YELLOW)\n\n        riemann_area = ax.get_riemann_rectangles(curve_1, x_range=[0.3, 0.6], dx=0.03, color=BLUE, fill_opacity=0.5)\n        area = ax.get_area(curve_2, [2, 3], bounded_graph=curve_1, color=GREY, opacity=0.5)\n\n        self.add(ax, labels, curve_1, curve_2, line_1, line_2, riemann_area, area)", "code_sha1": "161c4525076125046c3e4db368e176920aace3e7"}
{"url": "https://docs.manim.community/en/stable/examples.html", "depth": 0, "instruction": "The scene features a 6x6 axes grid with a yellow hyperbolic graph. A blue semi-transparent polygon dynamically updates its shape as a dot moves along the graph, representing the rectangle's area. The animation includes creating the polygon, followed by the dot moving from right to left, with keyframes at specific values of a tracker.", "code": "class PolygonOnAxes(Scene):\n    def get_rectangle_corners(self, bottom_left, top_right):\n        return [\n            (top_right[0], top_right[1]),\n            (bottom_left[0], top_right[1]),\n            (bottom_left[0], bottom_left[1]),\n            (top_right[0], bottom_left[1]),\n        ]\n\n    def construct(self):\n        ax = Axes(\n            x_range=[0, 10],\n            y_range=[0, 10],\n            x_length=6,\n            y_length=6,\n            axis_config={\"include_tip\": False},\n        )\n\n        t = ValueTracker(5)\n        k = 25\n\n        graph = ax.plot(\n            lambda x: k / x,\n            color=YELLOW_D,\n            x_range=[k / 10, 10.0, 0.01],\n            use_smoothing=False,\n        )\n\n        def get_rectangle():\n            polygon = Polygon(\n                *[\n                    ax.c2p(*i)\n                    for i in self.get_rectangle_corners(\n                        (0, 0), (t.get_value(), k / t.get_value())\n                    )\n                ]\n            )\n            polygon.stroke_width = 1\n            polygon.set_fill(BLUE, opacity=0.5)\n            polygon.set_stroke(YELLOW_B)\n            return polygon\n\n        polygon = always_redraw(get_rectangle)\n\n        dot = Dot()\n        dot.add_updater(lambda x: x.move_to(ax.c2p(t.get_value(), k / t.get_value())))\n        dot.set_z_index(10)\n\n        self.add(ax, graph, dot)\n        self.play(Create(polygon))\n        self.play(t.animate.set_value(10))\n        self.play(t.animate.set_value(k / 10))\n        self.play(t.animate.set_value(5))", "code_sha1": "851a3c2dd35aa6c7431410b0bd015967a8dbf1da"}
{"url": "https://docs.manim.community/en/stable/examples.html", "depth": 0, "instruction": "A 2D coordinate system with labeled axes (x: ΔQ, y: T[°C]) is displayed, featuring a line graph connecting points (0, 20), (8, 0), (38, 0), and (39, -5). The axes range from 0 to 40 on the x-axis and -8 to 32 on the y-axis, with no axis tips.", "code": "class HeatDiagramPlot(Scene):\n    def construct(self):\n        ax = Axes(\n            x_range=[0, 40, 5],\n            y_range=[-8, 32, 5],\n            x_length=9,\n            y_length=6,\n            x_axis_config={\"numbers_to_include\": np.arange(0, 40, 5)},\n            y_axis_config={\"numbers_to_include\": np.arange(-5, 34, 5)},\n            tips=False,\n        )\n        labels = ax.get_axis_labels(\n            x_label=Tex(r\"$\\Delta Q$\"), y_label=Tex(r\"T[$^\\circ C$]\")\n        )\n\n        x_vals = [0, 8, 38, 39]\n        y_vals = [20, 0, 0, -5]\n        graph = ax.plot_line_graph(x_values=x_vals, y_values=y_vals)\n\n        self.add(ax, labels, graph)", "code_sha1": "c64dd957030aea2754ae6c2eeece02daaf0e9cd7"}
{"url": "https://docs.manim.community/en/stable/examples.html", "depth": 0, "instruction": "The scene features a blue sine graph on a grid, with two static orange dots at the endpoints and a moving orange dot tracing the curve. The camera smoothly zooms in and follows the moving dot, which animates along the graph path, before restoring its original position.", "code": "class FollowingGraphCamera(MovingCameraScene):\n    def construct(self):\n        self.camera.frame.save_state()\n\n        # create the axes and the curve\n        ax = Axes(x_range=[-1, 10], y_range=[-1, 10])\n        graph = ax.plot(lambda x: np.sin(x), color=BLUE, x_range=[0, 3 * PI])\n\n        # create dots based on the graph\n        moving_dot = Dot(ax.i2gp(graph.t_min, graph), color=ORANGE)\n        dot_1 = Dot(ax.i2gp(graph.t_min, graph))\n        dot_2 = Dot(ax.i2gp(graph.t_max, graph))\n\n        self.add(ax, graph, dot_1, dot_2, moving_dot)\n        self.play(self.camera.frame.animate.scale(0.5).move_to(moving_dot))\n\n        def update_curve(mob):\n            mob.move_to(moving_dot.get_center())\n\n        self.camera.frame.add_updater(update_curve)\n        self.play(MoveAlongPath(moving_dot, graph, rate_func=linear))\n        self.camera.frame.remove_updater(update_curve)\n\n        self.play(Restore(self.camera.frame))", "code_sha1": "21c13878fdab50dcb2c1bcb98dfd0f2ca9c0bf03"}
{"url": "https://docs.manim.community/en/stable/examples.html", "depth": 0, "instruction": "The scene features a zoomed camera focusing on a dot and an image, with a purple frame and red display. Text labels appear and fade, while the frame and display scale and shift. A background rectangle updates dynamically, and the zoomed display pops out before fading away, concluding with a smooth uncreation of the frame.", "code": "class MovingZoomedSceneAround(ZoomedScene):\n# contributed by TheoremofBeethoven, www.youtube.com/c/TheoremofBeethoven\n    def __init__(self, **kwargs):\n        ZoomedScene.__init__(\n            self,\n            zoom_factor=0.3,\n            zoomed_display_height=1,\n            zoomed_display_width=6,\n            image_frame_stroke_width=20,\n            zoomed_camera_config={\n                \"default_frame_stroke_width\": 3,\n                },\n            **kwargs\n        )\n\n    def construct(self):\n        dot = Dot().shift(UL * 2)\n        image = ImageMobject(np.uint8([[0, 100, 30, 200],\n                                       [255, 0, 5, 33]]))\n        image.height = 7\n        frame_text = Text(\"Frame\", color=PURPLE, font_size=67)\n        zoomed_camera_text = Text(\"Zoomed camera\", color=RED, font_size=67)\n\n        self.add(image, dot)\n        zoomed_camera = self.zoomed_camera\n        zoomed_display = self.zoomed_display\n        frame = zoomed_camera.frame\n        zoomed_display_frame = zoomed_display.display_frame\n\n        frame.move_to(dot)\n        frame.set_color(PURPLE)\n        zoomed_display_frame.set_color(RED)\n        zoomed_display.shift(DOWN)\n\n        zd_rect = BackgroundRectangle(zoomed_display, fill_opacity=0, buff=MED_SMALL_BUFF)\n        self.add_foreground_mobject(zd_rect)\n\n        unfold_camera = UpdateFromFunc(zd_rect, lambda rect: rect.replace(zoomed_display))\n\n        frame_text.next_to(frame, DOWN)\n\n        self.play(Create(frame), FadeIn(frame_text, shift=UP))\n        self.activate_zooming()\n\n        self.play(self.get_zoomed_display_pop_out_animation(), unfold_camera)\n        zoomed_camera_text.next_to(zoomed_display_frame, DOWN)\n        self.play(FadeIn(zoomed_camera_text, shift=UP))\n        # Scale in        x   y  z\n        scale_factor = [0.5, 1.5, 0]\n        self.play(\n            frame.animate.scale(scale_factor),\n            zoomed_display.animate.scale(scale_factor),\n            FadeOut(zoomed_camera_text),\n            FadeOut(frame_text)\n        )\n        self.wait()\n        self.play(ScaleInPlace(zoomed_display, 2))\n        self.wait()\n        self.play(frame.animate.shift(2.5 * DOWN))\n        self.wait()\n        self.play(self.get_zoomed_display_pop_out_animation(), unfold_camera, rate_func=lambda t: smooth(1 - t))\n        self.play(Uncreate(zoomed_display_frame), FadeOut(frame))\n        self.wait()", "code_sha1": "8dc37bebc2810fbec6cfcee8a43717b12a508f67"}
{"url": "https://docs.manim.community/en/stable/examples.html", "depth": 0, "instruction": "A 3D scene displays axes in the background with a fixed 3D text \"This is a 3D text\" positioned in the upper left corner. The camera is oriented at a 75-degree elevation and -45-degree azimuth, creating a dynamic perspective. The scene pauses for a moment, allowing viewers to appreciate the setup.", "code": "class FixedInFrameMObjectTest(ThreeDScene):\n    def construct(self):\n        axes = ThreeDAxes()\n        self.set_camera_orientation(phi=75 * DEGREES, theta=-45 * DEGREES)\n        text3d = Text(\"This is a 3D text\")\n        self.add_fixed_in_frame_mobjects(text3d)\n        text3d.to_corner(UL)\n        self.add(axes)\n        self.wait()", "code_sha1": "67859c63fa5e9474862e5c166248a4949bf68c6a"}
{"url": "https://docs.manim.community/en/stable/examples.html", "depth": 0, "instruction": "A 3D scene displays a set of axes and a red checkerboard-patterned sphere, illuminated from a light source positioned at (0, 0, -3). The camera is oriented at a 75-degree elevation and a 30-degree azimuth, showcasing the sphere's surface details and depth.", "code": "class ThreeDLightSourcePosition(ThreeDScene):\n    def construct(self):\n        axes = ThreeDAxes()\n        sphere = Surface(\n            lambda u, v: np.array([\n                1.5 * np.cos(u) * np.cos(v),\n                1.5 * np.cos(u) * np.sin(v),\n                1.5 * np.sin(u)\n            ]), v_range=[0, TAU], u_range=[-PI / 2, PI / 2],\n            checkerboard_colors=[RED_D, RED_E], resolution=(15, 32)\n        )\n        self.renderer.camera.light_source.move_to(3*IN) # changes the source of the light\n        self.set_camera_orientation(phi=75 * DEGREES, theta=30 * DEGREES)\n        self.add(axes, sphere)", "code_sha1": "d89d9160bdba91368c2df2e2bfea553c10443cfe"}
{"url": "https://docs.manim.community/en/stable/examples.html", "depth": 0, "instruction": "A 3D scene featuring a blue circle and axes is displayed, with the camera initially set at a 75-degree elevation and 30-degree azimuth. The camera rotates continuously at a slow rate, then stops, maintaining the same orientation before concluding the scene.", "code": "class ThreeDCameraRotation(ThreeDScene):\n    def construct(self):\n        axes = ThreeDAxes()\n        circle=Circle()\n        self.set_camera_orientation(phi=75 * DEGREES, theta=30 * DEGREES)\n        self.add(circle,axes)\n        self.begin_ambient_camera_rotation(rate=0.1)\n        self.wait()\n        self.stop_ambient_camera_rotation()\n        self.move_camera(phi=75 * DEGREES, theta=30 * DEGREES)\n        self.wait()", "code_sha1": "7eb7623b1fe0dda222eddcf692abc8510ad8e1a3"}
{"url": "https://docs.manim.community/en/stable/examples.html", "depth": 0, "instruction": "The scene features a 3D coordinate system with axes and a circle, viewed from a fixed angle. The camera performs an illusionary rotation around the objects at a rate of 2, creating a dynamic visual effect for 1.57 seconds before stopping, while maintaining the initial camera orientation.", "code": "class ThreeDCameraIllusionRotation(ThreeDScene):\n    def construct(self):\n        axes = ThreeDAxes()\n        circle=Circle()\n        self.set_camera_orientation(phi=75 * DEGREES, theta=30 * DEGREES)\n        self.add(circle,axes)\n        self.begin_3dillusion_camera_rotation(rate=2)\n        self.wait(PI/2)\n        self.stop_3dillusion_camera_rotation()", "code_sha1": "99efc10608e83468326a28a0ec4a57f4033fef69"}
{"url": "https://docs.manim.community/en/stable/examples.html", "depth": 0, "instruction": "A 3D surface plot of a Gaussian function is displayed, colored with an orange and blue checkerboard pattern, and outlined in green. The surface is scaled to twice its size and positioned above a set of 3D axes, with the camera oriented at a 75-degree elevation and -30-degree azimuth.", "code": "class ThreeDSurfacePlot(ThreeDScene):\n    def construct(self):\n        resolution_fa = 24\n        self.set_camera_orientation(phi=75 * DEGREES, theta=-30 * DEGREES)\n\n        def param_gauss(u, v):\n            x = u\n            y = v\n            sigma, mu = 0.4, [0.0, 0.0]\n            d = np.linalg.norm(np.array([x - mu[0], y - mu[1]]))\n            z = np.exp(-(d ** 2 / (2.0 * sigma ** 2)))\n            return np.array([x, y, z])\n\n        gauss_plane = Surface(\n            param_gauss,\n            resolution=(resolution_fa, resolution_fa),\n            v_range=[-2, +2],\n            u_range=[-2, +2]\n        )\n\n        gauss_plane.scale(2, about_point=ORIGIN)\n        gauss_plane.set_style(fill_opacity=1,stroke_color=GREEN)\n        gauss_plane.set_fill_by_checkerboard(ORANGE, BLUE, opacity=0.5)\n        axes = ThreeDAxes()\n        self.add(axes,gauss_plane)", "code_sha1": "ee92b2cef800698a552b68c0fdafad77b183c04e"}
{"url": "https://docs.manim.community/en/stable/examples.html", "depth": 0, "instruction": "The scene features a LaTeX title and a mathematical equation appearing sequentially, followed by a transformation of the title and fading out of the equation. A grid is created with a large title, then the grid undergoes a non-linear transformation while the title changes, all with smooth animations and a wait time in between.", "code": "class OpeningManim(Scene):\n    def construct(self):\n        title = Tex(r\"This is some \\LaTeX\")\n        basel = MathTex(r\"\\sum_{n=1}^\\infty \\frac{1}{n^2} = \\frac{\\pi^2}{6}\")\n        VGroup(title, basel).arrange(DOWN)\n        self.play(\n            Write(title),\n            FadeIn(basel, shift=DOWN),\n        )\n        self.wait()\n\n        transform_title = Tex(\"That was a transform\")\n        transform_title.to_corner(UP + LEFT)\n        self.play(\n            Transform(title, transform_title),\n            LaggedStart(*[FadeOut(obj, shift=DOWN) for obj in basel]),\n        )\n        self.wait()\n\n        grid = NumberPlane()\n        grid_title = Tex(\"This is a grid\", font_size=72)\n        grid_title.move_to(transform_title)\n\n        self.add(grid, grid_title)  # Make sure title is on top of grid\n        self.play(\n            FadeOut(title),\n            FadeIn(grid_title, shift=UP),\n            Create(grid, run_time=3, lag_ratio=0.1),\n        )\n        self.wait()\n\n        grid_transform_title = Tex(\n            r\"That was a non-linear function \\\\ applied to the grid\"\n        )\n        grid_transform_title.move_to(grid_title, UL)\n        grid.prepare_for_nonlinear_transform()\n        self.play(\n            grid.animate.apply_function(\n                lambda p: p\n                          + np.array(\n                    [\n                        np.sin(p[1]),\n                        np.sin(p[0]),\n                        0,\n                    ]\n                )\n            ),\n            run_time=3,\n        )\n        self.wait()\n        self.play(Transform(grid_title, grid_transform_title))\n        self.wait()", "code_sha1": "f67503b68583246c51ed298570779f2abf6ab8f0"}
{"url": "https://docs.manim.community/en/stable/examples.html", "depth": 0, "instruction": "A yellow dot orbits a blue circle while tracing a yellow sine curve, with axes labeled at intervals of π. The scene features a static blue line from the origin to the dot and a dynamic yellow line from the dot to the curve, all animated over 8.5 seconds.", "code": "class SineCurveUnitCircle(Scene):\n    # contributed by heejin_park, https://infograph.tistory.com/230\n    def construct(self):\n        self.show_axis()\n        self.show_circle()\n        self.move_dot_and_draw_curve()\n        self.wait()\n\n    def show_axis(self):\n        x_start = np.array([-6,0,0])\n        x_end = np.array([6,0,0])\n\n        y_start = np.array([-4,-2,0])\n        y_end = np.array([-4,2,0])\n\n        x_axis = Line(x_start, x_end)\n        y_axis = Line(y_start, y_end)\n\n        self.add(x_axis, y_axis)\n        self.add_x_labels()\n\n        self.origin_point = np.array([-4,0,0])\n        self.curve_start = np.array([-3,0,0])\n\n    def add_x_labels(self):\n        x_labels = [\n            MathTex(r\"\\pi\"), MathTex(r\"2 \\pi\"),\n            MathTex(r\"3 \\pi\"), MathTex(r\"4 \\pi\"),\n        ]\n\n        for i in range(len(x_labels)):\n            x_labels[i].next_to(np.array([-1 + 2*i, 0, 0]), DOWN)\n            self.add(x_labels[i])\n\n    def show_circle(self):\n        circle = Circle(radius=1)\n        circle.move_to(self.origin_point)\n        self.add(circle)\n        self.circle = circle\n\n    def move_dot_and_draw_curve(self):\n        orbit = self.circle\n        origin_point = self.origin_point\n\n        dot = Dot(radius=0.08, color=YELLOW)\n        dot.move_to(orbit.point_from_proportion(0))\n        self.t_offset = 0\n        rate = 0.25\n\n        def go_around_circle(mob, dt):\n            self.t_offset += (dt * rate)\n            # print(self.t_offset)\n            mob.move_to(orbit.point_from_proportion(self.t_offset % 1))\n\n        def get_line_to_circle():\n            return Line(origin_point, dot.get_center(), color=BLUE)\n\n        def get_line_to_curve():\n            x = self.curve_start[0] + self.t_offset * 4\n            y = dot.get_center()[1]\n            return Line(dot.get_center(), np.array([x,y,0]), color=YELLOW_A, stroke_width=2 )\n\n\n        self.curve = VGroup()\n        self.curve.add(Line(self.curve_start,self.curve_start))\n        def get_curve():\n            last_line = self.curve[-1]\n            x = self.curve_start[0] + self.t_offset * 4\n            y = dot.get_center()[1]\n            new_line = Line(last_line.get_end(),np.array([x,y,0]), color=YELLOW_D)\n            self.curve.add(new_line)\n\n            return self.curve\n\n        dot.add_updater(go_around_circle)\n\n        origin_to_circle_line = always_redraw(get_line_to_circle)\n        dot_to_curve_line = always_redraw(get_line_to_curve)\n        sine_curve_line = always_redraw(get_curve)\n\n        self.add(dot)\n        self.add(orbit, origin_to_circle_line, dot_to_curve_line, sine_curve_line)\n        self.wait(8.5)\n\n        dot.remove_updater(go_around_circle)", "code_sha1": "a083ac71af5bdc016395be7538317b8b065a638f"}
{"url": "https://docs.manim.community/en/stable/installation/jupyter.html", "depth": 1, "instruction": "A square is created and displayed, then smoothly transforms into a pink circle with 50% opacity, while the background remains unchanged. The animation is concise, followed by a brief pause before the scene ends.", "code": "%%manim -qm -v WARNING SquareToCircle\n\nclass SquareToCircle(Scene):\n   def construct(self):\n      square = Square()\n      circle = Circle()\n      circle.set_fill(PINK, opacity=0.5)\n      self.play(Create(square))\n      self.play(Transform(square, circle))\n      self.wait()", "code_sha1": "be234ee3a8212c7597a1147f175244c8e3fc170f"}
{"url": "https://docs.manim.community/en/stable/tutorials/quickstart.html", "depth": 1, "instruction": "A pink circle with 50% opacity is animated onto the screen, appearing as if it is being drawn from nothing. The animation is smooth and continuous, showcasing the circle's outline filling in with the specified color.", "code": "from manim import *\n\n\nclass CreateCircle(Scene):\n    def construct(self):\n        circle = Circle()  # create a circle\n        circle.set_fill(PINK, opacity=0.5)  # set the color and transparency\n        self.play(Create(circle))  # show the circle on screen", "code_sha1": "cd6f049b703ae0b88f4e4401ca6b3d2355cddae3"}
{"url": "https://docs.manim.community/en/stable/tutorials/quickstart.html", "depth": 1, "instruction": "A pink circle is created and displayed on screen using the Create animation, appearing smoothly over a brief duration.", "code": "class CreateCircle(Scene):\n    def construct(self):\n        [...]", "code_sha1": "50c99aeff0c149fe16cec33de21d9ea3687e956c"}
{"url": "https://docs.manim.community/en/stable/tutorials/quickstart.html", "depth": 1, "instruction": "A pink circle with 50% opacity is created, and a square is rotated 45 degrees. The square is animated into the circle using a transformation, followed by a fade-out of the square, showcasing a smooth transition between the two shapes.", "code": "class SquareToCircle(Scene):\n    def construct(self):\n        circle = Circle()  # create a circle\n        circle.set_fill(PINK, opacity=0.5)  # set color and transparency\n\n        square = Square()  # create a square\n        square.rotate(PI / 4)  # rotate a certain amount\n\n        self.play(Create(square))  # animate the creation of the square\n        self.play(Transform(square, circle))  # interpolate the square into the circle\n        self.play(FadeOut(square))  # fade out animation", "code_sha1": "2e3dd86dd05f84566e6bc125fc0192544c044f8d"}
{"url": "https://docs.manim.community/en/stable/tutorials/quickstart.html", "depth": 1, "instruction": "The animation displays a pink circle with 50% opacity and a blue square, also with 50% opacity, positioned to the right of the circle with a 0.5 unit buffer. Both shapes are created simultaneously with a smooth entrance animation.", "code": "class SquareAndCircle(Scene):\n    def construct(self):\n        circle = Circle()  # create a circle\n        circle.set_fill(PINK, opacity=0.5)  # set the color and transparency\n\n        square = Square()  # create a square\n        square.set_fill(BLUE, opacity=0.5)  # set the color and transparency\n\n        square.next_to(circle, RIGHT, buff=0.5)  # set the position\n        self.play(Create(circle), Create(square))  # show the shapes on screen", "code_sha1": "c72dcbb21c495d333f062efcd9782544050e5c07"}
{"url": "https://docs.manim.community/en/stable/tutorials/quickstart.html", "depth": 1, "instruction": "The animation displays a square that first appears, then rotates 45 degrees, transforms into a circle, and finally changes to a pink color with 50% opacity. Each step is smoothly animated in sequence, showcasing dynamic transformations and color changes.", "code": "class AnimatedSquareToCircle(Scene):\n    def construct(self):\n        circle = Circle()  # create a circle\n        square = Square()  # create a square\n\n        self.play(Create(square))  # show the square on screen\n        self.play(square.animate.rotate(PI / 4))  # rotate the square\n        self.play(Transform(square, circle))  # transform the square into a circle\n        self.play(\n            square.animate.set_fill(PINK, opacity=0.5)\n        )  # color the circle on screen", "code_sha1": "e2e036212879ae7fd0b53ce43f9b84ab7ab084df"}
{"url": "https://docs.manim.community/en/stable/tutorials/quickstart.html", "depth": 1, "instruction": "The animation displays two squares: a blue square on the left and a green square on the right, both with 70% opacity. The blue square rotates 180 degrees using the .animate method, while the green square rotates 180 degrees using the Rotate method over 2 seconds. The scene concludes with a brief pause.", "code": "class DifferentRotations(Scene):\n    def construct(self):\n        left_square = Square(color=BLUE, fill_opacity=0.7).shift(2 * LEFT)\n        right_square = Square(color=GREEN, fill_opacity=0.7).shift(2 * RIGHT)\n        self.play(\n            left_square.animate.rotate(PI), Rotate(right_square, angle=PI), run_time=2\n        )\n        self.wait()", "code_sha1": "ecda428b491c48644a609ffa02a36419759628cc"}
{"url": "https://docs.manim.community/en/stable/tutorials/quickstart.html", "depth": 1, "instruction": "The scene displays a circle transforming into a square, then into a triangle, followed by a fade-out of the triangle. After a brief pause, the circle replaces the square, which then transforms into the triangle, concluding with the triangle fading out. All shapes are centered and maintain their original colors throughout the animations.", "code": "class TwoTransforms(Scene):\n    def transform(self):\n        a = Circle()\n        b = Square()\n        c = Triangle()\n        self.play(Transform(a, b))\n        self.play(Transform(a, c))\n        self.play(FadeOut(a))\n\n    def replacement_transform(self):\n        a = Circle()\n        b = Square()\n        c = Triangle()\n        self.play(ReplacementTransform(a, b))\n        self.play(ReplacementTransform(b, c))\n        self.play(FadeOut(c))\n\n    def construct(self):\n        self.transform()\n        self.wait(0.5)  # wait for 0.5 seconds\n        self.replacement_transform()", "code_sha1": "c1fcf5514cf3236d96704c0467b1b728be2fcd5a"}
{"url": "https://docs.manim.community/en/stable/tutorials/quickstart.html", "depth": 1, "instruction": "A circle transforms into a square, then into a triangle, with each shape smoothly morphing into the next. The animations occur sequentially, with a brief pause before each transformation, maintaining the circle's original position throughout the transitions.", "code": "from manim import *\n\nclass TransformCycle(Scene):\n    def construct(self):\n        a = Circle()\n        t1 = Square()\n        t2 = Triangle()\n        self.add(a)\n        self.wait()\n        for t in [t1,t2]:\n            self.play(Transform(a,t))", "code_sha1": "f056199765fa24f07a2d5aaddbcd62c2c5b47aca"}
{"url": "https://docs.manim.community/en/stable/tutorials/quickstart.html", "depth": 1, "instruction": "A circle transforms into a square, then into a triangle, with each shape appearing sequentially. The animations are smooth and continuous, maintaining the circle's position while changing its shape. The scene starts with the circle, pauses briefly, and then transitions through the shapes without any additional objects or camera movements.", "code": "class TransformCycle(Scene):\n    def construct(self):\n        a = Circle()\n        t1 = Square()\n        t2 = Triangle()\n        self.add(a)\n        self.wait()\n        for t in [t1,t2]:\n            self.play(Transform(a,t))", "code_sha1": "b2daccd61e5153e2fe2814c128c4f010c9ca6279"}
{"url": "https://docs.manim.community/en/stable/tutorials/output_and_config.html", "depth": 1, "instruction": "A circle appears at the center of the screen, with a default size and color, followed by a transition to a new section without any animations, resulting in an empty output for that section. The scene structure is organized into sections, but only the section with the circle will produce a video.", "code": "def construct(self):\n    self.next_section()\n    # this section doesn't have any animations and will be removed\n    # but no error will be thrown\n    # feel free to tend your flock of empty sections if you so desire\n    self.add(Circle())\n    self.next_section()", "code_sha1": "9c1b82284742e69e66fb56df09b6b75c6e62d9e4"}
{"url": "https://docs.manim.community/en/stable/tutorials/output_and_config.html", "depth": 1, "instruction": "A circle appears at the center of the screen, followed by a 1-second pause before transitioning to the next section, with no additional animations or camera operations.", "code": "def construct(self):\n    self.next_section()\n    self.add(Circle())\n    # now we wait 1sec and have an animation to satisfy the section\n    self.wait()\n    self.next_section()", "code_sha1": "73d03a72cb613d68959d1b45fb306073a9ba2eb3"}
{"url": "https://docs.manim.community/en/stable/tutorials/building_blocks.html", "depth": 1, "instruction": "A circle appears at the center of the screen, waits for one second, then disappears, followed by another one-second pause.", "code": "from manim import *\n\nclass CreatingMobjects(Scene):\n    def construct(self):\n        circle = Circle()\n        self.add(circle)\n        self.wait(1)\n        self.remove(circle)\n        self.wait(1)", "code_sha1": "474ab54e4bcd26272c78f75fe0be7627fe43fb32"}
{"url": "https://docs.manim.community/en/stable/tutorials/building_blocks.html", "depth": 1, "instruction": "The scene displays a circle (shifted left), a square (shifted up), and a triangle (shifted right), all centered on the screen. Each shape retains its default color and size, with a 1-second pause at the end to hold the view.", "code": "from manim import *\n\nclass Shapes(Scene):\n    def construct(self):\n        circle = Circle()\n        square = Square()\n        triangle = Triangle()\n\n        circle.shift(LEFT)\n        square.shift(UP)\n        triangle.shift(RIGHT)\n\n        self.add(circle, square, triangle)\n        self.wait(1)", "code_sha1": "fd66dd67ffcf4f2316636dd75bb6d18a973d1577"}
{"url": "https://docs.manim.community/en/stable/tutorials/building_blocks.html", "depth": 1, "instruction": "Three geometric shapes—a circle, square, and triangle—are displayed on screen. The circle is positioned 2 units left of the origin, the square is placed directly to the left of the circle, and the triangle aligns its left border with the circle's left border. The scene pauses for 1 second before ending.", "code": "from manim import *\n\nclass MobjectPlacement(Scene):\n    def construct(self):\n        circle = Circle()\n        square = Square()\n        triangle = Triangle()\n\n        # place the circle two units left from the origin\n        circle.move_to(LEFT * 2)\n        # place the square to the left of the circle\n        square.next_to(circle, LEFT)\n        # align the left border of the triangle to the left border of the circle\n        triangle.align_to(circle, LEFT)\n\n        self.add(circle, square, triangle)\n        self.wait(1)", "code_sha1": "8fad6a755794f99322f704a4b950142d833c09f6"}
{"url": "https://docs.manim.community/en/stable/tutorials/building_blocks.html", "depth": 1, "instruction": "A green circle with a thick border is positioned left, a fully opaque yellow square is above, and a semi-transparent pink triangle is on the right. All three shapes are displayed simultaneously for one second.", "code": "from manim import *\n\nclass MobjectStyling(Scene):\n    def construct(self):\n        circle = Circle().shift(LEFT)\n        square = Square().shift(UP)\n        triangle = Triangle().shift(RIGHT)\n\n        circle.set_stroke(color=GREEN, width=20)\n        square.set_fill(YELLOW, opacity=1.0)\n        triangle.set_fill(PINK, opacity=0.5)\n\n        self.add(circle, square, triangle)\n        self.wait(1)", "code_sha1": "f1c6b5eaaaa551672c43d800999360cf0f8ff511"}
{"url": "https://docs.manim.community/en/stable/tutorials/building_blocks.html", "depth": 1, "instruction": "The scene displays a green circle with a thick border, a fully opaque yellow square, and a semi-transparent pink triangle, arranged in that order from back to front. The objects are positioned left, up, and right, respectively, with a 1-second pause at the end.", "code": "from manim import *\n\nclass MobjectZOrder(Scene):\n    def construct(self):\n        circle = Circle().shift(LEFT)\n        square = Square().shift(UP)\n        triangle = Triangle().shift(RIGHT)\n\n        circle.set_stroke(color=GREEN, width=20)\n        square.set_fill(YELLOW, opacity=1.0)\n        triangle.set_fill(PINK, opacity=0.5)\n\n        self.add(triangle, square, circle)\n        self.wait(1)", "code_sha1": "59639f01474581d6e1112dd90188c841ec877493"}
{"url": "https://docs.manim.community/en/stable/tutorials/building_blocks.html", "depth": 1, "instruction": "A square fades in from transparency, rotates 45 degrees, and then fades out to transparency, with a 1-second pause at the end. The square remains centered throughout the animations, maintaining its original size and color.", "code": "from manim import *\n\nclass SomeAnimations(Scene):\n    def construct(self):\n        square = Square()\n\n        # some animations display mobjects, ...\n        self.play(FadeIn(square))\n\n        # ... some move or rotate mobjects around...\n        self.play(Rotate(square, PI/4))\n\n        # some animations remove mobjects from the screen\n        self.play(FadeOut(square))\n\n        self.wait(1)", "code_sha1": "870b81c6592d220042a164062de7fd5b086aed96"}
{"url": "https://docs.manim.community/en/stable/tutorials/building_blocks.html", "depth": 1, "instruction": "A red square fades to white, then shifts upward while rotating 60 degrees, with each animation lasting one second, followed by a one-second pause.", "code": "from manim import *\n\nclass AnimateExample(Scene):\n    def construct(self):\n        square = Square().set_fill(RED, opacity=1.0)\n        self.add(square)\n\n        # animate the change of color\n        self.play(square.animate.set_fill(WHITE))\n        self.wait(1)\n\n        # animate the change of position and the rotation at the same time\n        self.play(square.animate.shift(UP).rotate(PI / 3))\n        self.wait(1)", "code_sha1": "1187af7f6ae022041d61bf306cd9869846e7c03b"}
{"url": "https://docs.manim.community/en/stable/tutorials/building_blocks.html", "depth": 1, "instruction": "A square is added to the scene, then smoothly shifts upward over 3 seconds, followed by a 1-second pause before the scene ends.", "code": "from manim import *\n\nclass RunTime(Scene):\n    def construct(self):\n        square = Square()\n        self.add(square)\n        self.play(square.animate.shift(UP), run_time=3)\n        self.wait(1)", "code_sha1": "2c085b19f2dcf14b6510cef246ef85d9225d2719"}
{"url": "https://docs.manim.community/en/stable/tutorials/building_blocks.html", "depth": 1, "instruction": "A large white DecimalNumber animates from 0 to 100 over 4 seconds, centered at the origin, with a linear rate function. The number scales to 5 times its original size, maintaining its position as it updates. The scene includes a brief pause before and after the counting animation.", "code": "from manim import *\n\nclass Count(Animation):\n    def __init__(self, number: DecimalNumber, start: float, end: float, **kwargs) -> None:\n        # Pass number as the mobject of the animation\n        super().__init__(number,  **kwargs)\n        # Set start and end\n        self.start = start\n        self.end = end\n\n    def interpolate_mobject(self, alpha: float) -> None:\n        # Set value of DecimalNumber according to alpha\n        value = self.start + (alpha * (self.end - self.start))\n        self.mobject.set_value(value)\n\n\nclass CountingScene(Scene):\n    def construct(self):\n        # Create Decimal Number and add it to scene\n        number = DecimalNumber().set_color(WHITE).scale(5)\n        # Add an updater to keep the DecimalNumber centered as its value changes\n        number.add_updater(lambda number: number.move_to(ORIGIN))\n\n        self.add(number)\n\n        self.wait()\n\n        # Play the Count Animation to count from 0 to 100 in 4 seconds\n        self.play(Count(number, 0, 100), run_time=4, rate_func=linear)\n\n        self.wait()", "code_sha1": "c66677ade2ec791f7eef5d588f2c02c3ab36c2e7"}
{"url": "https://docs.manim.community/en/stable/tutorials/building_blocks.html", "depth": 1, "instruction": "The scene displays a polygon formed by connecting four points, with labeled text indicating the start, end, and center coordinates in yellow, red, and blue, respectively. Dots in various colors (yellow, red, green, blue, orange) highlight key points (corners, center, and midpoint) of the polygon, all added to the scene without animations.", "code": "from manim import *\n\nclass MobjectExample(Scene):\n    def construct(self):\n        p1 = [-1,-1, 0]\n        p2 = [ 1,-1, 0]\n        p3 = [ 1, 1, 0]\n        p4 = [-1, 1, 0]\n        a  = Line(p1,p2).append_points(Line(p2,p3).points).append_points(Line(p3,p4).points)\n        point_start  = a.get_start()\n        point_end    = a.get_end()\n        point_center = a.get_center()\n        self.add(Text(f\"a.get_start() = {np.round(point_start,2).tolist()}\", font_size=24).to_edge(UR).set_color(YELLOW))\n        self.add(Text(f\"a.get_end() = {np.round(point_end,2).tolist()}\", font_size=24).next_to(self.mobjects[-1],DOWN).set_color(RED))\n        self.add(Text(f\"a.get_center() = {np.round(point_center,2).tolist()}\", font_size=24).next_to(self.mobjects[-1],DOWN).set_color(BLUE))\n\n        self.add(Dot(a.get_start()).set_color(YELLOW).scale(2))\n        self.add(Dot(a.get_end()).set_color(RED).scale(2))\n        self.add(Dot(a.get_top()).set_color(GREEN_A).scale(2))\n        self.add(Dot(a.get_bottom()).set_color(GREEN_D).scale(2))\n        self.add(Dot(a.get_center()).set_color(BLUE).scale(2))\n        self.add(Dot(a.point_from_proportion(0.5)).set_color(ORANGE).scale(2))\n        self.add(*[Dot(x) for x in a.points])\n        self.add(a)", "code_sha1": "3fb3ce15d92487c28cc9710c77dcaa3c3d170278"}
{"url": "https://docs.manim.community/en/stable/tutorials/building_blocks.html", "depth": 1, "instruction": "A red square transforms into a red rectangle rotated slightly, set against a white background. The transformation occurs smoothly, showcasing the morphing of shapes.", "code": "from manim import *\n\nclass ExampleTransform(Scene):\n    def construct(self):\n        self.camera.background_color = WHITE\n        m1 = Square().set_color(RED)\n        m2 = Rectangle().set_color(RED).rotate(0.2)\n        self.play(Transform(m1,m2))", "code_sha1": "c1157a29f618f59725c4988c5d1dde0447f019b6"}
{"url": "https://docs.manim.community/en/stable/tutorials/building_blocks.html", "depth": 1, "instruction": "A red square transforms into a red circle, and a blue square transforms into a blue circle, both shifting from left to right. The background is white, and the transformations occur simultaneously over one second.", "code": "from manim import *\n\nclass ExampleRotation(Scene):\n    def construct(self):\n        self.camera.background_color = WHITE\n        m1a = Square().set_color(RED).shift(LEFT)\n        m1b = Circle().set_color(RED).shift(LEFT)\n        m2a = Square().set_color(BLUE).shift(RIGHT)\n        m2b = Circle().set_color(BLUE).shift(RIGHT)\n\n        points = m2a.points\n        points = np.roll(points, int(len(points)/4), axis=0)\n        m2a.points = points\n\n        self.play(Transform(m1a,m1b),Transform(m2a,m2b), run_time=1)", "code_sha1": "6f2f06fc715ebc335719692a8d0c4887bc71d52e"}
{"url": "https://docs.manim.community/en/stable/tutorials/building_blocks.html", "depth": 1, "instruction": "A circle appears at the center of the screen, waits for 1 second, then disappears, followed by another 1-second pause.", "code": "class CreatingMobjects(Scene):\n    def construct(self):\n        circle = Circle()\n        self.add(circle)\n        self.wait(1)\n        self.remove(circle)\n        self.wait(1)", "code_sha1": "e32d1670402b79bbaf19fdd46ad480d800907610"}
{"url": "https://docs.manim.community/en/stable/tutorials/building_blocks.html", "depth": 1, "instruction": "The scene displays a circle (shifted left), a square (shifted up), and a triangle (shifted right) in their default colors, arranged horizontally. Each shape is centered at its new position, and the scene pauses for one second before ending.", "code": "class Shapes(Scene):\n    def construct(self):\n        circle = Circle()\n        square = Square()\n        triangle = Triangle()\n\n        circle.shift(LEFT)\n        square.shift(UP)\n        triangle.shift(RIGHT)\n\n        self.add(circle, square, triangle)\n        self.wait(1)", "code_sha1": "3cf77c8a259204183a9ad408ec317c4b74ae5b74"}
{"url": "https://docs.manim.community/en/stable/tutorials/building_blocks.html", "depth": 1, "instruction": "Three shapes—a circle, square, and triangle—are displayed on screen. The circle is positioned two units left of the center, the square is placed directly to the left of the circle, and the triangle aligns its left border with the circle's left border. All shapes are added simultaneously, followed by a one-second pause.", "code": "class MobjectPlacement(Scene):\n    def construct(self):\n        circle = Circle()\n        square = Square()\n        triangle = Triangle()\n\n        # place the circle two units left from the origin\n        circle.move_to(LEFT * 2)\n        # place the square to the left of the circle\n        square.next_to(circle, LEFT)\n        # align the left border of the triangle to the left border of the circle\n        triangle.align_to(circle, LEFT)\n\n        self.add(circle, square, triangle)\n        self.wait(1)", "code_sha1": "50ff2a347e247fbee968013e20e0ec2b6d525a4c"}
{"url": "https://docs.manim.community/en/stable/tutorials/building_blocks.html", "depth": 1, "instruction": "A green-stroked circle (left), a fully yellow-filled square (up), and a pink-filled triangle (right, 50% opacity) are displayed simultaneously. The scene lasts for one second, showcasing the distinct colors and styles of each shape.", "code": "class MobjectStyling(Scene):\n    def construct(self):\n        circle = Circle().shift(LEFT)\n        square = Square().shift(UP)\n        triangle = Triangle().shift(RIGHT)\n\n        circle.set_stroke(color=GREEN, width=20)\n        square.set_fill(YELLOW, opacity=1.0)\n        triangle.set_fill(PINK, opacity=0.5)\n\n        self.add(circle, square, triangle)\n        self.wait(1)", "code_sha1": "5084af3fb8e7e73c42d2e9a3ef00f56eb3f6e970"}
{"url": "https://docs.manim.community/en/stable/tutorials/building_blocks.html", "depth": 1, "instruction": "The scene displays a green circle with a thick border, a fully opaque yellow square, and a semi-transparent pink triangle, arranged in that order from back to front. The objects are positioned left, up, and right, respectively, and the scene pauses for one second.", "code": "class MobjectZOrder(Scene):\n    def construct(self):\n        circle = Circle().shift(LEFT)\n        square = Square().shift(UP)\n        triangle = Triangle().shift(RIGHT)\n\n        circle.set_stroke(color=GREEN, width=20)\n        square.set_fill(YELLOW, opacity=1.0)\n        triangle.set_fill(PINK, opacity=0.5)\n\n        self.add(triangle, square, circle)\n        self.wait(1)", "code_sha1": "967ad0ccb029da384be3c321904f0636ddf2e796"}
{"url": "https://docs.manim.community/en/stable/tutorials/building_blocks.html", "depth": 1, "instruction": "A square fades in, becomes rotated by 45 degrees, and then fades out, with each animation smoothly transitioning over time. The scene includes a brief pause at the end.", "code": "class SomeAnimations(Scene):\n    def construct(self):\n        square = Square()\n\n        # some animations display mobjects, ...\n        self.play(FadeIn(square))\n\n        # ... some move or rotate mobjects around...\n        self.play(Rotate(square, PI/4))\n\n        # some animations remove mobjects from the screen\n        self.play(FadeOut(square))\n\n        self.wait(1)", "code_sha1": "b7d83891e2f2da1e1d4a5bac96bff5a114f78310"}
{"url": "https://docs.manim.community/en/stable/tutorials/building_blocks.html", "depth": 1, "instruction": "A red square fades to white, then shifts upward and rotates by 60 degrees, with each animation lasting one second, followed by a one-second pause.", "code": "class AnimateExample(Scene):\n    def construct(self):\n        square = Square().set_fill(RED, opacity=1.0)\n        self.add(square)\n\n        # animate the change of color\n        self.play(square.animate.set_fill(WHITE))\n        self.wait(1)\n\n        # animate the change of position and the rotation at the same time\n        self.play(square.animate.shift(UP).rotate(PI / 3))\n        self.wait(1)", "code_sha1": "73d31b06f63935ae65af7a88baac0af851d6e898"}
{"url": "https://docs.manim.community/en/stable/tutorials/building_blocks.html", "depth": 1, "instruction": "A square is added to the scene and animated to shift upward over 3 seconds, followed by a 1-second pause.", "code": "class RunTime(Scene):\n    def construct(self):\n        square = Square()\n        self.add(square)\n        self.play(square.animate.shift(UP), run_time=3)\n        self.wait(1)", "code_sha1": "93ce2e4be6a681b84962fc8a7346745b7a669dac"}
{"url": "https://docs.manim.community/en/stable/tutorials/building_blocks.html", "depth": 1, "instruction": "A large white DecimalNumber animates from 0 to 100 over 4 seconds, centered at the origin, with a linear rate function. The number scales to 5 times its original size, maintaining its position as it updates. The scene includes a brief pause before and after the counting animation.", "code": "class Count(Animation):\n    def __init__(self, number: DecimalNumber, start: float, end: float, **kwargs) -> None:\n        # Pass number as the mobject of the animation\n        super().__init__(number,  **kwargs)\n        # Set start and end\n        self.start = start\n        self.end = end\n\n    def interpolate_mobject(self, alpha: float) -> None:\n        # Set value of DecimalNumber according to alpha\n        value = self.start + (alpha * (self.end - self.start))\n        self.mobject.set_value(value)\n\n\nclass CountingScene(Scene):\n    def construct(self):\n        # Create Decimal Number and add it to scene\n        number = DecimalNumber().set_color(WHITE).scale(5)\n        # Add an updater to keep the DecimalNumber centered as its value changes\n        number.add_updater(lambda number: number.move_to(ORIGIN))\n\n        self.add(number)\n\n        self.wait()\n\n        # Play the Count Animation to count from 0 to 100 in 4 seconds\n        self.play(Count(number, 0, 100), run_time=4, rate_func=linear)\n\n        self.wait()", "code_sha1": "bdfb7ae508d7ecf3caf35ede74bb5a0186416a05"}
{"url": "https://docs.manim.community/en/stable/tutorials/building_blocks.html", "depth": 1, "instruction": "The scene displays a square formed by a line, with five colored dots marking its corners, center, and midpoint. Text annotations in yellow, red, and blue indicate the coordinates of the start, end, and center points, respectively. The square is outlined, and all elements are positioned dynamically around the square.", "code": "class MobjectExample(Scene):\n    def construct(self):\n        p1 = [-1,-1, 0]\n        p2 = [ 1,-1, 0]\n        p3 = [ 1, 1, 0]\n        p4 = [-1, 1, 0]\n        a  = Line(p1,p2).append_points(Line(p2,p3).points).append_points(Line(p3,p4).points)\n        point_start  = a.get_start()\n        point_end    = a.get_end()\n        point_center = a.get_center()\n        self.add(Text(f\"a.get_start() = {np.round(point_start,2).tolist()}\", font_size=24).to_edge(UR).set_color(YELLOW))\n        self.add(Text(f\"a.get_end() = {np.round(point_end,2).tolist()}\", font_size=24).next_to(self.mobjects[-1],DOWN).set_color(RED))\n        self.add(Text(f\"a.get_center() = {np.round(point_center,2).tolist()}\", font_size=24).next_to(self.mobjects[-1],DOWN).set_color(BLUE))\n\n        self.add(Dot(a.get_start()).set_color(YELLOW).scale(2))\n        self.add(Dot(a.get_end()).set_color(RED).scale(2))\n        self.add(Dot(a.get_top()).set_color(GREEN_A).scale(2))\n        self.add(Dot(a.get_bottom()).set_color(GREEN_D).scale(2))\n        self.add(Dot(a.get_center()).set_color(BLUE).scale(2))\n        self.add(Dot(a.point_from_proportion(0.5)).set_color(ORANGE).scale(2))\n        self.add(*[Dot(x) for x in a.points])\n        self.add(a)", "code_sha1": "be9de097d09f1d7891f7b9981e40bde274b2f645"}
{"url": "https://docs.manim.community/en/stable/tutorials/building_blocks.html", "depth": 1, "instruction": "A red square transforms into a red rectangle, both centered on the screen, against a white background. The transformation occurs smoothly, showcasing the morphing of shapes over time.", "code": "class ExampleTransform(Scene):\n    def construct(self):\n        self.camera.background_color = WHITE\n        m1 = Square().set_color(RED)\n        m2 = Rectangle().set_color(RED).rotate(0.2)\n        self.play(Transform(m1,m2))", "code_sha1": "1dc3d47e881b7f1cc90de1130a47d09967ed0c24"}
{"url": "https://docs.manim.community/en/stable/tutorials/building_blocks.html", "depth": 1, "instruction": "A red square transforms into a red circle, and a blue square transforms into a blue circle, both shifting from left to right. The background is white, and the transformations occur simultaneously over one second.", "code": "class ExampleRotation(Scene):\n    def construct(self):\n        self.camera.background_color = WHITE\n        m1a = Square().set_color(RED).shift(LEFT)\n        m1b = Circle().set_color(RED).shift(LEFT)\n        m2a = Square().set_color(BLUE).shift(RIGHT)\n        m2b = Circle().set_color(BLUE).shift(RIGHT)\n\n        points = m2a.points\n        points = np.roll(points, int(len(points)/4), axis=0)\n        m2a.points = points\n\n        self.play(Transform(m1a,m1b),Transform(m2a,m2b), run_time=1)", "code_sha1": "3f113ddf91e10366131bcb48dfadb7726065904c"}
{"url": "https://docs.manim.community/en/stable/guides/configuration.html", "depth": 1, "instruction": "The scene features a white background, with no visible objects or animations, as it is configured to render only the last frame without any animations or visual elements.", "code": "from manim import *\nconfig.background_color = WHITE\nconfig[\"background_color\"] = WHITE", "code_sha1": "b0c37379aee8039c139312ee27abc3cdeba6207d"}
{"url": "https://docs.manim.community/en/stable/guides/configuration.html", "depth": 1, "instruction": "The scene displays a dot at the center, a horizontal line labeled with the pixel width (1920) above it, and a vertical line labeled with the pixel height (1080) to the left. Both lines are positioned at the edges of the frame, creating a cross shape, with the text positioned adjacent to each line.", "code": "from manim import *\n\nclass ShowScreenResolution(Scene):\n    def construct(self):\n        pixel_height = config[\"pixel_height\"]  #  1080 is default\n        pixel_width = config[\"pixel_width\"]  # 1920 is default\n        frame_width = config[\"frame_width\"]\n        frame_height = config[\"frame_height\"]\n        self.add(Dot())\n        d1 = Line(frame_width * LEFT / 2, frame_width * RIGHT / 2).to_edge(DOWN)\n        self.add(d1)\n        self.add(Text(str(pixel_width)).next_to(d1, UP))\n        d2 = Line(frame_height * UP / 2, frame_height * DOWN / 2).to_edge(LEFT)\n        self.add(d2)\n        self.add(Text(str(pixel_height)).next_to(d2, RIGHT))", "code_sha1": "9c767a7136d625d93afdfb1c7e7a35e2a91dc07c"}
{"url": "https://docs.manim.community/en/stable/guides/configuration.html", "depth": 1, "instruction": "A scene displays a dot at the center, with a horizontal line labeled \"1920\" above it and a vertical line labeled \"1080\" to the left. The lines extend to the edges of the frame, visually representing the screen resolution in a clear, structured layout.", "code": "class ShowScreenResolution(Scene):\n    def construct(self):\n        pixel_height = config[\"pixel_height\"]  #  1080 is default\n        pixel_width = config[\"pixel_width\"]  # 1920 is default\n        frame_width = config[\"frame_width\"]\n        frame_height = config[\"frame_height\"]\n        self.add(Dot())\n        d1 = Line(frame_width * LEFT / 2, frame_width * RIGHT / 2).to_edge(DOWN)\n        self.add(d1)\n        self.add(Text(str(pixel_width)).next_to(d1, UP))\n        d2 = Line(frame_height * UP / 2, frame_height * DOWN / 2).to_edge(LEFT)\n        self.add(d2)\n        self.add(Text(str(pixel_height)).next_to(d2, RIGHT))", "code_sha1": "cd1a94edbf524a9c1ec32a3e8f76160e90c945fe"}
{"url": "https://docs.manim.community/en/stable/guides/deep_dive.html", "depth": 1, "instruction": "An orange square transforms into a blue circle over 3 seconds, followed by a small dot appearing below the circle. The circle then shifts right, with the dot following it. Finally, both the circle and dot fade out.", "code": "from manim import *\n\nclass ToyExample(Scene):\n    def construct(self):\n        orange_square = Square(color=ORANGE, fill_opacity=0.5)\n        blue_circle = Circle(color=BLUE, fill_opacity=0.5)\n        self.add(orange_square)\n        self.play(ReplacementTransform(orange_square, blue_circle, run_time=3))\n        small_dot = Dot()\n        small_dot.add_updater(lambda mob: mob.next_to(blue_circle, DOWN))\n        self.play(Create(small_dot))\n        self.play(blue_circle.animate.shift(RIGHT))\n        self.wait()\n        self.play(FadeOut(blue_circle, small_dot))", "code_sha1": "f73ff12304dacc7371c8e5eec0f8ebbf0441b8d7"}
{"url": "https://docs.manim.community/en/stable/guides/deep_dive.html", "depth": 1, "instruction": "A medium-quality animation displays an orange square transforming into a blue circle over 3 seconds, followed by a small dot that moves below the circle. The circle then shifts right, and both the circle and dot fade out at the end. The scene is rendered with a preview option enabled.", "code": "from manim import *\n\nclass ToyExample(Scene):\n    def construct(self):\n        orange_square = Square(color=ORANGE, fill_opacity=0.5)\n        blue_circle = Circle(color=BLUE, fill_opacity=0.5)\n        self.add(orange_square)\n        self.play(ReplacementTransform(orange_square, blue_circle, run_time=3))\n        small_dot = Dot()\n        small_dot.add_updater(lambda mob: mob.next_to(blue_circle, DOWN))\n        self.play(Create(small_dot))\n        self.play(blue_circle.animate.shift(RIGHT))\n        self.wait()\n        self.play(FadeOut(blue_circle, small_dot))\n\nwith tempconfig({\"quality\": \"medium_quality\", \"preview\": True}):\n    scene = ToyExample()\n    scene.render()", "code_sha1": "8779d24698bc759951147c144490d78b0b958390"}
{"url": "https://docs.manim.community/en/stable/guides/deep_dive.html", "depth": 1, "instruction": "A green VMobject composed of two cubic Bézier curves is displayed on a NumberPlane, with red dots representing control points and red lines connecting them to their respective anchor points. The VMobject and its components are added simultaneously without any animations.", "code": "from manim import *\n\nclass VMobjectDemo(Scene):\n    def construct(self):\n        plane = NumberPlane()\n        my_vmobject = VMobject(color=GREEN)\n        my_vmobject.points = [\n            np.array([-2, -1, 0]),  # start of first curve\n            np.array([-3, 1, 0]),\n            np.array([0, 3, 0]),\n            np.array([1, 3, 0]),  # end of first curve\n            np.array([1, 3, 0]),  # start of second curve\n            np.array([0, 1, 0]),\n            np.array([4, 3, 0]),\n            np.array([4, -2, 0]),  # end of second curve\n        ]\n        handles = [\n            Dot(point, color=RED) for point in\n            [[-3, 1, 0], [0, 3, 0], [0, 1, 0], [4, 3, 0]]\n        ]\n        handle_lines = [\n            Line(\n                my_vmobject.points[ind],\n                my_vmobject.points[ind+1],\n                color=RED,\n                stroke_width=2\n            ) for ind in range(0, len(my_vmobject.points), 2)\n        ]\n        self.add(plane, *handles, *handle_lines, my_vmobject)", "code_sha1": "712890efe01a61540412991721157fd946e6ec2a"}
{"url": "https://docs.manim.community/en/stable/guides/deep_dive.html", "depth": 1, "instruction": "A group containing an orange square and a blue circle is created and added to the scene, but upon restructuring, only the blue circle remains in the scene's mobjects list, effectively disbanding the group. The orange square is removed, leaving the blue circle as the sole visible object.", "code": "from manim import Scene, Square, Circle, Group\ntest_scene = Scene()\nmob1 = Square()\nmob2 = Circle()\nmob_group = Group(mob1, mob2)\ntest_scene.add(mob_group)\n<manim.scene.scene.Scene object at ...>\ntest_scene.mobjects\n[Group]\ntest_scene.restructure_mobjects(to_remove=[mob1])\n<manim.scene.scene.Scene object at ...>\ntest_scene.mobjects\n[Circle]", "code_sha1": "5e21065a979dd742bd9e6ded39ad2f7bdafda25b"}
{"url": "https://docs.manim.community/en/stable/guides/deep_dive.html", "depth": 1, "instruction": "A green VMobject composed of two cubic Bézier curves is displayed on a NumberPlane, with red dots representing control points and red lines connecting them to their respective anchor points. The VMobject is static, with no animations or camera operations applied.", "code": "class VMobjectDemo(Scene):\n    def construct(self):\n        plane = NumberPlane()\n        my_vmobject = VMobject(color=GREEN)\n        my_vmobject.points = [\n            np.array([-2, -1, 0]),  # start of first curve\n            np.array([-3, 1, 0]),\n            np.array([0, 3, 0]),\n            np.array([1, 3, 0]),  # end of first curve\n            np.array([1, 3, 0]),  # start of second curve\n            np.array([0, 1, 0]),\n            np.array([4, 3, 0]),\n            np.array([4, -2, 0]),  # end of second curve\n        ]\n        handles = [\n            Dot(point, color=RED) for point in\n            [[-3, 1, 0], [0, 3, 0], [0, 1, 0], [4, 3, 0]]\n        ]\n        handle_lines = [\n            Line(\n                my_vmobject.points[ind],\n                my_vmobject.points[ind+1],\n                color=RED,\n                stroke_width=2\n            ) for ind in range(0, len(my_vmobject.points), 2)\n        ]\n        self.add(plane, *handles, *handle_lines, my_vmobject)", "code_sha1": "7e84a6a0a27549d3f5dc84b23594aaeefcb82459"}
{"url": "https://docs.manim.community/en/stable/guides/using_text.html", "depth": 1, "instruction": "A large \"Hello world\" text appears centered on the screen with a font size of 144, rendered using the Pango library, without any animations or camera operations.", "code": "from manim import *\n\nclass HelloWorld(Scene):\n    def construct(self):\n        text = Text(\"Hello world\", font_size=144)\n        self.add(text)", "code_sha1": "0517c0dce6c6e02c982d1618c2250229a73cc08d"}
{"url": "https://docs.manim.community/en/stable/guides/using_text.html", "depth": 1, "instruction": "Display the text \"all in red except this\" with \"all in red\" in red and \"except this\" in yellow, centered on the screen. The text appears instantly without any animations.", "code": "from manim import *\n\nclass SingleLineColor(Scene):\n    def construct(self):\n        text = MarkupText(\n            f'all in red <span fgcolor=\"{YELLOW}\">except this</span>', color=RED\n        )\n        self.add(text)", "code_sha1": "c0531a982b3cddab3b475bc3be3320fc3c617788"}
{"url": "https://docs.manim.community/en/stable/guides/using_text.html", "depth": 1, "instruction": "The scene displays the text \"Noto Sans\" in the Noto Sans font, centered on the screen with default size and color.", "code": "from manim import *\n\nclass FontsExample(Scene):\n    def construct(self):\n        ft = Text(\"Noto Sans\", font=\"Noto Sans\")\n        self.add(ft)", "code_sha1": "52b370b3c845af32c63b809bb35b4ce1421d7483"}
{"url": "https://docs.manim.community/en/stable/guides/using_text.html", "depth": 1, "instruction": "A single italicized text \"Italic\" is displayed in the center of the scene, using a specified font. The text is styled with a slant effect, emphasizing its italic appearance.", "code": "from manim import *\n\nclass SlantsExample(Scene):\n    def construct(self):\n        a = Text(\"Italic\", slant=ITALIC)\n        self.add(a)", "code_sha1": "d225926979abe56ec36ba50955a2ec83f4034f64"}
{"url": "https://docs.manim.community/en/stable/guides/using_text.html", "depth": 1, "instruction": "A vertical arrangement of text labels displaying different font weights from \"Open Sans,\" each scaled to 50% size, with default colors, positioned evenly downwards in the scene.", "code": "from manim import *\n\nclass DifferentWeight(Scene):\n    def construct(self):\n        import manimpango\n\n        g = VGroup()\n        weight_list = dict(\n            sorted(\n                {\n                    weight: manimpango.Weight(weight).value\n                    for weight in manimpango.Weight\n                }.items(),\n                key=lambda x: x[1],\n            )\n        )\n        for weight in weight_list:\n            g += Text(weight.name, weight=weight.name, font=\"Open Sans\")\n        self.add(g.arrange(DOWN).scale(0.5))", "code_sha1": "80fc62d92ef221b595959d2900c92e137ecaade5"}
{"url": "https://docs.manim.community/en/stable/guides/using_text.html", "depth": 1, "instruction": "A red text \"RED COLOR\" appears centered on the screen, with a standard font style and no animations or camera operations.", "code": "from manim import *\n\nclass SimpleColor(Scene):\n    def construct(self):\n        col = Text(\"RED COLOR\", color=RED)\n        self.add(col)", "code_sha1": "86ff58cffff53a24860c0b2bd3904f1474d05e86"}
{"url": "https://docs.manim.community/en/stable/guides/using_text.html", "depth": 1, "instruction": "The scene displays two text objects: \"Hello\" in blue (except the first and last characters) positioned on the left, and \"World\" in red, placed to the right of \"Hello.\" Both texts are added to the scene without animations or camera operations.", "code": "from manim import *\n\nclass Textt2cExample(Scene):\n    def construct(self):\n        t2cindices = Text('Hello', t2c={'[1:-1]': BLUE}).move_to(LEFT)\n        t2cwords = Text('World',t2c={'rl':RED}).next_to(t2cindices, RIGHT)\n        self.add(t2cindices, t2cwords)", "code_sha1": "82ba2f1202d7293fe07e96b67fe634c223f81786"}
{"url": "https://docs.manim.community/en/stable/guides/using_text.html", "depth": 1, "instruction": "A large text \"Hello\" appears on the screen, displaying a smooth gradient transition from red to blue to green. The text is centered and has a font size of 96, creating a vibrant and visually appealing effect.", "code": "from manim import *\n\nclass GradientExample(Scene):\n    def construct(self):\n        t = Text(\"Hello\", gradient=(RED, BLUE, GREEN), font_size=96)\n        self.add(t)", "code_sha1": "e56dd7772fa1b6d490a6f55a61f2223d15febffb"}
{"url": "https://docs.manim.community/en/stable/guides/using_text.html", "depth": 1, "instruction": "The scene displays two text objects: \"Hello\" in a gradient from RED to GREEN (excluding the first and last characters) positioned on the left, and \"World\" in a gradient from RED to BLUE positioned to the right of \"Hello\". Both texts are added simultaneously without animations.", "code": "from manim import *\n\nclass t2gExample(Scene):\n    def construct(self):\n        t2gindices = Text(\n            'Hello',\n            t2g={\n                '[1:-1]': (RED,GREEN),\n            },\n        ).move_to(LEFT)\n        t2gwords = Text(\n            'World',\n            t2g={\n                'World':(RED,BLUE),\n            },\n        ).next_to(t2gindices, RIGHT)\n        self.add(t2gindices, t2gwords)", "code_sha1": "4a31d207c085459a076851b7c5314e1a2ca5c101"}
{"url": "https://docs.manim.community/en/stable/guides/using_text.html", "depth": 1, "instruction": "Two \"Hello\\nWorld\" text objects are displayed side by side with a leftward arrangement and a buffer of 5 units. The first text has a line spacing of 1, while the second has a line spacing of 4, creating a noticeable vertical distance between lines in the second text.", "code": "from manim import *\n\nclass LineSpacing(Scene):\n    def construct(self):\n        a = Text(\"Hello\\nWorld\", line_spacing=1)\n        b = Text(\"Hello\\nWorld\", line_spacing=4)\n        self.add(Group(a,b).arrange(LEFT, buff=5))", "code_sha1": "d22b90874f383902acd799a1ab17b904ee9a0e16"}
{"url": "https://docs.manim.community/en/stable/guides/using_text.html", "depth": 1, "instruction": "Two text objects, \"fl ligature\" with ligatures and \"fl ligature\" without ligatures, are displayed vertically aligned with a vertical spacing of 0.8 units. Both are sized at 96 points, showcasing the difference in character representation due to ligature settings.", "code": "from manim import *\n\nclass DisableLigature(Scene):\n    def construct(self):\n        li = Text(\"fl ligature\",font_size=96)\n        nli = Text(\"fl ligature\", disable_ligatures=True, font_size=96)\n        self.add(Group(li, nli).arrange(DOWN, buff=.8))", "code_sha1": "82f201825a69b7638d677b6542c5ed3774bbc39c"}
{"url": "https://docs.manim.community/en/stable/guides/using_text.html", "depth": 1, "instruction": "The scene displays the word \"Colors\" in a large font size (96), with each letter randomly colored using bright hues. The letters are positioned closely together, and no animations or camera operations are applied, resulting in a static visual of the colorful text.", "code": "from manim import *\n\nclass IterateColor(Scene):\n    def construct(self):\n        text = Text(\"Colors\", font_size=96)\n        for letter in text:\n            letter.set_color(random_bright_color())\n        self.add(text)", "code_sha1": "5c9048214a74ee60774ef6fe2cea7eabcc46d240"}
{"url": "https://docs.manim.community/en/stable/guides/using_text.html", "depth": 1, "instruction": "A red text phrase with a double green underline appears on screen, displaying the words \"double green underline\" prominently, while the phrase \"except this\" is highlighted in yellow, all rendered in a font size of 34.", "code": "from manim import *\n\nclass MarkupTest(Scene):\n    def construct(self):\n        text = MarkupText(\n            f'<span underline=\"double\" underline_color=\"green\">double green underline</span> in red text<span fgcolor=\"{YELLOW}\"> except this</span>',\n            color=RED,\n            font_size=34\n        )\n        self.add(text)", "code_sha1": "13717168926cf6561dde6902be60cce109738e03"}
{"url": "https://docs.manim.community/en/stable/guides/using_text.html", "depth": 1, "instruction": "A large, centered LaTeX text displaying \"LaTeX\" in a bold font appears on the screen, with a font size of 144. The scene starts with the text immediately visible, without any animations or camera operations.", "code": "from manim import *\n\nclass HelloLaTeX(Scene):\n    def construct(self):\n        tex = Tex(r\"\\LaTeX\", font_size=144)\n        self.add(tex)", "code_sha1": "197879d56b70b8691e2953ff78fc8f0f03edffdc"}
{"url": "https://docs.manim.community/en/stable/guides/using_text.html", "depth": 1, "instruction": "Two large mathematical arrows, both displaying \\( \\xrightarrow{x^6y^8} \\), are vertically arranged with a font size of 96. The first arrow uses MathTex, while the second uses Tex, both in default colors. The scene features no animations or camera operations.", "code": "from manim import *\n\nclass MathTeXDemo(Scene):\n    def construct(self):\n        rtarrow0 = MathTex(r\"\\xrightarrow{x^6y^8}\", font_size=96)\n        rtarrow1 = Tex(r\"$\\xrightarrow{x^6y^8}$\", font_size=96)\n\n        self.add(VGroup(rtarrow0, rtarrow1).arrange(DOWN))", "code_sha1": "5fd1ebeb47dd4084fe6f7376f54746af3a283a19"}
{"url": "https://docs.manim.community/en/stable/guides/using_text.html", "depth": 1, "instruction": "A large, bold text displaying \"H ↦ LaTeX\" in a monospaced font, with \"H\" in a dark color and the arrow in a contrasting color, centered on the screen. The text appears instantly without any animations.", "code": "from manim import *\n\nclass AMSLaTeX(Scene):\n    def construct(self):\n        tex = Tex(r'$\\mathtt{H} \\looparrowright$ \\LaTeX', font_size=144)\n        self.add(tex)", "code_sha1": "259234a3fef4c1d93deeb9ccf9c974344c124337"}
{"url": "https://docs.manim.community/en/stable/guides/using_text.html", "depth": 1, "instruction": "A blue \"Hello LaTeX\" text appears on the screen, rendered in a large font size of 144. The text is centered in the scene without any animations or camera operations.", "code": "from manim import *\n\nclass LaTeXAttributes(Scene):\n    def construct(self):\n        tex = Tex(r'Hello \\LaTeX', color=BLUE, font_size=144)\n        self.add(tex)", "code_sha1": "8588dc14320beb56c2313f4b04d9fa047d92f682"}
{"url": "https://docs.manim.community/en/stable/guides/using_text.html", "depth": 1, "instruction": "A large TeX equation displaying \"ℋ → ℍ\" in a script font, colored in default settings, is centered on the screen with a font size of 144. The scene features no animations or camera operations.", "code": "from manim import *\n\nclass AddPackageLatex(Scene):\n    def construct(self):\n        myTemplate = TexTemplate()\n        myTemplate.add_to_preamble(r\"\\usepackage{mathrsfs}\")\n        tex = Tex(\n            r\"$\\mathscr{H} \\rightarrow \\mathbb{H}$\",\n            tex_template=myTemplate,\n            font_size=144,\n        )\n        self.add(tex)", "code_sha1": "77869929b673551cd11d9c0cb70fabafcf35eb27"}
{"url": "https://docs.manim.community/en/stable/guides/using_text.html", "depth": 1, "instruction": "Display the text \"Hello\" in large font, with the star symbol and \"LaTeX\" in a single line. Color the substring \"igsta\" in red, while the rest remains in default color. The entire text appears simultaneously without any animations.", "code": "from manim import *\n\nclass LaTeXSubstrings(Scene):\n    def construct(self):\n        tex = Tex('Hello', r'$\\bigstar$', r'\\LaTeX', font_size=144)\n        tex.set_color_by_tex('igsta', RED)\n        self.add(tex)", "code_sha1": "03c3a39cbc948105753ab555b589f408dba39ffc"}
{"url": "https://docs.manim.community/en/stable/guides/using_text.html", "depth": 1, "instruction": "A yellow-colored equation displaying \\( e^x = x^0 + x^1 + \\frac{1}{2} x^2 + \\frac{1}{6} x^3 + \\cdots + \\frac{1}{n!} x^n + \\cdots \\) appears on the screen, with the entire equation incorrectly colored instead of just the \\( x \\) terms.", "code": "from manim import *\n\nclass IncorrectLaTeXSubstringColoring(Scene):\n    def construct(self):\n        equation = MathTex(\n            r\"e^x = x^0 + x^1 + \\frac{1}{2} x^2 + \\frac{1}{6} x^3 + \\cdots + \\frac{1}{n!} x^n + \\cdots\"\n        )\n        equation.set_color_by_tex(\"x\", YELLOW)\n        self.add(equation)", "code_sha1": "2680dfa2d3ab9b5623610939eb212cb61e51a999"}
{"url": "https://docs.manim.community/en/stable/guides/using_text.html", "depth": 1, "instruction": "A yellow-highlighted \"x\" appears within a complex mathematical equation rendered in white, centered on the screen. The equation is static, with no animations or camera operations applied.", "code": "from manim import *\n\nclass CorrectLaTeXSubstringColoring(Scene):\n    def construct(self):\n        equation = MathTex(\n            r\"e^x = x^0 + x^1 + \\frac{1}{2} x^2 + \\frac{1}{6} x^3 + \\cdots + \\frac{1}{n!} x^n + \\cdots\",\n            substrings_to_isolate=\"x\"\n        )\n        equation.set_color_by_tex(\"x\", YELLOW)\n        self.add(equation)", "code_sha1": "0b067916d73288700f8fafb8824f9601ce9595c8"}
{"url": "https://docs.manim.community/en/stable/guides/using_text.html", "depth": 1, "instruction": "A MathTex object displaying the binomial coefficient \\(\\binom{2n}{n+2}\\) is rendered, with the middle characters (2n) colored yellow and the bottom characters (n+2) colored red. Index labels are shown for the first term, aiding in identifying subcomponents. The font size is set to 96.", "code": "from manim import *\n\nclass IndexLabelsMathTex(Scene):\n    def construct(self):\n        text = MathTex(r\"\\binom{2n}{n+2}\", font_size=96)\n\n        # index the first (and only) term of the MathTex mob\n        self.add(index_labels(text[0]))\n\n        text[0][1:3].set_color(YELLOW)\n        text[0][3:6].set_color(RED)\n        self.add(text)", "code_sha1": "f00b98fdc44d0f6a4529f9fd9e7d910a9ff55490"}
{"url": "https://docs.manim.community/en/stable/guides/using_text.html", "depth": 1, "instruction": "A large, centered mathematical equation \"$x^2 + y^2 = z^2$\" is displayed in a cursive font, sized at 144 points, using the French cursive template. The equation appears without any animations or camera operations.", "code": "from manim import *\n\nclass LaTeXMathFonts(Scene):\n    def construct(self):\n        tex = Tex(\n            r\"$x^2 + y^2 = z^2$\",\n            tex_template=TexFontTemplates.french_cursive,\n            font_size=144,\n        )\n        self.add(tex)", "code_sha1": "bde1ce46ac330c2475861ae9d512dc0a61e9dda2"}
{"url": "https://docs.manim.community/en/stable/guides/using_text.html", "depth": 1, "instruction": "A large text displaying \"Hello 你好 LaTeX\" is rendered in a stylized font using the ctex LaTeX template, positioned at the center of the scene with a font size of 144.", "code": "from manim import *\n\nclass LaTeXTemplateLibrary(Scene):\n    def construct(self):\n        tex = Tex('Hello 你好 \\\\LaTeX', tex_template=TexTemplateLibrary.ctex, font_size=144)\n        self.add(tex)", "code_sha1": "a1a67a5063cac61837030ecf612b4ddeed7e4c4a"}
{"url": "https://docs.manim.community/en/stable/guides/using_text.html", "depth": 1, "instruction": "A multiline mathematical expression is displayed, aligned at the equals sign, with a font size of 96. The formula transitions from \\(f(x) = 3 + 2 + 1\\) to \\(= 6\\), showcasing step-by-step calculations in a clean, structured format.", "code": "from manim import *\n\nclass LaTeXAlignEnvironment(Scene):\n    def construct(self):\n        tex = MathTex(r'f(x) &= 3 + 2 + 1\\\\ &= 5 + 1 \\\\ &= 6', font_size=96)\n        self.add(tex)", "code_sha1": "859ee300ffab9738cf798d276e7d048d656e948f"}
{"url": "https://docs.manim.community/en/stable/guides/using_text.html", "depth": 1, "instruction": "A large \"Hello world\" text appears centered on the screen, rendered in a default font size of 144, with no animations or camera operations applied.", "code": "class HelloWorld(Scene):\n    def construct(self):\n        text = Text(\"Hello world\", font_size=144)\n        self.add(text)", "code_sha1": "96592184254557e5b065d21b3a968810a2f09d8c"}
{"url": "https://docs.manim.community/en/stable/guides/using_text.html", "depth": 1, "instruction": "Display the text \"all in red except this\" in a vibrant red color, centered on the screen, without any animations or camera operations.", "code": "class SingleLineColor(Scene):\n    def construct(self):\n        text = MarkupText(\n            f'all in red except this', color=RED\n        )\n        self.add(text)", "code_sha1": "e7e3f4bf1de15b33b364f2766ea01cd3b923efe8"}
{"url": "https://docs.manim.community/en/stable/guides/using_text.html", "depth": 1, "instruction": "A scene displays the text \"Noto Sans\" in the Noto Sans font, positioned at the center of the screen, with default size and color.", "code": "class FontsExample(Scene):\n    def construct(self):\n        ft = Text(\"Noto Sans\", font=\"Noto Sans\")\n        self.add(ft)", "code_sha1": "22aaa483f77086349abaa5b66ab0bee3e59cdc10"}
{"url": "https://docs.manim.community/en/stable/guides/using_text.html", "depth": 1, "instruction": "The scene displays the word \"Italic\" in an italicized font style, centered on the screen. The text is rendered in the default color and size, with no animations or camera operations applied.", "code": "class SlantsExample(Scene):\n    def construct(self):\n        a = Text(\"Italic\", slant=ITALIC)\n        self.add(a)", "code_sha1": "59c0315fe87ad0c55da4c55b5afb2aab631e5eb5"}
{"url": "https://docs.manim.community/en/stable/guides/using_text.html", "depth": 1, "instruction": "A vertical arrangement of text labels, each representing different font weights from \"Open Sans,\" displayed in a uniform size (50% scale) and positioned downwards. The text is added to the scene without any animations or camera operations.", "code": "class DifferentWeight(Scene):\n    def construct(self):\n        import manimpango\n\n        g = VGroup()\n        weight_list = dict(\n            sorted(\n                {\n                    weight: manimpango.Weight(weight).value\n                    for weight in manimpango.Weight\n                }.items(),\n                key=lambda x: x[1],\n            )\n        )\n        for weight in weight_list:\n            g += Text(weight.name, weight=weight.name, font=\"Open Sans\")\n        self.add(g.arrange(DOWN).scale(0.5))", "code_sha1": "c6f8823aca1274a189eeea14785cc3263c00a481"}
{"url": "https://docs.manim.community/en/stable/guides/using_text.html", "depth": 1, "instruction": "A red text \"RED COLOR\" is displayed in the center of the scene.", "code": "class SimpleColor(Scene):\n    def construct(self):\n        col = Text(\"RED COLOR\", color=RED)\n        self.add(col)", "code_sha1": "e9f9438ebddc083e6dcde6b528ef1b1020d2cbda"}
{"url": "https://docs.manim.community/en/stable/guides/using_text.html", "depth": 1, "instruction": "The scene displays the text \"Hello\" in blue, positioned to the left, and \"World\" in red, placed to the right of \"Hello.\" Both texts are added to the scene without animations or camera operations.", "code": "class Textt2cExample(Scene):\n    def construct(self):\n        t2cindices = Text('Hello', t2c={'[1:-1]': BLUE}).move_to(LEFT)\n        t2cwords = Text('World',t2c={'rl':RED}).next_to(t2cindices, RIGHT)\n        self.add(t2cindices, t2cwords)", "code_sha1": "a91d4cd2ab1bff59a39b6495882a90bcf2b1a7bc"}
{"url": "https://docs.manim.community/en/stable/guides/using_text.html", "depth": 1, "instruction": "A large text \"Hello\" appears on the screen, smoothly transitioning through a gradient from red to blue to green, with a font size of 96. The text is centered in the scene, showcasing vibrant color blending.", "code": "class GradientExample(Scene):\n    def construct(self):\n        t = Text(\"Hello\", gradient=(RED, BLUE, GREEN), font_size=96)\n        self.add(t)", "code_sha1": "8197bd3a11084e82305629037593cf53254565f3"}
{"url": "https://docs.manim.community/en/stable/guides/using_text.html", "depth": 1, "instruction": "The scene displays two text objects: \"Hello\" in a gradient from RED to GREEN, positioned on the left, and \"World\" in a gradient from RED to BLUE, positioned to the right of \"Hello.\" Both texts are added simultaneously without animations.", "code": "class t2gExample(Scene):\n    def construct(self):\n        t2gindices = Text(\n            'Hello',\n            t2g={\n                '[1:-1]': (RED,GREEN),\n            },\n        ).move_to(LEFT)\n        t2gwords = Text(\n            'World',\n            t2g={\n                'World':(RED,BLUE),\n            },\n        ).next_to(t2gindices, RIGHT)\n        self.add(t2gindices, t2gwords)", "code_sha1": "03f8937a68f6e53159f7679757582db4610944c5"}
{"url": "https://docs.manim.community/en/stable/guides/using_text.html", "depth": 1, "instruction": "Two \"Hello World\" text objects are displayed side by side, with the first having a line spacing of 1 and the second a line spacing of 4. They are arranged horizontally with a buffer of 5 units between them.", "code": "class LineSpacing(Scene):\n    def construct(self):\n        a = Text(\"Hello\\nWorld\", line_spacing=1)\n        b = Text(\"Hello\\nWorld\", line_spacing=4)\n        self.add(Group(a,b).arrange(LEFT, buff=5))", "code_sha1": "29acc88326682184d7dafffea2a399f0996fb8bf"}
{"url": "https://docs.manim.community/en/stable/guides/using_text.html", "depth": 1, "instruction": "Two text objects, \"fl ligature\" with ligatures and \"fl ligature\" without, are displayed vertically aligned with a vertical spacing of 0.8 units. Both are large (font size 96) and positioned centrally in the scene.", "code": "class DisableLigature(Scene):\n    def construct(self):\n        li = Text(\"fl ligature\",font_size=96)\n        nli = Text(\"fl ligature\", disable_ligatures=True, font_size=96)\n        self.add(Group(li, nli).arrange(DOWN, buff=.8))", "code_sha1": "a6d74ef6e5edc9e6d36e70e92d4e63978014be6f"}
{"url": "https://docs.manim.community/en/stable/guides/using_text.html", "depth": 1, "instruction": "The scene displays the word \"Colors\" in a large font size (96), with each letter randomly colored. The letters are individually colored, creating a vibrant, multicolored effect, and the text is centered on the screen without any animations or camera operations.", "code": "class IterateColor(Scene):\n    def construct(self):\n        text = Text(\"Colors\", font_size=96)\n        for letter in text:\n            letter.set_color(random_bright_color())\n        self.add(text)", "code_sha1": "3afc31c923f9b94aa3a4d2b1116c37c535b55694"}
{"url": "https://docs.manim.community/en/stable/guides/using_text.html", "depth": 1, "instruction": "A red text phrase appears on screen, featuring a double green underline, with a font size of 34. The text is displayed without any animations, positioned at the center of the scene.", "code": "class MarkupTest(Scene):\n    def construct(self):\n        text = MarkupText(\n            f'double green underline in red text except this',\n            color=RED,\n            font_size=34\n        )\n        self.add(text)", "code_sha1": "b4b132ebd174f6bf6680dacdaff1ba39b1fafaee"}
{"url": "https://docs.manim.community/en/stable/guides/using_text.html", "depth": 1, "instruction": "A large, centered LaTeX text displaying \"LaTeX\" in a bold font appears on the screen, with a font size of 144, creating a striking visual emphasis.", "code": "class HelloLaTeX(Scene):\n    def construct(self):\n        tex = Tex(r\"\\LaTeX\", font_size=144)\n        self.add(tex)", "code_sha1": "e2e58bffa8d85eb9f3fddd08ae80c1a0c815507d"}
{"url": "https://docs.manim.community/en/stable/guides/using_text.html", "depth": 1, "instruction": "Two large mathematical arrows, both styled identically with a font size of 96, are vertically arranged. The first arrow uses MathTex for rendering, while the second uses Tex, both displaying the expression \\( \\xrightarrow{x^6y^8} \\).", "code": "class MathTeXDemo(Scene):\n    def construct(self):\n        rtarrow0 = MathTex(r\"\\xrightarrow{x^6y^8}\", font_size=96)\n        rtarrow1 = Tex(r\"$\\xrightarrow{x^6y^8}$\", font_size=96)\n\n        self.add(VGroup(rtarrow0, rtarrow1).arrange(DOWN))", "code_sha1": "ba844a36b83a916e66e810435d56bfc784d67841"}
{"url": "https://docs.manim.community/en/stable/guides/using_text.html", "depth": 1, "instruction": "A large text displaying \"H ↦ LaTeX\" in a monospaced font, with \"H\" and the arrow in a distinct style, centered on the screen. The text is rendered in a bright color, emphasizing its mathematical context, with no animations or camera operations applied.", "code": "class AMSLaTeX(Scene):\n    def construct(self):\n        tex = Tex(r'$\\mathtt{H} \\looparrowright$ \\LaTeX', font_size=144)\n        self.add(tex)", "code_sha1": "a65c3d30e951edb530384b545ba6eee4100d32aa"}
{"url": "https://docs.manim.community/en/stable/guides/using_text.html", "depth": 1, "instruction": "A blue \"Hello LaTeX\" text appears on the screen, rendered in a large font size of 144. The text is centered in the scene without any animations or camera operations.", "code": "class LaTeXAttributes(Scene):\n    def construct(self):\n        tex = Tex(r'Hello \\LaTeX', color=BLUE, font_size=144)\n        self.add(tex)", "code_sha1": "c83bd06f81891ed0ad814dfc766bfd9ab254ca26"}
{"url": "https://docs.manim.community/en/stable/guides/using_text.html", "depth": 1, "instruction": "A large LaTeX equation displaying $\\mathscr{H} \\rightarrow \\mathbb{H}$ in a custom font size of 144, rendered in a scene with a white background, using the mathrsfs package for the script font. The equation is centered on the screen without any animations or camera operations.", "code": "class AddPackageLatex(Scene):\n    def construct(self):\n        myTemplate = TexTemplate()\n        myTemplate.add_to_preamble(r\"\\usepackage{mathrsfs}\")\n        tex = Tex(\n            r\"$\\mathscr{H} \\rightarrow \\mathbb{H}$\",\n            tex_template=myTemplate,\n            font_size=144,\n        )\n        self.add(tex)", "code_sha1": "639b9b57e67ac4816bcdec7fe26c8fc9f05b20ab"}
{"url": "https://docs.manim.community/en/stable/guides/using_text.html", "depth": 1, "instruction": "The scene displays the text \"Hello\" in large font, with the star symbol and \"LaTeX\" in a single line. The substring \"igsta\" is highlighted in red, while the rest remains in default color. The text is centered on the screen without any animations or camera operations.", "code": "class LaTeXSubstrings(Scene):\n    def construct(self):\n        tex = Tex('Hello', r'$\\bigstar$', r'\\LaTeX', font_size=144)\n        tex.set_color_by_tex('igsta', RED)\n        self.add(tex)", "code_sha1": "ba723b11da7e631bda350d3bd905741d2a15b757"}
{"url": "https://docs.manim.community/en/stable/guides/using_text.html", "depth": 1, "instruction": "A yellow-colored equation displaying \\( e^x = x^0 + x^1 + \\frac{1}{2} x^2 + \\frac{1}{6} x^3 + \\cdots + \\frac{1}{n!} x^n + \\cdots \\) appears on the screen, with all instances of \"x\" incorrectly colored, highlighting the limitation of the set_color_by_tex() method without substring isolation.", "code": "class IncorrectLaTeXSubstringColoring(Scene):\n    def construct(self):\n        equation = MathTex(\n            r\"e^x = x^0 + x^1 + \\frac{1}{2} x^2 + \\frac{1}{6} x^3 + \\cdots + \\frac{1}{n!} x^n + \\cdots\"\n        )\n        equation.set_color_by_tex(\"x\", YELLOW)\n        self.add(equation)", "code_sha1": "84ec13616e4ee1423f2b226bd37617eaa7da101b"}
{"url": "https://docs.manim.community/en/stable/guides/using_text.html", "depth": 1, "instruction": "A yellow-highlighted \"x\" appears within a complex mathematical equation rendered in white, centered on the screen. The equation is displayed without any animations or camera operations.", "code": "class CorrectLaTeXSubstringColoring(Scene):\n    def construct(self):\n        equation = MathTex(\n            r\"e^x = x^0 + x^1 + \\frac{1}{2} x^2 + \\frac{1}{6} x^3 + \\cdots + \\frac{1}{n!} x^n + \\cdots\",\n            substrings_to_isolate=\"x\"\n        )\n        equation.set_color_by_tex(\"x\", YELLOW)\n        self.add(equation)", "code_sha1": "a7452080ca9b9ad5c92b848d1ce2e04f73bc3ab1"}
{"url": "https://docs.manim.community/en/stable/guides/using_text.html", "depth": 1, "instruction": "A large binomial coefficient \\(\\binom{2n}{n+2}\\) is displayed, with the second and third characters highlighted in yellow and the fourth to sixth characters in red. The first term is indexed for clarity, and the scene includes a clean background with no additional animations or camera operations.", "code": "class IndexLabelsMathTex(Scene):\n    def construct(self):\n        text = MathTex(r\"\\binom{2n}{n+2}\", font_size=96)\n\n        # index the first (and only) term of the MathTex mob\n        self.add(index_labels(text[0]))\n\n        text[0][1:3].set_color(YELLOW)\n        text[0][3:6].set_color(RED)\n        self.add(text)", "code_sha1": "e55b07f3a1e65dcc9fb8902e17f809e81f884440"}
{"url": "https://docs.manim.community/en/stable/guides/using_text.html", "depth": 1, "instruction": "A large, cursive-styled mathematical equation \"$x^2 + y^2 = z^2$\" appears centered on the screen, rendered in a French cursive font with a font size of 144. The scene starts with the equation immediately visible, without any animations or camera operations.", "code": "class LaTeXMathFonts(Scene):\n    def construct(self):\n        tex = Tex(\n            r\"$x^2 + y^2 = z^2$\",\n            tex_template=TexFontTemplates.french_cursive,\n            font_size=144,\n        )\n        self.add(tex)", "code_sha1": "14c04b8b3920a176bff428182c37e81cb50a8853"}
{"url": "https://docs.manim.community/en/stable/guides/using_text.html", "depth": 1, "instruction": "A large \"Hello 你好 LaTeX\" text appears centered on the screen, rendered in a Chinese-compatible LaTeX template with a font size of 144. The text is static, with no animations or camera operations applied.", "code": "class LaTeXTemplateLibrary(Scene):\n    def construct(self):\n        tex = Tex('Hello 你好 \\\\LaTeX', tex_template=TexTemplateLibrary.ctex, font_size=144)\n        self.add(tex)", "code_sha1": "58715783894411b8333772ca733531a18ea0d3e6"}
{"url": "https://docs.manim.community/en/stable/guides/using_text.html", "depth": 1, "instruction": "A large, centered multiline mathematical equation appears on the screen, displaying the steps of a calculation in a clear, aligned format, using a font size of 96. The text is rendered in black against a white background.", "code": "class LaTeXAlignEnvironment(Scene):\n    def construct(self):\n        tex = MathTex(r'f(x) &= 3 + 2 + 1\\\\ &= 5 + 1 \\\\ &= 6', font_size=96)\n        self.add(tex)", "code_sha1": "632437b248fd551704ad374ff071268b26cd59fa"}
{"url": "https://docs.manim.community/en/stable/guides/add_voiceovers.html", "depth": 1, "instruction": "A circle is created on screen while a voiceover describes its drawing, followed by a leftward shift of the circle, timed to a subsequent voiceover. The circle is blue, and the animations are smooth, with each voiceover section dictating the timing of the corresponding animations.", "code": "from manim import *\nfrom manim_voiceover import VoiceoverScene\nfrom manim_voiceover.services.recorder import RecorderService\n\n\n# Simply inherit from VoiceoverScene instead of Scene to get all the\n# voiceover functionality.\nclass RecorderExample(VoiceoverScene):\n    def construct(self):\n        # You can choose from a multitude of TTS services,\n        # or in this example, record your own voice:\n        self.set_speech_service(RecorderService())\n\n        circle = Circle()\n\n        # Surround animation sections with with-statements:\n        with self.voiceover(text=\"This circle is drawn as I speak.\") as tracker:\n            self.play(Create(circle), run_time=tracker.duration)\n            # The duration of the animation is received from the audio file\n            # and passed to the tracker automatically.\n\n        # This part will not start playing until the previous voiceover is finished.\n        with self.voiceover(text=\"Let's shift it to the left 2 units.\") as tracker:\n            self.play(circle.animate.shift(2 * LEFT), run_time=tracker.duration)", "code_sha1": "6fd1bfac08f062605f31b896cf7b04d58dad7933"}
{"url": "https://docs.manim.community/en/stable/faq/general.html", "depth": 1, "instruction": "The scene displays a black frame due to the absence of a properly defined `construct` method; ensure it is correctly spelled and implemented to render visible objects.", "code": "class MyAwesomeScene(Scene):\n    def construct(self):\n\n        # your animation code", "code_sha1": "b41ed35980ee8face39b9a74567eb129f34abd2e"}
{"url": "https://docs.manim.community/en/stable/faq/general.html", "depth": 1, "instruction": "The code defines a new Scene class with two class attributes, `a` and `b`, both set to integers 1 and 2, respectively, without using CONFIG dictionaries, emphasizing direct attribute assignment for clarity and inheritance management.", "code": "class NewStyle(Scene):\n    a = 1\n    b = 2", "code_sha1": "d29464360a61963f51bf87fc8717cf04bbe620bd"}
{"url": "https://docs.manim.community/en/stable/reference/manim.animation.animation.html", "depth": 1, "instruction": "A square fades in using a \"Create\" animation instead of the standard \"FadeIn,\" appearing from nothing to full visibility in the center of the scene.", "code": "from manim import *\n\nclass MySquare(Square):\n    @override_animation(FadeIn)\n    def _fade_in_override(self, **kwargs):\n        return Create(self, **kwargs)\n\nclass OverrideAnimationExample(Scene):\n    def construct(self):\n        self.play(FadeIn(MySquare()))", "code_sha1": "9da02f503d8c30a232ae1c4503538fa7f82eab8b"}
{"url": "https://docs.manim.community/en/stable/reference/manim.animation.animation.html", "depth": 1, "instruction": "The visual result displays a square object appearing on screen with a fade-in effect, maintaining its original size and position. The animation is smooth and transitions over a standard duration, showcasing the square's introduction without any additional transformations or camera operations.", "code": "from manim import Square, FadeIn\ns = Square()\nprepare_animation(FadeIn(s))\nFadeIn(Square)", "code_sha1": "ff7f37219cbdcb19a781141773e4b13d7a41c932"}
{"url": "https://docs.manim.community/en/stable/reference/manim.animation.animation.html", "depth": 1, "instruction": "A square appears on the screen with a smooth creation animation instead of a fade-in, starting from a point and expanding to its full size, while the background remains static. The animation is executed immediately upon calling the `play` method.", "code": "class MySquare(Square):\n    @override_animation(FadeIn)\n    def _fade_in_override(self, **kwargs):\n        return Create(self, **kwargs)\n\nclass OverrideAnimationExample(Scene):\n    def construct(self):\n        self.play(FadeIn(MySquare()))", "code_sha1": "869c6a261b4a3e50b6f3760909f8cdb0d145a205"}
{"url": "https://docs.manim.community/en/stable/reference/manim.animation.animation.Add.html", "depth": 1, "instruction": "A rectangle surrounds three vertically arranged text objects (\"I was added with Add!\", \"Me too!\", \"And me!\") with a 0.5 buffer, appearing over 3 seconds. The first text appears after a 1-second wait, followed by the other two texts appearing simultaneously after another 1-second wait. The scene concludes with a pause.", "code": "from manim import *\n\nclass DefaultAddScene(Scene):\n    def construct(self):\n        text_1 = Text(\"I was added with Add!\")\n        text_2 = Text(\"Me too!\")\n        text_3 = Text(\"And me!\")\n        texts = VGroup(text_1, text_2, text_3).arrange(DOWN)\n        rect = SurroundingRectangle(texts, buff=0.5)\n\n        self.play(\n            Create(rect, run_time=3.0),\n            Succession(\n                Wait(1.0),\n                # You can Add a Mobject in the middle of an animation...\n                Add(text_1),\n                Wait(1.0),\n                # ...or multiple Mobjects at once!\n                Add(text_2, text_3),\n            ),\n        )\n        self.wait()", "code_sha1": "494f02d252193ea156f7778b2abbe1a4f7971451"}
{"url": "https://docs.manim.community/en/stable/reference/manim.animation.animation.Add.html", "depth": 1, "instruction": "A 5x5 grid of 25 circles appears sequentially, each added with a 0.2-second duration, creating a smooth visual effect. The circles are uniformly sized with a radius of 0.5, and the scene concludes with a brief pause.", "code": "from manim import *\n\nclass AddWithRunTimeScene(Scene):\n    def construct(self):\n        # A 5x5 grid of circles\n        circles = VGroup(\n            *[Circle(radius=0.5) for _ in range(25)]\n        ).arrange_in_grid(5, 5)\n\n        self.play(\n            Succession(\n                # Add a run_time of 0.2 to wait for 0.2 seconds after\n                # adding the circle, instead of using Wait(0.2) after Add!\n                *[Add(circle, run_time=0.2) for circle in circles],\n                rate_func=smooth,\n            )\n        )\n        self.wait()", "code_sha1": "94f626ef91b71ae69a08e886e16100fdcb0352b1"}
{"url": "https://docs.manim.community/en/stable/reference/manim.animation.animation.Add.html", "depth": 1, "instruction": "A rectangle surrounds three vertically arranged texts (\"I was added with Add!\", \"Me too!\", \"And me!\") as it is created over 3 seconds. After a 1-second wait, the first text appears, followed by a 1-second wait before the other two texts are added simultaneously. The scene concludes with a pause.", "code": "class DefaultAddScene(Scene):\n    def construct(self):\n        text_1 = Text(\"I was added with Add!\")\n        text_2 = Text(\"Me too!\")\n        text_3 = Text(\"And me!\")\n        texts = VGroup(text_1, text_2, text_3).arrange(DOWN)\n        rect = SurroundingRectangle(texts, buff=0.5)\n\n        self.play(\n            Create(rect, run_time=3.0),\n            Succession(\n                Wait(1.0),\n                # You can Add a Mobject in the middle of an animation...\n                Add(text_1),\n                Wait(1.0),\n                # ...or multiple Mobjects at once!\n                Add(text_2, text_3),\n            ),\n        )\n        self.wait()", "code_sha1": "2f84e0ab4be40241c89c5e2958d560a04902f564"}
{"url": "https://docs.manim.community/en/stable/reference/manim.animation.animation.Add.html", "depth": 1, "instruction": "A 5x5 grid of 25 circles, each with a radius of 0.5, is sequentially added to the scene with a smooth animation over 0.2 seconds per circle, followed by a brief pause.", "code": "class AddWithRunTimeScene(Scene):\n    def construct(self):\n        # A 5x5 grid of circles\n        circles = VGroup(\n            *[Circle(radius=0.5) for _ in range(25)]\n        ).arrange_in_grid(5, 5)\n\n        self.play(\n            Succession(\n                # Add a run_time of 0.2 to wait for 0.2 seconds after\n                # adding the circle, instead of using Wait(0.2) after Add!\n                *[Add(circle, run_time=0.2) for circle in circles],\n                rate_func=smooth,\n            )\n        )\n        self.wait()", "code_sha1": "04a5ab03eec500acc12c375109e155b0a869ab2f"}
{"url": "https://docs.manim.community/en/stable/reference/manim.animation.animation.Animation.html", "depth": 1, "instruction": "Four groups of dots animate downward simultaneously with varying lag ratios, creating a staggered effect. Each group is labeled with its corresponding ratio above, and after the first animation, all groups shift upward together with a slight delay, enhancing the visual rhythm. The scene features a clean layout with clear spacing and labels.", "code": "from manim import *\n\nclass LagRatios(Scene):\n    def construct(self):\n        ratios = [0, 0.1, 0.5, 1, 2]  # demonstrated lag_ratios\n\n        # Create dot groups\n        group = VGroup(*[Dot() for _ in range(4)]).arrange_submobjects()\n        groups = VGroup(*[group.copy() for _ in ratios]).arrange_submobjects(buff=1)\n        self.add(groups)\n\n        # Label groups\n        self.add(Text(\"lag_ratio = \", font_size=36).next_to(groups, UP, buff=1.5))\n        for group, ratio in zip(groups, ratios):\n            self.add(Text(str(ratio), font_size=36).next_to(group, UP))\n\n        #Animate groups with different lag_ratios\n        self.play(AnimationGroup(*[\n            group.animate(lag_ratio=ratio, run_time=1.5).shift(DOWN * 2)\n            for group, ratio in zip(groups, ratios)\n        ]))\n\n        # lag_ratio also works recursively on nested submobjects:\n        self.play(groups.animate(run_time=1, lag_ratio=0.1).shift(UP * 2))", "code_sha1": "c88b291c923d328aedd384587e6a11a7c092bf98"}
{"url": "https://docs.manim.community/en/stable/reference/manim.animation.animation.Animation.html", "depth": 1, "instruction": "A blue square with 25% opacity rotates 180 degrees over 2 seconds, followed by an indication animation with no color change. The animations are linear and default properties are reset afterward.", "code": "from manim import *\n\nclass ChangeDefaultAnimation(Scene):\n    def construct(self):\n        Rotate.set_default(run_time=2, rate_func=rate_functions.linear)\n        Indicate.set_default(color=None)\n\n        S = Square(color=BLUE, fill_color=BLUE, fill_opacity=0.25)\n        self.add(S)\n        self.play(Rotate(S, PI))\n        self.play(Indicate(S))\n\n        Rotate.set_default()\n        Indicate.set_default()", "code_sha1": "6e9d079cbe81d5d96bef6789ecdec1bede3a7714"}
{"url": "https://docs.manim.community/en/stable/reference/manim.animation.animation.Animation.html", "depth": 1, "instruction": "Four groups of dots animate downward with varying lag ratios, creating a staggered effect. Each group is labeled with its corresponding ratio above, and the entire arrangement shifts upward at the end. The animation lasts 1.5 seconds for the first part and 1 second for the final upward movement.", "code": "class LagRatios(Scene):\n    def construct(self):\n        ratios = [0, 0.1, 0.5, 1, 2]  # demonstrated lag_ratios\n\n        # Create dot groups\n        group = VGroup(*[Dot() for _ in range(4)]).arrange_submobjects()\n        groups = VGroup(*[group.copy() for _ in ratios]).arrange_submobjects(buff=1)\n        self.add(groups)\n\n        # Label groups\n        self.add(Text(\"lag_ratio = \", font_size=36).next_to(groups, UP, buff=1.5))\n        for group, ratio in zip(groups, ratios):\n            self.add(Text(str(ratio), font_size=36).next_to(group, UP))\n\n        #Animate groups with different lag_ratios\n        self.play(AnimationGroup(*[\n            group.animate(lag_ratio=ratio, run_time=1.5).shift(DOWN * 2)\n            for group, ratio in zip(groups, ratios)\n        ]))\n\n        # lag_ratio also works recursively on nested submobjects:\n        self.play(groups.animate(run_time=1, lag_ratio=0.1).shift(UP * 2))", "code_sha1": "83ae8a646cfb5e2af710b6d2c18c5ccfd0b91f48"}
{"url": "https://docs.manim.community/en/stable/reference/manim.animation.animation.Animation.html", "depth": 1, "instruction": "A blue square with 25% opacity rotates 180 degrees over 2 seconds, followed by an indication animation. The first animation uses a linear rate function, while the indication has no color change. The scene resets default animation settings afterward.", "code": "class ChangeDefaultAnimation(Scene):\n    def construct(self):\n        Rotate.set_default(run_time=2, rate_func=rate_functions.linear)\n        Indicate.set_default(color=None)\n\n        S = Square(color=BLUE, fill_color=BLUE, fill_opacity=0.25)\n        self.add(S)\n        self.play(Rotate(S, PI))\n        self.play(Indicate(S))\n\n        Rotate.set_default()\n        Indicate.set_default()", "code_sha1": "5f5fb6a8e18a6184a23e0da3c3f34e50a4184394"}
{"url": "https://docs.manim.community/en/stable/reference/manim.animation.changing.AnimatedBoundary.html", "depth": 1, "instruction": "The scene displays the text \"So shiny!\" with an animated boundary that cycles through red, green, and blue colors every 3 seconds, creating a vibrant effect. The text and boundary are centered, and the animation lasts for 2 seconds before the scene pauses.", "code": "from manim import *\n\nclass AnimatedBoundaryExample(Scene):\n    def construct(self):\n        text = Text(\"So shiny!\")\n        boundary = AnimatedBoundary(text, colors=[RED, GREEN, BLUE],\n                                    cycle_rate=3)\n        self.add(text, boundary)\n        self.wait(2)", "code_sha1": "b1eb735a83016dfe0ff0f42f87a319b141bb3f36"}
{"url": "https://docs.manim.community/en/stable/reference/manim.animation.changing.AnimatedBoundary.html", "depth": 1, "instruction": "The scene displays the text \"So shiny!\" surrounded by an animated boundary that cycles through red, green, and blue colors every 3 seconds, creating a vibrant effect. The text and boundary are centered, with the boundary's stroke width varying dynamically. The scene pauses for 2 seconds at the end.", "code": "class AnimatedBoundaryExample(Scene):\n    def construct(self):\n        text = Text(\"So shiny!\")\n        boundary = AnimatedBoundary(text, colors=[RED, GREEN, BLUE],\n                                    cycle_rate=3)\n        self.add(text, boundary)\n        self.wait(2)", "code_sha1": "0d83ba2d199317da095f19ce7142fc4fcbe318fe"}
{"url": "https://docs.manim.community/en/stable/reference/manim.animation.changing.TracedPath.html", "depth": 1, "instruction": "A red circle and a red dot move right across the screen, with the dot tracing a red path behind it. The circle rotates continuously while translating, and the animation lasts 4 seconds with a linear motion.", "code": "from manim import *\n\nclass TracedPathExample(Scene):\n    def construct(self):\n        circ = Circle(color=RED).shift(4*LEFT)\n        dot = Dot(color=RED).move_to(circ.get_start())\n        rolling_circle = VGroup(circ, dot)\n        trace = TracedPath(circ.get_start)\n        rolling_circle.add_updater(lambda m: m.rotate(-0.3))\n        self.add(trace, rolling_circle)\n        self.play(rolling_circle.animate.shift(8*RIGHT), run_time=4, rate_func=linear)", "code_sha1": "1ebf675a7066ac1e087b57c389165b01c9503c3a"}
{"url": "https://docs.manim.community/en/stable/reference/manim.animation.changing.TracedPath.html", "depth": 1, "instruction": "A dot moves along a curved path, traced by a line that gradually fades from fully opaque to transparent over 0.5 seconds, while the dot shifts left twice, first at a 45-degree angle and then at a -45-degree angle. The scene concludes with a brief pause.", "code": "from manim import *\n\nclass DissipatingPathExample(Scene):\n    def construct(self):\n        a = Dot(RIGHT * 2)\n        b = TracedPath(a.get_center, dissipating_time=0.5, stroke_opacity=[0, 1])\n        self.add(a, b)\n        self.play(a.animate(path_arc=PI / 4).shift(LEFT * 2))\n        self.play(a.animate(path_arc=-PI / 4).shift(LEFT * 2))\n        self.wait()", "code_sha1": "ae637081676ac3b4c5b42962a1af84fbaa0cd55f"}
{"url": "https://docs.manim.community/en/stable/reference/manim.animation.changing.TracedPath.html", "depth": 1, "instruction": "A red circle and a red dot rotate together while moving horizontally across the screen, leaving a red trace that follows the circle's path. The animation lasts 4 seconds with a linear motion, and the circle starts at the left, moving to the right.", "code": "class TracedPathExample(Scene):\n    def construct(self):\n        circ = Circle(color=RED).shift(4*LEFT)\n        dot = Dot(color=RED).move_to(circ.get_start())\n        rolling_circle = VGroup(circ, dot)\n        trace = TracedPath(circ.get_start)\n        rolling_circle.add_updater(lambda m: m.rotate(-0.3))\n        self.add(trace, rolling_circle)\n        self.play(rolling_circle.animate.shift(8*RIGHT), run_time=4, rate_func=linear)", "code_sha1": "febf026704f5d7893c93dec44d279054b3d8b113"}
{"url": "https://docs.manim.community/en/stable/reference/manim.animation.changing.TracedPath.html", "depth": 1, "instruction": "A dot moves along a curved path, first shifting left while tracing a line that fades from fully visible to invisible over 0.5 seconds. The path appears and disappears as the dot changes direction, creating a smooth visual effect.", "code": "class DissipatingPathExample(Scene):\n    def construct(self):\n        a = Dot(RIGHT * 2)\n        b = TracedPath(a.get_center, dissipating_time=0.5, stroke_opacity=[0, 1])\n        self.add(a, b)\n        self.play(a.animate(path_arc=PI / 4).shift(LEFT * 2))\n        self.play(a.animate(path_arc=-PI / 4).shift(LEFT * 2))\n        self.wait()", "code_sha1": "429bb84bc1f1207e06a851981cc353e4b217c5b9"}
{"url": "https://docs.manim.community/en/stable/reference/manim.animation.composition.LaggedStart.html", "depth": 1, "instruction": "Three dots shift right simultaneously, with a 25% lag between each, over 4 seconds. A red dashed line and a label indicating \"25%\" are positioned vertically, while a title \"lag_ratio = 0.25\" is at the top. The scene has a clean, minimalistic layout.", "code": "from manim import *\n\nclass LaggedStartExample(Scene):\n    def construct(self):\n        title = Text(\"lag_ratio = 0.25\").to_edge(UP)\n\n        dot1 = Dot(point=LEFT * 2 + UP, radius=0.16)\n        dot2 = Dot(point=LEFT * 2, radius=0.16)\n        dot3 = Dot(point=LEFT * 2 + DOWN, radius=0.16)\n        line_25 = DashedLine(\n            start=LEFT + UP * 2,\n            end=LEFT + DOWN * 2,\n            color=RED\n        )\n        label = Text(\"25%\", font_size=24).next_to(line_25, UP)\n        self.add(title, dot1, dot2, dot3, line_25, label)\n\n        self.play(LaggedStart(\n            dot1.animate.shift(RIGHT * 4),\n            dot2.animate.shift(RIGHT * 4),\n            dot3.animate.shift(RIGHT * 4),\n            lag_ratio=0.25,\n            run_time=4\n        ))", "code_sha1": "b754ad75b9d7711a355b3b1c68d645e3392df420"}
{"url": "https://docs.manim.community/en/stable/reference/manim.animation.composition.LaggedStart.html", "depth": 1, "instruction": "Three dots shift right simultaneously, with a 25% lag between each dot's movement, over a total duration of 4 seconds. A red dashed line and a label indicating \"25%\" appear above the line, while a title \"lag_ratio = 0.25\" is positioned at the top of the scene.", "code": "class LaggedStartExample(Scene):\n    def construct(self):\n        title = Text(\"lag_ratio = 0.25\").to_edge(UP)\n\n        dot1 = Dot(point=LEFT * 2 + UP, radius=0.16)\n        dot2 = Dot(point=LEFT * 2, radius=0.16)\n        dot3 = Dot(point=LEFT * 2 + DOWN, radius=0.16)\n        line_25 = DashedLine(\n            start=LEFT + UP * 2,\n            end=LEFT + DOWN * 2,\n            color=RED\n        )\n        label = Text(\"25%\", font_size=24).next_to(line_25, UP)\n        self.add(title, dot1, dot2, dot3, line_25, label)\n\n        self.play(LaggedStart(\n            dot1.animate.shift(RIGHT * 4),\n            dot2.animate.shift(RIGHT * 4),\n            dot3.animate.shift(RIGHT * 4),\n            lag_ratio=0.25,\n            run_time=4\n        ))", "code_sha1": "fc75018e1e18d6e8a17b7fb4408560676600273c"}
{"url": "https://docs.manim.community/en/stable/reference/manim.animation.composition.LaggedStartMap.html", "depth": 1, "instruction": "The scene displays a grid of 35 dots and a title \"LaggedStartMap\" at the top. Each dot and the title sequentially change to yellow with a ripple effect, using a lagged animation that lasts 2 seconds, with a back-and-forth motion and a lag ratio of 0.1.", "code": "from manim import *\n\nclass LaggedStartMapExample(Scene):\n    def construct(self):\n        title = Tex(\"LaggedStartMap\").to_edge(UP, buff=LARGE_BUFF)\n        dots = VGroup(\n            *[Dot(radius=0.16) for _ in range(35)]\n            ).arrange_in_grid(rows=5, cols=7, buff=MED_LARGE_BUFF)\n        self.add(dots, title)\n\n        # Animate yellow ripple effect\n        for mob in dots, title:\n            self.play(LaggedStartMap(\n                ApplyMethod, mob,\n                lambda m : (m.set_color, YELLOW),\n                lag_ratio = 0.1,\n                rate_func = there_and_back,\n                run_time = 2\n            ))", "code_sha1": "42859404787a18c46d0efd79dc503160179851c5"}
{"url": "https://docs.manim.community/en/stable/reference/manim.animation.composition.LaggedStartMap.html", "depth": 1, "instruction": "The scene displays a grid of 35 dots and a title \"LaggedStartMap\" at the top. Each dot and the title sequentially change to yellow with a ripple effect over 2 seconds, using a lagged animation that returns to the original color, creating a dynamic visual flow.", "code": "class LaggedStartMapExample(Scene):\n    def construct(self):\n        title = Tex(\"LaggedStartMap\").to_edge(UP, buff=LARGE_BUFF)\n        dots = VGroup(\n            *[Dot(radius=0.16) for _ in range(35)]\n            ).arrange_in_grid(rows=5, cols=7, buff=MED_LARGE_BUFF)\n        self.add(dots, title)\n\n        # Animate yellow ripple effect\n        for mob in dots, title:\n            self.play(LaggedStartMap(\n                ApplyMethod, mob,\n                lambda m : (m.set_color, YELLOW),\n                lag_ratio = 0.1,\n                rate_func = there_and_back,\n                run_time = 2\n            ))", "code_sha1": "0304ad12be57d7269dd732568bda4103d36569de"}
{"url": "https://docs.manim.community/en/stable/reference/manim.animation.composition.Succession.html", "depth": 1, "instruction": "Four colored dots (blue, maroon, green, yellow) are positioned at the corners of a square. They sequentially move to the next dot's position in a loop, creating a smooth, continuous animation. Each dot's movement occurs in succession, with a default timing that ensures each move starts after the previous one completes.", "code": "from manim import *\n\nclass SuccessionExample(Scene):\n    def construct(self):\n        dot1 = Dot(point=LEFT * 2 + UP * 2, radius=0.16, color=BLUE)\n        dot2 = Dot(point=LEFT * 2 + DOWN * 2, radius=0.16, color=MAROON)\n        dot3 = Dot(point=RIGHT * 2 + DOWN * 2, radius=0.16, color=GREEN)\n        dot4 = Dot(point=RIGHT * 2 + UP * 2, radius=0.16, color=YELLOW)\n        self.add(dot1, dot2, dot3, dot4)\n\n        self.play(Succession(\n            dot1.animate.move_to(dot2),\n            dot2.animate.move_to(dot3),\n            dot3.animate.move_to(dot4),\n            dot4.animate.move_to(dot1)\n        ))", "code_sha1": "d7afa642ec7c2b6dfe4abbfff04089841302a55a"}
{"url": "https://docs.manim.community/en/stable/reference/manim.animation.composition.Succession.html", "depth": 1, "instruction": "Four colored dots (blue, maroon, green, yellow) are positioned at the corners of a square. Each dot sequentially moves to the position of the next dot in a smooth succession, creating a continuous loop. The animation plays with a default lag ratio, ensuring each movement starts after the previous one completes.", "code": "class SuccessionExample(Scene):\n    def construct(self):\n        dot1 = Dot(point=LEFT * 2 + UP * 2, radius=0.16, color=BLUE)\n        dot2 = Dot(point=LEFT * 2 + DOWN * 2, radius=0.16, color=MAROON)\n        dot3 = Dot(point=RIGHT * 2 + DOWN * 2, radius=0.16, color=GREEN)\n        dot4 = Dot(point=RIGHT * 2 + UP * 2, radius=0.16, color=YELLOW)\n        self.add(dot1, dot2, dot3, dot4)\n\n        self.play(Succession(\n            dot1.animate.move_to(dot2),\n            dot2.animate.move_to(dot3),\n            dot3.animate.move_to(dot4),\n            dot4.animate.move_to(dot1)\n        ))", "code_sha1": "a19db2a4e461ede2bc2e828f7460488cf90ac7af"}
{"url": "https://docs.manim.community/en/stable/reference/manim.animation.creation.Create.html", "depth": 1, "instruction": "A square is created on the screen with a smooth drawing animation, appearing from nothing to its full size, using the default color and position at the center of the scene.", "code": "from manim import *\n\nclass CreateScene(Scene):\n    def construct(self):\n        self.play(Create(Square()))", "code_sha1": "f1adaf3c324ba531e3c8f9f2a15839de04a8e189"}
{"url": "https://docs.manim.community/en/stable/reference/manim.animation.creation.Create.html", "depth": 1, "instruction": "A square is drawn on the screen with a smooth animation, starting from an invisible state to fully visible, using the default animation timing. The square is centered in the scene and retains its default size and color.", "code": "class CreateScene(Scene):\n    def construct(self):\n        self.play(Create(Square()))", "code_sha1": "622bc6f2c309f6545d8abc9fb74ffb2736952d5e"}
{"url": "https://docs.manim.community/en/stable/reference/manim.animation.creation.DrawBorderThenFill.html", "depth": 1, "instruction": "A square with an orange fill and full opacity is animated by first drawing its border, followed by filling it in, creating a smooth transition effect.", "code": "from manim import *\n\nclass ShowDrawBorderThenFill(Scene):\n    def construct(self):\n        self.play(DrawBorderThenFill(Square(fill_opacity=1, fill_color=ORANGE)))", "code_sha1": "3b0ad702454bd2f7ffbeb9a2262231040df036b9"}
{"url": "https://docs.manim.community/en/stable/reference/manim.animation.creation.DrawBorderThenFill.html", "depth": 1, "instruction": "A square with an orange fill and full opacity is animated to first reveal its border, followed by filling the interior, creating a smooth transition effect.", "code": "class ShowDrawBorderThenFill(Scene):\n    def construct(self):\n        self.play(DrawBorderThenFill(Square(fill_opacity=1, fill_color=ORANGE)))", "code_sha1": "f2761ef28d1e2435d2fbe5ab837db7a962500b99"}
{"url": "https://docs.manim.community/en/stable/reference/manim.animation.creation.ShowIncreasingSubsets.html", "depth": 1, "instruction": "The scene displays a group of a dot, square, and triangle, revealing each shape sequentially with a smooth animation, while keeping previously shown shapes visible. The animation concludes with a brief pause before the scene ends.", "code": "from manim import *\n\nclass ShowIncreasingSubsetsScene(Scene):\n    def construct(self):\n        p = VGroup(Dot(), Square(), Triangle())\n        self.add(p)\n        self.play(ShowIncreasingSubsets(p))\n        self.wait()", "code_sha1": "60d837614b62977a3241864962506f0923ce79c2"}
{"url": "https://docs.manim.community/en/stable/reference/manim.animation.creation.ShowIncreasingSubsets.html", "depth": 1, "instruction": "The scene displays a group of three shapes (a dot, square, and triangle) sequentially appearing on screen, with each shape fading in one after the other while remaining visible. The animation concludes with a brief pause before the scene ends.", "code": "class ShowIncreasingSubsetsScene(Scene):\n    def construct(self):\n        p = VGroup(Dot(), Square(), Triangle())\n        self.add(p)\n        self.play(ShowIncreasingSubsets(p))\n        self.wait()", "code_sha1": "03fc96b2eb2635e4f4829a3074f2ba10426f9f40"}
{"url": "https://docs.manim.community/en/stable/reference/manim.animation.creation.SpiralIn.html", "depth": 1, "instruction": "The scene features a large, centered \\(\\pi\\) symbol (scaled to 7) alongside a green circle and a blue square, both fully opaque. The shapes spiral inward simultaneously, creating a dynamic entrance effect.", "code": "from manim import *\n\nclass SpiralInExample(Scene):\n    def construct(self):\n        pi = MathTex(r\"\\pi\").scale(7)\n        pi.shift(2.25 * LEFT + 1.5 * UP)\n        circle = Circle(color=GREEN_C, fill_opacity=1).shift(LEFT)\n        square = Square(color=BLUE_D, fill_opacity=1).shift(UP)\n        shapes = VGroup(pi, circle, square)\n        self.play(SpiralIn(shapes))", "code_sha1": "816d7d9dac159784acf75298bd68f13f860de543"}
{"url": "https://docs.manim.community/en/stable/reference/manim.animation.creation.SpiralIn.html", "depth": 1, "instruction": "The scene features a large, scaled \\( \\pi \\) symbol in the top left, a green filled circle to the left, and a blue filled square above. All three objects spiral inward simultaneously, with a smooth animation effect, creating a dynamic visual transition.", "code": "class SpiralInExample(Scene):\n    def construct(self):\n        pi = MathTex(r\"\\pi\").scale(7)\n        pi.shift(2.25 * LEFT + 1.5 * UP)\n        circle = Circle(color=GREEN_C, fill_opacity=1).shift(LEFT)\n        square = Square(color=BLUE_D, fill_opacity=1).shift(UP)\n        shapes = VGroup(pi, circle, square)\n        self.play(SpiralIn(shapes))", "code_sha1": "4515d70c03c53675e645f13c300d15b967143313"}
{"url": "https://docs.manim.community/en/stable/reference/manim.animation.creation.TypeWithCursor.html", "depth": 1, "instruction": "The scene features a purple text \"Inserting\" positioned on the left, with a grey cursor rectangle appearing at the start of the text. The cursor types the text with a typing animation, followed by two blinks, creating a dynamic insertion effect.", "code": "from manim import *\n\nclass InsertingTextExample(Scene):\n    def construct(self):\n        text = Text(\"Inserting\", color=PURPLE).scale(1.5).to_edge(LEFT)\n        cursor = Rectangle(\n            color = GREY_A,\n            fill_color = GREY_A,\n            fill_opacity = 1.0,\n            height = 1.1,\n            width = 0.5,\n        ).move_to(text[0]) # Position the cursor\n\n        self.play(TypeWithCursor(text, cursor))\n        self.play(Blink(cursor, blinks=2))", "code_sha1": "29c492a7c84dba90e9eac1770aa6507bb83d80c5"}
{"url": "https://docs.manim.community/en/stable/reference/manim.animation.creation.TypeWithCursor.html", "depth": 1, "instruction": "The scene displays a purple text \"Inserting\" scaled to 1.5, positioned to the left, with a grey rectangle cursor moving to the first letter. The text is typed out with the cursor, followed by two blinks of the cursor, creating a dynamic text insertion effect.", "code": "class InsertingTextExample(Scene):\n    def construct(self):\n        text = Text(\"Inserting\", color=PURPLE).scale(1.5).to_edge(LEFT)\n        cursor = Rectangle(\n            color = GREY_A,\n            fill_color = GREY_A,\n            fill_opacity = 1.0,\n            height = 1.1,\n            width = 0.5,\n        ).move_to(text[0]) # Position the cursor\n\n        self.play(TypeWithCursor(text, cursor))\n        self.play(Blink(cursor, blinks=2))", "code_sha1": "ddc74f844edf3623a42b882867dcbf9ffbe6e8f7"}
{"url": "https://docs.manim.community/en/stable/reference/manim.animation.creation.Uncreate.html", "depth": 1, "instruction": "A square gradually disappears from the center of the screen, reversing the creation process, with a smooth animation effect. The square's edges fade out, leaving the background visible, and the animation lasts for the default runtime duration.", "code": "from manim import *\n\nclass ShowUncreate(Scene):\n    def construct(self):\n        self.play(Uncreate(Square()))", "code_sha1": "de91ccf0fb418eaedab1142db876a66674fa887c"}
{"url": "https://docs.manim.community/en/stable/reference/manim.animation.creation.Uncreate.html", "depth": 1, "instruction": "A square gradually disappears from the center of the screen, reversing the creation process, with a smooth animation effect.", "code": "class ShowUncreate(Scene):\n    def construct(self):\n        self.play(Uncreate(Square()))", "code_sha1": "b3d3bfe06b0565c7fdd6b5b705810d4dc731edf2"}
{"url": "https://docs.manim.community/en/stable/reference/manim.animation.creation.UntypeWithCursor.html", "depth": 1, "instruction": "The scene features a purple \"Deleting\" text positioned on the left, accompanied by a grey cursor that moves to the first letter. The text is animated to appear as if being typed out, while the cursor blinks twice, enhancing the typing effect.", "code": "from manim import *\n\nclass DeletingTextExample(Scene):\n    def construct(self):\n        text = Text(\"Deleting\", color=PURPLE).scale(1.5).to_edge(LEFT)\n        cursor = Rectangle(\n            color = GREY_A,\n            fill_color = GREY_A,\n            fill_opacity = 1.0,\n            height = 1.1,\n            width = 0.5,\n        ).move_to(text[0]) # Position the cursor\n\n        self.play(UntypeWithCursor(text, cursor))\n        self.play(Blink(cursor, blinks=2))", "code_sha1": "04faa2ea403d27bdc12a7d98a5888d6e08c79c31"}
{"url": "https://docs.manim.community/en/stable/reference/manim.animation.creation.UntypeWithCursor.html", "depth": 1, "instruction": "The scene features a purple \"Deleting\" text scaling to 1.5, positioned to the left, with a grey cursor rectangle blinking twice as it types out the text character by character, creating a dynamic typing effect.", "code": "class DeletingTextExample(Scene):\n    def construct(self):\n        text = Text(\"Deleting\", color=PURPLE).scale(1.5).to_edge(LEFT)\n        cursor = Rectangle(\n            color = GREY_A,\n            fill_color = GREY_A,\n            fill_opacity = 1.0,\n            height = 1.1,\n            width = 0.5,\n        ).move_to(text[0]) # Position the cursor\n\n        self.play(UntypeWithCursor(text, cursor))\n        self.play(Blink(cursor, blinks=2))", "code_sha1": "2965828ba560b66e0dd35f8b6807aef7c189e525"}
{"url": "https://docs.manim.community/en/stable/reference/manim.animation.creation.Unwrite.html", "depth": 1, "instruction": "The scene displays the text \"Alice and Bob\" scaled to 3x its original size, which is added to the scene and then animated to gradually disappear in reverse order, creating a smooth unwriting effect.", "code": "from manim import *\n\nclass UnwriteReverseTrue(Scene):\n    def construct(self):\n        text = Tex(\"Alice and Bob\").scale(3)\n        self.add(text)\n        self.play(Unwrite(text))", "code_sha1": "f2c1e2a0a7597f6201a0bd0454da5c2328c1a6a1"}
{"url": "https://docs.manim.community/en/stable/reference/manim.animation.creation.Unwrite.html", "depth": 1, "instruction": "The scene displays the text \"Alice and Bob\" scaled to 3x size, which is animated to gradually disappear (unwritten) from the screen without reversing the order of its letters. The animation plays at a linear rate.", "code": "from manim import *\n\nclass UnwriteReverseFalse(Scene):\n    def construct(self):\n        text = Tex(\"Alice and Bob\").scale(3)\n        self.add(text)\n        self.play(Unwrite(text, reverse=False))", "code_sha1": "1a3960ac12e89285b618c728888a3ff493e8e872"}
{"url": "https://docs.manim.community/en/stable/reference/manim.animation.creation.Unwrite.html", "depth": 1, "instruction": "The scene displays the text \"Alice and Bob\" scaled to 3x its original size, which is added to the scene and then animated to unwrite (disappear) in reverse order, creating a smooth transition effect.", "code": "class UnwriteReverseTrue(Scene):\n    def construct(self):\n        text = Tex(\"Alice and Bob\").scale(3)\n        self.add(text)\n        self.play(Unwrite(text))", "code_sha1": "e8d2d6d1120b3e867920865eb7d34cb2f8102312"}
{"url": "https://docs.manim.community/en/stable/reference/manim.animation.creation.Unwrite.html", "depth": 1, "instruction": "The scene displays the text \"Alice and Bob\" scaled to 3x size, which is then animated to gradually disappear (unwritten) without reversing the order of its letters.", "code": "class UnwriteReverseFalse(Scene):\n    def construct(self):\n        text = Tex(\"Alice and Bob\").scale(3)\n        self.add(text)\n        self.play(Unwrite(text, reverse=False))", "code_sha1": "15dde65bf86dc0a221a3fce2cff29a82c21716ff"}
{"url": "https://docs.manim.community/en/stable/reference/manim.animation.creation.Write.html", "depth": 1, "instruction": "The scene displays the text \"Hello\" in a large font size (144), appearing as if it is being hand-written. The text is centered on the screen and the animation plays smoothly, creating a dynamic and engaging visual effect.", "code": "from manim import *\n\nclass ShowWrite(Scene):\n    def construct(self):\n        self.play(Write(Text(\"Hello\", font_size=144)))", "code_sha1": "146c1f5108e43a210ce02cd38c6388cfc62e50ac"}
{"url": "https://docs.manim.community/en/stable/reference/manim.animation.creation.Write.html", "depth": 1, "instruction": "The scene displays the text \"Hello\" in a large font (size 144), appearing as if it is being written in reverse. The animation plays smoothly without removing the text after completion.", "code": "from manim import *\n\nclass ShowWriteReversed(Scene):\n    def construct(self):\n        self.play(Write(Text(\"Hello\", font_size=144), reverse=True, remover=False))", "code_sha1": "0c5b14239433296816ac0904b691f84a1199ee0e"}
{"url": "https://docs.manim.community/en/stable/reference/manim.animation.creation.Write.html", "depth": 1, "instruction": "The visual result shows an empty scene with no text or objects displayed, as the Write animations are applied to empty Text objects, resulting in no visible output.", "code": "from manim import Write, Text\nWrite(Text(''))\nWrite(Text(''))", "code_sha1": "3c96b4f2405876f7e30462d5edf4f004edd8b39e"}
{"url": "https://docs.manim.community/en/stable/reference/manim.animation.creation.Write.html", "depth": 1, "instruction": "The scene displays the text \"Hello\" in a large font size (144), animated to appear as if it is being hand-written. The text is centered on the screen, and the animation plays smoothly, creating a dynamic and engaging visual effect.", "code": "class ShowWrite(Scene):\n    def construct(self):\n        self.play(Write(Text(\"Hello\", font_size=144)))", "code_sha1": "01dae21ed838d955dce2d78c3ee752fc8f8ede20"}
{"url": "https://docs.manim.community/en/stable/reference/manim.animation.creation.Write.html", "depth": 1, "instruction": "The scene displays the text \"Hello\" in a large font (size 144), which is animated to appear as if it is being written in reverse. The text remains on screen after the animation completes, with no additional objects or camera operations involved.", "code": "class ShowWriteReversed(Scene):\n    def construct(self):\n        self.play(Write(Text(\"Hello\", font_size=144), reverse=True, remover=False))", "code_sha1": "275fe266bd6bccf907ed84dd0edfdd08bbecb747"}
{"url": "https://docs.manim.community/en/stable/reference/manim.animation.fading.html", "depth": 1, "instruction": "The scene features two large text objects, \"Fade In\" and \"Fade Out,\" both scaled to 3. \"Fade In\" appears from below, then transforms into \"Fade Out,\" which subsequently fades out while shifting downwards and scaling up to 1.5, creating a smooth transition effect.", "code": "from manim import *\n\nclass Fading(Scene):\n    def construct(self):\n        tex_in = Tex(\"Fade\", \"In\").scale(3)\n        tex_out = Tex(\"Fade\", \"Out\").scale(3)\n        self.play(FadeIn(tex_in, shift=DOWN, scale=0.66))\n        self.play(ReplacementTransform(tex_in, tex_out))\n        self.play(FadeOut(tex_out, shift=DOWN * 2, scale=1.5))", "code_sha1": "d3ea57de93c0865021deba1cdc4fecbb15ba0268"}
{"url": "https://docs.manim.community/en/stable/reference/manim.animation.fading.html", "depth": 1, "instruction": "The scene features two large text objects, \"Fade In\" and \"Fade Out,\" initially positioned at the center. \"Fade In\" appears from below, then transforms into \"Fade Out,\" which subsequently fades out while moving downwards and enlarging. The animations are smooth and sequential, creating a visually engaging transition.", "code": "class Fading(Scene):\n    def construct(self):\n        tex_in = Tex(\"Fade\", \"In\").scale(3)\n        tex_out = Tex(\"Fade\", \"Out\").scale(3)\n        self.play(FadeIn(tex_in, shift=DOWN, scale=0.66))\n        self.play(ReplacementTransform(tex_in, tex_out))\n        self.play(FadeOut(tex_out, shift=DOWN * 2, scale=1.5))", "code_sha1": "fc1206767316366964e4d40ae584f3c1fcfba197"}
{"url": "https://docs.manim.community/en/stable/reference/manim.animation.fading.FadeIn.html", "depth": 1, "instruction": "The scene features a dot positioned at the top left, with four text elements fading in sequentially: the first appears normally, the second shifts down, the third targets the dot's position, and the fourth scales up to 1.5 times its size. The animations play with a 0.5 lag ratio, creating a staggered effect.", "code": "from manim import *\n\nclass FadeInExample(Scene):\n    def construct(self):\n        dot = Dot(UP * 2 + LEFT)\n        self.add(dot)\n        tex = Tex(\n            \"FadeIn with \", \"shift \", r\" or target\\_position\", \" and scale\"\n        ).scale(1)\n        animations = [\n            FadeIn(tex[0]),\n            FadeIn(tex[1], shift=DOWN),\n            FadeIn(tex[2], target_position=dot),\n            FadeIn(tex[3], scale=1.5),\n        ]\n        self.play(AnimationGroup(*animations, lag_ratio=0.5))", "code_sha1": "f299952042e577a70ba34c11e6defb8dbe673309"}
{"url": "https://docs.manim.community/en/stable/reference/manim.animation.fading.FadeIn.html", "depth": 1, "instruction": "The scene displays a dot positioned at (0, 2, 0) and a text object with four segments. Each segment fades in sequentially: the first at the top, the second shifts down, the third targets the dot's position, and the fourth scales up to 1.5. The animations are grouped with a 0.5 lag ratio.", "code": "class FadeInExample(Scene):\n    def construct(self):\n        dot = Dot(UP * 2 + LEFT)\n        self.add(dot)\n        tex = Tex(\n            \"FadeIn with \", \"shift \", r\" or target\\_position\", \" and scale\"\n        ).scale(1)\n        animations = [\n            FadeIn(tex[0]),\n            FadeIn(tex[1], shift=DOWN),\n            FadeIn(tex[2], target_position=dot),\n            FadeIn(tex[3], scale=1.5),\n        ]\n        self.play(AnimationGroup(*animations, lag_ratio=0.5))", "code_sha1": "09abf1da4c1371f5f6d4701f59fd08e32e0e72c4"}
{"url": "https://docs.manim.community/en/stable/reference/manim.animation.fading.FadeOut.html", "depth": 1, "instruction": "The scene features a dot positioned at the top left, and a text object with four segments. Each segment fades out with varying effects: the first fades out normally, the second shifts down, the third moves to the dot's position, and the fourth scales down to half size, all animated in a staggered manner.", "code": "from manim import *\n\nclass FadeInExample(Scene):\n    def construct(self):\n        dot = Dot(UP * 2 + LEFT)\n        self.add(dot)\n        tex = Tex(\n            \"FadeOut with \", \"shift \", r\" or target\\_position\", \" and scale\"\n        ).scale(1)\n        animations = [\n            FadeOut(tex[0]),\n            FadeOut(tex[1], shift=DOWN),\n            FadeOut(tex[2], target_position=dot),\n            FadeOut(tex[3], scale=0.5),\n        ]\n        self.play(AnimationGroup(*animations, lag_ratio=0.5))", "code_sha1": "a0883d34e2be5d62a9bfa4fa6f2c43a1cfa03edf"}
{"url": "https://docs.manim.community/en/stable/reference/manim.animation.fading.FadeOut.html", "depth": 1, "instruction": "Four text elements fade out sequentially: the first fades out normally, the second shifts down, the third moves to the dot's position, and the fourth scales down to half size. The animations are grouped with a 0.5 lag ratio, creating a staggered effect. A dot is positioned at the top left.", "code": "class FadeInExample(Scene):\n    def construct(self):\n        dot = Dot(UP * 2 + LEFT)\n        self.add(dot)\n        tex = Tex(\n            \"FadeOut with \", \"shift \", r\" or target\\_position\", \" and scale\"\n        ).scale(1)\n        animations = [\n            FadeOut(tex[0]),\n            FadeOut(tex[1], shift=DOWN),\n            FadeOut(tex[2], target_position=dot),\n            FadeOut(tex[3], scale=0.5),\n        ]\n        self.play(AnimationGroup(*animations, lag_ratio=0.5))", "code_sha1": "16947aa070781109f9c2a4376a158064892f68e2"}
{"url": "https://docs.manim.community/en/stable/reference/manim.animation.growing.html", "depth": 1, "instruction": "The scene features a square, circle, triangle, arrow, and star, arranged in two horizontal rows. The square grows from a point, the circle from its center, the triangle from its bottom edge, the arrow grows from its start, and the star spins in from nothing, creating a dynamic visual introduction of each shape.", "code": "from manim import *\n\nclass Growing(Scene):\n    def construct(self):\n        square = Square()\n        circle = Circle()\n        triangle = Triangle()\n        arrow = Arrow(LEFT, RIGHT)\n        star = Star()\n\n        VGroup(square, circle, triangle).set_x(0).arrange(buff=1.5).set_y(2)\n        VGroup(arrow, star).move_to(DOWN).set_x(0).arrange(buff=1.5).set_y(-2)\n\n        self.play(GrowFromPoint(square, ORIGIN))\n        self.play(GrowFromCenter(circle))\n        self.play(GrowFromEdge(triangle, DOWN))\n        self.play(GrowArrow(arrow))\n        self.play(SpinInFromNothing(star))", "code_sha1": "13a6ba08ba850e79e57f6c2129a41cba35512c44"}
{"url": "https://docs.manim.community/en/stable/reference/manim.animation.growing.html", "depth": 1, "instruction": "The scene features a square, circle, triangle, arrow, and star arranged in two rows. The square grows from a point, the circle from its center, the triangle from its bottom edge, the arrow grows towards its tip, and the star spins in from nothing, creating a dynamic introduction of shapes.", "code": "class Growing(Scene):\n    def construct(self):\n        square = Square()\n        circle = Circle()\n        triangle = Triangle()\n        arrow = Arrow(LEFT, RIGHT)\n        star = Star()\n\n        VGroup(square, circle, triangle).set_x(0).arrange(buff=1.5).set_y(2)\n        VGroup(arrow, star).move_to(DOWN).set_x(0).arrange(buff=1.5).set_y(-2)\n\n        self.play(GrowFromPoint(square, ORIGIN))\n        self.play(GrowFromCenter(circle))\n        self.play(GrowFromEdge(triangle, DOWN))\n        self.play(GrowArrow(arrow))\n        self.play(SpinInFromNothing(star))", "code_sha1": "7a0c02d347970cfa0771932ae829ab9a44636a10"}
{"url": "https://docs.manim.community/en/stable/reference/manim.animation.growing.GrowArrow.html", "depth": 1, "instruction": "Two arrows are displayed: one horizontal and one diagonal, arranged with a buffer of 2 units. The first arrow grows from its base to full size, while the second arrow grows with its tip colored red. The animations occur sequentially.", "code": "from manim import *\n\nclass GrowArrowExample(Scene):\n    def construct(self):\n        arrows = [Arrow(2 * LEFT, 2 * RIGHT), Arrow(2 * DR, 2 * UL)]\n        VGroup(*arrows).set_x(0).arrange(buff=2)\n        self.play(GrowArrow(arrows[0]))\n        self.play(GrowArrow(arrows[1], point_color=RED))", "code_sha1": "aaf9f98298149f764832fe34cc86265ef57e957f"}
{"url": "https://docs.manim.community/en/stable/reference/manim.animation.growing.GrowArrow.html", "depth": 1, "instruction": "Two arrows are displayed horizontally and diagonally, respectively, with the first arrow growing from left to right and the second arrow growing with a red point color. The arrows are arranged with a buffer of 2 units between them, centered at the origin.", "code": "class GrowArrowExample(Scene):\n    def construct(self):\n        arrows = [Arrow(2 * LEFT, 2 * RIGHT), Arrow(2 * DR, 2 * UL)]\n        VGroup(*arrows).set_x(0).arrange(buff=2)\n        self.play(GrowArrow(arrows[0]))\n        self.play(GrowArrow(arrows[1], point_color=RED))", "code_sha1": "6a0171480226cec99515b9ab5b91550d24739ab4"}
{"url": "https://docs.manim.community/en/stable/reference/manim.animation.growing.GrowFromCenter.html", "depth": 1, "instruction": "Two squares are arranged horizontally with a buffer of 2 units between them. The first square grows from its center normally, while the second square grows from its center with a red initial color, creating a visual contrast.", "code": "from manim import *\n\nclass GrowFromCenterExample(Scene):\n    def construct(self):\n        squares = [Square() for _ in range(2)]\n        VGroup(*squares).set_x(0).arrange(buff=2)\n        self.play(GrowFromCenter(squares[0]))\n        self.play(GrowFromCenter(squares[1], point_color=RED))", "code_sha1": "1fb9af039f17520431a2d9b4a9177e3b22b78df6"}
{"url": "https://docs.manim.community/en/stable/reference/manim.animation.growing.GrowFromCenter.html", "depth": 1, "instruction": "Two squares are arranged horizontally with a buffer of 2 units between them. The first square grows from its center to full size, while the second square grows from its center with a red initial color. The animations occur sequentially.", "code": "class GrowFromCenterExample(Scene):\n    def construct(self):\n        squares = [Square() for _ in range(2)]\n        VGroup(*squares).set_x(0).arrange(buff=2)\n        self.play(GrowFromCenter(squares[0]))\n        self.play(GrowFromCenter(squares[1], point_color=RED))", "code_sha1": "8dbdabb2f73a18eacc2828fb067160e6e59505b0"}
{"url": "https://docs.manim.community/en/stable/reference/manim.animation.growing.GrowFromEdge.html", "depth": 1, "instruction": "Four squares arranged horizontally with equal spacing grow from their respective edges: the first grows downward, the second to the right, the third diagonally up-right, and the fourth upward with an initial red color. Each growth animation occurs sequentially.", "code": "from manim import *\n\nclass GrowFromEdgeExample(Scene):\n    def construct(self):\n        squares = [Square() for _ in range(4)]\n        VGroup(*squares).set_x(0).arrange(buff=1)\n        self.play(GrowFromEdge(squares[0], DOWN))\n        self.play(GrowFromEdge(squares[1], RIGHT))\n        self.play(GrowFromEdge(squares[2], UR))\n        self.play(GrowFromEdge(squares[3], UP, point_color=RED))", "code_sha1": "e32bbdbd79dd6e3a8123a6aecf0fb190d7facf67"}
{"url": "https://docs.manim.community/en/stable/reference/manim.animation.growing.GrowFromEdge.html", "depth": 1, "instruction": "Four squares arranged horizontally grow from their respective edges: the first grows downward, the second to the right, the third diagonally up-right, and the fourth upward with a red initial color. Each growth is animated sequentially.", "code": "class GrowFromEdgeExample(Scene):\n    def construct(self):\n        squares = [Square() for _ in range(4)]\n        VGroup(*squares).set_x(0).arrange(buff=1)\n        self.play(GrowFromEdge(squares[0], DOWN))\n        self.play(GrowFromEdge(squares[1], RIGHT))\n        self.play(GrowFromEdge(squares[2], UR))\n        self.play(GrowFromEdge(squares[3], UP, point_color=RED))", "code_sha1": "3b23c83a4a6d64d49479d390cda556fcccefe72c"}
{"url": "https://docs.manim.community/en/stable/reference/manim.animation.growing.GrowFromPoint.html", "depth": 1, "instruction": "Four squares grow from specified points: the first from the origin, the second from the point (-2, 2, 0), the third from (3, -2, 0) in red, and the fourth from a green dot at (3, UR). Each square expands smoothly, with the dot initially displayed in green.", "code": "from manim import *\n\nclass GrowFromPointExample(Scene):\n    def construct(self):\n        dot = Dot(3 * UR, color=GREEN)\n        squares = [Square() for _ in range(4)]\n        VGroup(*squares).set_x(0).arrange(buff=1)\n        self.add(dot)\n        self.play(GrowFromPoint(squares[0], ORIGIN))\n        self.play(GrowFromPoint(squares[1], [-2, 2, 0]))\n        self.play(GrowFromPoint(squares[2], [3, -2, 0], RED))\n        self.play(GrowFromPoint(squares[3], dot, dot.get_color()))", "code_sha1": "7717c557d423a3c670af0725b00490a2d40838e4"}
{"url": "https://docs.manim.community/en/stable/reference/manim.animation.growing.GrowFromPoint.html", "depth": 1, "instruction": "Four squares grow from specified points: the first from the origin, the second from the point (-2, 2, 0), the third from (3, -2, 0) in red, and the last from a green dot at (3, 1, 0). Each square expands smoothly into view, with the dot initially positioned at (3, 1, 0).", "code": "class GrowFromPointExample(Scene):\n    def construct(self):\n        dot = Dot(3 * UR, color=GREEN)\n        squares = [Square() for _ in range(4)]\n        VGroup(*squares).set_x(0).arrange(buff=1)\n        self.add(dot)\n        self.play(GrowFromPoint(squares[0], ORIGIN))\n        self.play(GrowFromPoint(squares[1], [-2, 2, 0]))\n        self.play(GrowFromPoint(squares[2], [3, -2, 0], RED))\n        self.play(GrowFromPoint(squares[3], dot, dot.get_color()))", "code_sha1": "cf4ae3201387f550e468fc7f39f2fa4377507fa0"}
{"url": "https://docs.manim.community/en/stable/reference/manim.animation.growing.SpinInFromNothing.html", "depth": 1, "instruction": "Three squares are arranged horizontally with equal spacing. The first square spins in from nothing, the second completes a full spin before appearing, and the third spins in with a red initial color. Each square's entrance is animated sequentially.", "code": "from manim import *\n\nclass SpinInFromNothingExample(Scene):\n    def construct(self):\n        squares = [Square() for _ in range(3)]\n        VGroup(*squares).set_x(0).arrange(buff=2)\n        self.play(SpinInFromNothing(squares[0]))\n        self.play(SpinInFromNothing(squares[1], angle=2 * PI))\n        self.play(SpinInFromNothing(squares[2], point_color=RED))", "code_sha1": "d7cc5c359bc02b6289a38254e1fb9903029e6527"}
{"url": "https://docs.manim.community/en/stable/reference/manim.animation.growing.SpinInFromNothing.html", "depth": 1, "instruction": "Three squares are arranged horizontally with equal spacing. The first square spins in from nothing, fully appearing instantly. The second square performs a full spin before becoming visible. The third square spins in from nothing, starting as red before transitioning to its original color.", "code": "class SpinInFromNothingExample(Scene):\n    def construct(self):\n        squares = [Square() for _ in range(3)]\n        VGroup(*squares).set_x(0).arrange(buff=2)\n        self.play(SpinInFromNothing(squares[0]))\n        self.play(SpinInFromNothing(squares[1], angle=2 * PI))\n        self.play(SpinInFromNothing(squares[2], point_color=RED))", "code_sha1": "9b12016138e7a4528717565a25170adfa0d4ff0f"}
{"url": "https://docs.manim.community/en/stable/reference/manim.animation.indication.html", "depth": 1, "instruction": "The scene features a series of large, highlighted text labels representing animation techniques, each animated sequentially with distinct effects (e.g., Flash, Wiggle). Each label fades out while the next one fades in, creating a dynamic flow. The text is centered and scaled to 3, with upward shifts during transitions.", "code": "from manim import *\n\nclass Indications(Scene):\n    def construct(self):\n        indications = [ApplyWave,Circumscribe,Flash,FocusOn,Indicate,ShowPassingFlash,Wiggle]\n        names = [Tex(i.__name__).scale(3) for i in indications]\n\n        self.add(names[0])\n        for i in range(len(names)):\n            if indications[i] is Flash:\n                self.play(Flash(UP))\n            elif indications[i] is ShowPassingFlash:\n                self.play(ShowPassingFlash(Underline(names[i])))\n            else:\n                self.play(indications[i](names[i]))\n            self.play(AnimationGroup(\n                FadeOut(names[i], shift=UP*1.5),\n                FadeIn(names[(i+1)%len(names)], shift=UP*1.5),\n            ))", "code_sha1": "da062eaac3d842078e77927d4c2c04add23a579e"}
{"url": "https://docs.manim.community/en/stable/reference/manim.animation.indication.html", "depth": 1, "instruction": "The scene features a series of large, highlighted text labels representing animation methods, each animated sequentially with distinct effects (e.g., flashing, wiggling). Each label fades out while the next one fades in, creating a dynamic visual flow, with upward shifts and varying animation styles to emphasize each method.", "code": "class Indications(Scene):\n    def construct(self):\n        indications = [ApplyWave,Circumscribe,Flash,FocusOn,Indicate,ShowPassingFlash,Wiggle]\n        names = [Tex(i.__name__).scale(3) for i in indications]\n\n        self.add(names[0])\n        for i in range(len(names)):\n            if indications[i] is Flash:\n                self.play(Flash(UP))\n            elif indications[i] is ShowPassingFlash:\n                self.play(ShowPassingFlash(Underline(names[i])))\n            else:\n                self.play(indications[i](names[i]))\n            self.play(AnimationGroup(\n                FadeOut(names[i], shift=UP*1.5),\n                FadeIn(names[(i+1)%len(names)], shift=UP*1.5),\n            ))", "code_sha1": "51cb363efa053605c7eb96cecd9cfa1991a402a2"}
{"url": "https://docs.manim.community/en/stable/reference/manim.animation.indication.ApplyWave.html", "depth": 1, "instruction": "The scene displays the text \"WaveWaveWaveWaveWave\" scaled to 2, animated with three wave effects: a default wave, a right-directed wave with reduced amplitude and time width, and a linear wave with four ripples, all smoothly transitioning in sequence.", "code": "from manim import *\n\nclass ApplyingWaves(Scene):\n    def construct(self):\n        tex = Tex(\"WaveWaveWaveWaveWave\").scale(2)\n        self.play(ApplyWave(tex))\n        self.play(ApplyWave(\n            tex,\n            direction=RIGHT,\n            time_width=0.5,\n            amplitude=0.3\n        ))\n        self.play(ApplyWave(\n            tex,\n            rate_func=linear,\n            ripples=4\n        ))", "code_sha1": "cc0150335d75732c826932c4e446abb6981ff544"}
{"url": "https://docs.manim.community/en/stable/reference/manim.animation.indication.ApplyWave.html", "depth": 1, "instruction": "The scene displays the text \"WaveWaveWaveWaveWave\" scaled to 2, undergoing three wave animations: a default wave, a right-directed wave with a 0.5 time width and 0.3 amplitude, and a linear wave with 4 ripples, all smoothly transitioning in sequence.", "code": "class ApplyingWaves(Scene):\n    def construct(self):\n        tex = Tex(\"WaveWaveWaveWaveWave\").scale(2)\n        self.play(ApplyWave(tex))\n        self.play(ApplyWave(\n            tex,\n            direction=RIGHT,\n            time_width=0.5,\n            amplitude=0.3\n        ))\n        self.play(ApplyWave(\n            tex,\n            rate_func=linear,\n            ripples=4\n        ))", "code_sha1": "43076843a11b8d2da38069e92e95e55197f1d17f"}
{"url": "https://docs.manim.community/en/stable/reference/manim.animation.indication.Blink.html", "depth": 1, "instruction": "The scene displays the text \"Blinking\" in a large font (1.5 scale), which blinks three times, alternating between visible and invisible states, with each blink lasting 0.5 seconds on and 0.5 seconds off. The text remains visible at the end of the animation.", "code": "from manim import *\n\nclass BlinkingExample(Scene):\n    def construct(self):\n        text = Text(\"Blinking\").scale(1.5)\n        self.add(text)\n        self.play(Blink(text, blinks=3))", "code_sha1": "241e8a721ac87892f329eb05fadc0d43d681ed94"}
{"url": "https://docs.manim.community/en/stable/reference/manim.animation.indication.Blink.html", "depth": 1, "instruction": "The scene displays the text \"Blinking\" in a large font (1.5x scale), which blinks three times, alternating visibility every 0.5 seconds. The text remains visible at the end of the animation.", "code": "class BlinkingExample(Scene):\n    def construct(self):\n        text = Text(\"Blinking\").scale(1.5)\n        self.add(text)\n        self.play(Blink(text, blinks=3))", "code_sha1": "b2bdb4fae81d9677f8fc2b9f6f037e8f12925653"}
{"url": "https://docs.manim.community/en/stable/reference/manim.animation.indication.Circumscribe.html", "depth": 1, "instruction": "The scene features a large yellow text \"Circum-scribe\" that scales to 2. It undergoes a series of animations where it is circumscribed with varying properties: a default shape, a circle, with fade-out, extended time width, and a filled circle, each with smooth transitions.", "code": "from manim import *\n\nclass UsingCircumscribe(Scene):\n    def construct(self):\n        lbl = Tex(r\"Circum-\\\\scribe\").scale(2)\n        self.add(lbl)\n        self.play(Circumscribe(lbl))\n        self.play(Circumscribe(lbl, Circle))\n        self.play(Circumscribe(lbl, fade_out=True))\n        self.play(Circumscribe(lbl, time_width=2))\n        self.play(Circumscribe(lbl, Circle, True))", "code_sha1": "d90355a2927d853d5f0d8d114f2214a86f3d33c9"}
{"url": "https://docs.manim.community/en/stable/reference/manim.animation.indication.Circumscribe.html", "depth": 1, "instruction": "The scene features a large yellow \"Circum-scribe\" label, animated with a series of circumscribing effects: first with a default shape, then a circle, followed by a fade-out effect, a longer time width, and finally a circumscribe with a circle and fade-in. Each animation occurs sequentially, enhancing the label's visibility.", "code": "class UsingCircumscribe(Scene):\n    def construct(self):\n        lbl = Tex(r\"Circum-\\\\scribe\").scale(2)\n        self.add(lbl)\n        self.play(Circumscribe(lbl))\n        self.play(Circumscribe(lbl, Circle))\n        self.play(Circumscribe(lbl, fade_out=True))\n        self.play(Circumscribe(lbl, time_width=2))\n        self.play(Circumscribe(lbl, Circle, True))", "code_sha1": "12154dcd9f4de90b770ddd75bac6862973b5c71b"}
{"url": "https://docs.manim.community/en/stable/reference/manim.animation.indication.Flash.html", "depth": 1, "instruction": "A yellow dot positioned at the bottom flashes briefly while a text label \"Flash the dot below:\" appears above it, followed by a pause.", "code": "from manim import *\n\nclass UsingFlash(Scene):\n    def construct(self):\n        dot = Dot(color=YELLOW).shift(DOWN)\n        self.add(Tex(\"Flash the dot below:\"), dot)\n        self.play(Flash(dot))\n        self.wait()", "code_sha1": "f384a780a6f38ab055d285acf89640bdbd7ff441"}
{"url": "https://docs.manim.community/en/stable/reference/manim.animation.indication.Flash.html", "depth": 1, "instruction": "A red circle with a radius of 2 appears on screen, followed by a flashing animation that lasts 2 seconds, featuring 30 lines radiating outward. The flash effect uses a rush-from rate function, with a time width of 0.3 seconds and a slight buffer around the circle.", "code": "from manim import *\n\nclass FlashOnCircle(Scene):\n    def construct(self):\n        radius = 2\n        circle = Circle(radius)\n        self.add(circle)\n        self.play(Flash(\n            circle, line_length=1,\n            num_lines=30, color=RED,\n            flash_radius=radius+SMALL_BUFF,\n            time_width=0.3, run_time=2,\n            rate_func = rush_from\n        ))", "code_sha1": "35b058b65d3fb6436865e068ee0b9edfc88fcc54"}
{"url": "https://docs.manim.community/en/stable/reference/manim.animation.indication.Flash.html", "depth": 1, "instruction": "A yellow dot shifts downwards, accompanied by the text \"Flash the dot below:\"; the dot flashes briefly, creating a bright visual effect, followed by a pause.", "code": "class UsingFlash(Scene):\n    def construct(self):\n        dot = Dot(color=YELLOW).shift(DOWN)\n        self.add(Tex(\"Flash the dot below:\"), dot)\n        self.play(Flash(dot))\n        self.wait()", "code_sha1": "c2cdd2280b2eca884ca1146739f1c76353e48ae2"}
{"url": "https://docs.manim.community/en/stable/reference/manim.animation.indication.Flash.html", "depth": 1, "instruction": "A red circle with a radius of 2 appears on the screen, followed by a flashing animation where 30 lines radiate outward from the circle's edge over 2 seconds, using a rush-from rate function, creating a dynamic visual effect.", "code": "class FlashOnCircle(Scene):\n    def construct(self):\n        radius = 2\n        circle = Circle(radius)\n        self.add(circle)\n        self.play(Flash(\n            circle, line_length=1,\n            num_lines=30, color=RED,\n            flash_radius=radius+SMALL_BUFF,\n            time_width=0.3, run_time=2,\n            rate_func = rush_from\n        ))", "code_sha1": "3ae0180edbc81fc642cb3554af094627db8c75af"}
{"url": "https://docs.manim.community/en/stable/reference/manim.animation.indication.FocusOn.html", "depth": 1, "instruction": "The scene displays a yellow dot positioned at the bottom, accompanied by the text \"Focusing on the dot below:\". The animation focuses on the dot, highlighting it, while the text remains visible. The focus effect lasts for the duration of the animation, followed by a brief pause.", "code": "from manim import *\n\nclass UsingFocusOn(Scene):\n    def construct(self):\n        dot = Dot(color=YELLOW).shift(DOWN)\n        self.add(Tex(\"Focusing on the dot below:\"), dot)\n        self.play(FocusOn(dot))\n        self.wait()", "code_sha1": "d3da431c3c3b1f2b098cab13c4c52450d262db27"}
{"url": "https://docs.manim.community/en/stable/reference/manim.animation.indication.FocusOn.html", "depth": 1, "instruction": "A yellow dot is positioned at the bottom of the screen, accompanied by the text \"Focusing on the dot below:\". The scene animates a spotlight effect focusing on the dot, highlighting it while the text remains visible, followed by a brief pause.", "code": "class UsingFocusOn(Scene):\n    def construct(self):\n        dot = Dot(color=YELLOW).shift(DOWN)\n        self.add(Tex(\"Focusing on the dot below:\"), dot)\n        self.play(FocusOn(dot))\n        self.wait()", "code_sha1": "c1ecb2a0c46ac38a51ecc7fd217cc3f52c4be5b5"}
{"url": "https://docs.manim.community/en/stable/reference/manim.animation.indication.Indicate.html", "depth": 1, "instruction": "The scene displays the word \"Indicate\" in large, scaled-up text (size 3) that is highlighted with a pulsing animation. The animation emphasizes the text, followed by a brief pause before the scene ends.", "code": "from manim import *\n\nclass UsingIndicate(Scene):\n    def construct(self):\n        tex = Tex(\"Indicate\").scale(3)\n        self.play(Indicate(tex))\n        self.wait()", "code_sha1": "eb7353ee6a941498bfdca9ccf33149d6e87f1121"}
{"url": "https://docs.manim.community/en/stable/reference/manim.animation.indication.Indicate.html", "depth": 1, "instruction": "The scene displays the word \"Indicate\" in large, scaled-up text (size 3), which is highlighted with an Indicate animation, drawing attention to it. The animation occurs smoothly, followed by a brief pause where the text remains visible.", "code": "class UsingIndicate(Scene):\n    def construct(self):\n        tex = Tex(\"Indicate\").scale(3)\n        self.play(Indicate(tex))\n        self.wait()", "code_sha1": "9d3f6e8c4a8d1ee332ce87720d72089805db6022"}
{"url": "https://docs.manim.community/en/stable/reference/manim.animation.indication.ShowPassingFlash.html", "depth": 1, "instruction": "A blue, scaled-up regular pentagon flashes with a stroke animation, while a label displaying the current `time_width` value updates dynamically. The animation runs for 2 seconds, with the `time_width` values cycling through 0.2, 0.5, 1, and 2, creating a visual effect of varying stroke widths.", "code": "from manim import *\n\nclass TimeWidthValues(Scene):\n    def construct(self):\n        p = RegularPolygon(5, color=DARK_GRAY, stroke_width=6).scale(3)\n        lbl = VMobject()\n        self.add(p, lbl)\n        p = p.copy().set_color(BLUE)\n        for time_width in [0.2, 0.5, 1, 2]:\n            lbl.become(Tex(r\"\\texttt{time\\_width={{%.1f}}}\"%time_width))\n            self.play(ShowPassingFlash(\n                p.copy().set_color(BLUE),\n                run_time=2,\n                time_width=time_width\n            ))", "code_sha1": "768fe91e649fde18b768f188686437f1a7bfd700"}
{"url": "https://docs.manim.community/en/stable/reference/manim.animation.indication.ShowPassingFlash.html", "depth": 1, "instruction": "A blue, scaled-up regular pentagon flashes with a passing stroke effect, while a label displaying the current time width value updates dynamically. The animation runs for 2 seconds, with time widths of 0.2, 0.5, 1, and 2 sequentially shown.", "code": "class TimeWidthValues(Scene):\n    def construct(self):\n        p = RegularPolygon(5, color=DARK_GRAY, stroke_width=6).scale(3)\n        lbl = VMobject()\n        self.add(p, lbl)\n        p = p.copy().set_color(BLUE)\n        for time_width in [0.2, 0.5, 1, 2]:\n            lbl.become(Tex(r\"\\texttt{time\\_width={{%.1f}}}\"%time_width))\n            self.play(ShowPassingFlash(\n                p.copy().set_color(BLUE),\n                run_time=2,\n                time_width=time_width\n            ))", "code_sha1": "61c532b216dcd3d94559db501dae666ffb72f324"}
{"url": "https://docs.manim.community/en/stable/reference/manim.animation.indication.Wiggle.html", "depth": 1, "instruction": "The scene displays the word \"Wiggle\" in large, 3x scaled text, animated with a wiggling effect. The text is centered on the screen, and the animation runs for a brief duration, followed by a pause to hold the final position.", "code": "from manim import *\n\nclass ApplyingWaves(Scene):\n    def construct(self):\n        tex = Tex(\"Wiggle\").scale(3)\n        self.play(Wiggle(tex))\n        self.wait()", "code_sha1": "ac921ca865f0e874f395afa5fa1b76d269b38567"}
{"url": "https://docs.manim.community/en/stable/reference/manim.animation.indication.Wiggle.html", "depth": 1, "instruction": "The scene displays the word \"Wiggle\" in large, scaled text (size 3) that animates with a wiggling effect, creating a dynamic visual. The animation runs for a brief duration, followed by a pause to hold the final position.", "code": "class ApplyingWaves(Scene):\n    def construct(self):\n        tex = Tex(\"Wiggle\").scale(3)\n        self.play(Wiggle(tex))\n        self.wait()", "code_sha1": "5d4c8ae1b3f26fb72d1a7b90b3fd772e0f546c6b"}
{"url": "https://docs.manim.community/en/stable/reference/manim.animation.movement.Homotopy.html", "depth": 1, "instruction": "A square morphs into a wavy shape over 2 seconds, with a smooth transition defined by a sinusoidal function. The animation progresses linearly, first rising slightly, then creating a wave effect as it undulates. The background remains static, emphasizing the square's transformation.", "code": "from manim import *\n\nclass HomotopyExample(Scene):\n    def construct(self):\n        square = Square()\n\n        def homotopy(x, y, z, t):\n            if t <= 0.25:\n                progress = t / 0.25\n                return (x, y + progress * 0.2 * np.sin(x), z)\n            else:\n                wave_progress = (t - 0.25) / 0.75\n                return (x, y + 0.2 * np.sin(x + 10 * wave_progress), z)\n\n        self.play(Homotopy(homotopy, square, rate_func= linear, run_time=2))", "code_sha1": "c61dd699f52c9a646ee36249ab3f92a3a7a96710"}
{"url": "https://docs.manim.community/en/stable/reference/manim.animation.movement.Homotopy.html", "depth": 1, "instruction": "A square morphs into a wavy shape over 2 seconds, with vertical oscillations driven by a sine function. The animation progresses linearly, first rising slightly, then transitioning into a more pronounced wave pattern.", "code": "class HomotopyExample(Scene):\n    def construct(self):\n        square = Square()\n\n        def homotopy(x, y, z, t):\n            if t <= 0.25:\n                progress = t / 0.25\n                return (x, y + progress * 0.2 * np.sin(x), z)\n            else:\n                wave_progress = (t - 0.25) / 0.75\n                return (x, y + 0.2 * np.sin(x + 10 * wave_progress), z)\n\n        self.play(Homotopy(homotopy, square, rate_func= linear, run_time=2))", "code_sha1": "ac1219ccbbfa79b9f70f8931703e5b23e4b72d31"}
{"url": "https://docs.manim.community/en/stable/reference/manim.animation.movement.MoveAlongPath.html", "depth": 1, "instruction": "An orange dot moves linearly along a horizontal line from left to right, while a dynamically updating orange line extends from the left to the dot's current position, creating a visual connection between the two objects.", "code": "from manim import *\n\nclass MoveAlongPathExample(Scene):\n    def construct(self):\n        d1 = Dot().set_color(ORANGE)\n        l1 = Line(LEFT, RIGHT)\n        l2 = VMobject()\n        self.add(d1, l1, l2)\n        l2.add_updater(lambda x: x.become(Line(LEFT, d1.get_center()).set_color(ORANGE)))\n        self.play(MoveAlongPath(d1, l1), rate_func=linear)", "code_sha1": "5219d3faba476eeb6cde5254cb381d97fe29ff0c"}
{"url": "https://docs.manim.community/en/stable/reference/manim.animation.movement.MoveAlongPath.html", "depth": 1, "instruction": "An orange dot moves linearly along a horizontal line, while a dynamically updating orange line extends from the left to the dot's current position, creating a visual effect of the dot tracing the path.", "code": "class MoveAlongPathExample(Scene):\n    def construct(self):\n        d1 = Dot().set_color(ORANGE)\n        l1 = Line(LEFT, RIGHT)\n        l2 = VMobject()\n        self.add(d1, l1, l2)\n        l2.add_updater(lambda x: x.become(Line(LEFT, d1.get_center()).set_color(ORANGE)))\n        self.play(MoveAlongPath(d1, l1), rate_func=linear)", "code_sha1": "4469d7e4f6c1d50024c395230182a01377fcf552"}
{"url": "https://docs.manim.community/en/stable/reference/manim.animation.rotation.Rotate.html", "depth": 1, "instruction": "Two squares, each with a side length of 0.5, rotate 360 degrees: one around the origin at the top of the screen (shifted up), and the other at the center of the scene. Both rotations occur simultaneously with a linear timing function.", "code": "from manim import *\n\nclass UsingRotate(Scene):\n    def construct(self):\n        self.play(\n            Rotate(\n                Square(side_length=0.5).shift(UP * 2),\n                angle=2*PI,\n                about_point=ORIGIN,\n                rate_func=linear,\n            ),\n            Rotate(Square(side_length=0.5), angle=2*PI, rate_func=linear),\n            )", "code_sha1": "6c2a8b7fe0b4914b3c74bcb96a292d9c5d3a2f84"}
{"url": "https://docs.manim.community/en/stable/reference/manim.animation.rotation.Rotate.html", "depth": 1, "instruction": "Two squares, each with a side length of 0.5, rotate 360 degrees: one around the origin at the top of the screen (shifted up), and the other at the center. Both rotations occur simultaneously with a linear timing function.", "code": "class UsingRotate(Scene):\n    def construct(self):\n        self.play(\n            Rotate(\n                Square(side_length=0.5).shift(UP * 2),\n                angle=2*PI,\n                about_point=ORIGIN,\n                rate_func=linear,\n            ),\n            Rotate(Square(side_length=0.5), angle=2*PI, rate_func=linear),\n            )", "code_sha1": "b7976511b9397637d92b85634e538dee7ba1a81c"}
{"url": "https://docs.manim.community/en/stable/reference/manim.animation.specialized.Broadcast.html", "depth": 1, "instruction": "A teal circle with a radius of 4 appears at the center of the scene, gradually expanding and fading out over 3 seconds, creating a broadcast effect.", "code": "from manim import *\n\nclass BroadcastExample(Scene):\n    def construct(self):\n        mob = Circle(radius=4, color=TEAL_A)\n        self.play(Broadcast(mob))", "code_sha1": "9ae41e762b7603503d6e85506a7a29109d81344e"}
{"url": "https://docs.manim.community/en/stable/reference/manim.animation.specialized.Broadcast.html", "depth": 1, "instruction": "A teal circle with a radius of 4 appears at the center of the screen, gradually broadcasting five smaller copies outward, fading from fully opaque to transparent over a 3-second duration.", "code": "class BroadcastExample(Scene):\n    def construct(self):\n        mob = Circle(radius=4, color=TEAL_A)\n        self.play(Broadcast(mob))", "code_sha1": "fa3a08de57a719b444777935ff707eb355335e12"}
{"url": "https://docs.manim.community/en/stable/reference/manim.animation.speedmodifier.ChangeSpeed.html", "depth": 1, "instruction": "Two dots move horizontally across the screen: one shifts right 8 units from the left and the other shifts left 8 units from the right, both over 1 second. The speed of their movement varies according to specified keyframes, with a linear rate function.", "code": "from manim import *\n\nclass SpeedModifierExample(Scene):\n    def construct(self):\n        a = Dot().shift(LEFT * 4)\n        b = Dot().shift(RIGHT * 4)\n        self.add(a, b)\n        self.play(\n            ChangeSpeed(\n                AnimationGroup(\n                    a.animate(run_time=1).shift(RIGHT * 8),\n                    b.animate(run_time=1).shift(LEFT * 8),\n                ),\n                speedinfo={0.3: 1, 0.4: 0.1, 0.6: 0.1, 1: 1},\n                rate_func=linear,\n            )\n        )", "code_sha1": "78f4904d709d1d798e1322a4fcd7602e1d5436fa"}
{"url": "https://docs.manim.community/en/stable/reference/manim.animation.speedmodifier.ChangeSpeed.html", "depth": 1, "instruction": "A dot starts at the left of the screen and moves right, accelerating and decelerating according to specified speed changes over a 2-second wait, with the animation affecting its updater. The scene features a simple background and focuses on the dot's movement.", "code": "from manim import *\n\nclass SpeedModifierUpdaterExample(Scene):\n    def construct(self):\n        a = Dot().shift(LEFT * 4)\n        self.add(a)\n\n        ChangeSpeed.add_updater(a, lambda x, dt: x.shift(RIGHT * 4 * dt))\n        self.play(\n            ChangeSpeed(\n                Wait(2),\n                speedinfo={0.4: 1, 0.5: 0.2, 0.8: 0.2, 1: 1},\n                affects_speed_updaters=True,\n            )\n        )", "code_sha1": "5e5b026eadbbcca2a9f40dd4b4b2060b99cd78d1"}
{"url": "https://docs.manim.community/en/stable/reference/manim.animation.speedmodifier.ChangeSpeed.html", "depth": 1, "instruction": "A dot shifts continuously to the right at a speed determined by the `ChangeSpeed` animation, which is initiated with a wait. The dot starts at the left and moves rightward, with the speed of movement affected by the animation's parameters.", "code": "from manim import *\n\nclass SpeedModifierUpdaterExample2(Scene):\n    def construct(self):\n        a = Dot().shift(LEFT * 4)\n        self.add(a)\n\n        ChangeSpeed.add_updater(a, lambda x, dt: x.shift(RIGHT * 4 * dt))\n        self.wait()\n        self.play(\n            ChangeSpeed(\n                Wait(),\n                speedinfo={1: 0},\n                affects_speed_updaters=True,\n            )\n        )", "code_sha1": "7d66ad72639db7598b0aa92591d208dd844ec0f5"}
{"url": "https://docs.manim.community/en/stable/reference/manim.animation.speedmodifier.ChangeSpeed.html", "depth": 1, "instruction": "Two dots, one red and one blue, shift horizontally towards each other over 1 second, with varying speeds: initially fast, slowing down at 0.3 and 0.4 seconds, then speeding up again before returning to normal. The animation is linear, creating a smooth transition.", "code": "class SpeedModifierExample(Scene):\n    def construct(self):\n        a = Dot().shift(LEFT * 4)\n        b = Dot().shift(RIGHT * 4)\n        self.add(a, b)\n        self.play(\n            ChangeSpeed(\n                AnimationGroup(\n                    a.animate(run_time=1).shift(RIGHT * 8),\n                    b.animate(run_time=1).shift(LEFT * 8),\n                ),\n                speedinfo={0.3: 1, 0.4: 0.1, 0.6: 0.1, 1: 1},\n                rate_func=linear,\n            )\n        )", "code_sha1": "9688ec7ece55324ee5a981fd8184c380addd80c0"}
{"url": "https://docs.manim.community/en/stable/reference/manim.animation.speedmodifier.ChangeSpeed.html", "depth": 1, "instruction": "A blue dot shifts right from the left side of the screen, accelerating and decelerating according to specified speed changes over a 2-second wait, while the camera remains static.", "code": "class SpeedModifierUpdaterExample(Scene):\n    def construct(self):\n        a = Dot().shift(LEFT * 4)\n        self.add(a)\n\n        ChangeSpeed.add_updater(a, lambda x, dt: x.shift(RIGHT * 4 * dt))\n        self.play(\n            ChangeSpeed(\n                Wait(2),\n                speedinfo={0.4: 1, 0.5: 0.2, 0.8: 0.2, 1: 1},\n                affects_speed_updaters=True,\n            )\n        )", "code_sha1": "659eecf3329806fa2ed0f9e8acc1bbeacc11ca0f"}
{"url": "https://docs.manim.community/en/stable/reference/manim.animation.speedmodifier.ChangeSpeed.html", "depth": 1, "instruction": "A dot shifts continuously to the right at a speed determined by the `ChangeSpeed` animation, starting from the left side of the screen. The animation pauses briefly before applying the speed change, with the dot remaining visible throughout the scene.", "code": "class SpeedModifierUpdaterExample2(Scene):\n    def construct(self):\n        a = Dot().shift(LEFT * 4)\n        self.add(a)\n\n        ChangeSpeed.add_updater(a, lambda x, dt: x.shift(RIGHT * 4 * dt))\n        self.wait()\n        self.play(\n            ChangeSpeed(\n                Wait(),\n                speedinfo={1: 0},\n                affects_speed_updaters=True,\n            )\n        )", "code_sha1": "6398eb16103a98b7179d6dff3fc01eb2d48a6348"}
{"url": "https://docs.manim.community/en/stable/reference/manim.animation.transform.ApplyMatrix.html", "depth": 1, "instruction": "The scene displays the text \"Hello World!\" and a NumberPlane, both transforming simultaneously under a specified matrix. The text is white, while the NumberPlane is a grid of light blue lines. The transformations occur smoothly, creating a dynamic visual effect as both objects shift and scale according to the matrix.", "code": "from manim import *\n\nclass ApplyMatrixExample(Scene):\n    def construct(self):\n        matrix = [[1, 1], [0, 2/3]]\n        self.play(ApplyMatrix(matrix, Text(\"Hello World!\")), ApplyMatrix(matrix, NumberPlane()))", "code_sha1": "b0f2dfea2ff69dcbd61fb5c6161529c23228bdee"}
{"url": "https://docs.manim.community/en/stable/reference/manim.animation.transform.ApplyMatrix.html", "depth": 1, "instruction": "The scene displays the text \"Hello World!\" and a NumberPlane, both transformed by the matrix [[1, 1], [0, 2/3]]. The text is animated to change its position and size, while the NumberPlane adjusts its grid layout, creating a dynamic visual effect.", "code": "class ApplyMatrixExample(Scene):\n    def construct(self):\n        matrix = [[1, 1], [0, 2/3]]\n        self.play(ApplyMatrix(matrix, Text(\"Hello World!\")), ApplyMatrix(matrix, NumberPlane()))", "code_sha1": "47eac7aac11fb85cef2095f34af5339f240bee93"}
{"url": "https://docs.manim.community/en/stable/reference/manim.animation.transform.ApplyPointwiseFunction.html", "depth": 1, "instruction": "A square morphs into a wavy shape as it undergoes a pointwise transformation based on the exponential function, creating a dynamic visual effect. The animation lasts for a few seconds, followed by a brief pause.", "code": "from manim import *\n\nclass WarpSquare(Scene):\n    def construct(self):\n        square = Square()\n        self.play(\n            ApplyPointwiseFunction(\n                lambda point: complex_to_R3(np.exp(R3_to_complex(point))), square\n            )\n        )\n        self.wait()", "code_sha1": "9aa0aa31b0ed23b61170fbd25be135230a81037e"}
{"url": "https://docs.manim.community/en/stable/reference/manim.animation.transform.ApplyPointwiseFunction.html", "depth": 1, "instruction": "A square morphs into a wavy shape as it undergoes a pointwise transformation based on the exponential function, creating a dynamic visual effect. The animation lasts for a few seconds, followed by a brief pause.", "code": "class WarpSquare(Scene):\n    def construct(self):\n        square = Square()\n        self.play(\n            ApplyPointwiseFunction(\n                lambda point: complex_to_R3(np.exp(R3_to_complex(point))), square\n            )\n        )\n        self.wait()", "code_sha1": "2dd6dee7438a2341492d01d64c2daeee11432f62"}
{"url": "https://docs.manim.community/en/stable/reference/manim.animation.transform.ClockwiseTransform.html", "depth": 1, "instruction": "Two dots on the left and right transform into squares, with the left dot moving along a clockwise arc to become a square, while the right dot transforms directly into a square. The scene features a wait before and after the transformations, with the left and right groups arranged vertically and shifted horizontally.", "code": "from manim import *\n\nclass ClockwiseExample(Scene):\n    def construct(self):\n        dl, dr = Dot(), Dot()\n        sl, sr = Square(), Square()\n\n        VGroup(dl, sl).arrange(DOWN).shift(2*LEFT)\n        VGroup(dr, sr).arrange(DOWN).shift(2*RIGHT)\n\n        self.add(dl, dr)\n        self.wait()\n        self.play(\n            ClockwiseTransform(dl, sl),\n            Transform(dr, sr)\n        )\n        self.wait()", "code_sha1": "21fc2dd40029689333ecd3186f17390d7a1a163d"}
{"url": "https://docs.manim.community/en/stable/reference/manim.animation.transform.ClockwiseTransform.html", "depth": 1, "instruction": "The scene features two dots (left and right) and two squares (left and right) arranged vertically. The left dot transforms into the left square along a clockwise arc, while the right dot transforms into the right square. The animation occurs simultaneously, with a brief pause before and after the transformations.", "code": "class ClockwiseExample(Scene):\n    def construct(self):\n        dl, dr = Dot(), Dot()\n        sl, sr = Square(), Square()\n\n        VGroup(dl, sl).arrange(DOWN).shift(2*LEFT)\n        VGroup(dr, sr).arrange(DOWN).shift(2*RIGHT)\n\n        self.add(dl, dr)\n        self.wait()\n        self.play(\n            ClockwiseTransform(dl, sl),\n            Transform(dr, sr)\n        )\n        self.wait()", "code_sha1": "cb57f5aefe15f79957a9ce6dbca3bfb2fa750416"}
{"url": "https://docs.manim.community/en/stable/reference/manim.animation.transform.CounterclockwiseTransform.html", "depth": 1, "instruction": "The scene displays two groups of decimal numbers, each labeled with colored text (\"CounterclockwiseTransform\" in red and \"Transform\" in blue), arranged vertically. The first group undergoes a counterclockwise arc transformation, while the second group transforms straight upward. The animations occur sequentially, showcasing the contrasting movement styles.", "code": "from manim import *\n\nclass CounterclockwiseTransform_vs_Transform(Scene):\n    def construct(self):\n        # set up the numbers\n        c_transform = VGroup(DecimalNumber(number=3.141, num_decimal_places=3), DecimalNumber(number=1.618, num_decimal_places=3))\n        text_1 = Text(\"CounterclockwiseTransform\", color=RED)\n        c_transform.add(text_1)\n\n        transform = VGroup(DecimalNumber(number=1.618, num_decimal_places=3), DecimalNumber(number=3.141, num_decimal_places=3))\n        text_2 = Text(\"Transform\", color=BLUE)\n        transform.add(text_2)\n\n        ints = VGroup(c_transform, transform)\n        texts = VGroup(text_1, text_2).scale(0.75)\n        c_transform.arrange(direction=UP, buff=1)\n        transform.arrange(direction=UP, buff=1)\n\n        ints.arrange(buff=2)\n        self.add(ints, texts)\n\n        # The mobs move in clockwise direction for ClockwiseTransform()\n        self.play(CounterclockwiseTransform(c_transform[0], c_transform[1]))\n\n        # The mobs move straight up for Transform()\n        self.play(Transform(transform[0], transform[1]))", "code_sha1": "6c5589d318d3f6a8a38d31c697a4cd2a919f9a1c"}
{"url": "https://docs.manim.community/en/stable/reference/manim.animation.transform.CounterclockwiseTransform.html", "depth": 1, "instruction": "The scene displays two groups of numbers, each labeled with colored text: \"CounterclockwiseTransform\" in red and \"Transform\" in blue. The first group moves along a counterclockwise arc, while the second group transforms straight upward. The numbers are arranged vertically with a slight buffer, and the text is scaled down to 75% of its original size.", "code": "class CounterclockwiseTransform_vs_Transform(Scene):\n    def construct(self):\n        # set up the numbers\n        c_transform = VGroup(DecimalNumber(number=3.141, num_decimal_places=3), DecimalNumber(number=1.618, num_decimal_places=3))\n        text_1 = Text(\"CounterclockwiseTransform\", color=RED)\n        c_transform.add(text_1)\n\n        transform = VGroup(DecimalNumber(number=1.618, num_decimal_places=3), DecimalNumber(number=3.141, num_decimal_places=3))\n        text_2 = Text(\"Transform\", color=BLUE)\n        transform.add(text_2)\n\n        ints = VGroup(c_transform, transform)\n        texts = VGroup(text_1, text_2).scale(0.75)\n        c_transform.arrange(direction=UP, buff=1)\n        transform.arrange(direction=UP, buff=1)\n\n        ints.arrange(buff=2)\n        self.add(ints, texts)\n\n        # The mobs move in clockwise direction for ClockwiseTransform()\n        self.play(CounterclockwiseTransform(c_transform[0], c_transform[1]))\n\n        # The mobs move straight up for Transform()\n        self.play(Transform(transform[0], transform[1]))", "code_sha1": "3d5b300e48da249fd1238781cf3831451cdc7de0"}
{"url": "https://docs.manim.community/en/stable/reference/manim.animation.transform.CyclicReplace.html", "depth": 1, "instruction": "The scene displays a horizontally arranged group of a square, circle, triangle, and star. Each shape cyclically replaces the previous one in a smooth animation, with a default path arc, creating a dynamic visual effect. The colors and sizes of the shapes remain unchanged throughout the animation.", "code": "from manim import *\n\nclass CyclicReplaceExample(Scene):\n    def construct(self):\n        group = VGroup(Square(), Circle(), Triangle(), Star())\n        group.arrange(RIGHT)\n        self.add(group)\n\n        for _ in range(4):\n            self.play(CyclicReplace(*group))", "code_sha1": "d85137d504671592fd3c23c0a2c003af3544c349"}
{"url": "https://docs.manim.community/en/stable/reference/manim.animation.transform.CyclicReplace.html", "depth": 1, "instruction": "Four shapes (Square, Circle, Triangle, Star) arranged horizontally will cyclically replace each other in a smooth animation, with each shape transitioning to the next in a continuous loop. The animation will repeat four times, maintaining the original arrangement and size, with no color changes or camera operations.", "code": "class CyclicReplaceExample(Scene):\n    def construct(self):\n        group = VGroup(Square(), Circle(), Triangle(), Star())\n        group.arrange(RIGHT)\n        self.add(group)\n\n        for _ in range(4):\n            self.play(CyclicReplace(*group))", "code_sha1": "691f2d207153a0262e5c3c3cb0ba1b7399a5f424"}
{"url": "https://docs.manim.community/en/stable/reference/manim.animation.transform.FadeToColor.html", "depth": 1, "instruction": "The scene displays the text \"Hello World!\" in its default color, which then smoothly transitions to red over the duration of the animation. The text remains centered on the screen throughout the effect.", "code": "from manim import *\n\nclass FadeToColorExample(Scene):\n    def construct(self):\n        self.play(FadeToColor(Text(\"Hello World!\"), color=RED))", "code_sha1": "d163ca81dcea89e50f496fa68ce51fb3084ffceb"}
{"url": "https://docs.manim.community/en/stable/reference/manim.animation.transform.FadeToColor.html", "depth": 1, "instruction": "The scene displays the text \"Hello World!\" in its default color, which then smoothly transitions to red over the duration of the animation. The text remains centered on the screen throughout the effect.", "code": "class FadeToColorExample(Scene):\n    def construct(self):\n        self.play(FadeToColor(Text(\"Hello World!\"), color=RED))", "code_sha1": "59b65d9df3a8a8aa18d72c1bb1127c26f45b1660"}
{"url": "https://docs.manim.community/en/stable/reference/manim.animation.transform.FadeTransform.html", "depth": 1, "instruction": "Three rectangles fade in from the left, arranged vertically. They transform into three circles on the right: the first stretches, the second matches width, and the third matches height. All objects fade out at the end.", "code": "from manim import *\n\nclass DifferentFadeTransforms(Scene):\n    def construct(self):\n        starts = [Rectangle(width=4, height=1) for _ in range(3)]\n        VGroup(*starts).arrange(DOWN, buff=1).shift(3*LEFT)\n        targets = [Circle(fill_opacity=1).scale(0.25) for _ in range(3)]\n        VGroup(*targets).arrange(DOWN, buff=1).shift(3*RIGHT)\n\n        self.play(*[FadeIn(s) for s in starts])\n        self.play(\n            FadeTransform(starts[0], targets[0], stretch=True),\n            FadeTransform(starts[1], targets[1], stretch=False, dim_to_match=0),\n            FadeTransform(starts[2], targets[2], stretch=False, dim_to_match=1)\n        )\n\n        self.play(*[FadeOut(mobj) for mobj in self.mobjects])", "code_sha1": "7345cef92e536fe06c1a480192510015f0758ec7"}
{"url": "https://docs.manim.community/en/stable/reference/manim.animation.transform.FadeTransform.html", "depth": 1, "instruction": "Three rectangles fade in from the left, arranged vertically. They transform into three circles on the right: the first stretches, the second matches width, and the third matches height. All objects fade out at the end.", "code": "class DifferentFadeTransforms(Scene):\n    def construct(self):\n        starts = [Rectangle(width=4, height=1) for _ in range(3)]\n        VGroup(*starts).arrange(DOWN, buff=1).shift(3*LEFT)\n        targets = [Circle(fill_opacity=1).scale(0.25) for _ in range(3)]\n        VGroup(*targets).arrange(DOWN, buff=1).shift(3*RIGHT)\n\n        self.play(*[FadeIn(s) for s in starts])\n        self.play(\n            FadeTransform(starts[0], targets[0], stretch=True),\n            FadeTransform(starts[1], targets[1], stretch=False, dim_to_match=0),\n            FadeTransform(starts[2], targets[2], stretch=False, dim_to_match=1)\n        )\n\n        self.play(*[FadeOut(mobj) for mobj in self.mobjects])", "code_sha1": "a5f8d964fca3c1917ab5310232eebb89fb8d7773"}
{"url": "https://docs.manim.community/en/stable/reference/manim.animation.transform.FadeTransformPieces.html", "depth": 1, "instruction": "The scene features a square and a circle fading into a circle and a triangle, respectively, with both pairs positioned at different locations. The initial shapes appear, then transform smoothly into their targets, followed by a fade-out of all objects. The colors are default, and the animations occur sequentially.", "code": "from manim import *\n\nclass FadeTransformSubmobjects(Scene):\n    def construct(self):\n        src = VGroup(Square(), Circle().shift(LEFT + UP))\n        src.shift(3*LEFT + 2*UP)\n        src_copy = src.copy().shift(4*DOWN)\n\n        target = VGroup(Circle(), Triangle().shift(RIGHT + DOWN))\n        target.shift(3*RIGHT + 2*UP)\n        target_copy = target.copy().shift(4*DOWN)\n\n        self.play(FadeIn(src), FadeIn(src_copy))\n        self.play(\n            FadeTransform(src, target),\n            FadeTransformPieces(src_copy, target_copy)\n        )\n        self.play(*[FadeOut(mobj) for mobj in self.mobjects])", "code_sha1": "23e940b13c4e8cdcb1da4c550f15c361044f5d62"}
{"url": "https://docs.manim.community/en/stable/reference/manim.animation.transform.FadeTransformPieces.html", "depth": 1, "instruction": "The scene features a square and a circle fading in, positioned left and above the center, with a copy below. They transform into a circle and a triangle, positioned right and below the center, with a copy below. Finally, all objects fade out simultaneously.", "code": "class FadeTransformSubmobjects(Scene):\n    def construct(self):\n        src = VGroup(Square(), Circle().shift(LEFT + UP))\n        src.shift(3*LEFT + 2*UP)\n        src_copy = src.copy().shift(4*DOWN)\n\n        target = VGroup(Circle(), Triangle().shift(RIGHT + DOWN))\n        target.shift(3*RIGHT + 2*UP)\n        target_copy = target.copy().shift(4*DOWN)\n\n        self.play(FadeIn(src), FadeIn(src_copy))\n        self.play(\n            FadeTransform(src, target),\n            FadeTransformPieces(src_copy, target_copy)\n        )\n        self.play(*[FadeOut(mobj) for mobj in self.mobjects])", "code_sha1": "1bc2edc55c2e93be27dff64f776178d8e5b48420"}
{"url": "https://docs.manim.community/en/stable/reference/manim.animation.transform.MoveToTarget.html", "depth": 1, "instruction": "A blue circle transforms into a smaller green circle with 50% opacity, shifting to the right and upward during the animation. The transition is smooth and occurs over a default duration, showcasing the MoveToTarget effect.", "code": "from manim import *\n\nclass MoveToTargetExample(Scene):\n    def construct(self):\n        c = Circle()\n\n        c.generate_target()\n        c.target.set_fill(color=GREEN, opacity=0.5)\n        c.target.shift(2*RIGHT + UP).scale(0.5)\n\n        self.add(c)\n        self.play(MoveToTarget(c))", "code_sha1": "4002909b8f487dcdf4b657ae25214134c37f1381"}
{"url": "https://docs.manim.community/en/stable/reference/manim.animation.transform.MoveToTarget.html", "depth": 1, "instruction": "A blue circle transforms into a smaller, green circle with 50% opacity, shifting to the right and upward during the animation. The transition occurs smoothly over the default duration, showcasing the movement and color change.", "code": "class MoveToTargetExample(Scene):\n    def construct(self):\n        c = Circle()\n\n        c.generate_target()\n        c.target.set_fill(color=GREEN, opacity=0.5)\n        c.target.shift(2*RIGHT + UP).scale(0.5)\n\n        self.add(c)\n        self.play(MoveToTarget(c))", "code_sha1": "2eaa38f6a580cec5ad506420f456a4861b7d7e03"}
{"url": "https://docs.manim.community/en/stable/reference/manim.animation.transform.ReplacementTransform.html", "depth": 1, "instruction": "The scene features two groups of integers (1-3 in red, 4-6 in blue) arranged vertically with text labels. The first group undergoes sequential replacements, while the second group transforms, lingering after each transformation. The animation includes smooth transitions, with a wait at the end, showcasing the dynamic changes in the objects.", "code": "from manim import *\n\nclass ReplacementTransformOrTransform(Scene):\n    def construct(self):\n        # set up the numbers\n        r_transform = VGroup(*[Integer(i) for i in range(1,4)])\n        text_1 = Text(\"ReplacementTransform\", color=RED)\n        r_transform.add(text_1)\n\n        transform = VGroup(*[Integer(i) for i in range(4,7)])\n        text_2 = Text(\"Transform\", color=BLUE)\n        transform.add(text_2)\n\n        ints = VGroup(r_transform, transform)\n        texts = VGroup(text_1, text_2).scale(0.75)\n        r_transform.arrange(direction=UP, buff=1)\n        transform.arrange(direction=UP, buff=1)\n\n        ints.arrange(buff=2)\n        self.add(ints, texts)\n\n        # The mobs replace each other and none are left behind\n        self.play(ReplacementTransform(r_transform[0], r_transform[1]))\n        self.play(ReplacementTransform(r_transform[1], r_transform[2]))\n\n        # The mobs linger after the Transform()\n        self.play(Transform(transform[0], transform[1]))\n        self.play(Transform(transform[1], transform[2]))\n        self.wait()", "code_sha1": "eec345bade696f78511368f910a584b017d28052"}
{"url": "https://docs.manim.community/en/stable/reference/manim.animation.transform.ReplacementTransform.html", "depth": 1, "instruction": "The scene features two groups of integers (1-3 in red, 4-6 in blue) arranged vertically, with corresponding text labels. The first group undergoes a smooth replacement transformation, while the second group transforms without disappearing. The final scene holds the transformed objects, creating a dynamic visual contrast between the two transformation methods.", "code": "class ReplacementTransformOrTransform(Scene):\n    def construct(self):\n        # set up the numbers\n        r_transform = VGroup(*[Integer(i) for i in range(1,4)])\n        text_1 = Text(\"ReplacementTransform\", color=RED)\n        r_transform.add(text_1)\n\n        transform = VGroup(*[Integer(i) for i in range(4,7)])\n        text_2 = Text(\"Transform\", color=BLUE)\n        transform.add(text_2)\n\n        ints = VGroup(r_transform, transform)\n        texts = VGroup(text_1, text_2).scale(0.75)\n        r_transform.arrange(direction=UP, buff=1)\n        transform.arrange(direction=UP, buff=1)\n\n        ints.arrange(buff=2)\n        self.add(ints, texts)\n\n        # The mobs replace each other and none are left behind\n        self.play(ReplacementTransform(r_transform[0], r_transform[1]))\n        self.play(ReplacementTransform(r_transform[1], r_transform[2]))\n\n        # The mobs linger after the Transform()\n        self.play(Transform(transform[0], transform[1]))\n        self.play(Transform(transform[1], transform[2]))\n        self.wait()", "code_sha1": "6f478bb14e701850d83a78746c86397812cd53d5"}
{"url": "https://docs.manim.community/en/stable/reference/manim.animation.transform.Restore.html", "depth": 1, "instruction": "A purple square fades in, then transforms to a larger size with 50% opacity, shifts left, and rotates. It subsequently moves down and rotates further. After a pause, the square smoothly restores to its original state over 2 seconds.", "code": "from manim import *\n\nclass RestoreExample(Scene):\n    def construct(self):\n        s = Square()\n        s.save_state()\n        self.play(FadeIn(s))\n        self.play(s.animate.set_color(PURPLE).set_opacity(0.5).shift(2*LEFT).scale(3))\n        self.play(s.animate.shift(5*DOWN).rotate(PI/4))\n        self.wait()\n        self.play(Restore(s), run_time=2)", "code_sha1": "2afd9805e8ba0bbe5cac8d41df54dc04001af2c1"}
{"url": "https://docs.manim.community/en/stable/reference/manim.animation.transform.Restore.html", "depth": 1, "instruction": "A purple square fades in, shifts left, scales up, and rotates downwards, then restores to its original state over 2 seconds.", "code": "class RestoreExample(Scene):\n    def construct(self):\n        s = Square()\n        s.save_state()\n        self.play(FadeIn(s))\n        self.play(s.animate.set_color(PURPLE).set_opacity(0.5).shift(2*LEFT).scale(3))\n        self.play(s.animate.shift(5*DOWN).rotate(PI/4))\n        self.wait()\n        self.play(Restore(s), run_time=2)", "code_sha1": "f278dce612f28a7cc69b2d4a53a1590f12a5714f"}
{"url": "https://docs.manim.community/en/stable/reference/manim.animation.transform.ScaleInPlace.html", "depth": 1, "instruction": "The scene displays the text \"Hello World!\" which scales up in size over 2 seconds, starting from its original size. The text is centered on the screen and retains its color throughout the animation.", "code": "from manim import *\n\nclass ScaleInPlaceExample(Scene):\n    def construct(self):\n        self.play(ScaleInPlace(Text(\"Hello World!\"), 2))", "code_sha1": "fad4c536c541aecb54974cc67aaae736afb1fa86"}
{"url": "https://docs.manim.community/en/stable/reference/manim.animation.transform.ScaleInPlace.html", "depth": 1, "instruction": "The scene displays the text \"Hello World!\" scaling up in size over 2 seconds, centered in the frame, with no additional colors or effects applied.", "code": "class ScaleInPlaceExample(Scene):\n    def construct(self):\n        self.play(ScaleInPlace(Text(\"Hello World!\"), 2))", "code_sha1": "525cc1825415494a45fc7b46bca63d756a86389b"}
{"url": "https://docs.manim.community/en/stable/reference/manim.animation.transform.ShrinkToCenter.html", "depth": 1, "instruction": "The animation displays the text \"Hello World!\" in a default color, shrinking smoothly towards its center over a brief duration, creating a visually appealing effect as it disappears.", "code": "from manim import *\n\nclass ShrinkToCenterExample(Scene):\n    def construct(self):\n        self.play(ShrinkToCenter(Text(\"Hello World!\")))", "code_sha1": "3aba526255415ca0828c4f4fcf1ec847e423703c"}
{"url": "https://docs.manim.community/en/stable/reference/manim.animation.transform.ShrinkToCenter.html", "depth": 1, "instruction": "The scene displays the text \"Hello World!\" in a default color, which smoothly shrinks to its center over a brief duration, creating a visually appealing contraction effect.", "code": "class ShrinkToCenterExample(Scene):\n    def construct(self):\n        self.play(ShrinkToCenter(Text(\"Hello World!\")))", "code_sha1": "a5d62db0446814b9efd6f30681a91627f498e1e1"}
{"url": "https://docs.manim.community/en/stable/reference/manim.animation.transform.Transform.html", "depth": 1, "instruction": "The scene displays six colored circles (blue, teal shades, green) arranged vertically, each transforming into a corresponding circle to the right along an arc path defined by specified angles. The transformations occur simultaneously over 2 seconds, with arcs appearing in yellow, and accompanying text labels indicating the angles next to each circle.", "code": "from manim import *\n\nclass TransformPathArc(Scene):\n    def construct(self):\n        def make_arc_path(start, end, arc_angle):\n            points = []\n            p_fn = path_along_arc(arc_angle)\n            # alpha animates between 0.0 and 1.0, where 0.0\n            # is the beginning of the animation and 1.0 is the end.\n            for alpha in range(0, 11):\n                points.append(p_fn(start, end, alpha / 10.0))\n            path = VMobject(stroke_color=YELLOW)\n            path.set_points_smoothly(points)\n            return path\n\n        left = Circle(stroke_color=BLUE_E, fill_opacity=1.0, radius=0.5).move_to(LEFT * 2)\n        colors = [TEAL_A, TEAL_B, TEAL_C, TEAL_D, TEAL_E, GREEN_A]\n        # Positive angles move counter-clockwise, negative angles move clockwise.\n        examples = [-90, 0, 30, 90, 180, 270]\n        anims = []\n        for idx, angle in enumerate(examples):\n            left_c = left.copy().shift((3 - idx) * UP)\n            left_c.fill_color = colors[idx]\n            right_c = left_c.copy().shift(4 * RIGHT)\n            path_arc = make_arc_path(left_c.get_center(), right_c.get_center(),\n                                     arc_angle=angle * DEGREES)\n            desc = Text('%d°' % examples[idx]).next_to(left_c, LEFT)\n            # Make the circles in front of the text in front of the arcs.\n            self.add(\n                path_arc.set_z_index(1),\n                desc.set_z_index(2),\n                left_c.set_z_index(3),\n            )\n            anims.append(Transform(left_c, right_c, path_arc=angle * DEGREES))\n\n        self.play(*anims, run_time=2)\n        self.wait()", "code_sha1": "bf43a4a681de8f834e8a41b860b948078aa01369"}
{"url": "https://docs.manim.community/en/stable/reference/manim.animation.transform.Transform.html", "depth": 1, "instruction": "The scene displays six colored circles (blue, teal shades, green) arranged vertically, each transforming into a corresponding circle on the right while following an arc path defined by specified angles (-90°, 0°, 30°, 90°, 180°, 270°). The transformations occur simultaneously over 2 seconds, with accompanying angle labels positioned to the left of each circle.", "code": "class TransformPathArc(Scene):\n    def construct(self):\n        def make_arc_path(start, end, arc_angle):\n            points = []\n            p_fn = path_along_arc(arc_angle)\n            # alpha animates between 0.0 and 1.0, where 0.0\n            # is the beginning of the animation and 1.0 is the end.\n            for alpha in range(0, 11):\n                points.append(p_fn(start, end, alpha / 10.0))\n            path = VMobject(stroke_color=YELLOW)\n            path.set_points_smoothly(points)\n            return path\n\n        left = Circle(stroke_color=BLUE_E, fill_opacity=1.0, radius=0.5).move_to(LEFT * 2)\n        colors = [TEAL_A, TEAL_B, TEAL_C, TEAL_D, TEAL_E, GREEN_A]\n        # Positive angles move counter-clockwise, negative angles move clockwise.\n        examples = [-90, 0, 30, 90, 180, 270]\n        anims = []\n        for idx, angle in enumerate(examples):\n            left_c = left.copy().shift((3 - idx) * UP)\n            left_c.fill_color = colors[idx]\n            right_c = left_c.copy().shift(4 * RIGHT)\n            path_arc = make_arc_path(left_c.get_center(), right_c.get_center(),\n                                     arc_angle=angle * DEGREES)\n            desc = Text('%d°' % examples[idx]).next_to(left_c, LEFT)\n            # Make the circles in front of the text in front of the arcs.\n            self.add(\n                path_arc.set_z_index(1),\n                desc.set_z_index(2),\n                left_c.set_z_index(3),\n            )\n            anims.append(Transform(left_c, right_c, path_arc=angle * DEGREES))\n\n        self.play(*anims, run_time=2)\n        self.wait()", "code_sha1": "5992a36663dbad310c05c7f2dcd40f61851b865e"}
{"url": "https://docs.manim.community/en/stable/reference/manim.animation.transform_matching_parts.TransformMatchingShapes.html", "depth": 1, "instruction": "The animation displays the text \"the morse code\" being written on screen, followed by a smooth transformation into \"here come dots\" using a curved path. The transition lasts for 0.5 seconds, with both texts centered and maintaining a consistent height throughout the animation.", "code": "from manim import *\n\nclass Anagram(Scene):\n    def construct(self):\n        src = Text(\"the morse code\")\n        tar = Text(\"here come dots\")\n        self.play(Write(src))\n        self.wait(0.5)\n        self.play(TransformMatchingShapes(src, tar, path_arc=PI/2))\n        self.wait(0.5)", "code_sha1": "20d1b33f4e60b1b019296e49d9f22219a3549778"}
{"url": "https://docs.manim.community/en/stable/reference/manim.animation.transform_matching_parts.TransformMatchingShapes.html", "depth": 1, "instruction": "The animation displays the text \"the morse code\" being written on screen, followed by a smooth transformation into \"here come dots\" using a curved path. The text is white against a dark background, with a brief pause before and after the transformation.", "code": "class Anagram(Scene):\n    def construct(self):\n        src = Text(\"the morse code\")\n        tar = Text(\"here come dots\")\n        self.play(Write(src))\n        self.wait(0.5)\n        self.play(TransformMatchingShapes(src, tar, path_arc=PI/2))\n        self.wait(0.5)", "code_sha1": "5759bb2e05a28a3cbc438c50848dac8558cec464"}
{"url": "https://docs.manim.community/en/stable/reference/manim.animation.transform_matching_parts.TransformMatchingTex.html", "depth": 1, "instruction": "The scene displays a sequence of mathematical equations, starting with \\(x^2 + y^2 = z^2\\) transitioning to \\(a^2 + b^2 = c^2\\) and finally \\(a^2 = c^2 - b^2\\). Each transformation smoothly replaces matching variables with corresponding symbols, with a brief pause between each transformation for emphasis.", "code": "from manim import *\n\nclass MatchingEquationParts(Scene):\n    def construct(self):\n        variables = VGroup(MathTex(\"a\"), MathTex(\"b\"), MathTex(\"c\")).arrange_submobjects().shift(UP)\n\n        eq1 = MathTex(\"{{x}}^2\", \"+\", \"{{y}}^2\", \"=\", \"{{z}}^2\")\n        eq2 = MathTex(\"{{a}}^2\", \"+\", \"{{b}}^2\", \"=\", \"{{c}}^2\")\n        eq3 = MathTex(\"{{a}}^2\", \"=\", \"{{c}}^2\", \"-\", \"{{b}}^2\")\n\n        self.add(eq1)\n        self.wait(0.5)\n        self.play(TransformMatchingTex(Group(eq1, variables), eq2))\n        self.wait(0.5)\n        self.play(TransformMatchingTex(eq2, eq3))\n        self.wait(0.5)", "code_sha1": "31e294780f4106d85bf130ba60cefe51f3c651e1"}
{"url": "https://docs.manim.community/en/stable/reference/manim.animation.transform_matching_parts.TransformMatchingTex.html", "depth": 1, "instruction": "The scene displays a sequence of mathematical equations. Initially, \"x² + y² = z²\" appears, then transforms into \"a² + b² = c²\" with matching variables, followed by a transformation to \"a² = c² - b²\". Each transformation occurs smoothly after a brief pause, maintaining the same layout and size throughout.", "code": "class MatchingEquationParts(Scene):\n    def construct(self):\n        variables = VGroup(MathTex(\"a\"), MathTex(\"b\"), MathTex(\"c\")).arrange_submobjects().shift(UP)\n\n        eq1 = MathTex(\"{{x}}^2\", \"+\", \"{{y}}^2\", \"=\", \"{{z}}^2\")\n        eq2 = MathTex(\"{{a}}^2\", \"+\", \"{{b}}^2\", \"=\", \"{{c}}^2\")\n        eq3 = MathTex(\"{{a}}^2\", \"=\", \"{{c}}^2\", \"-\", \"{{b}}^2\")\n\n        self.add(eq1)\n        self.wait(0.5)\n        self.play(TransformMatchingTex(Group(eq1, variables), eq2))\n        self.wait(0.5)\n        self.play(TransformMatchingTex(eq2, eq3))\n        self.wait(0.5)", "code_sha1": "2ba119f30a6cafa4c7ffaf07dc23897ddf2fb072"}
{"url": "https://docs.manim.community/en/stable/reference/manim.animation.updaters.mobject_update_utils.html", "depth": 1, "instruction": "In the scene, a red sine wave is plotted on axes, with a blue dot moving along it and a yellow tangent line dynamically adjusting to the dot's position. The dot travels from the start to the end of the sine wave over 2 seconds, while the tangent line updates in real-time.", "code": "from manim import *\n\nclass TangentAnimation(Scene):\n    def construct(self):\n        ax = Axes()\n        sine = ax.plot(np.sin, color=RED)\n        alpha = ValueTracker(0)\n        point = always_redraw(\n            lambda: Dot(\n                sine.point_from_proportion(alpha.get_value()),\n                color=BLUE\n            )\n        )\n        tangent = always_redraw(\n            lambda: TangentLine(\n                sine,\n                alpha=alpha.get_value(),\n                color=YELLOW,\n                length=4\n            )\n        )\n        self.add(ax, sine, point, tangent)\n        self.play(alpha.animate.set_value(1), rate_func=linear, run_time=2)", "code_sha1": "ce8788600e113e731432a00522b10bae0210905d"}
{"url": "https://docs.manim.community/en/stable/reference/manim.animation.updaters.mobject_update_utils.html", "depth": 1, "instruction": "A triangle continuously spins around its center while a square moves linearly to the right, starting from the left edge of the screen. The triangle is fully opaque, and both shapes are added to the scene simultaneously, with the square's movement animated over one second at a constant speed.", "code": "from manim import *\n\nclass SpinningTriangle(Scene):\n    def construct(self):\n        tri = Triangle().set_fill(opacity=1).set_z_index(2)\n        sq = Square().to_edge(LEFT)\n\n        # will keep spinning while there is an animation going on\n        always_rotate(tri, rate=2*PI, about_point=ORIGIN)\n\n        self.add(tri, sq)\n        self.play(sq.animate.to_edge(RIGHT), rate_func=linear, run_time=1)", "code_sha1": "417bba4b15b98a462c8b7e2c51adae85b4cc31ee"}
{"url": "https://docs.manim.community/en/stable/reference/manim.animation.updaters.mobject_update_utils.html", "depth": 1, "instruction": "A filled square continuously shifts to the right at a rate of 5 units per second, while a triangle appears with a fill opacity of 1, positioned to the left of the square.", "code": "from manim import *\n\nclass ShiftingSquare(Scene):\n    def construct(self):\n        sq = Square().set_fill(opacity=1)\n        tri = Triangle()\n        VGroup(sq, tri).arrange(LEFT)\n\n        # construct a square which is continuously\n        # shifted to the right\n        always_shift(sq, RIGHT, rate=5)\n\n        self.add(sq)\n        self.play(tri.animate.set_fill(opacity=1))", "code_sha1": "6d244ae39a83d0a884664ef91c6479ee1d8640fd"}
{"url": "https://docs.manim.community/en/stable/reference/manim.animation.updaters.mobject_update_utils.html", "depth": 1, "instruction": "The scene displays the text \"Welcome to\" being written over 0.9 seconds, followed by a 0.5-second pause. A scaled-down Manim banner expands beneath the text, creating a visually engaging introduction. The text and banner are vertically arranged, with the banner's expansion animated smoothly.", "code": "from manim import *\n\nclass WelcomeToManim(Scene):\n    def construct(self):\n        words = Text(\"Welcome to\")\n        banner = ManimBanner().scale(0.5)\n        VGroup(words, banner).arrange(DOWN)\n\n        turn_animation_into_updater(Write(words, run_time=0.9))\n        self.add(words)\n        self.wait(0.5)\n        self.play(banner.expand(), run_time=0.5)", "code_sha1": "1942de9585fa689c319677f932e8163caef8b67f"}
{"url": "https://docs.manim.community/en/stable/reference/manim.animation.updaters.mobject_update_utils.html", "depth": 1, "instruction": "The scene features a red sine wave plotted on axes, with a blue dot moving along it and a yellow tangent line dynamically adjusting to the dot's position. The dot and tangent line are continuously updated as the dot travels from the start to the end of the sine wave over 2 seconds, using a linear animation.", "code": "class TangentAnimation(Scene):\n    def construct(self):\n        ax = Axes()\n        sine = ax.plot(np.sin, color=RED)\n        alpha = ValueTracker(0)\n        point = always_redraw(\n            lambda: Dot(\n                sine.point_from_proportion(alpha.get_value()),\n                color=BLUE\n            )\n        )\n        tangent = always_redraw(\n            lambda: TangentLine(\n                sine,\n                alpha=alpha.get_value(),\n                color=YELLOW,\n                length=4\n            )\n        )\n        self.add(ax, sine, point, tangent)\n        self.play(alpha.animate.set_value(1), rate_func=linear, run_time=2)", "code_sha1": "097a3fb8b4de8b84442a95c8683a732a69d044e2"}
{"url": "https://docs.manim.community/en/stable/reference/manim.animation.updaters.mobject_update_utils.html", "depth": 1, "instruction": "A triangle continuously spins around its center while a square moves linearly to the right, both appearing on the screen. The triangle is fully opaque, and the square's movement lasts for one second with a linear timing function. The triangle remains in the foreground due to its z-index.", "code": "class SpinningTriangle(Scene):\n    def construct(self):\n        tri = Triangle().set_fill(opacity=1).set_z_index(2)\n        sq = Square().to_edge(LEFT)\n\n        # will keep spinning while there is an animation going on\n        always_rotate(tri, rate=2*PI, about_point=ORIGIN)\n\n        self.add(tri, sq)\n        self.play(sq.animate.to_edge(RIGHT), rate_func=linear, run_time=1)", "code_sha1": "637d684dbf08a17636c8f95c65116dfb544a4561"}
{"url": "https://docs.manim.community/en/stable/reference/manim.animation.updaters.mobject_update_utils.html", "depth": 1, "instruction": "A filled square shifts continuously to the right at a speed of 5 units per second, while a triangle appears with a fade-in effect as its fill opacity is animated to 1. The square and triangle are arranged side by side on the left.", "code": "class ShiftingSquare(Scene):\n    def construct(self):\n        sq = Square().set_fill(opacity=1)\n        tri = Triangle()\n        VGroup(sq, tri).arrange(LEFT)\n\n        # construct a square which is continuously\n        # shifted to the right\n        always_shift(sq, RIGHT, rate=5)\n\n        self.add(sq)\n        self.play(tri.animate.set_fill(opacity=1))", "code_sha1": "b789cf402c03f3819f1dd06965336c5eae6006ab"}
{"url": "https://docs.manim.community/en/stable/reference/manim.animation.updaters.mobject_update_utils.html", "depth": 1, "instruction": "The scene displays the text \"Welcome to\" being written over 0.9 seconds, followed by a 0.5-second pause. A scaled-down Manim banner expands beneath the text, creating a visually engaging introduction. The text and banner are vertically arranged, with the text appearing first, then the banner expanding smoothly.", "code": "class WelcomeToManim(Scene):\n    def construct(self):\n        words = Text(\"Welcome to\")\n        banner = ManimBanner().scale(0.5)\n        VGroup(words, banner).arrange(DOWN)\n\n        turn_animation_into_updater(Write(words, run_time=0.9))\n        self.add(words)\n        self.wait(0.5)\n        self.play(banner.expand(), run_time=0.5)", "code_sha1": "3fc0257a1b557d6930f583f529640e2aa5493088"}
{"url": "https://docs.manim.community/en/stable/reference/manim._config.utils.ManimConfig.html", "depth": 1, "instruction": "The scene displays a white background, with no objects present. The camera remains static, emphasizing the empty space. The visual result highlights the configuration of the background color, demonstrating the effect of setting `config.background_color` to WHITE programmatically.", "code": "from manim import WHITE\nconfig.background_color = WHITE\nconfig[\"background_color\"] = WHITE", "code_sha1": "13bf431558a13b967d4339b70ba4ae4e4535d8c5"}
{"url": "https://docs.manim.community/en/stable/reference/manim._config.utils.ManimConfig.html", "depth": 1, "instruction": "The scene displays a RED background, overriding any previous configurations or command line arguments.", "code": "from manim import *\n\nconfig.background_color = RED\n\nclass MyScene(Scene): ...", "code_sha1": "b13618140e6ba485d4e71c96e39672a93863f5ed"}
{"url": "https://docs.manim.community/en/stable/reference/manim._config.utils.ManimConfig.html", "depth": 1, "instruction": "The visual result displays a directory structure with a labeled path \"media/Tex\" highlighted in a vibrant color, positioned centrally on the screen. The animation smoothly fades in the text, while the background remains a subtle gradient, enhancing visibility. The camera remains static throughout the presentation.", "code": "from manim import config as globalconfig\nconfig = globalconfig.copy()\nconfig.tex_dir\n'{media_dir}/Tex'\nconfig.media_dir\n'./media'\nconfig.get_dir(\"tex_dir\").as_posix()\n'media/Tex'", "code_sha1": "70a5951185a3f8fee629704c1cadca57ccfe61ac"}
{"url": "https://docs.manim.community/en/stable/reference/manim.mobject.geometry.arc.html", "depth": 1, "instruction": "The scene displays six mobjects: a small dot, an annotation dot, a labeled dot with \"ii,\" a labeled dot with an orange alpha symbol, and three curved arrows (two with different radii and one double arrow). Each object is vertically spaced, with the first three dots positioned above the center and the last three below.", "code": "from manim import *\n\nclass UsefulAnnotations(Scene):\n    def construct(self):\n        m0 = Dot()\n        m1 = AnnotationDot()\n        m2 = LabeledDot(\"ii\")\n        m3 = LabeledDot(MathTex(r\"\\alpha\").set_color(ORANGE))\n        m4 = CurvedArrow(2*LEFT, 2*RIGHT, radius= -5)\n        m5 = CurvedArrow(2*LEFT, 2*RIGHT, radius= 8)\n        m6 = CurvedDoubleArrow(ORIGIN, 2*RIGHT)\n\n        self.add(m0, m1, m2, m3, m4, m5, m6)\n        for i, mobj in enumerate(self.mobjects):\n            mobj.shift(DOWN * (i-3))", "code_sha1": "dba69eed2eeb014e7724d4cc1241648ac57612af"}
{"url": "https://docs.manim.community/en/stable/reference/manim.mobject.geometry.arc.html", "depth": 1, "instruction": "The scene displays six mobjects: a small dot, an annotation dot, a labeled dot with \"ii,\" a labeled dot with an orange alpha symbol, and two curved arrows (one with a negative radius and one with a positive radius), along with a curved double arrow. Each object is vertically spaced, shifted downwards from the center.", "code": "class UsefulAnnotations(Scene):\n    def construct(self):\n        m0 = Dot()\n        m1 = AnnotationDot()\n        m2 = LabeledDot(\"ii\")\n        m3 = LabeledDot(MathTex(r\"\\alpha\").set_color(ORANGE))\n        m4 = CurvedArrow(2*LEFT, 2*RIGHT, radius= -5)\n        m5 = CurvedArrow(2*LEFT, 2*RIGHT, radius= 8)\n        m6 = CurvedDoubleArrow(ORIGIN, 2*RIGHT)\n\n        self.add(m0, m1, m2, m3, m4, m5, m6)\n        for i, mobj in enumerate(self.mobjects):\n            mobj.shift(DOWN * (i-3))", "code_sha1": "9f654cfb63498776bd238339bb53dfc755c8e65b"}
{"url": "https://docs.manim.community/en/stable/reference/manim.mobject.geometry.arc.AnnularSector.html", "depth": 1, "instruction": "The scene displays four annular sectors in different colors (yellow, red, blue, green) positioned at the corners of a square. The background is white, and the blue sector has a fill opacity of 0.25, making it semi-transparent. Each sector has varying inner and outer radii and angles, creating distinct shapes.", "code": "from manim import *\n\nclass AnnularSectorExample(Scene):\n    def construct(self):\n        # Changes background color to clearly visualize changes in fill_opacity.\n        self.camera.background_color = WHITE\n\n        # The default parameter start_angle is 0, so the AnnularSector starts from the +x-axis.\n        s1 = AnnularSector(color=YELLOW).move_to(2 * UL)\n\n        # Different inner_radius and outer_radius than the default.\n        s2 = AnnularSector(inner_radius=1.5, outer_radius=2, angle=45 * DEGREES, color=RED).move_to(2 * UR)\n\n        # fill_opacity is typically a number > 0 and <= 1. If fill_opacity=0, the AnnularSector is transparent.\n        s3 = AnnularSector(inner_radius=1, outer_radius=1.5, angle=PI, fill_opacity=0.25, color=BLUE).move_to(2 * DL)\n\n        # With a negative value for the angle, the AnnularSector is drawn clockwise from the start value.\n        s4 = AnnularSector(inner_radius=1, outer_radius=1.5, angle=-3 * PI / 2, color=GREEN).move_to(2 * DR)\n\n        self.add(s1, s2, s3, s4)", "code_sha1": "201e007e12dfcd4fabeab2315ff7d2d532f0f999"}
{"url": "https://docs.manim.community/en/stable/reference/manim.mobject.geometry.arc.AnnularSector.html", "depth": 1, "instruction": "Four annular sectors are displayed on a white background: a yellow sector at the top left, a red sector at the top right with a 45-degree angle, a blue sector at the bottom left with 25% opacity, and a green sector at the bottom right drawn clockwise.", "code": "class AnnularSectorExample(Scene):\n    def construct(self):\n        # Changes background color to clearly visualize changes in fill_opacity.\n        self.camera.background_color = WHITE\n\n        # The default parameter start_angle is 0, so the AnnularSector starts from the +x-axis.\n        s1 = AnnularSector(color=YELLOW).move_to(2 * UL)\n\n        # Different inner_radius and outer_radius than the default.\n        s2 = AnnularSector(inner_radius=1.5, outer_radius=2, angle=45 * DEGREES, color=RED).move_to(2 * UR)\n\n        # fill_opacity is typically a number > 0 and <= 1. If fill_opacity=0, the AnnularSector is transparent.\n        s3 = AnnularSector(inner_radius=1, outer_radius=1.5, angle=PI, fill_opacity=0.25, color=BLUE).move_to(2 * DL)\n\n        # With a negative value for the angle, the AnnularSector is drawn clockwise from the start value.\n        s4 = AnnularSector(inner_radius=1, outer_radius=1.5, angle=-3 * PI / 2, color=GREEN).move_to(2 * DR)\n\n        self.add(s1, s2, s3, s4)", "code_sha1": "8024c38342c8aade5e272d1ab2f3d3aca53f11f6"}
{"url": "https://docs.manim.community/en/stable/reference/manim.mobject.geometry.arc.Annulus.html", "depth": 1, "instruction": "The scene displays two annuli: a larger one with a radius from 0.5 to 1, positioned above, and a smaller red one with a radius from 0.3 to 0.6, placed directly below the first. Both annuli are added to the scene simultaneously without animations.", "code": "from manim import *\n\nclass AnnulusExample(Scene):\n    def construct(self):\n        annulus_1 = Annulus(inner_radius=0.5, outer_radius=1).shift(UP)\n        annulus_2 = Annulus(inner_radius=0.3, outer_radius=0.6, color=RED).next_to(annulus_1, DOWN)\n        self.add(annulus_1, annulus_2)", "code_sha1": "713299cf724aa303bca8fb291161c5cb0e44e42e"}
{"url": "https://docs.manim.community/en/stable/reference/manim.mobject.geometry.arc.Annulus.html", "depth": 1, "instruction": "The scene displays two annuli: a larger one with a radius of 0.5 (inner) and 1 (outer) positioned upwards, and a smaller red annulus with a radius of 0.3 (inner) and 0.6 (outer) placed directly below the first. Both annuli are added to the scene simultaneously.", "code": "class AnnulusExample(Scene):\n    def construct(self):\n        annulus_1 = Annulus(inner_radius=0.5, outer_radius=1).shift(UP)\n        annulus_2 = Annulus(inner_radius=0.3, outer_radius=0.6, color=RED).next_to(annulus_1, DOWN)\n        self.add(annulus_1, annulus_2)", "code_sha1": "a25526e5fe381c9c9b2a3a53bc860a71a0b96093"}
{"url": "https://docs.manim.community/en/stable/reference/manim.mobject.geometry.arc.Arc.html", "depth": 1, "instruction": "A semicircular arc is displayed in the center of the scene, with a default stroke color and width. The arc spans from the left to the right, creating a smooth curve. No animations or camera operations are applied.", "code": "from manim import *\n\nclass ArcExample(Scene):\n    def construct(self):\n        self.add(Arc(angle=PI))", "code_sha1": "c1546b98ee5114386e29f6be8a4a2a0724682ff5"}
{"url": "https://docs.manim.community/en/stable/reference/manim.mobject.geometry.arc.Arc.html", "depth": 1, "instruction": "A semicircular arc is displayed, centered at the origin, with a radius of 1 unit. The arc is drawn in a default color (usually white) and has a stroke width of 1. No animations or camera operations are applied.", "code": "class ArcExample(Scene):\n    def construct(self):\n        self.add(Arc(angle=PI))", "code_sha1": "265962434f7320dc9876127e2d5393250940fb16"}
{"url": "https://docs.manim.community/en/stable/reference/manim.mobject.geometry.arc.ArcBetweenPoints.html", "depth": 1, "instruction": "A grey circle with a radius of 2 units is displayed, along with two green dots at (2,0) and (0,2), each accompanied by blue text labels. A yellow arc is animated to appear between the two dots, creating a smooth transition effect.", "code": "from manim import *\n\nclass ArcBetweenPointsExample(Scene):\n    def construct(self):\n        circle = Circle(radius=2, stroke_color=GREY)\n        dot_1 = Dot(color=GREEN).move_to([2, 0, 0]).scale(0.5)\n        dot_1_text = Tex(\"(2,0)\").scale(0.5).next_to(dot_1, RIGHT).set_color(BLUE)\n        dot_2 = Dot(color=GREEN).move_to([0, 2, 0]).scale(0.5)\n        dot_2_text = Tex(\"(0,2)\").scale(0.5).next_to(dot_2, UP).set_color(BLUE)\n        arc= ArcBetweenPoints(start=2 * RIGHT, end=2 * UP, stroke_color=YELLOW)\n        self.add(circle, dot_1, dot_2, dot_1_text, dot_2_text)\n        self.play(Create(arc))", "code_sha1": "c67a3d198ffa38175898d12dd7b3523cd15a69c1"}
{"url": "https://docs.manim.community/en/stable/reference/manim.mobject.geometry.arc.ArcBetweenPoints.html", "depth": 1, "instruction": "A grey circle with a radius of 2 units is displayed, along with two green dots at (2,0) and (0,2), each accompanied by blue text labels. A yellow arc is animated to appear between the two dots, creating a smooth transition effect.", "code": "class ArcBetweenPointsExample(Scene):\n    def construct(self):\n        circle = Circle(radius=2, stroke_color=GREY)\n        dot_1 = Dot(color=GREEN).move_to([2, 0, 0]).scale(0.5)\n        dot_1_text = Tex(\"(2,0)\").scale(0.5).next_to(dot_1, RIGHT).set_color(BLUE)\n        dot_2 = Dot(color=GREEN).move_to([0, 2, 0]).scale(0.5)\n        dot_2_text = Tex(\"(0,2)\").scale(0.5).next_to(dot_2, UP).set_color(BLUE)\n        arc= ArcBetweenPoints(start=2 * RIGHT, end=2 * UP, stroke_color=YELLOW)\n        self.add(circle, dot_1, dot_2, dot_1_text, dot_2_text)\n        self.play(Create(arc))", "code_sha1": "3d1494a2ac1124f9286df3d14a65ac729b8896c7"}
{"url": "https://docs.manim.community/en/stable/reference/manim.mobject.geometry.arc.ArcPolygon.html", "depth": 1, "instruction": "The code creates an ArcPolygon with three vertices, resulting in three arcs connecting these points. The arcs are visually represented as curved lines, each between the specified points, forming a triangular shape in 3D space.", "code": "from manim import ArcPolygon\nap = ArcPolygon([0, 0, 0], [2, 0, 0], [0, 2, 0])\nap.arcs\n[ArcBetweenPoints, ArcBetweenPoints, ArcBetweenPoints]", "code_sha1": "313011f67a089ca3f9c0f5da9f6103b506b67b59"}
{"url": "https://docs.manim.community/en/stable/reference/manim.mobject.geometry.arc.ArcPolygon.html", "depth": 1, "instruction": "Four arc polygons are displayed in a horizontal arrangement: the first with a default radius, the second with a 45-degree angle, the third in red with a smaller radius, and the fourth with mixed colors and radii. Each polygon is created sequentially with a \"Create\" animation, followed by a pause.", "code": "from manim import *\n\nclass SeveralArcPolygons(Scene):\n    def construct(self):\n        a = [0, 0, 0]\n        b = [2, 0, 0]\n        c = [0, 2, 0]\n        ap1 = ArcPolygon(a, b, c, radius=2)\n        ap2 = ArcPolygon(a, b, c, angle=45*DEGREES)\n        ap3 = ArcPolygon(a, b, c, arc_config={'radius': 1.7, 'color': RED})\n        ap4 = ArcPolygon(a, b, c, color=RED, fill_opacity=1,\n                                    arc_config=[{'radius': 1.7, 'color': RED},\n                                    {'angle': 20*DEGREES, 'color': BLUE},\n                                    {'radius': 1}])\n        ap_group = VGroup(ap1, ap2, ap3, ap4).arrange()\n        self.play(*[Create(ap) for ap in [ap1, ap2, ap3, ap4]])\n        self.wait()", "code_sha1": "6301fd7af8b0cc4ecb81e04ad5488250374a553a"}
{"url": "https://docs.manim.community/en/stable/reference/manim.mobject.geometry.arc.ArcPolygon.html", "depth": 1, "instruction": "The scene displays four arranged ArcPolygons: the first with a radius of 2, the second with a 45-degree angle, the third in red with a radius of 1.7, and the fourth with mixed configurations in red and blue. Each polygon is created sequentially with a \"Create\" animation, followed by a pause.", "code": "class SeveralArcPolygons(Scene):\n    def construct(self):\n        a = [0, 0, 0]\n        b = [2, 0, 0]\n        c = [0, 2, 0]\n        ap1 = ArcPolygon(a, b, c, radius=2)\n        ap2 = ArcPolygon(a, b, c, angle=45*DEGREES)\n        ap3 = ArcPolygon(a, b, c, arc_config={'radius': 1.7, 'color': RED})\n        ap4 = ArcPolygon(a, b, c, color=RED, fill_opacity=1,\n                                    arc_config=[{'radius': 1.7, 'color': RED},\n                                    {'angle': 20*DEGREES, 'color': BLUE},\n                                    {'radius': 1}])\n        ap_group = VGroup(ap1, ap2, ap3, ap4).arrange()\n        self.play(*[Create(ap) for ap in [ap1, ap2, ap3, ap4]])\n        self.wait()", "code_sha1": "91793898ee309a1137f70715a4e78fb3b06eec75"}
{"url": "https://docs.manim.community/en/stable/reference/manim.mobject.geometry.arc.ArcPolygonFromArcs.html", "depth": 1, "instruction": "The visual result displays an ArcPolygon constructed from three arcs: a standard Arc, an ArcBetweenPoints, and another Arc. The arcs are smoothly connected, showcasing their curvature. The colors and sizes are default, with no animations or camera operations applied, resulting in a static representation of the polygon formed by the arcs.", "code": "from manim import ArcPolygonFromArcs, Arc, ArcBetweenPoints\nap = ArcPolygonFromArcs(Arc(), ArcBetweenPoints([1,0,0], [0,1,0]), Arc())\nap.arcs\n[Arc, ArcBetweenPoints, Arc]", "code_sha1": "449c7197cc7095d7dcacd22947c30a44678ec349"}
{"url": "https://docs.manim.community/en/stable/reference/manim.mobject.geometry.arc.ArcPolygonFromArcs.html", "depth": 1, "instruction": "A Reuleaux triangle is displayed, composed of three blue arcs with a thick stroke, filled with purple. The triangle fades in over two seconds, remaining visible for an additional two seconds before the scene ends.", "code": "from manim import *\n\nclass ArcPolygonExample(Scene):\n    def construct(self):\n        arc_conf = {\"stroke_width\": 0}\n        poly_conf = {\"stroke_width\": 10, \"stroke_color\": BLUE,\n              \"fill_opacity\": 1, \"color\": PURPLE}\n        a = [-1, 0, 0]\n        b = [1, 0, 0]\n        c = [0, np.sqrt(3), 0]\n        arc0 = ArcBetweenPoints(a, b, radius=2, **arc_conf)\n        arc1 = ArcBetweenPoints(b, c, radius=2, **arc_conf)\n        arc2 = ArcBetweenPoints(c, a, radius=2, **arc_conf)\n        reuleaux_tri = ArcPolygonFromArcs(arc0, arc1, arc2, **poly_conf)\n        self.play(FadeIn(reuleaux_tri))\n        self.wait(2)", "code_sha1": "344dbef22bac8ca49bfdecaa5806b91a0cb1334c"}
{"url": "https://docs.manim.community/en/stable/reference/manim.mobject.geometry.arc.ArcPolygonFromArcs.html", "depth": 1, "instruction": "The scene displays a Reuleaux triangle formed by three arcs: two blue arcs and one red arc, with a semi-transparent green fill. The triangle fades in over two seconds, while the arcs remain visible, showcasing their connection points. The background is dark, enhancing the arcs' colors.", "code": "from manim import *\n\nclass ArcPolygonExample2(Scene):\n    def construct(self):\n        arc_conf = {\"stroke_width\": 3, \"stroke_color\": BLUE,\n            \"fill_opacity\": 0.5, \"color\": GREEN}\n        poly_conf = {\"color\": None}\n        a = [-1, 0, 0]\n        b = [1, 0, 0]\n        c = [0, np.sqrt(3), 0]\n        arc0 = ArcBetweenPoints(a, b, radius=2, **arc_conf)\n        arc1 = ArcBetweenPoints(b, c, radius=2, **arc_conf)\n        arc2 = ArcBetweenPoints(c, a, radius=2, stroke_color=RED)\n        reuleaux_tri = ArcPolygonFromArcs(arc0, arc1, arc2, **poly_conf)\n        self.play(FadeIn(reuleaux_tri))\n        self.wait(2)", "code_sha1": "26f5013f6f3e587f788163741485965b6cd32a0e"}
{"url": "https://docs.manim.community/en/stable/reference/manim.mobject.geometry.arc.ArcPolygonFromArcs.html", "depth": 1, "instruction": "A Reuleaux triangle is displayed, composed of three blue arcs with a 10-unit stroke width, filled with purple. The triangle fades in over 2 seconds, remaining visible for an additional 2 seconds before the scene ends.", "code": "class ArcPolygonExample(Scene):\n    def construct(self):\n        arc_conf = {\"stroke_width\": 0}\n        poly_conf = {\"stroke_width\": 10, \"stroke_color\": BLUE,\n              \"fill_opacity\": 1, \"color\": PURPLE}\n        a = [-1, 0, 0]\n        b = [1, 0, 0]\n        c = [0, np.sqrt(3), 0]\n        arc0 = ArcBetweenPoints(a, b, radius=2, **arc_conf)\n        arc1 = ArcBetweenPoints(b, c, radius=2, **arc_conf)\n        arc2 = ArcBetweenPoints(c, a, radius=2, **arc_conf)\n        reuleaux_tri = ArcPolygonFromArcs(arc0, arc1, arc2, **poly_conf)\n        self.play(FadeIn(reuleaux_tri))\n        self.wait(2)", "code_sha1": "cf9293ce563a500ab52939dc5784734d27142af7"}
{"url": "https://docs.manim.community/en/stable/reference/manim.mobject.geometry.arc.ArcPolygonFromArcs.html", "depth": 1, "instruction": "A Reuleaux triangle is displayed, formed by three arcs: two blue arcs and one red arc, with a semi-transparent green fill. The triangle fades in over 2 seconds, while the arcs remain visible, showcasing their connection without the polygon outline. The scene holds for an additional 2 seconds before concluding.", "code": "class ArcPolygonExample2(Scene):\n    def construct(self):\n        arc_conf = {\"stroke_width\": 3, \"stroke_color\": BLUE,\n            \"fill_opacity\": 0.5, \"color\": GREEN}\n        poly_conf = {\"color\": None}\n        a = [-1, 0, 0]\n        b = [1, 0, 0]\n        c = [0, np.sqrt(3), 0]\n        arc0 = ArcBetweenPoints(a, b, radius=2, **arc_conf)\n        arc1 = ArcBetweenPoints(b, c, radius=2, **arc_conf)\n        arc2 = ArcBetweenPoints(c, a, radius=2, stroke_color=RED)\n        reuleaux_tri = ArcPolygonFromArcs(arc0, arc1, arc2, **poly_conf)\n        self.play(FadeIn(reuleaux_tri))\n        self.wait(2)", "code_sha1": "37beaf8a9f26e865505077efc390d822c620c0d5"}
{"url": "https://docs.manim.community/en/stable/reference/manim.mobject.geometry.arc.Circle.html", "depth": 1, "instruction": "Three circles are arranged horizontally: a red circle with radius 1.0, a green circle with radius 1.5, and a blue circle with radius 1.0 and full opacity. The circles are spaced evenly with a buffer of 1 unit between them.", "code": "from manim import *\n\nclass CircleExample(Scene):\n    def construct(self):\n        circle_1 = Circle(radius=1.0)\n        circle_2 = Circle(radius=1.5, color=GREEN)\n        circle_3 = Circle(radius=1.0, color=BLUE_B, fill_opacity=1)\n\n        circle_group = Group(circle_1, circle_2, circle_3).arrange(buff=1)\n        self.add(circle_group)", "code_sha1": "b3eaa80b0bb644831bd28ab7df0977f7d66b0c52"}
{"url": "https://docs.manim.community/en/stable/reference/manim.mobject.geometry.arc.Circle.html", "depth": 1, "instruction": "A red circle is displayed, passing through three specified points: LEFT, LEFT + UP, and UP * 2. Three dots are positioned at these points, and a number plane is visible in the background.", "code": "from manim import *\n\nclass CircleFromPointsExample(Scene):\n    def construct(self):\n        circle = Circle.from_three_points(LEFT, LEFT + UP, UP * 2, color=RED)\n        dots = VGroup(\n            Dot(LEFT),\n            Dot(LEFT + UP),\n            Dot(UP * 2),\n        )\n        self.add(NumberPlane(), circle, dots)", "code_sha1": "96e48d140cadb0af86b2e39bd020672792b3c2bd"}
{"url": "https://docs.manim.community/en/stable/reference/manim.mobject.geometry.arc.Circle.html", "depth": 1, "instruction": "The scene displays a blue circle with a radius of 2.0, centered at the origin, and two small squares (0.25 side length) positioned at the top (90 degrees) and bottom (270 degrees) of the circle. All objects are added simultaneously without animations.", "code": "from manim import *\n\nclass PointAtAngleExample(Scene):\n    def construct(self):\n        circle = Circle(radius=2.0)\n        p1 = circle.point_at_angle(PI/2)\n        p2 = circle.point_at_angle(270*DEGREES)\n\n        s1 = Square(side_length=0.25).move_to(p1)\n        s2 = Square(side_length=0.25).move_to(p2)\n        self.add(circle, s1, s2)", "code_sha1": "2836ae916030ec1cd82b7e9576bf798c70cfe54f"}
{"url": "https://docs.manim.community/en/stable/reference/manim.mobject.geometry.arc.Circle.html", "depth": 1, "instruction": "The scene displays three groups: a triangle surrounded by a tight circle, a line surrounded by a larger circle, and a square surrounded by a smaller circle. The groups are arranged horizontally with equal spacing, showcasing different buffer factors for the circles.", "code": "from manim import *\n\nclass CircleSurround(Scene):\n    def construct(self):\n        triangle1 = Triangle()\n        circle1 = Circle().surround(triangle1)\n        group1 = Group(triangle1,circle1) # treat the two mobjects as one\n\n        line2 = Line()\n        circle2 = Circle().surround(line2, buffer_factor=2.0)\n        group2 = Group(line2,circle2)\n\n        # buffer_factor < 1, so the circle is smaller than the square\n        square3 = Square()\n        circle3 = Circle().surround(square3, buffer_factor=0.5)\n        group3 = Group(square3, circle3)\n\n        group = Group(group1, group2, group3).arrange(buff=1)\n        self.add(group)", "code_sha1": "96f0a36a16c6e6d8124f21178972e6cac14e876b"}
{"url": "https://docs.manim.community/en/stable/reference/manim.mobject.geometry.arc.Circle.html", "depth": 1, "instruction": "Three circles are arranged horizontally: a red circle with radius 1.0, a green circle with radius 1.5, and a blue circle with radius 1.0 and full opacity. The circles are spaced evenly with a buffer of 1 unit between them.", "code": "class CircleExample(Scene):\n    def construct(self):\n        circle_1 = Circle(radius=1.0)\n        circle_2 = Circle(radius=1.5, color=GREEN)\n        circle_3 = Circle(radius=1.0, color=BLUE_B, fill_opacity=1)\n\n        circle_group = Group(circle_1, circle_2, circle_3).arrange(buff=1)\n        self.add(circle_group)", "code_sha1": "be6b0e773bdeb81d17c22b61bd678d26496aff66"}
{"url": "https://docs.manim.community/en/stable/reference/manim.mobject.geometry.arc.Circle.html", "depth": 1, "instruction": "A red circle is drawn passing through three specified points: LEFT, LEFT + UP, and UP * 2, with three corresponding dots at these points. The scene includes a NumberPlane as the background.", "code": "class CircleFromPointsExample(Scene):\n    def construct(self):\n        circle = Circle.from_three_points(LEFT, LEFT + UP, UP * 2, color=RED)\n        dots = VGroup(\n            Dot(LEFT),\n            Dot(LEFT + UP),\n            Dot(UP * 2),\n        )\n        self.add(NumberPlane(), circle, dots)", "code_sha1": "b8057c5ea9ffd70d1076e04f069fcfe4b7cd09fa"}
{"url": "https://docs.manim.community/en/stable/reference/manim.mobject.geometry.arc.Circle.html", "depth": 1, "instruction": "A circle with a radius of 2.0 is displayed, with two small squares (0.25 side length) positioned at the top (90 degrees) and bottom (270 degrees) of the circle. The circle and squares are added to the scene without any animations or camera operations.", "code": "class PointAtAngleExample(Scene):\n    def construct(self):\n        circle = Circle(radius=2.0)\n        p1 = circle.point_at_angle(PI/2)\n        p2 = circle.point_at_angle(270*DEGREES)\n\n        s1 = Square(side_length=0.25).move_to(p1)\n        s2 = Square(side_length=0.25).move_to(p2)\n        self.add(circle, s1, s2)", "code_sha1": "790efbead0f056728a8482caf40432a6d3bb3785"}
{"url": "https://docs.manim.community/en/stable/reference/manim.mobject.geometry.arc.Circle.html", "depth": 1, "instruction": "The scene displays three groups: a triangle surrounded by a tight circle, a line surrounded by a larger circle, and a square surrounded by a smaller circle. Each group is arranged horizontally with a buffer of 1 unit, showcasing varying circle sizes and positions relative to their respective shapes.", "code": "class CircleSurround(Scene):\n    def construct(self):\n        triangle1 = Triangle()\n        circle1 = Circle().surround(triangle1)\n        group1 = Group(triangle1,circle1) # treat the two mobjects as one\n\n        line2 = Line()\n        circle2 = Circle().surround(line2, buffer_factor=2.0)\n        group2 = Group(line2,circle2)\n\n        # buffer_factor < 1, so the circle is smaller than the square\n        square3 = Square()\n        circle3 = Circle().surround(square3, buffer_factor=0.5)\n        group3 = Group(square3, circle3)\n\n        group = Group(group1, group2, group3).arrange(buff=1)\n        self.add(group)", "code_sha1": "ff7080ace5197429dfe7036f960a62933505aa3e"}
{"url": "https://docs.manim.community/en/stable/reference/manim.mobject.geometry.arc.CubicBezier.html", "depth": 1, "instruction": "The scene displays two dots (one blue at (-3, 1, 0) and one red at (3, -1, 0)), connected by two lines. A cubic Bézier curve is drawn between the endpoints of these lines, with control points creating a smooth arc. The overall composition is centered in the 3D space.", "code": "from manim import *\n\nclass BezierSplineExample(Scene):\n    def construct(self):\n        p1 = np.array([-3, 1, 0])\n        p1b = p1 + [1, 0, 0]\n        d1 = Dot(point=p1).set_color(BLUE)\n        l1 = Line(p1, p1b)\n        p2 = np.array([3, -1, 0])\n        p2b = p2 - [1, 0, 0]\n        d2 = Dot(point=p2).set_color(RED)\n        l2 = Line(p2, p2b)\n        bezier = CubicBezier(p1b, p1b + 3 * RIGHT, p2b - 3 * RIGHT, p2b)\n        self.add(l1, d1, l2, d2, bezier)", "code_sha1": "3802f81630bb8d96bbbe19537f41dc6160d986c8"}
{"url": "https://docs.manim.community/en/stable/reference/manim.mobject.geometry.arc.CubicBezier.html", "depth": 1, "instruction": "The scene displays two dots (one blue at (-3, 1, 0) and one red at (3, -1, 0)), connected by two lines. A cubic Bézier curve is drawn between the endpoints of the lines, with control points positioned to create a smooth arc. The overall composition is centered in the scene.", "code": "class BezierSplineExample(Scene):\n    def construct(self):\n        p1 = np.array([-3, 1, 0])\n        p1b = p1 + [1, 0, 0]\n        d1 = Dot(point=p1).set_color(BLUE)\n        l1 = Line(p1, p1b)\n        p2 = np.array([3, -1, 0])\n        p2b = p2 - [1, 0, 0]\n        d2 = Dot(point=p2).set_color(RED)\n        l2 = Line(p2, p2b)\n        bezier = CubicBezier(p1b, p1b + 3 * RIGHT, p2b - 3 * RIGHT, p2b)\n        self.add(l1, d1, l2, d2, bezier)", "code_sha1": "db96606860f24b94a3cfc3e7e4df337ab3dc2830"}
{"url": "https://docs.manim.community/en/stable/reference/manim.mobject.geometry.arc.Dot.html", "depth": 1, "instruction": "Three dots are displayed in a horizontal line: one at the left (radius 0.08), one at the center, and one at the right, all in default color.", "code": "from manim import *\n\nclass DotExample(Scene):\n    def construct(self):\n        dot1 = Dot(point=LEFT, radius=0.08)\n        dot2 = Dot(point=ORIGIN)\n        dot3 = Dot(point=RIGHT)\n        self.add(dot1,dot2,dot3)", "code_sha1": "c3a7d19a5063d07d9775f526e58e72cdbc8f782b"}
{"url": "https://docs.manim.community/en/stable/reference/manim.mobject.geometry.arc.Dot.html", "depth": 1, "instruction": "Three dots are displayed: one at the left (small, radius 0.08), one at the center (default size), and one at the right (default size), all in the same color.", "code": "class DotExample(Scene):\n    def construct(self):\n        dot1 = Dot(point=LEFT, radius=0.08)\n        dot2 = Dot(point=ORIGIN)\n        dot3 = Dot(point=RIGHT)\n        self.add(dot1,dot2,dot3)", "code_sha1": "59d0389ea43e2b89527ddf46c12f8654ee764604"}
{"url": "https://docs.manim.community/en/stable/reference/manim.mobject.geometry.arc.Ellipse.html", "depth": 1, "instruction": "Two ellipses are displayed side by side: a blue ellipse (width 2, height 4) on the left and a darker blue ellipse (width 4, height 1) on the right, with a buffer of 1 unit between them.", "code": "from manim import *\n\nclass EllipseExample(Scene):\n    def construct(self):\n        ellipse_1 = Ellipse(width=2.0, height=4.0, color=BLUE_B)\n        ellipse_2 = Ellipse(width=4.0, height=1.0, color=BLUE_D)\n        ellipse_group = Group(ellipse_1,ellipse_2).arrange(buff=1)\n        self.add(ellipse_group)", "code_sha1": "3e12ab11a6df670f771b382edbd3f36ba2ba213a"}
{"url": "https://docs.manim.community/en/stable/reference/manim.mobject.geometry.arc.Ellipse.html", "depth": 1, "instruction": "Two ellipses are displayed side by side: a blue ellipse (width 2, height 4) and a darker blue ellipse (width 4, height 1), with a buffer of 1 unit between them.", "code": "class EllipseExample(Scene):\n    def construct(self):\n        ellipse_1 = Ellipse(width=2.0, height=4.0, color=BLUE_B)\n        ellipse_2 = Ellipse(width=4.0, height=1.0, color=BLUE_D)\n        ellipse_group = Group(ellipse_1,ellipse_2).arrange(buff=1)\n        self.add(ellipse_group)", "code_sha1": "f25cc6bc1969ace0cb8ca623dc82110478440a92"}
{"url": "https://docs.manim.community/en/stable/reference/manim.mobject.geometry.arc.LabeledDot.html", "depth": 1, "instruction": "The scene features a red square at the center, with four labeled dots positioned around it: a red dot labeled \"42\" at the upper left, a green dot labeled \"a\" at the upper right, a blue dot labeled \"ii\" at the lower left, and a default dot labeled \"3\" at the lower right.", "code": "from manim import *\n\nclass SeveralLabeledDots(Scene):\n    def construct(self):\n        sq = Square(fill_color=RED, fill_opacity=1)\n        self.add(sq)\n        dot1 = LabeledDot(Tex(\"42\", color=RED))\n        dot2 = LabeledDot(MathTex(\"a\", color=GREEN))\n        dot3 = LabeledDot(Text(\"ii\", color=BLUE))\n        dot4 = LabeledDot(\"3\")\n        dot1.next_to(sq, UL)\n        dot2.next_to(sq, UR)\n        dot3.next_to(sq, DL)\n        dot4.next_to(sq, DR)\n        self.add(dot1, dot2, dot3, dot4)", "code_sha1": "affcc4975027c1af28e17fe08d160ca7d1cca140"}
{"url": "https://docs.manim.community/en/stable/reference/manim.mobject.geometry.arc.LabeledDot.html", "depth": 1, "instruction": "A red square fills the center of the scene, with four labeled dots positioned around it: a red \"42\" in the upper left, a green \"a\" in the upper right, a blue \"ii\" in the lower left, and a default-colored \"3\" in the lower right, all clearly visible.", "code": "class SeveralLabeledDots(Scene):\n    def construct(self):\n        sq = Square(fill_color=RED, fill_opacity=1)\n        self.add(sq)\n        dot1 = LabeledDot(Tex(\"42\", color=RED))\n        dot2 = LabeledDot(MathTex(\"a\", color=GREEN))\n        dot3 = LabeledDot(Text(\"ii\", color=BLUE))\n        dot4 = LabeledDot(\"3\")\n        dot1.next_to(sq, UL)\n        dot2.next_to(sq, UR)\n        dot3.next_to(sq, DL)\n        dot4.next_to(sq, DR)\n        self.add(dot1, dot2, dot3, dot4)", "code_sha1": "acb66ea62562306a144528dc641cc3772d389f51"}
{"url": "https://docs.manim.community/en/stable/reference/manim.mobject.geometry.arc.Sector.html", "depth": 1, "instruction": "Two sectors are displayed: a red sector with a radius of 2 at the origin and a pink sector with a radius of 2.5 and a 60-degree angle, positioned at (-3, 0, 0).", "code": "from manim import *\n\nclass ExampleSector(Scene):\n    def construct(self):\n        sector = Sector(radius=2)\n        sector2 = Sector(radius=2.5, angle=60*DEGREES).move_to([-3, 0, 0])\n        sector.set_color(RED)\n        sector2.set_color(PINK)\n        self.add(sector, sector2)", "code_sha1": "53ed99a013ac6a6b0e73abc55e2d1d0596a6ff62"}
{"url": "https://docs.manim.community/en/stable/reference/manim.mobject.geometry.arc.Sector.html", "depth": 1, "instruction": "Two sectors are displayed: a red sector with a radius of 2 at the origin and a pink sector with a radius of 2.5 and a 60-degree angle, positioned at (-3, 0, 0). The sectors are static, with no animations or camera operations applied.", "code": "class ExampleSector(Scene):\n    def construct(self):\n        sector = Sector(radius=2)\n        sector2 = Sector(radius=2.5, angle=60*DEGREES).move_to([-3, 0, 0])\n        sector.set_color(RED)\n        sector2.set_color(PINK)\n        self.add(sector, sector2)", "code_sha1": "a1412393f1df199741caadc9aa2098386cec7625"}
{"url": "https://docs.manim.community/en/stable/reference/manim.mobject.geometry.boolean_ops.Difference.html", "depth": 1, "instruction": "The scene displays a red square on the left, a blue circle slightly above it, and a green shape representing their difference on the right. All shapes are filled with solid colors and fully opaque.", "code": "from manim import *\n\nclass DifferenceExample(Scene):\n    def construct(self):\n        sq = Square(color=RED, fill_opacity=1)\n        sq.move_to([-2, 0, 0])\n        cr = Circle(color=BLUE, fill_opacity=1)\n        cr.move_to([-1.3, 0.7, 0])\n        un = Difference(sq, cr, color=GREEN, fill_opacity=1)\n        un.move_to([1.5, 0, 0])\n        self.add(sq, cr, un)", "code_sha1": "e81346f64445898bda55b3a1c2bbd3cd9c973e11"}
{"url": "https://docs.manim.community/en/stable/reference/manim.mobject.geometry.boolean_ops.Difference.html", "depth": 1, "instruction": "Display a red square and a blue circle overlapping slightly, with a green shape representing their difference positioned to the right. The square is filled and opaque, while the circle is also filled and opaque. The square is located at (-2, 0, 0), the circle at (-1.3, 0.7, 0), and the difference shape at (1.5, 0, 0).", "code": "class DifferenceExample(Scene):\n    def construct(self):\n        sq = Square(color=RED, fill_opacity=1)\n        sq.move_to([-2, 0, 0])\n        cr = Circle(color=BLUE, fill_opacity=1)\n        cr.move_to([-1.3, 0.7, 0])\n        un = Difference(sq, cr, color=GREEN, fill_opacity=1)\n        un.move_to([1.5, 0, 0])\n        self.add(sq, cr, un)", "code_sha1": "d915195f3eee50cd12a4657026381b567b595d91"}
{"url": "https://docs.manim.community/en/stable/reference/manim.mobject.geometry.boolean_ops.Exclusion.html", "depth": 1, "instruction": "The scene displays a red square positioned at (-2, 0, 0), a blue circle at (-1.3, 0.7, 0), and a green exclusion shape at (1.5, 0.4, 0), all with full opacity. The square and circle overlap, creating a visual intersection effect.", "code": "from manim import *\n\nclass IntersectionExample(Scene):\n    def construct(self):\n        sq = Square(color=RED, fill_opacity=1)\n        sq.move_to([-2, 0, 0])\n        cr = Circle(color=BLUE, fill_opacity=1)\n        cr.move_to([-1.3, 0.7, 0])\n        un = Exclusion(sq, cr, color=GREEN, fill_opacity=1)\n        un.move_to([1.5, 0.4, 0])\n        self.add(sq, cr, un)", "code_sha1": "574b3689c126aa897852d44895b59e87f5b8876d"}
{"url": "https://docs.manim.community/en/stable/reference/manim.mobject.geometry.boolean_ops.Exclusion.html", "depth": 1, "instruction": "The scene displays a red square positioned at (-2, 0, 0) and a blue circle at (-1.3, 0.7, 0). An exclusion shape, colored green, is placed at (1.5, 0.4, 0), visually representing the intersection of the square and circle. All shapes are fully filled and opaque.", "code": "class IntersectionExample(Scene):\n    def construct(self):\n        sq = Square(color=RED, fill_opacity=1)\n        sq.move_to([-2, 0, 0])\n        cr = Circle(color=BLUE, fill_opacity=1)\n        cr.move_to([-1.3, 0.7, 0])\n        un = Exclusion(sq, cr, color=GREEN, fill_opacity=1)\n        un.move_to([1.5, 0.4, 0])\n        self.add(sq, cr, un)", "code_sha1": "bfebcafd37ea86a19f5a4f5eae1c15fc86a227c7"}
{"url": "https://docs.manim.community/en/stable/reference/manim.mobject.geometry.boolean_ops.Intersection.html", "depth": 1, "instruction": "The scene displays a red square on the left, a blue circle slightly above it, and a green intersection shape on the right. All shapes are filled with their respective colors and fully opaque. The square is positioned at (-2, 0, 0), the circle at (-1.3, 0.7, 0), and the intersection at (1.5, 0, 0).", "code": "from manim import *\n\nclass IntersectionExample(Scene):\n    def construct(self):\n        sq = Square(color=RED, fill_opacity=1)\n        sq.move_to([-2, 0, 0])\n        cr = Circle(color=BLUE, fill_opacity=1)\n        cr.move_to([-1.3, 0.7, 0])\n        un = Intersection(sq, cr, color=GREEN, fill_opacity=1)\n        un.move_to([1.5, 0, 0])\n        self.add(sq, cr, un)", "code_sha1": "14b6b53f1e6a68747f0e3ce442e149ae80d3bc28"}
{"url": "https://docs.manim.community/en/stable/reference/manim.mobject.geometry.boolean_ops.Intersection.html", "depth": 1, "instruction": "The scene displays a red square positioned at (-2, 0, 0), a blue circle at (-1.3, 0.7, 0), and a green intersection shape at (1.5, 0, 0), all with full opacity. The objects are added simultaneously without animations.", "code": "class IntersectionExample(Scene):\n    def construct(self):\n        sq = Square(color=RED, fill_opacity=1)\n        sq.move_to([-2, 0, 0])\n        cr = Circle(color=BLUE, fill_opacity=1)\n        cr.move_to([-1.3, 0.7, 0])\n        un = Intersection(sq, cr, color=GREEN, fill_opacity=1)\n        un.move_to([1.5, 0, 0])\n        self.add(sq, cr, un)", "code_sha1": "14dbbe0285d255513138a585736d5b896e20aae5"}
{"url": "https://docs.manim.community/en/stable/reference/manim.mobject.geometry.boolean_ops.Union.html", "depth": 1, "instruction": "The scene displays a red square and a blue circle, both fully opaque, positioned on the left. A green union shape of the two is displayed on the right, also fully opaque. All objects are added simultaneously without animations.", "code": "from manim import *\n\nclass UnionExample(Scene):\n    def construct(self):\n        sq = Square(color=RED, fill_opacity=1)\n        sq.move_to([-2, 0, 0])\n        cr = Circle(color=BLUE, fill_opacity=1)\n        cr.move_to([-1.3, 0.7, 0])\n        un = Union(sq, cr, color=GREEN, fill_opacity=1)\n        un.move_to([1.5, 0.3, 0])\n        self.add(sq, cr, un)", "code_sha1": "57dd0944454151c0ea6809183c45ae9d9cb574db"}
{"url": "https://docs.manim.community/en/stable/reference/manim.mobject.geometry.boolean_ops.Union.html", "depth": 1, "instruction": "The scene displays a red square and a blue circle, both fully opaque, positioned at specific coordinates. A green union of the two shapes is created and placed at a different location. All three shapes are added to the scene simultaneously.", "code": "class UnionExample(Scene):\n    def construct(self):\n        sq = Square(color=RED, fill_opacity=1)\n        sq.move_to([-2, 0, 0])\n        cr = Circle(color=BLUE, fill_opacity=1)\n        cr.move_to([-1.3, 0.7, 0])\n        un = Union(sq, cr, color=GREEN, fill_opacity=1)\n        un.move_to([1.5, 0.3, 0])\n        self.add(sq, cr, un)", "code_sha1": "bbcf9ee595e5aa799df1bf7c21b522dacfbf6eea"}
{"url": "https://docs.manim.community/en/stable/reference/manim.mobject.geometry.labeled.Label.html", "depth": 1, "instruction": "A blue, semi-transparent label with the text \"Label Text\" in a sans-serif font is displayed, scaled to three times its original size, centered in the scene.", "code": "from manim import *\n\nclass LabelExample(Scene):\n    def construct(self):\n        label = Label(\n            label=Text('Label Text', font='sans-serif'),\n            box_config = {\n                \"color\" : BLUE,\n                \"fill_opacity\" : 0.75\n            }\n        )\n        label.scale(3)\n        self.add(label)", "code_sha1": "58b50cc65ceb799580abdaae9987914e83b60d21"}
{"url": "https://docs.manim.community/en/stable/reference/manim.mobject.geometry.labeled.Label.html", "depth": 1, "instruction": "A blue, semi-transparent label box containing the text \"Label Text\" in a sans-serif font, scaled to three times its original size, is displayed at the center of the scene.", "code": "class LabelExample(Scene):\n    def construct(self):\n        label = Label(\n            label=Text('Label Text', font='sans-serif'),\n            box_config = {\n                \"color\" : BLUE,\n                \"fill_opacity\" : 0.75\n            }\n        )\n        label.scale(3)\n        self.add(label)", "code_sha1": "07aae84d1e1210582e9ef7068f9a571baf6008d7"}
{"url": "https://docs.manim.community/en/stable/reference/manim.mobject.geometry.labeled.LabeledArrow.html", "depth": 1, "instruction": "A labeled arrow extends from the left to the right, positioned slightly above the center, with the label \"0.5\" centered along the arrow's length. The arrow is visually prominent, contrasting against the background.", "code": "from manim import *\n\nclass LabeledArrowExample(Scene):\n    def construct(self):\n        l_arrow = LabeledArrow(\"0.5\", start=LEFT*3, end=RIGHT*3 + UP*2, label_position=0.5)\n\n        self.add(l_arrow)", "code_sha1": "9aa0f15144c2967601b491f9d3fea0777e5e83d2"}
{"url": "https://docs.manim.community/en/stable/reference/manim.mobject.geometry.labeled.LabeledArrow.html", "depth": 1, "instruction": "A labeled arrow extends from the left to the right, positioned 2 units up, with the label \"0.5\" centered along the arrow's length. The arrow is visually prominent, contrasting against the background, and is added to the scene without any animations.", "code": "class LabeledArrowExample(Scene):\n    def construct(self):\n        l_arrow = LabeledArrow(\"0.5\", start=LEFT*3, end=RIGHT*3 + UP*2, label_position=0.5)\n\n        self.add(l_arrow)", "code_sha1": "c6237a103ca4b775796c5f1ec7b8a8318b2a6113"}
{"url": "https://docs.manim.community/en/stable/reference/manim.mobject.geometry.labeled.LabeledLine.html", "depth": 1, "instruction": "A labeled line extends diagonally from the bottom left to the top right, with the label '0.5' positioned near the end. The label is in a font size of 20, and the line's length is doubled, creating a prominent visual effect.", "code": "from manim import *\n\nclass LabeledLineExample(Scene):\n    def construct(self):\n        line = LabeledLine(\n            label          = '0.5',\n            label_position = 0.8,\n            label_config = {\n                \"font_size\" : 20\n            },\n            start=LEFT+DOWN,\n            end=RIGHT+UP)\n\n        line.set_length(line.get_length() * 2)\n        self.add(line)", "code_sha1": "41a4e62053cba0a8d2d6a77aadf090cbbf0c0925"}
{"url": "https://docs.manim.community/en/stable/reference/manim.mobject.geometry.labeled.LabeledLine.html", "depth": 1, "instruction": "A labeled line is displayed diagonally from the bottom left to the top right, with a label \"0.5\" positioned slightly above the line. The line is twice its original length and has a font size of 20 for the label.", "code": "class LabeledLineExample(Scene):\n    def construct(self):\n        line = LabeledLine(\n            label          = '0.5',\n            label_position = 0.8,\n            label_config = {\n                \"font_size\" : 20\n            },\n            start=LEFT+DOWN,\n            end=RIGHT+UP)\n\n        line.set_length(line.get_length() * 2)\n        self.add(line)", "code_sha1": "2262254da1bae9010b78a018e127cc53227c3fc9"}
{"url": "https://docs.manim.community/en/stable/reference/manim.mobject.geometry.labeled.LabeledPolygram.html", "depth": 1, "instruction": "The scene displays three polygons in varying opacities and colors, a labeled polygram with the label \"Pole,\" and a white circle centered on the polygram's pole. All objects are added simultaneously without animations, creating a static composition.", "code": "from manim import *\n\nclass LabeledPolygramExample(Scene):\n    def construct(self):\n        # Define Rings\n        ring1 = [\n            [-3.8, -2.4, 0], [-2.4, -2.5, 0], [-1.3, -1.6, 0], [-0.2, -1.7, 0],\n            [1.7, -2.5, 0], [2.9, -2.6, 0], [3.5, -1.5, 0], [4.9, -1.4, 0],\n            [4.5, 0.2, 0], [4.7, 1.6, 0], [3.5, 2.4, 0], [1.1, 2.5, 0],\n            [-0.1, 0.9, 0], [-1.2, 0.5, 0], [-1.6, 0.7, 0], [-1.4, 1.9, 0],\n            [-2.6, 2.6, 0], [-4.4, 1.2, 0], [-4.9, -0.8, 0], [-3.8, -2.4, 0]\n        ]\n        ring2 = [\n            [0.2, -1.2, 0], [0.9, -1.2, 0], [1.4, -2.0, 0], [2.1, -1.6, 0],\n            [2.2, -0.5, 0], [1.4, 0.0, 0], [0.4, -0.2, 0], [0.2, -1.2, 0]\n        ]\n        ring3 = [[-2.7, 1.4, 0], [-2.3, 1.7, 0], [-2.8, 1.9, 0], [-2.7, 1.4, 0]]\n\n        # Create Polygons (for reference)\n        p1 = Polygon(*ring1, fill_opacity=0.75)\n        p2 = Polygon(*ring2, fill_color=BLACK, fill_opacity=1)\n        p3 = Polygon(*ring3, fill_color=BLACK, fill_opacity=1)\n\n        # Create Labeled Polygram\n        polygram = LabeledPolygram(\n            *[ring1, ring2, ring3],\n            label=Text('Pole', font='sans-serif'),\n            precision=0.01,\n        )\n\n        # Display Circle (for reference)\n        circle = Circle(radius=polygram.radius, color=WHITE).move_to(polygram.pole)\n\n        self.add(p1, p2, p3)\n        self.add(polygram)\n        self.add(circle)", "code_sha1": "9f5ac3243646f3d15864889f18904cecfed37d75"}
{"url": "https://docs.manim.community/en/stable/reference/manim.mobject.geometry.labeled.LabeledPolygram.html", "depth": 1, "instruction": "The scene displays a blue, semi-transparent LabeledPolygram representing the USA, overlaid on a coordinate Axes system. A white circle, matching the polygram's radius, is centered at its pole. The Axes are visible, and all elements are statically positioned without animations.", "code": "from manim import *\n\nimport requests\nimport json\n\nclass LabeledCountryExample(Scene):\n    def construct(self):\n        # Fetch JSON data and process arcs\n        data = requests.get('https://cdn.jsdelivr.net/npm/us-atlas@3/nation-10m.json').json()\n        arcs, transform = data['arcs'], data['transform']\n        sarcs = [np.cumsum(arc, axis=0) * transform['scale'] + transform['translate'] for arc in arcs]\n        ssarcs = sorted(sarcs, key=len, reverse=True)[:1]\n\n        # Compute Bounding Box\n        points = np.concatenate(ssarcs)\n        mins, maxs = np.min(points, axis=0), np.max(points, axis=0)\n\n        # Build Axes\n        ax = Axes(\n            x_range=[mins[0], maxs[0], maxs[0] - mins[0]], x_length=10,\n            y_range=[mins[1], maxs[1], maxs[1] - mins[1]], y_length=7,\n            tips=False\n        )\n\n        # Adjust Coordinates\n        array = [[ax.c2p(*point) for point in sarc] for sarc in ssarcs]\n\n        # Add Polygram\n        polygram = LabeledPolygram(\n            *array,\n            label=Text('USA', font='sans-serif'),\n            precision=0.01,\n            fill_color=BLUE,\n            stroke_width=0,\n            fill_opacity=0.75\n        )\n\n        # Display Circle (for reference)\n        circle = Circle(radius=polygram.radius, color=WHITE).move_to(polygram.pole)\n\n        self.add(ax)\n        self.add(polygram)\n        self.add(circle)", "code_sha1": "0ccf0c0ad9473c54ebd695a7b78c17e4da8c7445"}
{"url": "https://docs.manim.community/en/stable/reference/manim.mobject.geometry.labeled.LabeledPolygram.html", "depth": 1, "instruction": "The scene displays three polygons in varying opacities and colors, a labeled polygram with the label \"Pole,\" and a white circle centered on the polygram's pole. All elements are added simultaneously without animations, creating a static visual composition.", "code": "class LabeledPolygramExample(Scene):\n    def construct(self):\n        # Define Rings\n        ring1 = [\n            [-3.8, -2.4, 0], [-2.4, -2.5, 0], [-1.3, -1.6, 0], [-0.2, -1.7, 0],\n            [1.7, -2.5, 0], [2.9, -2.6, 0], [3.5, -1.5, 0], [4.9, -1.4, 0],\n            [4.5, 0.2, 0], [4.7, 1.6, 0], [3.5, 2.4, 0], [1.1, 2.5, 0],\n            [-0.1, 0.9, 0], [-1.2, 0.5, 0], [-1.6, 0.7, 0], [-1.4, 1.9, 0],\n            [-2.6, 2.6, 0], [-4.4, 1.2, 0], [-4.9, -0.8, 0], [-3.8, -2.4, 0]\n        ]\n        ring2 = [\n            [0.2, -1.2, 0], [0.9, -1.2, 0], [1.4, -2.0, 0], [2.1, -1.6, 0],\n            [2.2, -0.5, 0], [1.4, 0.0, 0], [0.4, -0.2, 0], [0.2, -1.2, 0]\n        ]\n        ring3 = [[-2.7, 1.4, 0], [-2.3, 1.7, 0], [-2.8, 1.9, 0], [-2.7, 1.4, 0]]\n\n        # Create Polygons (for reference)\n        p1 = Polygon(*ring1, fill_opacity=0.75)\n        p2 = Polygon(*ring2, fill_color=BLACK, fill_opacity=1)\n        p3 = Polygon(*ring3, fill_color=BLACK, fill_opacity=1)\n\n        # Create Labeled Polygram\n        polygram = LabeledPolygram(\n            *[ring1, ring2, ring3],\n            label=Text('Pole', font='sans-serif'),\n            precision=0.01,\n        )\n\n        # Display Circle (for reference)\n        circle = Circle(radius=polygram.radius, color=WHITE).move_to(polygram.pole)\n\n        self.add(p1, p2, p3)\n        self.add(polygram)\n        self.add(circle)", "code_sha1": "2825db336059adced2cca2727c280155337f340e"}
{"url": "https://docs.manim.community/en/stable/reference/manim.mobject.geometry.labeled.LabeledPolygram.html", "depth": 1, "instruction": "The scene displays a blue, semi-transparent polygon labeled \"USA\" overlaid on a coordinate axes system, with a white circle centered at the polygon's pole. The polygon is derived from geographic data, and the axes are scaled to fit the bounding box of the polygon.", "code": "import requests\nimport json\n\nclass LabeledCountryExample(Scene):\n    def construct(self):\n        # Fetch JSON data and process arcs\n        data = requests.get('https://cdn.jsdelivr.net/npm/us-atlas@3/nation-10m.json').json()\n        arcs, transform = data['arcs'], data['transform']\n        sarcs = [np.cumsum(arc, axis=0) * transform['scale'] + transform['translate'] for arc in arcs]\n        ssarcs = sorted(sarcs, key=len, reverse=True)[:1]\n\n        # Compute Bounding Box\n        points = np.concatenate(ssarcs)\n        mins, maxs = np.min(points, axis=0), np.max(points, axis=0)\n\n        # Build Axes\n        ax = Axes(\n            x_range=[mins[0], maxs[0], maxs[0] - mins[0]], x_length=10,\n            y_range=[mins[1], maxs[1], maxs[1] - mins[1]], y_length=7,\n            tips=False\n        )\n\n        # Adjust Coordinates\n        array = [[ax.c2p(*point) for point in sarc] for sarc in ssarcs]\n\n        # Add Polygram\n        polygram = LabeledPolygram(\n            *array,\n            label=Text('USA', font='sans-serif'),\n            precision=0.01,\n            fill_color=BLUE,\n            stroke_width=0,\n            fill_opacity=0.75\n        )\n\n        # Display Circle (for reference)\n        circle = Circle(radius=polygram.radius, color=WHITE).move_to(polygram.pole)\n\n        self.add(ax)\n        self.add(polygram)\n        self.add(circle)", "code_sha1": "3b7ada26e6d7664bf31fbf06104a16a313e0ca8d"}
{"url": "https://docs.manim.community/en/stable/reference/manim.mobject.geometry.line.Angle.html", "depth": 1, "instruction": "The scene displays four right-angle arcs formed by two intersecting lines, each with varying properties: the first is standard, the second has a smaller radius and a yellow dot, the third features a thicker stroke and a green dot, and the fourth is red with a larger green dot. The angles are arranged horizontally with equal spacing.", "code": "from manim import *\n\nclass RightArcAngleExample(Scene):\n    def construct(self):\n        line1 = Line( LEFT, RIGHT )\n        line2 = Line( DOWN, UP )\n        rightarcangles = [\n            Angle(line1, line2, dot=True),\n            Angle(line1, line2, radius=0.4, quadrant=(1,-1), dot=True, other_angle=True),\n            Angle(line1, line2, radius=0.5, quadrant=(-1,1), stroke_width=8, dot=True, dot_color=YELLOW, dot_radius=0.04, other_angle=True),\n            Angle(line1, line2, radius=0.7, quadrant=(-1,-1), color=RED, dot=True, dot_color=GREEN, dot_radius=0.08),\n        ]\n        plots = VGroup()\n        for angle in rightarcangles:\n            plot=VGroup(line1.copy(),line2.copy(), angle)\n            plots.add(plot)\n        plots.arrange(buff=1.5)\n        self.add(plots)", "code_sha1": "d37c555f1af23150d0254331bddc0b3cf9c2c87e"}
{"url": "https://docs.manim.community/en/stable/reference/manim.mobject.geometry.line.Angle.html", "depth": 1, "instruction": "The scene displays a grid of eight angles formed by two intersecting lines, each surrounded by a rectangle. Angles vary in radius, stroke width, and color (some in red), with some showing the other angle. The layout is organized in two rows with a uniform buffer between plots.", "code": "from manim import *\n\nclass AngleExample(Scene):\n    def construct(self):\n        line1 = Line( LEFT + (1/3) * UP, RIGHT + (1/3) * DOWN )\n        line2 = Line( DOWN + (1/3) * RIGHT, UP + (1/3) * LEFT )\n        angles = [\n            Angle(line1, line2),\n            Angle(line1, line2, radius=0.4, quadrant=(1,-1), other_angle=True),\n            Angle(line1, line2, radius=0.5, quadrant=(-1,1), stroke_width=8, other_angle=True),\n            Angle(line1, line2, radius=0.7, quadrant=(-1,-1), color=RED),\n            Angle(line1, line2, other_angle=True),\n            Angle(line1, line2, radius=0.4, quadrant=(1,-1)),\n            Angle(line1, line2, radius=0.5, quadrant=(-1,1), stroke_width=8),\n            Angle(line1, line2, radius=0.7, quadrant=(-1,-1), color=RED, other_angle=True),\n        ]\n        plots = VGroup()\n        for angle in angles:\n            plot=VGroup(line1.copy(),line2.copy(), angle)\n            plots.add(VGroup(plot,SurroundingRectangle(plot, buff=0.3)))\n        plots.arrange_in_grid(rows=2,buff=1)\n        self.add(plots)", "code_sha1": "fb843a8daad19766c856ad6739bd56bf959b9293"}
{"url": "https://docs.manim.community/en/stable/reference/manim.mobject.geometry.line.Angle.html", "depth": 1, "instruction": "The scene displays two green lines forming an angle, with an orange-filled area representing the angle between them. The angle is highlighted in green, and the filled area has full opacity. The lines are positioned at the origin, with one rotated slightly, creating a visually distinct angle.", "code": "from manim import *\n\nclass FilledAngle(Scene):\n    def construct(self):\n        l1 = Line(ORIGIN, 2 * UP + RIGHT).set_color(GREEN)\n        l2 = (\n            Line(ORIGIN, 2 * UP + RIGHT)\n            .set_color(GREEN)\n            .rotate(-20 * DEGREES, about_point=ORIGIN)\n        )\n        norm = l1.get_length()\n        a1 = Angle(l1, l2, other_angle=True, radius=norm - 0.5).set_color(GREEN)\n        a2 = Angle(l1, l2, other_angle=True, radius=norm).set_color(GREEN)\n        q1 = a1.points #  save all coordinates of points of angle a1\n        q2 = a2.reverse_direction().points  #  save all coordinates of points of angle a1 (in reversed direction)\n        pnts = np.concatenate([q1, q2, q1[0].reshape(1, 3)])  # adds points and ensures that path starts and ends at same point\n        mfill = VMobject().set_color(ORANGE)\n        mfill.set_points_as_corners(pnts).set_fill(GREEN, opacity=1)\n        self.add(l1, l2)\n        self.add(mfill)", "code_sha1": "d3cef8a8807f81caf318f5f5d6e8c94feeea461c"}
{"url": "https://docs.manim.community/en/stable/reference/manim.mobject.geometry.line.Angle.html", "depth": 1, "instruction": "The scene displays two angles: a default angle in white from points UP, ORIGIN, and LEFT, and a larger red angle from points LEFT+UP, ORIGIN, and RIGHT, with a stroke width of 8. Both angles are positioned prominently, showcasing their distinct colors and sizes.", "code": "from manim import *\n\nclass AngleFromThreePointsExample(Scene):\n    def construct(self):\n        sample_angle = Angle.from_three_points(UP, ORIGIN, LEFT)\n        red_angle = Angle.from_three_points(LEFT + UP, ORIGIN, RIGHT, radius=.8, quadrant=(-1,-1), color=RED, stroke_width=8, other_angle=True)\n        self.add(red_angle, sample_angle)", "code_sha1": "8b7e053f4ed969590852194197fd1c9ac82e41dd"}
{"url": "https://docs.manim.community/en/stable/reference/manim.mobject.geometry.line.Angle.html", "depth": 1, "instruction": "The scene displays two intersecting lines forming an angle, with the angle visually represented by a curved arc. A decimal number indicating the angle's value in degrees is positioned above the angle, all elements are added simultaneously without animations. The lines are colored in default colors, and the angle arc has a radius of 0.4.", "code": "from manim import *\n\nclass GetValueExample(Scene):\n    def construct(self):\n        line1 = Line(LEFT+(1/3)*UP, RIGHT+(1/3)*DOWN)\n        line2 = Line(DOWN+(1/3)*RIGHT, UP+(1/3)*LEFT)\n\n        angle = Angle(line1, line2, radius=0.4)\n\n        value = DecimalNumber(angle.get_value(degrees=True), unit=r\"^{\\circ}\")\n        value.next_to(angle, UR)\n\n        self.add(line1, line2, angle, value)", "code_sha1": "9e7589faa9ee2a00ef75de94dd586b5040b506b9"}
{"url": "https://docs.manim.community/en/stable/reference/manim.mobject.geometry.line.Angle.html", "depth": 1, "instruction": "The scene displays four right angles formed by two intersecting lines, each with a dot at the vertex. The angles vary in radius, stroke width, and color: the last angle is red with a green dot. The angles are arranged horizontally with 1.5 units of space between them.", "code": "class RightArcAngleExample(Scene):\n    def construct(self):\n        line1 = Line( LEFT, RIGHT )\n        line2 = Line( DOWN, UP )\n        rightarcangles = [\n            Angle(line1, line2, dot=True),\n            Angle(line1, line2, radius=0.4, quadrant=(1,-1), dot=True, other_angle=True),\n            Angle(line1, line2, radius=0.5, quadrant=(-1,1), stroke_width=8, dot=True, dot_color=YELLOW, dot_radius=0.04, other_angle=True),\n            Angle(line1, line2, radius=0.7, quadrant=(-1,-1), color=RED, dot=True, dot_color=GREEN, dot_radius=0.08),\n        ]\n        plots = VGroup()\n        for angle in rightarcangles:\n            plot=VGroup(line1.copy(),line2.copy(), angle)\n            plots.add(plot)\n        plots.arrange(buff=1.5)\n        self.add(plots)", "code_sha1": "166381474177c47f7c74fc0a99131a7f1b1e0f58"}
{"url": "https://docs.manim.community/en/stable/reference/manim.mobject.geometry.line.Angle.html", "depth": 1, "instruction": "The scene displays eight angles formed by two intersecting lines, arranged in a grid. Each angle has varying properties such as radius, color (some in red), and stroke width. Surrounding rectangles highlight each angle plot, creating a visually organized layout with clear distinctions between the angles.", "code": "class AngleExample(Scene):\n    def construct(self):\n        line1 = Line( LEFT + (1/3) * UP, RIGHT + (1/3) * DOWN )\n        line2 = Line( DOWN + (1/3) * RIGHT, UP + (1/3) * LEFT )\n        angles = [\n            Angle(line1, line2),\n            Angle(line1, line2, radius=0.4, quadrant=(1,-1), other_angle=True),\n            Angle(line1, line2, radius=0.5, quadrant=(-1,1), stroke_width=8, other_angle=True),\n            Angle(line1, line2, radius=0.7, quadrant=(-1,-1), color=RED),\n            Angle(line1, line2, other_angle=True),\n            Angle(line1, line2, radius=0.4, quadrant=(1,-1)),\n            Angle(line1, line2, radius=0.5, quadrant=(-1,1), stroke_width=8),\n            Angle(line1, line2, radius=0.7, quadrant=(-1,-1), color=RED, other_angle=True),\n        ]\n        plots = VGroup()\n        for angle in angles:\n            plot=VGroup(line1.copy(),line2.copy(), angle)\n            plots.add(VGroup(plot,SurroundingRectangle(plot, buff=0.3)))\n        plots.arrange_in_grid(rows=2,buff=1)\n        self.add(plots)", "code_sha1": "86221e12b05db45bd20857739c4fb0ad0bb6c618"}
{"url": "https://docs.manim.community/en/stable/reference/manim.mobject.geometry.line.Angle.html", "depth": 1, "instruction": "The scene displays two green lines forming an angle, with an orange-filled area representing the angle between them. The angle is highlighted in green, and the filled area has full opacity. The lines are positioned at the origin, with one rotated slightly, creating a visually distinct angle.", "code": "class FilledAngle(Scene):\n    def construct(self):\n        l1 = Line(ORIGIN, 2 * UP + RIGHT).set_color(GREEN)\n        l2 = (\n            Line(ORIGIN, 2 * UP + RIGHT)\n            .set_color(GREEN)\n            .rotate(-20 * DEGREES, about_point=ORIGIN)\n        )\n        norm = l1.get_length()\n        a1 = Angle(l1, l2, other_angle=True, radius=norm - 0.5).set_color(GREEN)\n        a2 = Angle(l1, l2, other_angle=True, radius=norm).set_color(GREEN)\n        q1 = a1.points #  save all coordinates of points of angle a1\n        q2 = a2.reverse_direction().points  #  save all coordinates of points of angle a1 (in reversed direction)\n        pnts = np.concatenate([q1, q2, q1[0].reshape(1, 3)])  # adds points and ensures that path starts and ends at same point\n        mfill = VMobject().set_color(ORANGE)\n        mfill.set_points_as_corners(pnts).set_fill(GREEN, opacity=1)\n        self.add(l1, l2)\n        self.add(mfill)", "code_sha1": "ff34fc4e6df769428db50bd6167bf1219c611ab6"}
{"url": "https://docs.manim.community/en/stable/reference/manim.mobject.geometry.line.Angle.html", "depth": 1, "instruction": "The scene displays two angles: a default angle in white from points UP, ORIGIN, and LEFT, and a larger red angle with a stroke width of 8 from points LEFT + UP, ORIGIN, and RIGHT, positioned in the third quadrant. Both angles are added to the scene simultaneously.", "code": "class AngleFromThreePointsExample(Scene):\n    def construct(self):\n        sample_angle = Angle.from_three_points(UP, ORIGIN, LEFT)\n        red_angle = Angle.from_three_points(LEFT + UP, ORIGIN, RIGHT, radius=.8, quadrant=(-1,-1), color=RED, stroke_width=8, other_angle=True)\n        self.add(red_angle, sample_angle)", "code_sha1": "889ce567b4808c5f2c729efe0b2789508a13197f"}
{"url": "https://docs.manim.community/en/stable/reference/manim.mobject.geometry.line.Angle.html", "depth": 1, "instruction": "The scene displays two intersecting lines forming an angle, with the angle visually represented by an arc. A decimal number indicating the angle's value in degrees is positioned above the angle, all elements are added to the scene simultaneously without animations.", "code": "class GetValueExample(Scene):\n    def construct(self):\n        line1 = Line(LEFT+(1/3)*UP, RIGHT+(1/3)*DOWN)\n        line2 = Line(DOWN+(1/3)*RIGHT, UP+(1/3)*LEFT)\n\n        angle = Angle(line1, line2, radius=0.4)\n\n        value = DecimalNumber(angle.get_value(degrees=True), unit=r\"^{\\circ}\")\n        value.next_to(angle, UR)\n\n        self.add(line1, line2, angle, value)", "code_sha1": "7aa0a629cb4e73d86fedab50ea0604aa146318c3"}
{"url": "https://docs.manim.community/en/stable/reference/manim.mobject.geometry.line.Arrow.html", "depth": 1, "instruction": "The scene displays three groups of arrows arranged horizontally with a maroon square. The first group features two gold arrows (one with a square tip) positioned vertically. The second group includes a maroon square and two horizontal arrows, one with no buffer. The third group consists of two shorter arrows, all with distinct lengths and orientations.", "code": "from manim import *\n\nfrom manim.mobject.geometry.tips import ArrowSquareTip\nclass ArrowExample(Scene):\n    def construct(self):\n        arrow_1 = Arrow(start=RIGHT, end=LEFT, color=GOLD)\n        arrow_2 = Arrow(start=RIGHT, end=LEFT, color=GOLD, tip_shape=ArrowSquareTip).shift(DOWN)\n        g1 = Group(arrow_1, arrow_2)\n\n        # the effect of buff\n        square = Square(color=MAROON_A)\n        arrow_3 = Arrow(start=LEFT, end=RIGHT)\n        arrow_4 = Arrow(start=LEFT, end=RIGHT, buff=0).next_to(arrow_1, UP)\n        g2 = Group(arrow_3, arrow_4, square)\n\n        # a shorter arrow has a shorter tip and smaller stroke width\n        arrow_5 = Arrow(start=ORIGIN, end=config.top).shift(LEFT * 4)\n        arrow_6 = Arrow(start=config.top + DOWN, end=config.top).shift(LEFT * 3)\n        g3 = Group(arrow_5, arrow_6)\n\n        self.add(Group(g1, g2, g3).arrange(buff=2))", "code_sha1": "db51bfea51b7a168b8f36d0bf50880093f18263c"}
{"url": "https://docs.manim.community/en/stable/reference/manim.mobject.geometry.line.Arrow.html", "depth": 1, "instruction": "The scene displays four vertical groups of arrows: the left group features decreasing sizes with increasing buff, the middle group shows increasing stroke widths, the upper right group has increasing tip lengths, and the lower right group showcases various colors and tip shapes. All groups are positioned at specific locations in the scene.", "code": "from manim import *\n\nclass ArrowExample(Scene):\n    def construct(self):\n        left_group = VGroup()\n        # As buff increases, the size of the arrow decreases.\n        for buff in np.arange(0, 2.2, 0.45):\n            left_group += Arrow(buff=buff, start=2 * LEFT, end=2 * RIGHT)\n        # Required to arrange arrows.\n        left_group.arrange(DOWN)\n        left_group.move_to(4 * LEFT)\n\n        middle_group = VGroup()\n        # As max_stroke_width_to_length_ratio gets bigger,\n        # the width of stroke increases.\n        for i in np.arange(0, 5, 0.5):\n            middle_group += Arrow(max_stroke_width_to_length_ratio=i)\n        middle_group.arrange(DOWN)\n\n        UR_group = VGroup()\n        # As max_tip_length_to_length_ratio increases,\n        # the length of the tip increases.\n        for i in np.arange(0, 0.3, 0.1):\n            UR_group += Arrow(max_tip_length_to_length_ratio=i)\n        UR_group.arrange(DOWN)\n        UR_group.move_to(4 * RIGHT + 2 * UP)\n\n        DR_group = VGroup()\n        DR_group += Arrow(start=LEFT, end=RIGHT, color=BLUE, tip_shape=ArrowSquareTip)\n        DR_group += Arrow(start=LEFT, end=RIGHT, color=BLUE, tip_shape=ArrowSquareFilledTip)\n        DR_group += Arrow(start=LEFT, end=RIGHT, color=YELLOW, tip_shape=ArrowCircleTip)\n        DR_group += Arrow(start=LEFT, end=RIGHT, color=YELLOW, tip_shape=ArrowCircleFilledTip)\n        DR_group.arrange(DOWN)\n        DR_group.move_to(4 * RIGHT + 2 * DOWN)\n\n        self.add(left_group, middle_group, UR_group, DR_group)", "code_sha1": "a3ff106627cf176de98ffee59f73fd8af43b5f5a"}
{"url": "https://docs.manim.community/en/stable/reference/manim.mobject.geometry.line.Arrow.html", "depth": 1, "instruction": "The scene displays three groups of arrows arranged horizontally with a maroon square. The first group features two gold arrows, one with a square tip. The second group includes a maroon square and two arrows, one with no buffer. The third group contains two shorter arrows. All elements are spaced evenly with a buffer of 2.", "code": "from manim.mobject.geometry.tips import ArrowSquareTip\nclass ArrowExample(Scene):\n    def construct(self):\n        arrow_1 = Arrow(start=RIGHT, end=LEFT, color=GOLD)\n        arrow_2 = Arrow(start=RIGHT, end=LEFT, color=GOLD, tip_shape=ArrowSquareTip).shift(DOWN)\n        g1 = Group(arrow_1, arrow_2)\n\n        # the effect of buff\n        square = Square(color=MAROON_A)\n        arrow_3 = Arrow(start=LEFT, end=RIGHT)\n        arrow_4 = Arrow(start=LEFT, end=RIGHT, buff=0).next_to(arrow_1, UP)\n        g2 = Group(arrow_3, arrow_4, square)\n\n        # a shorter arrow has a shorter tip and smaller stroke width\n        arrow_5 = Arrow(start=ORIGIN, end=config.top).shift(LEFT * 4)\n        arrow_6 = Arrow(start=config.top + DOWN, end=config.top).shift(LEFT * 3)\n        g3 = Group(arrow_5, arrow_6)\n\n        self.add(Group(g1, g2, g3).arrange(buff=2))", "code_sha1": "93e27fc1113687252004c5c0ff18359863d62595"}
{"url": "https://docs.manim.community/en/stable/reference/manim.mobject.geometry.line.Arrow.html", "depth": 1, "instruction": "The scene displays four groups of arrows: the left group features decreasing sizes, the middle group shows increasing stroke widths, the upper right group has increasing tip lengths, and the lower right group showcases various colors and tip shapes. All groups are arranged vertically and positioned at specific locations in the scene.", "code": "class ArrowExample(Scene):\n    def construct(self):\n        left_group = VGroup()\n        # As buff increases, the size of the arrow decreases.\n        for buff in np.arange(0, 2.2, 0.45):\n            left_group += Arrow(buff=buff, start=2 * LEFT, end=2 * RIGHT)\n        # Required to arrange arrows.\n        left_group.arrange(DOWN)\n        left_group.move_to(4 * LEFT)\n\n        middle_group = VGroup()\n        # As max_stroke_width_to_length_ratio gets bigger,\n        # the width of stroke increases.\n        for i in np.arange(0, 5, 0.5):\n            middle_group += Arrow(max_stroke_width_to_length_ratio=i)\n        middle_group.arrange(DOWN)\n\n        UR_group = VGroup()\n        # As max_tip_length_to_length_ratio increases,\n        # the length of the tip increases.\n        for i in np.arange(0, 0.3, 0.1):\n            UR_group += Arrow(max_tip_length_to_length_ratio=i)\n        UR_group.arrange(DOWN)\n        UR_group.move_to(4 * RIGHT + 2 * UP)\n\n        DR_group = VGroup()\n        DR_group += Arrow(start=LEFT, end=RIGHT, color=BLUE, tip_shape=ArrowSquareTip)\n        DR_group += Arrow(start=LEFT, end=RIGHT, color=BLUE, tip_shape=ArrowSquareFilledTip)\n        DR_group += Arrow(start=LEFT, end=RIGHT, color=YELLOW, tip_shape=ArrowCircleTip)\n        DR_group += Arrow(start=LEFT, end=RIGHT, color=YELLOW, tip_shape=ArrowCircleFilledTip)\n        DR_group.arrange(DOWN)\n        DR_group.move_to(4 * RIGHT + 2 * DOWN)\n\n        self.add(left_group, middle_group, UR_group, DR_group)", "code_sha1": "5734a9d166e54072c99ed724ba697f3b2b3e96f4"}
{"url": "https://docs.manim.community/en/stable/reference/manim.mobject.geometry.line.DashedLine.html", "depth": 1, "instruction": "Three horizontal dashed lines are displayed: the first, with long dashes, is positioned 2 units above the center; the second has standard dashes at the center; the third, with short dashes, is positioned 2 units below the center. All lines are added simultaneously without animations.", "code": "from manim import *\n\nclass DashedLineExample(Scene):\n    def construct(self):\n        # dash_length increased\n        dashed_1 = DashedLine(config.left_side, config.right_side, dash_length=2.0).shift(UP*2)\n        # normal\n        dashed_2 = DashedLine(config.left_side, config.right_side)\n        # dashed_ratio decreased\n        dashed_3 = DashedLine(config.left_side, config.right_side, dashed_ratio=0.1).shift(DOWN*2)\n        self.add(dashed_1, dashed_2, dashed_3)", "code_sha1": "4a601a34a84b30832de1b92df21646928236910d"}
{"url": "https://docs.manim.community/en/stable/reference/manim.mobject.geometry.line.DashedLine.html", "depth": 1, "instruction": "Three horizontal dashed lines are displayed: the first, with long dashes, is positioned 2 units above the center; the second has standard dashes at the center; the third, with short dashes, is positioned 2 units below the center. All lines are aligned and evenly spaced vertically.", "code": "class DashedLineExample(Scene):\n    def construct(self):\n        # dash_length increased\n        dashed_1 = DashedLine(config.left_side, config.right_side, dash_length=2.0).shift(UP*2)\n        # normal\n        dashed_2 = DashedLine(config.left_side, config.right_side)\n        # dashed_ratio decreased\n        dashed_3 = DashedLine(config.left_side, config.right_side, dashed_ratio=0.1).shift(DOWN*2)\n        self.add(dashed_1, dashed_2, dashed_3)", "code_sha1": "2dad2629d77f74a3a6bec7b6aa869af435819f59"}
{"url": "https://docs.manim.community/en/stable/reference/manim.mobject.geometry.line.DoubleArrow.html", "depth": 1, "instruction": "The scene displays a circle with a radius of 2.0, flanked by a horizontal double arrow and another double arrow with filled circular tips, arranged vertically with a buffer of 1 unit between them.", "code": "from manim import *\n\nfrom manim.mobject.geometry.tips import ArrowCircleFilledTip\nclass DoubleArrowExample(Scene):\n    def construct(self):\n        circle = Circle(radius=2.0)\n        d_arrow = DoubleArrow(start=circle.get_left(), end=circle.get_right())\n        d_arrow_2 = DoubleArrow(tip_shape_end=ArrowCircleFilledTip, tip_shape_start=ArrowCircleFilledTip)\n        group = Group(Group(circle, d_arrow), d_arrow_2).arrange(UP, buff=1)\n        self.add(group)", "code_sha1": "d5e5088a1fe4ff0a8222d58cc5f3637a40fd0cc0"}
{"url": "https://docs.manim.community/en/stable/reference/manim.mobject.geometry.line.DoubleArrow.html", "depth": 1, "instruction": "The scene features a square box with three vertically arranged double arrows pointing right: a default arrow, a yellow arrow with a shorter tip, and a blue arrow with a longer tip. The arrows are closely spaced with no buffer, emphasizing their alignment and color differences.", "code": "from manim import *\n\nclass DoubleArrowExample2(Scene):\n    def construct(self):\n        box = Square()\n        p1 = box.get_left()\n        p2 = box.get_right()\n        d1 = DoubleArrow(p1, p2, buff=0)\n        d2 = DoubleArrow(p1, p2, buff=0, tip_length=0.2, color=YELLOW)\n        d3 = DoubleArrow(p1, p2, buff=0, tip_length=0.4, color=BLUE)\n        Group(d1, d2, d3).arrange(DOWN)\n        self.add(box, d1, d2, d3)", "code_sha1": "35a2e0f1576e4a35dedfbc88e6f454f784c9bf0e"}
{"url": "https://docs.manim.community/en/stable/reference/manim.mobject.geometry.line.DoubleArrow.html", "depth": 1, "instruction": "The scene displays a circle with a radius of 2.0, flanked by two double arrows: one extending horizontally across the circle, and another with filled circular tips at both ends, arranged vertically with a buffer of 1 unit.", "code": "from manim.mobject.geometry.tips import ArrowCircleFilledTip\nclass DoubleArrowExample(Scene):\n    def construct(self):\n        circle = Circle(radius=2.0)\n        d_arrow = DoubleArrow(start=circle.get_left(), end=circle.get_right())\n        d_arrow_2 = DoubleArrow(tip_shape_end=ArrowCircleFilledTip, tip_shape_start=ArrowCircleFilledTip)\n        group = Group(Group(circle, d_arrow), d_arrow_2).arrange(UP, buff=1)\n        self.add(group)", "code_sha1": "68becadb561c84d3a78a4a5d4b27f3d154076875"}
{"url": "https://docs.manim.community/en/stable/reference/manim.mobject.geometry.line.DoubleArrow.html", "depth": 1, "instruction": "The scene displays a square with three vertically arranged double arrows pointing right: a default arrow (black), a yellow arrow with a shorter tip (0.2), and a blue arrow with a longer tip (0.4). All arrows are aligned with no buffer space between them.", "code": "class DoubleArrowExample2(Scene):\n    def construct(self):\n        box = Square()\n        p1 = box.get_left()\n        p2 = box.get_right()\n        d1 = DoubleArrow(p1, p2, buff=0)\n        d2 = DoubleArrow(p1, p2, buff=0, tip_length=0.2, color=YELLOW)\n        d3 = DoubleArrow(p1, p2, buff=0, tip_length=0.4, color=BLUE)\n        Group(d1, d2, d3).arrange(DOWN)\n        self.add(box, d1, d2, d3)", "code_sha1": "dfb6afb061ea078a5bbc065e9d5e1364bc434a53"}
{"url": "https://docs.manim.community/en/stable/reference/manim.mobject.geometry.line.Elbow.html", "depth": 1, "instruction": "Three elbow shapes are arranged horizontally with a buffer of 1 unit between them: the first is default size, the second is twice as wide, and the third has a 5π/4 angle. All elbows are displayed in a single group.", "code": "from manim import *\n\nclass ElbowExample(Scene):\n    def construct(self):\n        elbow_1 = Elbow()\n        elbow_2 = Elbow(width=2.0)\n        elbow_3 = Elbow(width=2.0, angle=5*PI/4)\n\n        elbow_group = Group(elbow_1, elbow_2, elbow_3).arrange(buff=1)\n        self.add(elbow_group)", "code_sha1": "ce37205d28ae3b40dc11bc1df071f3e523092ef0"}
{"url": "https://docs.manim.community/en/stable/reference/manim.mobject.geometry.line.Elbow.html", "depth": 1, "instruction": "Three elbow shapes are displayed side by side, with the first being the default size, the second twice as wide, and the third at a 5π/4 angle. They are arranged with a buffer of 1 unit between them, all in a single group on the scene.", "code": "class ElbowExample(Scene):\n    def construct(self):\n        elbow_1 = Elbow()\n        elbow_2 = Elbow(width=2.0)\n        elbow_3 = Elbow(width=2.0, angle=5*PI/4)\n\n        elbow_group = Group(elbow_1, elbow_2, elbow_3).arrange(buff=1)\n        self.add(elbow_group)", "code_sha1": "9ccb07b8816e206643e78037d63fdf8553a36e16"}
{"url": "https://docs.manim.community/en/stable/reference/manim.mobject.geometry.line.Line.html", "depth": 1, "instruction": "A grid of 10 evenly spaced dots appears, followed by a line connecting the first two dots. The line then animates to connect the second and third dots, pauses, and finally moves to connect the fifth and eighth dots, with each transition separated by a brief pause.", "code": "from manim import *\n\nclass LineExample(Scene):\n    def construct(self):\n        d = VGroup()\n        for i in range(0,10):\n            d.add(Dot())\n        d.arrange_in_grid(buff=1)\n        self.add(d)\n        l= Line(d[0], d[1])\n        self.add(l)\n        self.wait()\n        l.put_start_and_end_on(d[1].get_center(), d[2].get_center())\n        self.wait()\n        l.put_start_and_end_on(d[4].get_center(), d[7].get_center())\n        self.wait()", "code_sha1": "810aee1ffa0a981fb70909aa837503dbc510dadc"}
{"url": "https://docs.manim.community/en/stable/reference/manim.mobject.geometry.line.Line.html", "depth": 1, "instruction": "A grid of 10 dots is displayed, with a line initially connecting the first two dots. The line's endpoints animate to connect the second and third dots, then to connect the fifth and eighth dots, with pauses in between each movement.", "code": "class LineExample(Scene):\n    def construct(self):\n        d = VGroup()\n        for i in range(0,10):\n            d.add(Dot())\n        d.arrange_in_grid(buff=1)\n        self.add(d)\n        l= Line(d[0], d[1])\n        self.add(l)\n        self.wait()\n        l.put_start_and_end_on(d[1].get_center(), d[2].get_center())\n        self.wait()\n        l.put_start_and_end_on(d[4].get_center(), d[7].get_center())\n        self.wait()", "code_sha1": "76ba82547d4d2a5c223cc02a4909e4d629fa99d9"}
{"url": "https://docs.manim.community/en/stable/reference/manim.mobject.geometry.line.RightAngle.html", "depth": 1, "instruction": "The scene displays four pairs of intersecting lines forming right angles, arranged horizontally with 1.5 units of space between them. The angles vary in length, stroke width, and color, with the last angle highlighted in red. Each right angle is visually distinct, showcasing different properties while maintaining a consistent layout.", "code": "from manim import *\n\nclass RightAngleExample(Scene):\n    def construct(self):\n        line1 = Line( LEFT, RIGHT )\n        line2 = Line( DOWN, UP )\n        rightangles = [\n            RightAngle(line1, line2),\n            RightAngle(line1, line2, length=0.4, quadrant=(1,-1)),\n            RightAngle(line1, line2, length=0.5, quadrant=(-1,1), stroke_width=8),\n            RightAngle(line1, line2, length=0.7, quadrant=(-1,-1), color=RED),\n        ]\n        plots = VGroup()\n        for rightangle in rightangles:\n            plot=VGroup(line1.copy(),line2.copy(), rightangle)\n            plots.add(plot)\n        plots.arrange(buff=1.5)\n        self.add(plots)", "code_sha1": "346e32b2c528243af2ea51c02182b72a1fc1f511"}
{"url": "https://docs.manim.community/en/stable/reference/manim.mobject.geometry.line.RightAngle.html", "depth": 1, "instruction": "The scene displays four right angles formed by two intersecting lines, arranged horizontally with 1.5 units of space between them. The angles vary in length, stroke width, and color, with the last angle in red. All elements are static, with no animations or camera operations applied.", "code": "class RightAngleExample(Scene):\n    def construct(self):\n        line1 = Line( LEFT, RIGHT )\n        line2 = Line( DOWN, UP )\n        rightangles = [\n            RightAngle(line1, line2),\n            RightAngle(line1, line2, length=0.4, quadrant=(1,-1)),\n            RightAngle(line1, line2, length=0.5, quadrant=(-1,1), stroke_width=8),\n            RightAngle(line1, line2, length=0.7, quadrant=(-1,-1), color=RED),\n        ]\n        plots = VGroup()\n        for rightangle in rightangles:\n            plot=VGroup(line1.copy(),line2.copy(), rightangle)\n            plots.add(plot)\n        plots.arrange(buff=1.5)\n        self.add(plots)", "code_sha1": "9bb535350724262deb03dbd7529f8dff74973add"}
{"url": "https://docs.manim.community/en/stable/reference/manim.mobject.geometry.line.TangentLine.html", "depth": 1, "instruction": "A blue tangent line extends right from a circle, and a green tangent line extends from the top left, both positioned around a 2-unit radius circle, all displayed simultaneously in a static scene.", "code": "from manim import *\n\nclass TangentLineExample(Scene):\n    def construct(self):\n        circle = Circle(radius=2)\n        line_1 = TangentLine(circle, alpha=0.0, length=4, color=BLUE_D) # right\n        line_2 = TangentLine(circle, alpha=0.4, length=4, color=GREEN) # top left\n        self.add(circle, line_1, line_2)", "code_sha1": "3e66942a20502428d170b6b9e51bf74e27aa48c5"}
{"url": "https://docs.manim.community/en/stable/reference/manim.mobject.geometry.line.TangentLine.html", "depth": 1, "instruction": "A blue tangent line extends right from a circle, while a green tangent line extends from the top left, both positioned around a 2-radius circle, creating a visually balanced composition.", "code": "class TangentLineExample(Scene):\n    def construct(self):\n        circle = Circle(radius=2)\n        line_1 = TangentLine(circle, alpha=0.0, length=4, color=BLUE_D) # right\n        line_2 = TangentLine(circle, alpha=0.4, length=4, color=GREEN) # top left\n        self.add(circle, line_1, line_2)", "code_sha1": "7ebee49223d8d5b25781b2300cc9e2b0f29bf601"}
{"url": "https://docs.manim.community/en/stable/reference/manim.mobject.geometry.line.Vector.html", "depth": 1, "instruction": "The scene displays a NumberPlane with two vectors: one pointing to (1, 2) in blue and the other to (-5, -2) in red, both added simultaneously without animations.", "code": "from manim import *\n\nclass VectorExample(Scene):\n    def construct(self):\n        plane = NumberPlane()\n        vector_1 = Vector([1,2])\n        vector_2 = Vector([-5,-2])\n        self.add(plane, vector_1, vector_2)", "code_sha1": "f2a1713c75ebe00558e743c73cd3034488cb1289"}
{"url": "https://docs.manim.community/en/stable/reference/manim.mobject.geometry.line.Vector.html", "depth": 1, "instruction": "The scene displays a NumberPlane with two vectors: one pointing to (1, 2) and the other to (-3, -2). The first vector has a default label, while the second's label is highlighted in yellow. All elements are added simultaneously without animations.", "code": "from manim import *\n\nclass VectorCoordinateLabel(Scene):\n    def construct(self):\n        plane = NumberPlane()\n\n        vec_1 = Vector([1, 2])\n        vec_2 = Vector([-3, -2])\n        label_1 = vec_1.coordinate_label()\n        label_2 = vec_2.coordinate_label(color=YELLOW)\n\n        self.add(plane, vec_1, vec_2, label_1, label_2)", "code_sha1": "06250f467a29e5cb855f62a7e39134d47a88402e"}
{"url": "https://docs.manim.community/en/stable/reference/manim.mobject.geometry.line.Vector.html", "depth": 1, "instruction": "The scene displays a NumberPlane with two vectors: one pointing to (1, 2) in blue and another pointing to (-5, -2) in red, both added simultaneously without animations.", "code": "class VectorExample(Scene):\n    def construct(self):\n        plane = NumberPlane()\n        vector_1 = Vector([1,2])\n        vector_2 = Vector([-5,-2])\n        self.add(plane, vector_1, vector_2)", "code_sha1": "cb35c9442e64f42aa33208a90c9e8eb21b3754a4"}
{"url": "https://docs.manim.community/en/stable/reference/manim.mobject.geometry.line.Vector.html", "depth": 1, "instruction": "The scene displays a NumberPlane with two vectors: one pointing to (1, 2) and the other to (-3, -2). The first vector has a default label, while the second's label is colored yellow. All elements are added simultaneously without animations.", "code": "class VectorCoordinateLabel(Scene):\n    def construct(self):\n        plane = NumberPlane()\n\n        vec_1 = Vector([1, 2])\n        vec_2 = Vector([-3, -2])\n        label_1 = vec_1.coordinate_label()\n        label_2 = vec_2.coordinate_label(color=YELLOW)\n\n        self.add(plane, vec_1, vec_2, label_1, label_2)", "code_sha1": "f1fd1ece2cb3820d030981b6983ac20d65896bd1"}
{"url": "https://docs.manim.community/en/stable/reference/manim.mobject.geometry.polygram.ConvexHull.html", "depth": 1, "instruction": "The scene displays a blue convex hull surrounding a group of ten colored dots, each representing a point in 3D space. The dots are positioned at specified coordinates, while the hull encapsulates them, emphasizing their arrangement.", "code": "from manim import *\n\nclass ConvexHullExample(Scene):\n    def construct(self):\n        points = [\n            [-2.35, -2.25, 0],\n            [1.65, -2.25, 0],\n            [2.65, -0.25, 0],\n            [1.65, 1.75, 0],\n            [-0.35, 2.75, 0],\n            [-2.35, 0.75, 0],\n            [-0.35, -1.25, 0],\n            [0.65, -0.25, 0],\n            [-1.35, 0.25, 0],\n            [0.15, 0.75, 0]\n        ]\n        hull = ConvexHull(*points, color=BLUE)\n        dots = VGroup(*[Dot(point) for point in points])\n        self.add(hull)\n        self.add(dots)", "code_sha1": "626b5fd20ba00b248bd62a40c6222888fed9fb01"}
{"url": "https://docs.manim.community/en/stable/reference/manim.mobject.geometry.polygram.ConvexHull.html", "depth": 1, "instruction": "The scene displays a blue convex hull surrounding a group of ten colored dots, each representing a point in 3D space. The dots are positioned at specified coordinates, while the hull visually encapsulates them, emphasizing their arrangement.", "code": "class ConvexHullExample(Scene):\n    def construct(self):\n        points = [\n            [-2.35, -2.25, 0],\n            [1.65, -2.25, 0],\n            [2.65, -0.25, 0],\n            [1.65, 1.75, 0],\n            [-0.35, 2.75, 0],\n            [-2.35, 0.75, 0],\n            [-0.35, -1.25, 0],\n            [0.65, -0.25, 0],\n            [-1.35, 0.25, 0],\n            [0.15, 0.75, 0]\n        ]\n        hull = ConvexHull(*points, color=BLUE)\n        dots = VGroup(*[Dot(point) for point in points])\n        self.add(hull)\n        self.add(dots)", "code_sha1": "e390db26f11aefe883edb26d9f82374625a8da59"}
{"url": "https://docs.manim.community/en/stable/reference/manim.mobject.geometry.polygram.Cutout.html", "depth": 1, "instruction": "A large blue square with a red outline appears, featuring cutouts shaped like a small triangle and various polygons, animated with a smooth writing effect over 4 seconds. The scene concludes with a brief pause.", "code": "from manim import *\n\nclass CutoutExample(Scene):\n    def construct(self):\n        s1 = Square().scale(2.5)\n        s2 = Triangle().shift(DOWN + RIGHT).scale(0.5)\n        s3 = Square().shift(UP + RIGHT).scale(0.5)\n        s4 = RegularPolygon(5).shift(DOWN + LEFT).scale(0.5)\n        s5 = RegularPolygon(6).shift(UP + LEFT).scale(0.5)\n        c = Cutout(s1, s2, s3, s4, s5, fill_opacity=1, color=BLUE, stroke_color=RED)\n        self.play(Write(c), run_time=4)\n        self.wait()", "code_sha1": "6b5800e60bf92181c371f580952e3e4baaebed14"}
{"url": "https://docs.manim.community/en/stable/reference/manim.mobject.geometry.polygram.Cutout.html", "depth": 1, "instruction": "The scene displays a large blue cutout shape formed by overlapping a large square with five smaller geometric shapes (triangle and regular polygons) in red outlines. The cutout is animated with a 4-second writing effect, followed by a pause.", "code": "class CutoutExample(Scene):\n    def construct(self):\n        s1 = Square().scale(2.5)\n        s2 = Triangle().shift(DOWN + RIGHT).scale(0.5)\n        s3 = Square().shift(UP + RIGHT).scale(0.5)\n        s4 = RegularPolygon(5).shift(DOWN + LEFT).scale(0.5)\n        s5 = RegularPolygon(6).shift(UP + LEFT).scale(0.5)\n        c = Cutout(s1, s2, s3, s4, s5, fill_opacity=1, color=BLUE, stroke_color=RED)\n        self.play(Write(c), run_time=4)\n        self.wait()", "code_sha1": "22d1843c8698aaef462c1218b7558c64ce996d0b"}
{"url": "https://docs.manim.community/en/stable/reference/manim.mobject.geometry.polygram.Polygon.html", "depth": 1, "instruction": "The scene displays an isosceles triangle in the left part, colored white, and a large purple polygon composed of multiple vertices on the right. Both shapes are static, positioned prominently in the frame without any animations or camera movements.", "code": "from manim import *\n\nclass PolygonExample(Scene):\n    def construct(self):\n        isosceles = Polygon([-5, 1.5, 0], [-2, 1.5, 0], [-3.5, -2, 0])\n        position_list = [\n            [4, 1, 0],  # middle right\n            [4, -2.5, 0],  # bottom right\n            [0, -2.5, 0],  # bottom left\n            [0, 3, 0],  # top left\n            [2, 1, 0],  # middle\n            [4, 3, 0],  # top right\n        ]\n        square_and_triangles = Polygon(*position_list, color=PURPLE_B)\n        self.add(isosceles, square_and_triangles)", "code_sha1": "f15aebc7f35e961a7ac6b176655b4a0dc9bc7945"}
{"url": "https://docs.manim.community/en/stable/reference/manim.mobject.geometry.polygram.Polygon.html", "depth": 1, "instruction": "The scene displays an isosceles triangle in its original position and a purple polygon composed of multiple vertices, both simultaneously added to the scene. The triangle is positioned on the left, while the purple polygon occupies the right side, creating a visually balanced composition.", "code": "class PolygonExample(Scene):\n    def construct(self):\n        isosceles = Polygon([-5, 1.5, 0], [-2, 1.5, 0], [-3.5, -2, 0])\n        position_list = [\n            [4, 1, 0],  # middle right\n            [4, -2.5, 0],  # bottom right\n            [0, -2.5, 0],  # bottom left\n            [0, 3, 0],  # top left\n            [2, 1, 0],  # middle\n            [4, 3, 0],  # top right\n        ]\n        square_and_triangles = Polygon(*position_list, color=PURPLE_B)\n        self.add(isosceles, square_and_triangles)", "code_sha1": "946552c8689f27596ff0984ffca94ec76d1a6968"}
{"url": "https://docs.manim.community/en/stable/reference/manim.mobject.geometry.polygram.Polygram.html", "depth": 1, "instruction": "A hexagram is displayed, with a dot moving along its perimeter over 5 seconds in a linear motion. The scene concludes with the dot removed and a brief pause.", "code": "from manim import *\n\nimport numpy as np\n\nclass PolygramExample(Scene):\n    def construct(self):\n        hexagram = Polygram(\n            [[0, 2, 0], [-np.sqrt(3), -1, 0], [np.sqrt(3), -1, 0]],\n            [[-np.sqrt(3), 1, 0], [0, -2, 0], [np.sqrt(3), 1, 0]],\n        )\n        self.add(hexagram)\n\n        dot = Dot()\n        self.play(MoveAlongPath(dot, hexagram), run_time=5, rate_func=linear)\n        self.remove(dot)\n        self.wait()", "code_sha1": "4a84a62d3ddffb963e23aa140cd799bf0fa72429"}
{"url": "https://docs.manim.community/en/stable/reference/manim.mobject.geometry.polygram.Polygram.html", "depth": 1, "instruction": "A square with vertices at specified coordinates is displayed, showcasing its corners. The square is positioned at the origin, with a size of 2 units. The vertices are represented as a numpy array, illustrating the square's geometry without any animations or camera operations.", "code": "sq = Square()\nsq.get_vertices()\narray([[ 1.,  1.,  0.],\n       [-1.,  1.,  0.],\n       [-1., -1.,  0.],\n       [ 1., -1.,  0.]])", "code_sha1": "03617888400098748bbdc0a6a1f054ecd35c7e19"}
{"url": "https://docs.manim.community/en/stable/reference/manim.mobject.geometry.polygram.Polygram.html", "depth": 1, "instruction": "Three stars arranged horizontally, with the first star having sharp corners, the second star featuring slightly rounded corners (radius 0.1), and the third star with more pronounced rounded corners (radius 0.25). All stars are the same size and color, maintaining a uniform appearance.", "code": "from manim import *\n\nclass PolygramRoundCorners(Scene):\n    def construct(self):\n        star = Star(outer_radius=2)\n\n        shapes = VGroup(star)\n        shapes.add(star.copy().round_corners(radius=0.1))\n        shapes.add(star.copy().round_corners(radius=0.25))\n\n        shapes.arrange(RIGHT)\n        self.add(shapes)", "code_sha1": "e1ee934745ede482dfadafd27e736ef75aaf7601"}
{"url": "https://docs.manim.community/en/stable/reference/manim.mobject.geometry.polygram.Polygram.html", "depth": 1, "instruction": "A hexagram is displayed in the center of the scene, with a dot moving along its perimeter over 5 seconds in a linear motion, before the dot is removed, leaving the hexagram visible.", "code": "import numpy as np\n\nclass PolygramExample(Scene):\n    def construct(self):\n        hexagram = Polygram(\n            [[0, 2, 0], [-np.sqrt(3), -1, 0], [np.sqrt(3), -1, 0]],\n            [[-np.sqrt(3), 1, 0], [0, -2, 0], [np.sqrt(3), 1, 0]],\n        )\n        self.add(hexagram)\n\n        dot = Dot()\n        self.play(MoveAlongPath(dot, hexagram), run_time=5, rate_func=linear)\n        self.remove(dot)\n        self.wait()", "code_sha1": "449ad0815f6dd236c0b9b65607205397bdf18962"}
{"url": "https://docs.manim.community/en/stable/reference/manim.mobject.geometry.polygram.Polygram.html", "depth": 1, "instruction": "Three stars arranged horizontally: the first with sharp corners, the second with corners rounded to a radius of 0.1, and the third with corners rounded to a radius of 0.25. All stars are the same size and color, positioned evenly with equal spacing.", "code": "class PolygramRoundCorners(Scene):\n    def construct(self):\n        star = Star(outer_radius=2)\n\n        shapes = VGroup(star)\n        shapes.add(star.copy().round_corners(radius=0.1))\n        shapes.add(star.copy().round_corners(radius=0.25))\n\n        shapes.arrange(RIGHT)\n        self.add(shapes)", "code_sha1": "4dc76a63545a68f247dd80f2446c4889efa01a05"}
{"url": "https://docs.manim.community/en/stable/reference/manim.mobject.geometry.polygram.Rectangle.html", "depth": 1, "instruction": "Three rectangles are arranged horizontally with a buffer of 1 unit between them: a large rectangle (4x2), a tall rectangle (1x4), and a square (2x2) with grid lines. The rectangles are added to the scene without any animations or camera operations.", "code": "from manim import *\n\nclass RectangleExample(Scene):\n    def construct(self):\n        rect1 = Rectangle(width=4.0, height=2.0, grid_xstep=1.0, grid_ystep=0.5)\n        rect2 = Rectangle(width=1.0, height=4.0)\n        rect3 = Rectangle(width=2.0, height=2.0, grid_xstep=1.0, grid_ystep=1.0)\n        rect3.grid_lines.set_stroke(width=1)\n\n        rects = Group(rect1, rect2, rect3).arrange(buff=1)\n        self.add(rects)", "code_sha1": "a76aba5623b14575fadec38d09308001b057693e"}
{"url": "https://docs.manim.community/en/stable/reference/manim.mobject.geometry.polygram.Rectangle.html", "depth": 1, "instruction": "Three rectangles are arranged horizontally with a buffer of 1 unit: a wide rectangle (4x2) in the center, a tall rectangle (1x4) on the left, and a square (2x2) on the right. The grid lines of the square are thinly stroked. All rectangles are displayed in their default colors.", "code": "class RectangleExample(Scene):\n    def construct(self):\n        rect1 = Rectangle(width=4.0, height=2.0, grid_xstep=1.0, grid_ystep=0.5)\n        rect2 = Rectangle(width=1.0, height=4.0)\n        rect3 = Rectangle(width=2.0, height=2.0, grid_xstep=1.0, grid_ystep=1.0)\n        rect3.grid_lines.set_stroke(width=1)\n\n        rects = Group(rect1, rect2, rect3).arrange(buff=1)\n        self.add(rects)", "code_sha1": "92e07a95073e27b3228b8af7806ca308f5f37a1c"}
{"url": "https://docs.manim.community/en/stable/reference/manim.mobject.geometry.polygram.RegularPolygon.html", "depth": 1, "instruction": "Display three regular polygons: a blue hexagon, a green hexagon rotated 30 degrees, and a red decagon, all scaled to 1.5 times their original size and arranged horizontally with a buffer of 1 unit between them.", "code": "from manim import *\n\nclass RegularPolygonExample(Scene):\n    def construct(self):\n        poly_1 = RegularPolygon(n=6)\n        poly_2 = RegularPolygon(n=6, start_angle=30*DEGREES, color=GREEN)\n        poly_3 = RegularPolygon(n=10, color=RED)\n\n        poly_group = Group(poly_1, poly_2, poly_3).scale(1.5).arrange(buff=1)\n        self.add(poly_group)", "code_sha1": "6946375d80e8ba08e269cbd5a81315e782a3d0b1"}
{"url": "https://docs.manim.community/en/stable/reference/manim.mobject.geometry.polygram.RegularPolygon.html", "depth": 1, "instruction": "Three regular polygons (one hexagon in default color, one hexagon in green rotated 30 degrees, and one decagon in red) are grouped, scaled to 1.5 times their size, and arranged with a buffer of 1 unit between them, displayed together on the scene.", "code": "class RegularPolygonExample(Scene):\n    def construct(self):\n        poly_1 = RegularPolygon(n=6)\n        poly_2 = RegularPolygon(n=6, start_angle=30*DEGREES, color=GREEN)\n        poly_3 = RegularPolygon(n=10, color=RED)\n\n        poly_group = Group(poly_1, poly_2, poly_3).scale(1.5).arrange(buff=1)\n        self.add(poly_group)", "code_sha1": "4d9b4a849717d66ad0ab3a2ae4660a8a40895b8e"}
{"url": "https://docs.manim.community/en/stable/reference/manim.mobject.geometry.polygram.RegularPolygram.html", "depth": 1, "instruction": "A pentagram with a radius of 2 units is displayed at the center of the scene, with no animations or transformations applied.", "code": "from manim import *\n\nclass RegularPolygramExample(Scene):\n    def construct(self):\n        pentagram = RegularPolygram(5, radius=2)\n        self.add(pentagram)", "code_sha1": "8e81144912e522e27bd1b55b8f67873219b7b4e6"}
{"url": "https://docs.manim.community/en/stable/reference/manim.mobject.geometry.polygram.RegularPolygram.html", "depth": 1, "instruction": "A pentagram with a radius of 2 is displayed at the center of the scene, with no animations or transformations applied.", "code": "class RegularPolygramExample(Scene):\n    def construct(self):\n        pentagram = RegularPolygram(5, radius=2)\n        self.add(pentagram)", "code_sha1": "f746e640a942384543081c45a753511277332bd7"}
{"url": "https://docs.manim.community/en/stable/reference/manim.mobject.geometry.polygram.RoundedRectangle.html", "depth": 1, "instruction": "Two rounded rectangles are displayed side by side: one with a corner radius of 0.5 and the other with a corner radius of 1.5, sized 4x4. They are grouped and arranged with a buffer of 1 unit between them, positioned centrally in the scene.", "code": "from manim import *\n\nclass RoundedRectangleExample(Scene):\n    def construct(self):\n        rect_1 = RoundedRectangle(corner_radius=0.5)\n        rect_2 = RoundedRectangle(corner_radius=1.5, height=4.0, width=4.0)\n\n        rect_group = Group(rect_1, rect_2).arrange(buff=1)\n        self.add(rect_group)", "code_sha1": "152ffda16e5e54ac1313b97895a454d76f64bbd6"}
{"url": "https://docs.manim.community/en/stable/reference/manim.mobject.geometry.polygram.RoundedRectangle.html", "depth": 1, "instruction": "Two rounded rectangles are displayed side by side: one with a corner radius of 0.5 and the other with a radius of 1.5, sized 4x4. They are grouped and arranged with a buffer of 1 unit between them, positioned centrally on the screen.", "code": "class RoundedRectangleExample(Scene):\n    def construct(self):\n        rect_1 = RoundedRectangle(corner_radius=0.5)\n        rect_2 = RoundedRectangle(corner_radius=1.5, height=4.0, width=4.0)\n\n        rect_group = Group(rect_1, rect_2).arrange(buff=1)\n        self.add(rect_group)", "code_sha1": "0b1506516a95bf59d86a32fb0ada9c3fad33e2e7"}
{"url": "https://docs.manim.community/en/stable/reference/manim.mobject.geometry.polygram.Square.html", "depth": 1, "instruction": "Three squares are displayed vertically: a large square (2.0 units, blue) at the bottom, a medium square (1.0 unit, green) above it, and a small square (0.5 units, red) at the top, all centered horizontally.", "code": "from manim import *\n\nclass SquareExample(Scene):\n    def construct(self):\n        square_1 = Square(side_length=2.0).shift(DOWN)\n        square_2 = Square(side_length=1.0).next_to(square_1, direction=UP)\n        square_3 = Square(side_length=0.5).next_to(square_2, direction=UP)\n        self.add(square_1, square_2, square_3)", "code_sha1": "9fb306872e7f2cd1240d4eae990556865a07af2e"}
{"url": "https://docs.manim.community/en/stable/reference/manim.mobject.geometry.polygram.Square.html", "depth": 1, "instruction": "Three squares are displayed vertically: a large square (2.0 units, blue) at the bottom, a medium square (1.0 unit, green) above it, and a small square (0.5 units, red) at the top, all centered horizontally.", "code": "class SquareExample(Scene):\n    def construct(self):\n        square_1 = Square(side_length=2.0).shift(DOWN)\n        square_2 = Square(side_length=1.0).next_to(square_1, direction=UP)\n        square_3 = Square(side_length=0.5).next_to(square_2, direction=UP)\n        self.add(square_1, square_2, square_3)", "code_sha1": "75c3d9f4a7a6917033a57fa65df891dac7616958"}
{"url": "https://docs.manim.community/en/stable/reference/manim.mobject.geometry.polygram.Star.html", "depth": 1, "instruction": "A red star with an outer radius of 2 is created over a pentagram, which is added to the scene. The star is animated to appear over 3 seconds, then fades out over 2 seconds.", "code": "from manim import *\n\nclass StarExample(Scene):\n    def construct(self):\n        pentagram = RegularPolygram(5, radius=2)\n        star = Star(outer_radius=2, color=RED)\n\n        self.add(pentagram)\n        self.play(Create(star), run_time=3)\n        self.play(FadeOut(star), run_time=2)", "code_sha1": "fea859571142caccc2cc9f9d83a8486deacfd183"}
{"url": "https://docs.manim.community/en/stable/reference/manim.mobject.geometry.polygram.Star.html", "depth": 1, "instruction": "Display two stars side by side: a red star with an outer radius of 2 and density 2, and a purple star with the same outer radius but density 3, arranged horizontally.", "code": "from manim import *\n\nclass DifferentDensitiesExample(Scene):\n    def construct(self):\n        density_2 = Star(7, outer_radius=2, density=2, color=RED)\n        density_3 = Star(7, outer_radius=2, density=3, color=PURPLE)\n\n        self.add(VGroup(density_2, density_3).arrange(RIGHT))", "code_sha1": "8ee146f053963a20e4d2c855021e06648588c1c1"}
{"url": "https://docs.manim.community/en/stable/reference/manim.mobject.geometry.polygram.Star.html", "depth": 1, "instruction": "A red star is created over a pentagram, with the star appearing over 3 seconds and then fading out over 2 seconds, while both shapes are centered in the scene.", "code": "class StarExample(Scene):\n    def construct(self):\n        pentagram = RegularPolygram(5, radius=2)\n        star = Star(outer_radius=2, color=RED)\n\n        self.add(pentagram)\n        self.play(Create(star), run_time=3)\n        self.play(FadeOut(star), run_time=2)", "code_sha1": "f790c0dcc367ad31d764138bef11228a66bca3e7"}
{"url": "https://docs.manim.community/en/stable/reference/manim.mobject.geometry.polygram.Star.html", "depth": 1, "instruction": "Display two stars side by side: one red with density 2 and outer radius 2, and one purple with density 3 and the same outer radius, arranged horizontally.", "code": "class DifferentDensitiesExample(Scene):\n    def construct(self):\n        density_2 = Star(7, outer_radius=2, density=2, color=RED)\n        density_3 = Star(7, outer_radius=2, density=3, color=PURPLE)\n\n        self.add(VGroup(density_2, density_3).arrange(RIGHT))", "code_sha1": "25e805462c830c07314dde07438a4d0230b61d65"}
{"url": "https://docs.manim.community/en/stable/reference/manim.mobject.geometry.polygram.Triangle.html", "depth": 1, "instruction": "Two triangles are displayed: a smaller triangle in its default position and a larger triangle, scaled to twice the size and rotated 60 degrees, arranged with a buffer of 1 unit between them. Both triangles are grouped together and added to the scene.", "code": "from manim import *\n\nclass TriangleExample(Scene):\n    def construct(self):\n        triangle_1 = Triangle()\n        triangle_2 = Triangle().scale(2).rotate(60*DEGREES)\n        tri_group = Group(triangle_1, triangle_2).arrange(buff=1)\n        self.add(tri_group)", "code_sha1": "62efebe50567b41441724718a2ae4c5c370dc6bd"}
{"url": "https://docs.manim.community/en/stable/reference/manim.mobject.geometry.polygram.Triangle.html", "depth": 1, "instruction": "Two equilateral triangles are displayed: one is the original size, and the other is scaled to twice the size and rotated 60 degrees. They are arranged with a buffer of 1 unit between them, forming a visually appealing group.", "code": "class TriangleExample(Scene):\n    def construct(self):\n        triangle_1 = Triangle()\n        triangle_2 = Triangle().scale(2).rotate(60*DEGREES)\n        tri_group = Group(triangle_1, triangle_2).arrange(buff=1)\n        self.add(tri_group)", "code_sha1": "af95223313089151b55790f2c3bd75ba161b6963"}
{"url": "https://docs.manim.community/en/stable/reference/manim.mobject.geometry.shape_matchers.BackgroundRectangle.html", "depth": 1, "instruction": "Two semi-transparent white rectangles rotate around a green circle and a pink triangle, respectively. The first rectangle rotates 45 degrees, while the second rotates 90 degrees, both appearing behind their corresponding shapes. The circle is positioned to the left, and the triangle is positioned to the right.", "code": "from manim import *\n\nclass ExampleBackgroundRectangle(Scene):\n    def construct(self):\n        circle = Circle().shift(LEFT)\n        circle.set_stroke(color=GREEN, width=20)\n        triangle = Triangle().shift(2 * RIGHT)\n        triangle.set_fill(PINK, opacity=0.5)\n        backgroundRectangle1 = BackgroundRectangle(circle, color=WHITE, fill_opacity=0.15)\n        backgroundRectangle2 = BackgroundRectangle(triangle, color=WHITE, fill_opacity=0.15)\n        self.add(backgroundRectangle1)\n        self.add(backgroundRectangle2)\n        self.add(circle)\n        self.add(triangle)\n        self.play(Rotate(backgroundRectangle1, PI / 4))\n        self.play(Rotate(backgroundRectangle2, PI / 2))", "code_sha1": "0c5a2fc4263564dc441dfa5ead1c9953b55ab8cf"}
{"url": "https://docs.manim.community/en/stable/reference/manim.mobject.geometry.shape_matchers.BackgroundRectangle.html", "depth": 1, "instruction": "A green-stroked circle shifts left, a pink-filled triangle shifts right, both with white, semi-transparent background rectangles. The first rectangle rotates 45 degrees, while the second rotates 90 degrees, creating a dynamic visual effect.", "code": "class ExampleBackgroundRectangle(Scene):\n    def construct(self):\n        circle = Circle().shift(LEFT)\n        circle.set_stroke(color=GREEN, width=20)\n        triangle = Triangle().shift(2 * RIGHT)\n        triangle.set_fill(PINK, opacity=0.5)\n        backgroundRectangle1 = BackgroundRectangle(circle, color=WHITE, fill_opacity=0.15)\n        backgroundRectangle2 = BackgroundRectangle(triangle, color=WHITE, fill_opacity=0.15)\n        self.add(backgroundRectangle1)\n        self.add(backgroundRectangle2)\n        self.add(circle)\n        self.add(triangle)\n        self.play(Rotate(backgroundRectangle1, PI / 4))\n        self.play(Rotate(backgroundRectangle2, PI / 2))", "code_sha1": "b79b337e04f24d05ec3c730d7ad9644547161bf9"}
{"url": "https://docs.manim.community/en/stable/reference/manim.mobject.geometry.shape_matchers.Cross.html", "depth": 1, "instruction": "A simple cross is displayed at the center of the scene with default size and color. No animations or camera operations are applied, resulting in a static visual.", "code": "from manim import *\n\nclass ExampleCross(Scene):\n    def construct(self):\n        cross = Cross()\n        self.add(cross)", "code_sha1": "18a4f5b85146d10ca05b3e303b005c8a6e639063"}
{"url": "https://docs.manim.community/en/stable/reference/manim.mobject.geometry.shape_matchers.Cross.html", "depth": 1, "instruction": "A cross is displayed at the center of the scene with default size and color. No animations or camera operations are applied, resulting in a static visual.", "code": "class ExampleCross(Scene):\n    def construct(self):\n        cross = Cross()\n        self.add(cross)", "code_sha1": "be6fd68b73ba39504a249e328c347ce5b6f479b5"}
{"url": "https://docs.manim.community/en/stable/reference/manim.mobject.geometry.shape_matchers.SurroundingRectangle.html", "depth": 1, "instruction": "The scene displays a title \"A Quote from Newton\" at the top, with a blue quote text surrounded by a yellow rectangle below it, and a larger \"Hello World\" text surrounded by a rounded rectangle beneath. The two groups are arranged vertically with medium spacing.", "code": "from manim import *\n\nclass SurroundingRectExample(Scene):\n    def construct(self):\n        title = Title(\"A Quote from Newton\")\n        quote = Text(\n            \"If I have seen further than others, \\n\"\n            \"it is by standing upon the shoulders of giants.\",\n            color=BLUE,\n        ).scale(0.75)\n        box = SurroundingRectangle(quote, color=YELLOW, buff=MED_LARGE_BUFF)\n\n        t2 = Tex(r\"Hello World\").scale(1.5)\n        box2 = SurroundingRectangle(t2, corner_radius=0.2)\n        mobjects = VGroup(VGroup(box, quote), VGroup(t2, box2)).arrange(DOWN)\n        self.add(title, mobjects)", "code_sha1": "dcc7bf7fdb65f16889de84d04ed42b13b7e05f12"}
{"url": "https://docs.manim.community/en/stable/reference/manim.mobject.geometry.shape_matchers.SurroundingRectangle.html", "depth": 1, "instruction": "The scene displays a title \"A Quote from Newton\" at the top, with a blue quote text surrounded by a yellow rectangle below it, and a larger \"Hello World\" text surrounded by a rounded rectangle beneath. The two groups are arranged vertically with medium spacing.", "code": "class SurroundingRectExample(Scene):\n    def construct(self):\n        title = Title(\"A Quote from Newton\")\n        quote = Text(\n            \"If I have seen further than others, \\n\"\n            \"it is by standing upon the shoulders of giants.\",\n            color=BLUE,\n        ).scale(0.75)\n        box = SurroundingRectangle(quote, color=YELLOW, buff=MED_LARGE_BUFF)\n\n        t2 = Tex(r\"Hello World\").scale(1.5)\n        box2 = SurroundingRectangle(t2, corner_radius=0.2)\n        mobjects = VGroup(VGroup(box, quote), VGroup(t2, box2)).arrange(DOWN)\n        self.add(title, mobjects)", "code_sha1": "c9253dacb78808169b81982cc92047161d892dc4"}
{"url": "https://docs.manim.community/en/stable/reference/manim.mobject.geometry.shape_matchers.Underline.html", "depth": 1, "instruction": "The scene displays the word \"Manim\" in a standard font, with a black underline directly beneath it, both centered on the screen. The underline matches the width of the text and has a slight vertical offset, creating a clear emphasis on the word.", "code": "from manim import *\n\nclass UnderLine(Scene):\n    def construct(self):\n        man = Tex(\"Manim\")  # Full Word\n        ul = Underline(man)  # Underlining the word\n        self.add(man, ul)", "code_sha1": "037825fb6df3e493493080c53df9497992498fce"}
{"url": "https://docs.manim.community/en/stable/reference/manim.mobject.geometry.shape_matchers.Underline.html", "depth": 1, "instruction": "The scene displays the word \"Manim\" in a bold font, with a black underline directly beneath it. Both the text and underline are centered on the screen, with no animations or camera operations applied.", "code": "class UnderLine(Scene):\n    def construct(self):\n        man = Tex(\"Manim\")  # Full Word\n        ul = Underline(man)  # Underlining the word\n        self.add(man, ul)", "code_sha1": "98802948270c29209ec8cc0f7ba5a3c549366af9"}
{"url": "https://docs.manim.community/en/stable/reference/manim.mobject.geometry.tips.ArrowTip.html", "depth": 1, "instruction": "A green arrow with a custom non-filled pentagonal tip is created, extending from coordinates (-2, -2) to (2, 2). The arrow is animated into view with a smooth \"Create\" effect.", "code": "from manim import *\nfrom manim import RegularPolygon, Arrow\nclass MyCustomArrowTip(ArrowTip, RegularPolygon):\n    def __init__(self, length=0.35, **kwargs):\n        RegularPolygon.__init__(self, n=5, **kwargs)\n        self.width = length\n        self.stretch_to_fit_height(length)\narr = Arrow(\n    np.array([-2, -2, 0]), np.array([2, 2, 0]), tip_shape=MyCustomArrowTip\n)\nisinstance(arr.tip, RegularPolygon)\nTrue\nfrom manim import Scene, Create\nclass CustomTipExample(Scene):\n    def construct(self):\n        self.play(Create(arr))", "code_sha1": "6a3e5c2494cdd594601c162de1f842fb73ddc1bf"}
{"url": "https://docs.manim.community/en/stable/reference/manim.mobject.geometry.tips.ArrowTip.html", "depth": 1, "instruction": "The scene displays eight horizontal arrows with varying tip styles (e.g., triangle, square, circle) in two rows, with the top row in yellow and the bottom row in different colors. Each arrow has a corresponding blue label in monospace font positioned to the left. The arrows are evenly spaced vertically, showcasing their distinct tips.", "code": "from manim import *\n\nclass ArrowTipsShowcase(Scene):\n    def construct(self):\n        tip_names = [\n            'Default (YELLOW)', 'ArrowTriangleTip', 'Default', 'ArrowSquareTip',\n            'ArrowSquareFilledTip', 'ArrowCircleTip', 'ArrowCircleFilledTip', 'StealthTip'\n        ]\n\n        big_arrows = [\n            Arrow(start=[-4, 3.5, 0], end=[2, 3.5, 0], color=YELLOW),\n            Arrow(start=[-4, 2.5, 0], end=[2, 2.5, 0], tip_shape=ArrowTriangleTip),\n            Arrow(start=[-4, 1.5, 0], end=[2, 1.5, 0]),\n            Arrow(start=[-4, 0.5, 0], end=[2, 0.5, 0], tip_shape=ArrowSquareTip),\n\n            Arrow([-4, -0.5, 0], [2, -0.5, 0], tip_shape=ArrowSquareFilledTip),\n            Arrow([-4, -1.5, 0], [2, -1.5, 0], tip_shape=ArrowCircleTip),\n            Arrow([-4, -2.5, 0], [2, -2.5, 0], tip_shape=ArrowCircleFilledTip),\n            Arrow([-4, -3.5, 0], [2, -3.5, 0], tip_shape=StealthTip)\n        ]\n\n        small_arrows = (\n            arrow.copy().scale(0.5, scale_tips=True).next_to(arrow, RIGHT) for arrow in big_arrows\n        )\n\n        labels = (\n            Text(tip_names[i], font='monospace', font_size=20, color=BLUE).next_to(big_arrows[i], LEFT) for i in range(len(big_arrows))\n        )\n\n        self.add(*big_arrows, *small_arrows, *labels)", "code_sha1": "affe8efd93ef9fbefcfd136ecf6732482679d15e"}
{"url": "https://docs.manim.community/en/stable/reference/manim.mobject.geometry.tips.ArrowTip.html", "depth": 1, "instruction": "A 3D arrow is displayed, extending from the origin (0, 0, 0) to (2, 0, 0), with a tip base at approximately (1.65, 0, 0). The arrow is rendered in a solid color, with no additional animations or camera operations applied.", "code": "from manim import Arrow\narrow = Arrow(np.array([0, 0, 0]), np.array([2, 0, 0]), buff=0)\narrow.tip.base.round(2) + 0.  # add 0. to avoid negative 0 in output\narray([1.65, 0.  , 0.  ])", "code_sha1": "038cc0e364afbf58d266f60caa98a5a624200823"}
{"url": "https://docs.manim.community/en/stable/reference/manim.mobject.geometry.tips.ArrowTip.html", "depth": 1, "instruction": "A green arrow is drawn from the origin (0, 0, 0) to the point (1, 2, 0), with a tip length of 0.35. The arrow is static, with no animations or camera operations applied.", "code": "from manim import Arrow\narrow = Arrow(np.array([0, 0, 0]), np.array([1, 2, 0]))\nround(arrow.tip.length, 3)\n0.35", "code_sha1": "8e457ae7cd65320544f68558a089cfe712698731"}
{"url": "https://docs.manim.community/en/stable/reference/manim.mobject.geometry.tips.ArrowTip.html", "depth": 1, "instruction": "An arrow is drawn from the origin (0, 0, 0) to the point (1, 1, 0) with a tip angle of 45 degrees, visually confirming its properties.", "code": "from manim import Arrow\narrow = Arrow(np.array([0, 0, 0]), np.array([1, 1, 0]), buff=0)\nbool(round(arrow.tip.tip_angle, 5) == round(PI/4, 5))\nTrue", "code_sha1": "407237836212d02c252713843e4229592e4c5dba"}
{"url": "https://docs.manim.community/en/stable/reference/manim.mobject.geometry.tips.ArrowTip.html", "depth": 1, "instruction": "A 3D arrow is displayed, extending from the origin (0, 0, 0) to the point (2, 0, 0), with a sharp tip at the end. The arrow is colored and sized according to default properties, with no animations or camera operations applied.", "code": "from manim import Arrow\narrow = Arrow(np.array([0, 0, 0]), np.array([2, 0, 0]), buff=0)\narrow.tip.tip_point.round(2) + 0.\narray([2., 0., 0.])", "code_sha1": "c18782ffe08cdea540cd59032724b1f9ea432b5f"}
{"url": "https://docs.manim.community/en/stable/reference/manim.mobject.geometry.tips.ArrowTip.html", "depth": 1, "instruction": "A green arrow is drawn from the origin (0, 0, 0) to the point (2, 2, 0), with a sharp tip. The arrow's tip vector is calculated and rounded to (0.25, 0.25, 0), indicating its direction. No animations or camera operations are specified.", "code": "from manim import Arrow\narrow = Arrow(np.array([0, 0, 0]), np.array([2, 2, 0]), buff=0)\narrow.tip.vector.round(2) + 0.\narray([0.25, 0.25, 0.  ])", "code_sha1": "bd4fe6285552dd1b7baafd9f5b77582eb8d241d0"}
{"url": "https://docs.manim.community/en/stable/reference/manim.mobject.geometry.tips.ArrowTip.html", "depth": 1, "instruction": "A green arrow with a custom non-filled pentagonal tip extends diagonally from the bottom left to the top right of the scene, created with a smooth animation. The arrow's body is sleek, and the tip is proportionate, enhancing the visual appeal.", "code": "from manim import RegularPolygon, Arrow\nclass MyCustomArrowTip(ArrowTip, RegularPolygon):\n    def __init__(self, length=0.35, **kwargs):\n        RegularPolygon.__init__(self, n=5, **kwargs)\n        self.width = length\n        self.stretch_to_fit_height(length)\narr = Arrow(\n    np.array([-2, -2, 0]), np.array([2, 2, 0]), tip_shape=MyCustomArrowTip\n)\nisinstance(arr.tip, RegularPolygon)\nTrue\nfrom manim import Scene, Create\nclass CustomTipExample(Scene):\n    def construct(self):\n        self.play(Create(arr))", "code_sha1": "a8e9a45d60349b017c8ad0d9431fb7811c307294"}
{"url": "https://docs.manim.community/en/stable/reference/manim.mobject.geometry.tips.ArrowTip.html", "depth": 1, "instruction": "The scene displays eight horizontal arrows of varying styles and colors, positioned at different vertical levels, with corresponding blue labels on the left. Each arrow is either large or scaled down to half size, showcasing different arrow tips. The arrows are static, with no animations or camera operations applied.", "code": "class ArrowTipsShowcase(Scene):\n    def construct(self):\n        tip_names = [\n            'Default (YELLOW)', 'ArrowTriangleTip', 'Default', 'ArrowSquareTip',\n            'ArrowSquareFilledTip', 'ArrowCircleTip', 'ArrowCircleFilledTip', 'StealthTip'\n        ]\n\n        big_arrows = [\n            Arrow(start=[-4, 3.5, 0], end=[2, 3.5, 0], color=YELLOW),\n            Arrow(start=[-4, 2.5, 0], end=[2, 2.5, 0], tip_shape=ArrowTriangleTip),\n            Arrow(start=[-4, 1.5, 0], end=[2, 1.5, 0]),\n            Arrow(start=[-4, 0.5, 0], end=[2, 0.5, 0], tip_shape=ArrowSquareTip),\n\n            Arrow([-4, -0.5, 0], [2, -0.5, 0], tip_shape=ArrowSquareFilledTip),\n            Arrow([-4, -1.5, 0], [2, -1.5, 0], tip_shape=ArrowCircleTip),\n            Arrow([-4, -2.5, 0], [2, -2.5, 0], tip_shape=ArrowCircleFilledTip),\n            Arrow([-4, -3.5, 0], [2, -3.5, 0], tip_shape=StealthTip)\n        ]\n\n        small_arrows = (\n            arrow.copy().scale(0.5, scale_tips=True).next_to(arrow, RIGHT) for arrow in big_arrows\n        )\n\n        labels = (\n            Text(tip_names[i], font='monospace', font_size=20, color=BLUE).next_to(big_arrows[i], LEFT) for i in range(len(big_arrows))\n        )\n\n        self.add(*big_arrows, *small_arrows, *labels)", "code_sha1": "91844c2e178415376e02bfc02924b36e33d98dca"}
{"url": "https://docs.manim.community/en/stable/reference/manim.mobject.graph.DiGraph.html", "depth": 1, "instruction": "The scene features a directed graph with four vertices labeled 1 to 4, initially positioned at the origin. During the animation, each vertex moves to distinct 3D coordinates: vertex 1 to (1, 1, 1), vertex 2 to (-1, 1, 2), vertex 3 to (1, -1, -1), and vertex 4 to (-1, -1, 0), followed by a brief pause.", "code": "from manim import *\n\nclass MovingDiGraph(Scene):\n    def construct(self):\n        vertices = [1, 2, 3, 4]\n        edges = [(1, 2), (2, 3), (3, 4), (1, 3), (1, 4)]\n\n        g = DiGraph(vertices, edges)\n\n        self.add(g)\n        self.play(\n            g[1].animate.move_to([1, 1, 1]),\n            g[2].animate.move_to([-1, 1, 2]),\n            g[3].animate.move_to([1, -1, -1]),\n            g[4].animate.move_to([-1, -1, 0]),\n        )\n        self.wait()", "code_sha1": "6c180983e475fcf46becc35df60c038a2678aaa6"}
{"url": "https://docs.manim.community/en/stable/reference/manim.mobject.graph.DiGraph.html", "depth": 1, "instruction": "A circular directed graph with 5 labeled vertices and 4 edges is created, featuring a red edge from vertex 3 to 4 with a larger arrow tip. The graph is scaled to 1.4 times its original size and is animated with a creation effect, followed by a pause.", "code": "from manim import *\n\nclass CustomDiGraph(Scene):\n    def construct(self):\n        vertices = [i for i in range(5)]\n        edges = [\n            (0, 1),\n            (1, 2),\n            (3, 2),\n            (3, 4),\n        ]\n\n        edge_config = {\n            \"stroke_width\": 2,\n            \"tip_config\": {\n                \"tip_shape\": ArrowSquareTip,\n                \"tip_length\": 0.15,\n            },\n            (3, 4): {\n                \"color\": RED,\n                \"tip_config\": {\"tip_length\": 0.25, \"tip_width\": 0.25}\n            },\n        }\n\n        g = DiGraph(\n            vertices,\n            edges,\n            labels=True,\n            layout=\"circular\",\n            edge_config=edge_config,\n        ).scale(1.4)\n\n        self.play(Create(g))\n        self.wait()", "code_sha1": "21c9ca4424183be0ec6677ded4c26c4960682223"}
{"url": "https://docs.manim.community/en/stable/reference/manim.mobject.graph.DiGraph.html", "depth": 1, "instruction": "A circular undirected graph with 5 vertices and 4 edges appears, where edges are styled with a stroke width of 2 and the edge (3, 4) is colored red. The graph is created, then vertices 1, 2, 3, and 4 animate to new positions, followed by a pause.", "code": "from manim import *\n\nclass UndirectedMovingDiGraph(Scene):\n    def construct(self):\n        vertices = [i for i in range(5)]\n        edges = [\n            (0, 1),\n            (1, 2),\n            (3, 2),\n            (3, 4),\n        ]\n\n        edge_config = {\n            \"stroke_width\": 2,\n            \"tip_config\": {\"tip_length\": 0, \"tip_width\": 0},\n            (3, 4): {\"color\": RED},\n        }\n\n        g = DiGraph(\n            vertices,\n            edges,\n            labels=True,\n            layout=\"circular\",\n            edge_config=edge_config,\n        ).scale(1.4)\n\n        self.play(Create(g))\n        self.wait()\n\n        self.play(\n            g[1].animate.move_to([1, 1, 1]),\n            g[2].animate.move_to([-1, 1, 2]),\n            g[3].animate.move_to([-1.5, -1.5, -1]),\n            g[4].animate.move_to([1, -2, -1]),\n        )\n        self.wait()", "code_sha1": "a8a66bf5e9c8ee496f55fae024906037b652771e"}
{"url": "https://docs.manim.community/en/stable/reference/manim.mobject.graph.DiGraph.html", "depth": 1, "instruction": "The scene features a directed graph with four vertices (1, 2, 3, 4) represented as points in 3D space. Each vertex moves to a specified position with smooth animations, while the graph structure remains visible. The animation concludes with a pause, showcasing the final arrangement of the vertices.", "code": "class MovingDiGraph(Scene):\n    def construct(self):\n        vertices = [1, 2, 3, 4]\n        edges = [(1, 2), (2, 3), (3, 4), (1, 3), (1, 4)]\n\n        g = DiGraph(vertices, edges)\n\n        self.add(g)\n        self.play(\n            g[1].animate.move_to([1, 1, 1]),\n            g[2].animate.move_to([-1, 1, 2]),\n            g[3].animate.move_to([1, -1, -1]),\n            g[4].animate.move_to([-1, -1, 0]),\n        )\n        self.wait()", "code_sha1": "12d48550f72c6dfe7dde33fce5d90a9829ee3f79"}
{"url": "https://docs.manim.community/en/stable/reference/manim.mobject.graph.DiGraph.html", "depth": 1, "instruction": "A circular directed graph with 5 vertices labeled 0 to 4 is created, featuring edges with a stroke width of 2. The edge from vertex 3 to 4 is colored red with a larger arrow tip. The graph is animated into view with a \"Create\" effect, followed by a pause.", "code": "class CustomDiGraph(Scene):\n    def construct(self):\n        vertices = [i for i in range(5)]\n        edges = [\n            (0, 1),\n            (1, 2),\n            (3, 2),\n            (3, 4),\n        ]\n\n        edge_config = {\n            \"stroke_width\": 2,\n            \"tip_config\": {\n                \"tip_shape\": ArrowSquareTip,\n                \"tip_length\": 0.15,\n            },\n            (3, 4): {\n                \"color\": RED,\n                \"tip_config\": {\"tip_length\": 0.25, \"tip_width\": 0.25}\n            },\n        }\n\n        g = DiGraph(\n            vertices,\n            edges,\n            labels=True,\n            layout=\"circular\",\n            edge_config=edge_config,\n        ).scale(1.4)\n\n        self.play(Create(g))\n        self.wait()", "code_sha1": "cbb3e524c3492b75b0f8bec417da9f3ea52009e0"}
{"url": "https://docs.manim.community/en/stable/reference/manim.mobject.graph.DiGraph.html", "depth": 1, "instruction": "A circular undirected graph with five vertices and four edges appears, where vertex 0 is stationary, while vertices 1, 2, 3, and 4 animate to new positions. The edge between vertices 3 and 4 is colored red, and the graph is scaled to 1.4 times its original size.", "code": "class UndirectedMovingDiGraph(Scene):\n    def construct(self):\n        vertices = [i for i in range(5)]\n        edges = [\n            (0, 1),\n            (1, 2),\n            (3, 2),\n            (3, 4),\n        ]\n\n        edge_config = {\n            \"stroke_width\": 2,\n            \"tip_config\": {\"tip_length\": 0, \"tip_width\": 0},\n            (3, 4): {\"color\": RED},\n        }\n\n        g = DiGraph(\n            vertices,\n            edges,\n            labels=True,\n            layout=\"circular\",\n            edge_config=edge_config,\n        ).scale(1.4)\n\n        self.play(Create(g))\n        self.wait()\n\n        self.play(\n            g[1].animate.move_to([1, 1, 1]),\n            g[2].animate.move_to([-1, 1, 2]),\n            g[3].animate.move_to([-1.5, -1.5, -1]),\n            g[4].animate.move_to([1, -2, -1]),\n        )\n        self.wait()", "code_sha1": "253a66049cb281102e5a7d55f8f9c13802b99329"}
{"url": "https://docs.manim.community/en/stable/reference/manim.mobject.graph.GenericGraph.html", "depth": 1, "instruction": "A graph with five nodes (1 to 5) is initially displayed in a horizontal layout. After creation, the graph smoothly transitions to a circular layout, with nodes evenly spaced around a circle. The animation is fluid, and the scene concludes with a brief pause.", "code": "from manim import *\n\nclass ChangeGraphLayout(Scene):\n    def construct(self):\n        G = Graph([1, 2, 3, 4, 5], [(1, 2), (2, 3), (3, 4), (4, 5)],\n                  layout={1: [-2, 0, 0], 2: [-1, 0, 0], 3: [0, 0, 0],\n                          4: [1, 0, 0], 5: [2, 0, 0]}\n                  )\n        self.play(Create(G))\n        self.play(G.animate.change_layout(\"circular\"))\n        self.wait()", "code_sha1": "1883a7fd5dd26be2ee5d0824b683a7f362c72b16"}
{"url": "https://docs.manim.community/en/stable/reference/manim.mobject.graph.GenericGraph.html", "depth": 1, "instruction": "A spring-layout graph with 14 vertices appears, then each vertex animates in a circular motion around a central point, before the graph is uncreated, fading out smoothly.", "code": "from manim import *\n\nimport networkx as nx\n\nnxgraph = nx.erdos_renyi_graph(14, 0.5)\n\nclass ImportNetworkxGraph(Scene):\n    def construct(self):\n        G = Graph.from_networkx(nxgraph, layout=\"spring\", layout_scale=3.5)\n        self.play(Create(G))\n        self.play(*[G[v].animate.move_to(5*RIGHT*np.cos(ind/7 * PI) +\n                                         3*UP*np.sin(ind/7 * PI))\n                    for ind, v in enumerate(G.vertices)])\n        self.play(Uncreate(G))", "code_sha1": "50ee7da2c7df1de4d2fa6527c6c399ea17628748"}
{"url": "https://docs.manim.community/en/stable/reference/manim.mobject.graph.GenericGraph.html", "depth": 1, "instruction": "A graph with five nodes (1 to 5) is created in a horizontal line, then animates to a circular layout, maintaining the same colors and sizes of nodes. The transition occurs smoothly, followed by a brief pause.", "code": "class ChangeGraphLayout(Scene):\n    def construct(self):\n        G = Graph([1, 2, 3, 4, 5], [(1, 2), (2, 3), (3, 4), (4, 5)],\n                  layout={1: [-2, 0, 0], 2: [-1, 0, 0], 3: [0, 0, 0],\n                          4: [1, 0, 0], 5: [2, 0, 0]}\n                  )\n        self.play(Create(G))\n        self.play(G.animate.change_layout(\"circular\"))\n        self.wait()", "code_sha1": "33fe0f0d755f787077915100716abbfd2a1d0f28"}
{"url": "https://docs.manim.community/en/stable/reference/manim.mobject.graph.GenericGraph.html", "depth": 1, "instruction": "A spring-layout graph with 14 vertices appears, then each vertex animates in a circular motion around a central point, followed by the graph disappearing. The graph is initially created, animated with vibrant colors, and finally uncreated, showcasing smooth transitions and dynamic movement.", "code": "import networkx as nx\n\nnxgraph = nx.erdos_renyi_graph(14, 0.5)\n\nclass ImportNetworkxGraph(Scene):\n    def construct(self):\n        G = Graph.from_networkx(nxgraph, layout=\"spring\", layout_scale=3.5)\n        self.play(Create(G))\n        self.play(*[G[v].animate.move_to(5*RIGHT*np.cos(ind/7 * PI) +\n                                         3*UP*np.sin(ind/7 * PI))\n                    for ind, v in enumerate(G.vertices)])\n        self.play(Uncreate(G))", "code_sha1": "9b4505648f510fd64e53bc69e45d72be7dd4e9d1"}
{"url": "https://docs.manim.community/en/stable/reference/manim.mobject.graph.Graph.html", "depth": 1, "instruction": "A graph with four vertices labeled 1 to 4 is created, initially displayed at their default positions. After a brief pause, the vertices animate to new positions: vertex 1 moves to (1, 1), vertex 2 to (-1, 1), vertex 3 to (1, -1), and vertex 4 to (-1, -1), maintaining their connections.", "code": "from manim import *\n\nclass MovingVertices(Scene):\n    def construct(self):\n        vertices = [1, 2, 3, 4]\n        edges = [(1, 2), (2, 3), (3, 4), (1, 3), (1, 4)]\n        g = Graph(vertices, edges)\n        self.play(Create(g))\n        self.wait()\n        self.play(g[1].animate.move_to([1, 1, 0]),\n                  g[2].animate.move_to([-1, 1, 0]),\n                  g[3].animate.move_to([1, -1, 0]),\n                  g[4].animate.move_to([-1, -1, 0]))\n        self.wait()", "code_sha1": "47471787cfabef02077516cc7aa6d6ea8a1c9798"}
{"url": "https://docs.manim.community/en/stable/reference/manim.mobject.graph.Graph.html", "depth": 1, "instruction": "The scene displays three rows of small graphs, each using different automatic layouts (spring, circular, kamada_kawai, etc.), arranged vertically. Each graph is scaled to half size, with edges connecting vertices. The overall arrangement is neat and organized, emphasizing the distinct layouts of the graphs.", "code": "from manim import *\n\nclass GraphAutoPosition(Scene):\n    def construct(self):\n        vertices = [1, 2, 3, 4, 5, 6, 7, 8]\n        edges = [(1, 7), (1, 8), (2, 3), (2, 4), (2, 5),\n                 (2, 8), (3, 4), (6, 1), (6, 2),\n                 (6, 3), (7, 2), (7, 4)]\n        autolayouts = [\"spring\", \"circular\", \"kamada_kawai\",\n                       \"planar\", \"random\", \"shell\",\n                       \"spectral\", \"spiral\"]\n        graphs = [Graph(vertices, edges, layout=lt).scale(0.5)\n                  for lt in autolayouts]\n        r1 = VGroup(*graphs[:3]).arrange()\n        r2 = VGroup(*graphs[3:6]).arrange()\n        r3 = VGroup(*graphs[6:]).arrange()\n        self.add(VGroup(r1, r2, r3).arrange(direction=DOWN))", "code_sha1": "a5bf35855a1a6d7d5ba73bd5c6522a7037119eb5"}
{"url": "https://docs.manim.community/en/stable/reference/manim.mobject.graph.Graph.html", "depth": 1, "instruction": "A graph with four vertices labeled 1 to 4 is displayed, connected by edges in a square formation. The vertices are positioned at specific coordinates: (0,0), (1,1), (1,-1), and (-1,0). The graph is static, with no animations or camera operations applied.", "code": "from manim import *\n\nclass GraphManualPosition(Scene):\n    def construct(self):\n        vertices = [1, 2, 3, 4]\n        edges = [(1, 2), (2, 3), (3, 4), (4, 1)]\n        lt = {1: [0, 0, 0], 2: [1, 1, 0], 3: [1, -1, 0], 4: [-1, 0, 0]}\n        G = Graph(vertices, edges, layout=lt)\n        self.add(G)", "code_sha1": "cfab9369ea8fc69cf771118990d2adcb57c32511"}
{"url": "https://docs.manim.community/en/stable/reference/manim.mobject.graph.Graph.html", "depth": 1, "instruction": "A circular graph with 8 labeled vertices, where vertex 7 is red, and edges (1, 7), (2, 7), and (4, 7) are also red. The graph is displayed with a layout scale of 3, emphasizing the connections among vertices.", "code": "from manim import *\n\nclass LabeledModifiedGraph(Scene):\n    def construct(self):\n        vertices = [1, 2, 3, 4, 5, 6, 7, 8]\n        edges = [(1, 7), (1, 8), (2, 3), (2, 4), (2, 5),\n                 (2, 8), (3, 4), (6, 1), (6, 2),\n                 (6, 3), (7, 2), (7, 4)]\n        g = Graph(vertices, edges, layout=\"circular\", layout_scale=3,\n                  labels=True, vertex_config={7: {\"fill_color\": RED}},\n                  edge_config={(1, 7): {\"stroke_color\": RED},\n                               (2, 7): {\"stroke_color\": RED},\n                               (4, 7): {\"stroke_color\": RED}})\n        self.add(g)", "code_sha1": "28c9e3d307c5034512162818cd2ed4a22b8fa659"}
{"url": "https://docs.manim.community/en/stable/reference/manim.mobject.graph.Graph.html", "depth": 1, "instruction": "A partite graph with four nodes (0, 1, 2, 3) is displayed, where nodes 0 and 1 are in the left column and nodes 2 and 3 in the right column. The edges (0, 2), (0, 3), and (1, 2) are shown. The graph is created with a smooth animation, appearing from the center of the screen.", "code": "from manim import *\n\nimport networkx as nx\n\nclass PartiteGraph(Scene):\n    def construct(self):\n        G = nx.Graph()\n        G.add_nodes_from([0, 1, 2, 3])\n        G.add_edges_from([(0, 2), (0,3), (1, 2)])\n        graph = Graph(list(G.nodes), list(G.edges), layout=\"partite\", partitions=[[0, 1]])\n        self.play(Create(graph))", "code_sha1": "a51fc7c97dae723516a9318621286611691a5fef"}
{"url": "https://docs.manim.community/en/stable/reference/manim.mobject.graph.Graph.html", "depth": 1, "instruction": "A partite graph representing a linear artificial neural network with four layers of neurons is displayed. Each layer's neurons are arranged in vertical columns, with edges connecting them. Neurons are circular with a radius of 0.20, and the layout is scaled by a factor of 3, creating a clear, structured visualization of the network's architecture.", "code": "from manim import *\n\nclass LinearNN(Scene):\n    def construct(self):\n        edges = []\n        partitions = []\n        c = 0\n        layers = [2, 3, 3, 2]  # the number of neurons in each layer\n\n        for i in layers:\n            partitions.append(list(range(c + 1, c + i + 1)))\n            c += i\n        for i, v in enumerate(layers[1:]):\n                last = sum(layers[:i+1])\n                for j in range(v):\n                    for k in range(last - layers[i], last):\n                        edges.append((k + 1, j + last + 1))\n\n        vertices = np.arange(1, sum(layers) + 1)\n\n        graph = Graph(\n            vertices,\n            edges,\n            layout='partite',\n            partitions=partitions,\n            layout_scale=3,\n            vertex_config={'radius': 0.20},\n        )\n        self.add(graph)", "code_sha1": "d071706ecc0351c545ce2ec6534373bd4e4457d5"}
{"url": "https://docs.manim.community/en/stable/reference/manim.mobject.graph.Graph.html", "depth": 1, "instruction": "A tree graph is displayed with \"ROOT\" at the top, branching down to five \"Child\" nodes, each leading to \"Grandchild\" nodes, which further connect to \"Greatgrandchild\" nodes. The graph is created with a smooth animation, showcasing a hierarchical structure in a visually appealing layout.", "code": "from manim import *\n\nimport networkx as nx\n\nclass Tree(Scene):\n    def construct(self):\n        G = nx.Graph()\n\n        G.add_node(\"ROOT\")\n\n        for i in range(5):\n            G.add_node(\"Child_%i\" % i)\n            G.add_node(\"Grandchild_%i\" % i)\n            G.add_node(\"Greatgrandchild_%i\" % i)\n\n            G.add_edge(\"ROOT\", \"Child_%i\" % i)\n            G.add_edge(\"Child_%i\" % i, \"Grandchild_%i\" % i)\n            G.add_edge(\"Grandchild_%i\" % i, \"Greatgrandchild_%i\" % i)\n\n        self.play(Create(\n            Graph(list(G.nodes), list(G.edges), layout=\"tree\", root_vertex=\"ROOT\")))", "code_sha1": "1c76f4a46b5d84bb8100f503c8acd04595b2ee20"}
{"url": "https://docs.manim.community/en/stable/reference/manim.mobject.graph.Graph.html", "depth": 1, "instruction": "A large tree structure with a blue vertex at the root expands into three child vertices per node, arranged in a tree layout. The camera smoothly zooms out to fit the entire tree within the frame, completing the animation in 0.5 seconds.", "code": "class LargeTreeGeneration(MovingCameraScene):\n    DEPTH = 4\n    CHILDREN_PER_VERTEX = 3\n    LAYOUT_CONFIG = {\"vertex_spacing\": (0.5, 1)}\n    VERTEX_CONF = {\"radius\": 0.25, \"color\": BLUE_B, \"fill_opacity\": 1}\n\n    def expand_vertex(self, g, vertex_id: str, depth: int):\n        new_vertices = [\n            f\"{vertex_id}/{i}\" for i in range(self.CHILDREN_PER_VERTEX)\n        ]\n        new_edges = [(vertex_id, child_id) for child_id in new_vertices]\n        g.add_edges(\n            *new_edges,\n            vertex_config=self.VERTEX_CONF,\n            positions={\n                k: g.vertices[vertex_id].get_center() + 0.1 * DOWN\n                for k in new_vertices\n            },\n        )\n        if depth < self.DEPTH:\n            for child_id in new_vertices:\n                self.expand_vertex(g, child_id, depth + 1)\n\n        return g\n\n    def construct(self):\n        g = Graph([\"ROOT\"], [], vertex_config=self.VERTEX_CONF)\n        g = self.expand_vertex(g, \"ROOT\", 1)\n        self.add(g)\n\n        self.play(\n            g.animate.change_layout(\n                \"tree\",\n                root_vertex=\"ROOT\",\n                layout_config=self.LAYOUT_CONFIG,\n            )\n        )\n        self.play(self.camera.auto_zoom(g, margin=1), run_time=0.5)", "code_sha1": "327bdd013ce8221d8190b6b75acb06a8aa985ab9"}
{"url": "https://docs.manim.community/en/stable/reference/manim.mobject.graph.Graph.html", "depth": 1, "instruction": "A graph with four vertices labeled 1 to 4 is created, initially displayed in a standard layout. After a brief pause, the vertices animate to new positions: vertex 1 moves to (1, 1), vertex 2 to (-1, 1), vertex 3 to (1, -1), and vertex 4 to (-1, -1), maintaining their connections.", "code": "class MovingVertices(Scene):\n    def construct(self):\n        vertices = [1, 2, 3, 4]\n        edges = [(1, 2), (2, 3), (3, 4), (1, 3), (1, 4)]\n        g = Graph(vertices, edges)\n        self.play(Create(g))\n        self.wait()\n        self.play(g[1].animate.move_to([1, 1, 0]),\n                  g[2].animate.move_to([-1, 1, 0]),\n                  g[3].animate.move_to([1, -1, 0]),\n                  g[4].animate.move_to([-1, -1, 0]))\n        self.wait()", "code_sha1": "c7b6c37e97d0ece7ae30ead669222ca2954a1c02"}
{"url": "https://docs.manim.community/en/stable/reference/manim.mobject.graph.Graph.html", "depth": 1, "instruction": "Display three rows of three small graphs, each using different automatic layouts (spring, circular, etc.), arranged vertically. Each graph consists of labeled vertices and edges, with a uniform scale of 0.5. The overall arrangement is neat and organized, emphasizing the distinct layouts of the graphs.", "code": "class GraphAutoPosition(Scene):\n    def construct(self):\n        vertices = [1, 2, 3, 4, 5, 6, 7, 8]\n        edges = [(1, 7), (1, 8), (2, 3), (2, 4), (2, 5),\n                 (2, 8), (3, 4), (6, 1), (6, 2),\n                 (6, 3), (7, 2), (7, 4)]\n        autolayouts = [\"spring\", \"circular\", \"kamada_kawai\",\n                       \"planar\", \"random\", \"shell\",\n                       \"spectral\", \"spiral\"]\n        graphs = [Graph(vertices, edges, layout=lt).scale(0.5)\n                  for lt in autolayouts]\n        r1 = VGroup(*graphs[:3]).arrange()\n        r2 = VGroup(*graphs[3:6]).arrange()\n        r3 = VGroup(*graphs[6:]).arrange()\n        self.add(VGroup(r1, r2, r3).arrange(direction=DOWN))", "code_sha1": "d34e9e04a9725664082d8e3d669ba4d0e4cf6b68"}
{"url": "https://docs.manim.community/en/stable/reference/manim.mobject.graph.Graph.html", "depth": 1, "instruction": "A graph with four labeled vertices (1, 2, 3, 4) is displayed, connected by edges in a square formation. The vertices are positioned at coordinates (0,0), (1,1), (1,-1), and (-1,0). The graph is static, with no animations or camera operations.", "code": "class GraphManualPosition(Scene):\n    def construct(self):\n        vertices = [1, 2, 3, 4]\n        edges = [(1, 2), (2, 3), (3, 4), (4, 1)]\n        lt = {1: [0, 0, 0], 2: [1, 1, 0], 3: [1, -1, 0], 4: [-1, 0, 0]}\n        G = Graph(vertices, edges, layout=lt)\n        self.add(G)", "code_sha1": "8ac48b7c23779a46b6bd1a1b2653fd6f684d83d9"}
{"url": "https://docs.manim.community/en/stable/reference/manim.mobject.graph.Graph.html", "depth": 1, "instruction": "A circular graph displays vertices labeled 1 to 8, with vertex 7 colored red. Edges connect specified vertices, with edges (1, 7), (2, 7), and (4, 7) highlighted in red. The graph is animated with a smooth entrance, showcasing the layout and connections clearly.", "code": "class LabeledModifiedGraph(Scene):\n    def construct(self):\n        vertices = [1, 2, 3, 4, 5, 6, 7, 8]\n        edges = [(1, 7), (1, 8), (2, 3), (2, 4), (2, 5),\n                 (2, 8), (3, 4), (6, 1), (6, 2),\n                 (6, 3), (7, 2), (7, 4)]\n        g = Graph(vertices, edges, layout=\"circular\", layout_scale=3,\n                  labels=True, vertex_config={7: {\"fill_color\": RED}},\n                  edge_config={(1, 7): {\"stroke_color\": RED},\n                               (2, 7): {\"stroke_color\": RED},\n                               (4, 7): {\"stroke_color\": RED}})\n        self.add(g)", "code_sha1": "c0cd6f410e9875a7b8427d6cdf6175934beb15e8"}
{"url": "https://docs.manim.community/en/stable/reference/manim.mobject.graph.Graph.html", "depth": 1, "instruction": "A partite graph with nodes 0, 1, 2, and 3 is displayed, where nodes 0 and 1 are in the left column, and nodes 2 and 3 are in the right column. The edges (0, 2), (0, 3), and (1, 2) are shown, with a smooth animation creating the graph.", "code": "import networkx as nx\n\nclass PartiteGraph(Scene):\n    def construct(self):\n        G = nx.Graph()\n        G.add_nodes_from([0, 1, 2, 3])\n        G.add_edges_from([(0, 2), (0,3), (1, 2)])\n        graph = Graph(list(G.nodes), list(G.edges), layout=\"partite\", partitions=[[0, 1]])\n        self.play(Create(graph))", "code_sha1": "3c84676af6021226ff17fe87e5eee088b15f1592"}
{"url": "https://docs.manim.community/en/stable/reference/manim.mobject.graph.Graph.html", "depth": 1, "instruction": "A partite graph representing a linear artificial neural network with four layers of neurons is displayed. Each layer contains circles (neurons) arranged in vertical columns, with edges (connections) drawn between them. Neurons are colored uniformly, sized at a radius of 0.20, and the layout is scaled to three times its default size.", "code": "class LinearNN(Scene):\n    def construct(self):\n        edges = []\n        partitions = []\n        c = 0\n        layers = [2, 3, 3, 2]  # the number of neurons in each layer\n\n        for i in layers:\n            partitions.append(list(range(c + 1, c + i + 1)))\n            c += i\n        for i, v in enumerate(layers[1:]):\n                last = sum(layers[:i+1])\n                for j in range(v):\n                    for k in range(last - layers[i], last):\n                        edges.append((k + 1, j + last + 1))\n\n        vertices = np.arange(1, sum(layers) + 1)\n\n        graph = Graph(\n            vertices,\n            edges,\n            layout='partite',\n            partitions=partitions,\n            layout_scale=3,\n            vertex_config={'radius': 0.20},\n        )\n        self.add(graph)", "code_sha1": "ef95b0a427420b575be316f1cf2d2678f2f44ea6"}
{"url": "https://docs.manim.community/en/stable/reference/manim.mobject.graph.Graph.html", "depth": 1, "instruction": "A tree graph is displayed with \"ROOT\" at the top, branching down to five \"Child\" nodes, each leading to \"Grandchild\" and \"Greatgrandchild\" nodes, all connected by edges. The graph is animated into view with a smooth creation effect, maintaining a clear hierarchical layout.", "code": "import networkx as nx\n\nclass Tree(Scene):\n    def construct(self):\n        G = nx.Graph()\n\n        G.add_node(\"ROOT\")\n\n        for i in range(5):\n            G.add_node(\"Child_%i\" % i)\n            G.add_node(\"Grandchild_%i\" % i)\n            G.add_node(\"Greatgrandchild_%i\" % i)\n\n            G.add_edge(\"ROOT\", \"Child_%i\" % i)\n            G.add_edge(\"Child_%i\" % i, \"Grandchild_%i\" % i)\n            G.add_edge(\"Grandchild_%i\" % i, \"Greatgrandchild_%i\" % i)\n\n        self.play(Create(\n            Graph(list(G.nodes), list(G.edges), layout=\"tree\", root_vertex=\"ROOT\")))", "code_sha1": "0fa317f9663fee8bf49e8655b1e67bb1b0fc44ea"}
{"url": "https://docs.manim.community/en/stable/reference/manim.mobject.graph.LayoutFunction.html", "depth": 1, "instruction": "A grid of 7 labeled nodes arranged in a 2x4 layout, with nodes positioned symmetrically around the center. The nodes are connected by edges, displayed in a static scene without animations, using default colors and sizes.", "code": "from manim import *\n\nclass CustomLayoutExample(Scene):\n    def construct(self):\n        import numpy as np\n        import networkx as nx\n\n        # create custom layout\n        def custom_layout(\n            graph: nx.Graph,\n            scale: float | tuple[float, float, float] = 2,\n            n: int | None = None,\n            *args: Any,\n            **kwargs: Any,\n        ):\n            nodes = sorted(list(graph))\n            height = len(nodes) // n\n            return {\n                node: (scale * np.array([\n                    (i % n) - (n-1)/2,\n                    -(i // n) + height/2,\n                    0\n                ])) for i, node in enumerate(graph)\n            }\n\n        # draw graph\n        n = 4\n        graph = Graph(\n            [i for i in range(4 * 2 - 1)],\n            [(0, 1), (0, 4), (1, 2), (1, 5), (2, 3), (2, 6), (4, 5), (5, 6)],\n            labels=True,\n            layout=custom_layout,\n            layout_config={'n': n}\n        )\n        self.add(graph)", "code_sha1": "f662cd25e5dd34635803094edb4da8f4f2f767aa"}
{"url": "https://docs.manim.community/en/stable/reference/manim.mobject.graph.LayoutFunction.html", "depth": 1, "instruction": "A circular graph with six vertices labeled 1 to 6 is displayed, arranged evenly around a circle. Edges connect the vertices according to specified pairs, creating a closed loop with additional connections. The scene features a clean background, emphasizing the graph's structure.", "code": "from manim import *\n\nclass CircularLayout(Scene):\n    def construct(self):\n        graph = Graph(\n            [1, 2, 3, 4, 5, 6],\n            [(1, 2), (2, 3), (3, 4), (4, 5), (5, 6), (6, 1), (5, 1), (1, 3), (3, 5)],\n            layout=\"circular\",\n            labels=True\n        )\n        self.add(graph)", "code_sha1": "8cb61e8c9e12b8623ec778de3e0714aeb50efe4f"}
{"url": "https://docs.manim.community/en/stable/reference/manim.mobject.graph.LayoutFunction.html", "depth": 1, "instruction": "A graph with six labeled vertices arranged according to the Kamada-Kawai layout, reflecting specified distances: vertices 1 and 2 are close, while vertex 6 is positioned far from vertex 1. The graph is scaled to four times its default size, with edges connecting the vertices in a circular manner, creating a visually appealing structure.", "code": "from manim import *\n\nclass KamadaKawaiLayout(Scene):\n    def construct(self):\n        from collections import defaultdict\n        distances: dict[int, dict[int, float]] = defaultdict(dict)\n\n        # set desired distances\n        distances[1][2] = 1  # distance between vertices 1 and 2 is 1\n        distances[2][3] = 1  # distance between vertices 2 and 3 is 1\n        distances[3][4] = 2  # etc\n        distances[4][5] = 3\n        distances[5][6] = 5\n        distances[6][1] = 8\n\n        graph = Graph(\n            [1, 2, 3, 4, 5, 6],\n            [(1, 2), (2, 3), (3, 4), (4, 5), (5, 6), (6, 1)],\n            layout=\"kamada_kawai\",\n            layout_config={\"dist\": distances},\n            layout_scale=4,\n            labels=True\n        )\n        self.add(graph)", "code_sha1": "ae3eda2020a05adaea06b81c833b2438e5f8de1f"}
{"url": "https://docs.manim.community/en/stable/reference/manim.mobject.graph.LayoutFunction.html", "depth": 1, "instruction": "A graph with six labeled vertices arranged in three distinct horizontal layers, representing partitions: the first layer contains vertices 1 and 2, the second layer contains 3 and 4, and the third layer contains 5 and 6, all connected by edges, displayed with clear visibility and no overlapping.", "code": "from manim import *\n\nclass PartiteLayout(Scene):\n    def construct(self):\n        graph = Graph(\n            [1, 2, 3, 4, 5, 6],\n            [(1, 2), (2, 3), (3, 4), (4, 5), (5, 6), (6, 1), (5, 1), (1, 3), (3, 5)],\n            layout=\"partite\",\n            layout_config={\"partitions\": [[1,2],[3,4],[5,6]]},\n            labels=True\n        )\n        self.add(graph)", "code_sha1": "93f07759b53e7f6eec09f5dc429926a65c89e354"}
{"url": "https://docs.manim.community/en/stable/reference/manim.mobject.graph.LayoutFunction.html", "depth": 1, "instruction": "A planar graph with six labeled vertices (1 to 6) is displayed, arranged without crossing edges, scaled to four times the default size. The vertices are connected by edges forming a cycle and additional connections, all presented in a clear, organized layout.", "code": "from manim import *\n\nclass PlanarLayout(Scene):\n    def construct(self):\n        graph = Graph(\n            [1, 2, 3, 4, 5, 6],\n            [(1, 2), (2, 3), (3, 4), (4, 5), (5, 6), (6, 1), (5, 1), (1, 3), (3, 5)],\n            layout=\"planar\",\n            layout_scale=4,\n            labels=True\n        )\n        self.add(graph)", "code_sha1": "d90f4c306019607a78e0d8e1110c2ec96ee47538"}
{"url": "https://docs.manim.community/en/stable/reference/manim.mobject.graph.LayoutFunction.html", "depth": 1, "instruction": "A randomly arranged graph with six vertices labeled 1 to 6, connected by edges, is displayed on the screen. The vertices are colored in default colors, and the edges are drawn in a standard style. The graph appears without any specific layout pattern, creating a chaotic visual effect.", "code": "from manim import *\n\nclass RandomLayout(Scene):\n    def construct(self):\n        graph = Graph(\n            [1, 2, 3, 4, 5, 6],\n            [(1, 2), (2, 3), (3, 4), (4, 5), (5, 6), (6, 1), (5, 1), (1, 3), (3, 5)],\n            layout=\"random\",\n            labels=True\n        )\n        self.add(graph)", "code_sha1": "b5975e6cc5ae972c1855560206f3f23b11196eed"}
{"url": "https://docs.manim.community/en/stable/reference/manim.mobject.graph.LayoutFunction.html", "depth": 1, "instruction": "The scene displays a graph with vertices labeled 1 to 9 arranged in two concentric circles, with edges connecting specified pairs. The vertices are colored and sized uniformly, and the graph is centered in the scene. No animations or camera operations are applied.", "code": "from manim import *\n\nclass ShellLayout(Scene):\n    def construct(self):\n        nlist = [[1, 2, 3], [4, 5, 6, 7, 8, 9]]\n        graph = Graph(\n            [1, 2, 3, 4, 5, 6, 7, 8, 9],\n            [(1, 2), (2, 3), (3, 1), (4, 1), (4, 2), (5, 2), (6, 2), (6, 3), (7, 3), (8, 3), (8, 1), (9, 1)],\n            layout=\"shell\",\n            layout_config={\"nlist\": nlist},\n            labels=True\n        )\n        self.add(graph)", "code_sha1": "8e8bd1d9e614f8c4b95dce0cd7a68f6c9bda86a1"}
{"url": "https://docs.manim.community/en/stable/reference/manim.mobject.graph.LayoutFunction.html", "depth": 1, "instruction": "A graph with six labeled vertices arranged according to a spectral layout, displaying edges connecting them in a circular pattern. The vertices are evenly spaced, with clear labels, and the scene features a static camera view without animations.", "code": "from manim import *\n\nclass SpectralLayout(Scene):\n    def construct(self):\n        graph = Graph(\n            [1, 2, 3, 4, 5, 6],\n            [(1, 2), (2, 3), (3, 4), (4, 5), (5, 6), (6, 1), (5, 1), (1, 3), (3, 5)],\n            layout=\"spectral\",\n            labels=True\n        )\n        self.add(graph)", "code_sha1": "eaaf57ff20719d0a55c764122152827d7afb8861"}
{"url": "https://docs.manim.community/en/stable/reference/manim.mobject.graph.LayoutFunction.html", "depth": 1, "instruction": "A spiral graph with six labeled nodes (1 to 6) arranged in a spiraling pattern, connected by edges, is displayed. The nodes are evenly spaced along the spiral, and the graph is added to the scene without any animations or camera operations.", "code": "from manim import *\n\nclass SpiralLayout(Scene):\n    def construct(self):\n        graph = Graph(\n            [1, 2, 3, 4, 5, 6],\n            [(1, 2), (2, 3), (3, 4), (4, 5), (5, 6), (6, 1), (5, 1), (1, 3), (3, 5)],\n            layout=\"spiral\",\n            labels=True\n        )\n        self.add(graph)", "code_sha1": "016ce91efc52053e28551a0721b31bbd51a1a5e8"}
{"url": "https://docs.manim.community/en/stable/reference/manim.mobject.graph.LayoutFunction.html", "depth": 1, "instruction": "A graph with six labeled nodes arranged in a spring layout appears on screen, with edges connecting them in a circular pattern. The nodes are evenly spaced, creating a visually appealing structure that emphasizes node separation while minimizing edge lengths. The scene is static, with no animations or camera operations.", "code": "from manim import *\n\nclass SpringLayout(Scene):\n    def construct(self):\n        graph = Graph(\n            [1, 2, 3, 4, 5, 6],\n            [(1, 2), (2, 3), (3, 4), (4, 5), (5, 6), (6, 1), (5, 1), (1, 3), (3, 5)],\n            layout=\"spring\",\n            labels=True\n        )\n        self.add(graph)", "code_sha1": "70b6b036246cd87535174538783bee1e5fd76cc7"}
{"url": "https://docs.manim.community/en/stable/reference/manim.mobject.graph.LayoutFunction.html", "depth": 1, "instruction": "A tree graph with nodes labeled 1 to 7 is displayed, arranged in a hierarchical structure with node 1 at the top as the root. The edges connect the nodes according to the specified relationships, and the graph is presented with clear labels for each node.", "code": "from manim import *\n\nclass TreeLayout(Scene):\n    def construct(self):\n        graph = Graph(\n            [1, 2, 3, 4, 5, 6, 7],\n            [(1, 2), (1, 3), (2, 4), (2, 5), (3, 6), (3, 7)],\n            layout=\"tree\",\n            layout_config={\"root_vertex\": 1},\n            labels=True\n        )\n        self.add(graph)", "code_sha1": "02fa04e03c4759d824f3abd6200506e3661fac9f"}
{"url": "https://docs.manim.community/en/stable/reference/manim.mobject.graph.LayoutFunction.html", "depth": 1, "instruction": "The scene displays a graph with 7 nodes arranged in a 4x2 grid layout, where nodes are labeled with their indices. The nodes are positioned symmetrically around the center, with edges connecting specific pairs. The graph is visually clear, with a balanced distribution and no animations or camera operations.", "code": "class CustomLayoutExample(Scene):\n    def construct(self):\n        import numpy as np\n        import networkx as nx\n\n        # create custom layout\n        def custom_layout(\n            graph: nx.Graph,\n            scale: float | tuple[float, float, float] = 2,\n            n: int | None = None,\n            *args: Any,\n            **kwargs: Any,\n        ):\n            nodes = sorted(list(graph))\n            height = len(nodes) // n\n            return {\n                node: (scale * np.array([\n                    (i % n) - (n-1)/2,\n                    -(i // n) + height/2,\n                    0\n                ])) for i, node in enumerate(graph)\n            }\n\n        # draw graph\n        n = 4\n        graph = Graph(\n            [i for i in range(4 * 2 - 1)],\n            [(0, 1), (0, 4), (1, 2), (1, 5), (2, 3), (2, 6), (4, 5), (5, 6)],\n            labels=True,\n            layout=custom_layout,\n            layout_config={'n': n}\n        )\n        self.add(graph)", "code_sha1": "d9b0bf1da545a42722835be24fcebff81c55a488"}
{"url": "https://docs.manim.community/en/stable/reference/manim.mobject.graph.LayoutFunction.html", "depth": 1, "instruction": "A circular graph with six vertices labeled 1 to 6 is displayed, arranged evenly around a circle. Edges connect the vertices according to specified pairs, creating a closed loop with additional connections. The graph is visually clear and centered in the scene.", "code": "class CircularLayout(Scene):\n    def construct(self):\n        graph = Graph(\n            [1, 2, 3, 4, 5, 6],\n            [(1, 2), (2, 3), (3, 4), (4, 5), (5, 6), (6, 1), (5, 1), (1, 3), (3, 5)],\n            layout=\"circular\",\n            labels=True\n        )\n        self.add(graph)", "code_sha1": "81a3ae887eb7de5c76143526c7d92eb754542ba7"}
{"url": "https://docs.manim.community/en/stable/reference/manim.mobject.graph.LayoutFunction.html", "depth": 1, "instruction": "A graph with six vertices arranged according to the Kamada-Kawai layout, displaying edges connecting them based on specified distances. Each vertex is labeled, and the graph is scaled to four times its default size, creating a visually clear representation of the relationships between the vertices.", "code": "class KamadaKawaiLayout(Scene):\n    def construct(self):\n        from collections import defaultdict\n        distances: dict[int, dict[int, float]] = defaultdict(dict)\n\n        # set desired distances\n        distances[1][2] = 1  # distance between vertices 1 and 2 is 1\n        distances[2][3] = 1  # distance between vertices 2 and 3 is 1\n        distances[3][4] = 2  # etc\n        distances[4][5] = 3\n        distances[5][6] = 5\n        distances[6][1] = 8\n\n        graph = Graph(\n            [1, 2, 3, 4, 5, 6],\n            [(1, 2), (2, 3), (3, 4), (4, 5), (5, 6), (6, 1)],\n            layout=\"kamada_kawai\",\n            layout_config={\"dist\": distances},\n            layout_scale=4,\n            labels=True\n        )\n        self.add(graph)", "code_sha1": "dd4465bd6d520e97cd0b21f74660f400a6ab82e0"}
{"url": "https://docs.manim.community/en/stable/reference/manim.mobject.graph.LayoutFunction.html", "depth": 1, "instruction": "Display a graph with six labeled vertices arranged in three distinct horizontal layers, representing partitions: {1, 2}, {3, 4}, and {5, 6}. The vertices are connected by edges, forming a circular and interconnected structure, with clear spacing and no overlapping edges.", "code": "class PartiteLayout(Scene):\n    def construct(self):\n        graph = Graph(\n            [1, 2, 3, 4, 5, 6],\n            [(1, 2), (2, 3), (3, 4), (4, 5), (5, 6), (6, 1), (5, 1), (1, 3), (3, 5)],\n            layout=\"partite\",\n            layout_config={\"partitions\": [[1,2],[3,4],[5,6]]},\n            labels=True\n        )\n        self.add(graph)", "code_sha1": "94545b6742b3549530fae116123c0d34a4256f77"}
{"url": "https://docs.manim.community/en/stable/reference/manim.mobject.graph.LayoutFunction.html", "depth": 1, "instruction": "A planar graph with six vertices labeled 1 to 6 is displayed, arranged to avoid edge crossings, with a layout scale of 4. The vertices are connected by edges forming a cycle and additional connections, all presented in a clear, labeled format.", "code": "class PlanarLayout(Scene):\n    def construct(self):\n        graph = Graph(\n            [1, 2, 3, 4, 5, 6],\n            [(1, 2), (2, 3), (3, 4), (4, 5), (5, 6), (6, 1), (5, 1), (1, 3), (3, 5)],\n            layout=\"planar\",\n            layout_scale=4,\n            labels=True\n        )\n        self.add(graph)", "code_sha1": "2ea2febfa1d0b10bfde07090d06e05ec7fd468a1"}
{"url": "https://docs.manim.community/en/stable/reference/manim.mobject.graph.LayoutFunction.html", "depth": 1, "instruction": "A graph with six vertices labeled 1 to 6 is displayed, connected by edges in a random layout. The vertices are randomly positioned within the scene, and the edges connect them without crossing. The graph is static, with no animations or camera operations.", "code": "class RandomLayout(Scene):\n    def construct(self):\n        graph = Graph(\n            [1, 2, 3, 4, 5, 6],\n            [(1, 2), (2, 3), (3, 4), (4, 5), (5, 6), (6, 1), (5, 1), (1, 3), (3, 5)],\n            layout=\"random\",\n            labels=True\n        )\n        self.add(graph)", "code_sha1": "b649fddd267cc8337328163013938f839208a259"}
{"url": "https://docs.manim.community/en/stable/reference/manim.mobject.graph.LayoutFunction.html", "depth": 1, "instruction": "A graph with vertices labeled 1 to 9 is displayed in concentric circles, with edges connecting specified pairs. The vertices are colored in a uniform style, and the scene includes smooth transitions as the graph is added to the scene.", "code": "class ShellLayout(Scene):\n    def construct(self):\n        nlist = [[1, 2, 3], [4, 5, 6, 7, 8, 9]]\n        graph = Graph(\n            [1, 2, 3, 4, 5, 6, 7, 8, 9],\n            [(1, 2), (2, 3), (3, 1), (4, 1), (4, 2), (5, 2), (6, 2), (6, 3), (7, 3), (8, 3), (8, 1), (9, 1)],\n            layout=\"shell\",\n            layout_config={\"nlist\": nlist},\n            labels=True\n        )\n        self.add(graph)", "code_sha1": "249b1d00cb82e7c3e3110a2b9dfdbbc6a23091e4"}
{"url": "https://docs.manim.community/en/stable/reference/manim.mobject.graph.LayoutFunction.html", "depth": 1, "instruction": "A graph with six labeled vertices arranged according to a spectral layout, displaying edges connecting them in a circular pattern, is presented on the screen. The vertices are evenly spaced, and the scene has a clean, minimalistic background.", "code": "class SpectralLayout(Scene):\n    def construct(self):\n        graph = Graph(\n            [1, 2, 3, 4, 5, 6],\n            [(1, 2), (2, 3), (3, 4), (4, 5), (5, 6), (6, 1), (5, 1), (1, 3), (3, 5)],\n            layout=\"spectral\",\n            labels=True\n        )\n        self.add(graph)", "code_sha1": "3099b830e62e5d40f9cae2afe693fa149c569c2c"}
{"url": "https://docs.manim.community/en/stable/reference/manim.mobject.graph.LayoutFunction.html", "depth": 1, "instruction": "A spiral graph with six labeled nodes (1 to 6) arranged in a spiraling pattern, connected by edges, is displayed on the screen. The nodes are evenly spaced along the spiral, creating a visually appealing layout.", "code": "class SpiralLayout(Scene):\n    def construct(self):\n        graph = Graph(\n            [1, 2, 3, 4, 5, 6],\n            [(1, 2), (2, 3), (3, 4), (4, 5), (5, 6), (6, 1), (5, 1), (1, 3), (3, 5)],\n            layout=\"spiral\",\n            labels=True\n        )\n        self.add(graph)", "code_sha1": "e6da10cf7539c08041f6d53ec9683101aba88897"}
{"url": "https://docs.manim.community/en/stable/reference/manim.mobject.graph.LayoutFunction.html", "depth": 1, "instruction": "A graph with six labeled nodes arranged in a spring layout, where edges connect them in a circular pattern, is displayed. The nodes are dynamically positioned to minimize edge lengths while maximizing separation, creating a visually appealing structure.", "code": "class SpringLayout(Scene):\n    def construct(self):\n        graph = Graph(\n            [1, 2, 3, 4, 5, 6],\n            [(1, 2), (2, 3), (3, 4), (4, 5), (5, 6), (6, 1), (5, 1), (1, 3), (3, 5)],\n            layout=\"spring\",\n            labels=True\n        )\n        self.add(graph)", "code_sha1": "501e7e53f5e89e2cc9b2aac325f7e38afe0d4c61"}
{"url": "https://docs.manim.community/en/stable/reference/manim.mobject.graph.LayoutFunction.html", "depth": 1, "instruction": "A tree graph is displayed with nodes labeled 1 to 7, arranged in a hierarchical structure with node 1 at the top. The edges connect the nodes according to a tree layout, visually emphasizing the parent-child relationships. The nodes are evenly spaced, and the graph is centered in the scene.", "code": "class TreeLayout(Scene):\n    def construct(self):\n        graph = Graph(\n            [1, 2, 3, 4, 5, 6, 7],\n            [(1, 2), (1, 3), (2, 4), (2, 5), (3, 6), (3, 7)],\n            layout=\"tree\",\n            layout_config={\"root_vertex\": 1},\n            labels=True\n        )\n        self.add(graph)", "code_sha1": "c07b1639a783f67cc6e3670fe7f7074b8e92c359"}
{"url": "https://docs.manim.community/en/stable/reference/manim.mobject.graphing.coordinate_systems.Axes.html", "depth": 1, "instruction": "A 2D coordinate system with logarithmic scaling on the y-axis, displaying a quadratic graph from (0.001, 0) to (10, 100) in blue, with labeled axes and no tips, is presented. The axes are positioned at the origin, and the graph is smoothly plotted without animation.", "code": "from manim import *\n\nclass LogScalingExample(Scene):\n    def construct(self):\n        ax = Axes(\n            x_range=[0, 10, 1],\n            y_range=[-2, 6, 1],\n            tips=False,\n            axis_config={\"include_numbers\": True},\n            y_axis_config={\"scaling\": LogBase(custom_labels=True)},\n        )\n\n        # x_min must be > 0 because log is undefined at 0.\n        graph = ax.plot(lambda x: x ** 2, x_range=[0.001, 10], use_smoothing=False)\n        self.add(ax, graph)", "code_sha1": "e7d05e24c71719eef488bb9259975953f45e5109"}
{"url": "https://docs.manim.community/en/stable/reference/manim.mobject.graphing.coordinate_systems.Axes.html", "depth": 1, "instruction": "A coordinate system with axes featuring StealthTip arrowheads is displayed, with the axes in standard colors and positioned at the center of the scene. The axes are static, with no animations or camera operations applied.", "code": "from manim import *\n\nclass AxesWithDifferentTips(Scene):\n    def construct(self):\n        ax = Axes(axis_config={'tip_shape': StealthTip})\n        self.add(ax)", "code_sha1": "d22e0f5779724785394e7fba89916167443e2974"}
{"url": "https://docs.manim.community/en/stable/reference/manim.mobject.graphing.coordinate_systems.Axes.html", "depth": 1, "instruction": "The code generates a 3D coordinate system with axes, displaying points at specified coordinates. The points are represented as small dots, with their positions calculated based on the axes' transformations. The visual output includes a grid-like arrangement of points, with varying heights, and is centered in the scene.", "code": "from manim import Axes\nimport numpy as np\nax = Axes()\nnp.around(ax.coords_to_point(1, 0, 0), 2)\narray([0.86, 0.  , 0.  ])\nnp.around(ax @ (1, 0, 0), 2)\narray([0.86, 0.  , 0.  ])\nnp.around(ax.coords_to_point([[0, 1], [1, 1], [1, 0]]), 2)\narray([[0.  , 0.75, 0.  ],\n       [0.86, 0.75, 0.  ],\n       [0.86, 0.  , 0.  ]])\nnp.around(\n    ax.coords_to_point([0, 1, 1], [1, 1, 0]), 2\n)  # Transposed version of the above\narray([[0.  , 0.86, 0.86],\n       [0.75, 0.75, 0.  ],\n       [0.  , 0.  , 0.  ]])", "code_sha1": "5b355d8628cd2438d2b73eee7c44ab5811e938be"}
{"url": "https://docs.manim.community/en/stable/reference/manim.mobject.graphing.coordinate_systems.Axes.html", "depth": 1, "instruction": "The scene displays a green dot positioned at (2, 2) on a coordinate axes, with lines connecting it to the axes. A red dot is also shown at (2, 2) on a number plane. Both dots are added simultaneously, with the axes and lines clearly visible in the background.", "code": "from manim import *\n\nclass CoordsToPointExample(Scene):\n    def construct(self):\n        ax = Axes().add_coordinates()\n\n        # a dot with respect to the axes\n        dot_axes = Dot(ax.coords_to_point(2, 2), color=GREEN)\n        lines = ax.get_lines_to_point(ax.c2p(2,2))\n\n        # a dot with respect to the scene\n        # the default plane corresponds to the coordinates of the scene.\n        plane = NumberPlane()\n        dot_scene = Dot((2,2,0), color=RED)\n\n        self.add(plane, dot_scene, ax, dot_axes, lines)", "code_sha1": "beb04ae01424252a303223252a58bfe521545539"}
{"url": "https://docs.manim.community/en/stable/reference/manim.mobject.graphing.coordinate_systems.Axes.html", "depth": 1, "instruction": "A coordinate system is displayed with labeled axes: \"x-axis\" in scaled Tex and \"y-axis\" in scaled Text. The axes are positioned at the origin, with the x-axis horizontal and the y-axis vertical, both in standard colors. The labels are added without animations, creating a static visual representation of the axes and their labels.", "code": "from manim import *\n\nclass GetAxisLabelsExample(Scene):\n    def construct(self):\n        ax = Axes()\n        labels = ax.get_axis_labels(\n            Tex(\"x-axis\").scale(0.7), Text(\"y-axis\").scale(0.45)\n        )\n        self.add(ax, labels)", "code_sha1": "1cdf04bdd01042baea9ac73e036c6dc4bac93fa2"}
{"url": "https://docs.manim.community/en/stable/reference/manim.mobject.graphing.coordinate_systems.Axes.html", "depth": 1, "instruction": "A centered NumberPlane with x and y axes labeled, displaying a golden line graph connecting six points, with purple vertex dots at each point. The line has a stroke width of 4, and the dots have a stroke width of 3. The scene contains no animations or camera operations.", "code": "from manim import *\n\nclass LineGraphExample(Scene):\n    def construct(self):\n        plane = NumberPlane(\n            x_range = (0, 7),\n            y_range = (0, 5),\n            x_length = 7,\n            axis_config={\"include_numbers\": True},\n        )\n        plane.center()\n        line_graph = plane.plot_line_graph(\n            x_values = [0, 1.5, 2, 2.8, 4, 6.25],\n            y_values = [1, 3, 2.25, 4, 2.5, 1.75],\n            line_color=GOLD_E,\n            vertex_dot_style=dict(stroke_width=3,  fill_color=PURPLE),\n            stroke_width = 4,\n        )\n        self.add(plane, line_graph)", "code_sha1": "c1d4d39843221dbe80f6e5a9f507a50f348b2b49"}
{"url": "https://docs.manim.community/en/stable/reference/manim.mobject.graphing.coordinate_systems.Axes.html", "depth": 1, "instruction": "The code calculates the coordinates of points on a 2D Axes object, returning arrays of coordinates based on specified input points, with the x-axis ranging from 0 to 10. The output is formatted to two decimal places, showing the transformation of points from their original representation to their corresponding coordinates on the axes.", "code": "from manim import Axes, RIGHT\nimport numpy as np\nax = Axes(x_range=[0, 10, 2])\nnp.around(ax.point_to_coords(RIGHT), 2)\narray([5.83, 0.  ])\nnp.around(ax.point_to_coords([[0, 0, 1], [1, 0, 0]]), 2)\narray([[5.  , 0.  ],\n       [5.83, 0.  ]])", "code_sha1": "f51834f82a69720eea9a4baf46c434d56786242f"}
{"url": "https://docs.manim.community/en/stable/reference/manim.mobject.graphing.coordinate_systems.Axes.html", "depth": 1, "instruction": "A scene featuring a 2D Axes with labeled coordinates, a small circle positioned at the upper right quadrant, and a dot marking the circle's rightmost point. A matrix label displaying the circle's coordinates appears to the right of the circle, all elements are animated without specific timing details.", "code": "from manim import *\n\nclass PointToCoordsExample(Scene):\n    def construct(self):\n        ax = Axes(x_range=[0, 10, 2]).add_coordinates()\n        circ = Circle(radius=0.5).shift(UR * 2)\n\n        # get the coordinates of the circle with respect to the axes\n        coords = np.around(ax.point_to_coords(circ.get_right()), decimals=2)\n\n        label = (\n            Matrix([[coords[0]], [coords[1]]]).scale(0.75).next_to(circ, RIGHT)\n        )\n\n        self.add(ax, circ, label, Dot(circ.get_right()))", "code_sha1": "a97c7ef874ffccc9430627ff546f90a21752912d"}
{"url": "https://docs.manim.community/en/stable/reference/manim.mobject.graphing.coordinate_systems.Axes.html", "depth": 1, "instruction": "A 2D coordinate system with labeled axes (x: 0-10, y: -2-6) is displayed, featuring a logarithmic y-axis. A smooth parabolic graph (y = x²) is plotted from x = 0.001 to 10, with no axis tips. The axes are styled with visible numbers, and both elements are added to the scene.", "code": "class LogScalingExample(Scene):\n    def construct(self):\n        ax = Axes(\n            x_range=[0, 10, 1],\n            y_range=[-2, 6, 1],\n            tips=False,\n            axis_config={\"include_numbers\": True},\n            y_axis_config={\"scaling\": LogBase(custom_labels=True)},\n        )\n\n        # x_min must be > 0 because log is undefined at 0.\n        graph = ax.plot(lambda x: x ** 2, x_range=[0.001, 10], use_smoothing=False)\n        self.add(ax, graph)", "code_sha1": "85240a13daa3a62c74a9a3a4e110efe31a3959ce"}
{"url": "https://docs.manim.community/en/stable/reference/manim.mobject.graphing.coordinate_systems.Axes.html", "depth": 1, "instruction": "A coordinate system with axes featuring StealthTip arrowheads is displayed. The axes are positioned in the center of the scene, with standard colors and sizes. No animations or camera operations are applied.", "code": "class AxesWithDifferentTips(Scene):\n    def construct(self):\n        ax = Axes(axis_config={'tip_shape': StealthTip})\n        self.add(ax)", "code_sha1": "ba0e49ed1b91a78daa8ef447fa54e50f431a585b"}
{"url": "https://docs.manim.community/en/stable/reference/manim.mobject.graphing.coordinate_systems.Axes.html", "depth": 1, "instruction": "The scene displays a green dot positioned at (2, 2) on a coordinate axes, with lines connecting it to the axes. A red dot is also shown at (2, 2) on a number plane. Both dots are added to the scene along with the axes and lines, creating a clear visual distinction between the coordinate system and the scene's coordinates.", "code": "class CoordsToPointExample(Scene):\n    def construct(self):\n        ax = Axes().add_coordinates()\n\n        # a dot with respect to the axes\n        dot_axes = Dot(ax.coords_to_point(2, 2), color=GREEN)\n        lines = ax.get_lines_to_point(ax.c2p(2,2))\n\n        # a dot with respect to the scene\n        # the default plane corresponds to the coordinates of the scene.\n        plane = NumberPlane()\n        dot_scene = Dot((2,2,0), color=RED)\n\n        self.add(plane, dot_scene, ax, dot_axes, lines)", "code_sha1": "ca22a27d3d4f8ab0cd5d5d8181f525ef46e1118f"}
{"url": "https://docs.manim.community/en/stable/reference/manim.mobject.graphing.coordinate_systems.Axes.html", "depth": 1, "instruction": "The scene displays a set of axes with labeled x-axis (\"x-axis\" in scaled Tex) and y-axis (\"y-axis\" in scaled Text), both positioned at the origin. The axes are standard black, while the labels are smaller and positioned appropriately along each axis. The scene is static with no animations.", "code": "class GetAxisLabelsExample(Scene):\n    def construct(self):\n        ax = Axes()\n        labels = ax.get_axis_labels(\n            Tex(\"x-axis\").scale(0.7), Text(\"y-axis\").scale(0.45)\n        )\n        self.add(ax, labels)", "code_sha1": "24456c54f5c12a85a4b99b1f389db005b073e049"}
{"url": "https://docs.manim.community/en/stable/reference/manim.mobject.graphing.coordinate_systems.Axes.html", "depth": 1, "instruction": "A centered NumberPlane with x-range 0-7 and y-range 0-5 displays a golden line graph connecting six points, with purple vertex dots. The line has a stroke width of 4, while the dots have a stroke width of 3 and a fill color of purple.", "code": "class LineGraphExample(Scene):\n    def construct(self):\n        plane = NumberPlane(\n            x_range = (0, 7),\n            y_range = (0, 5),\n            x_length = 7,\n            axis_config={\"include_numbers\": True},\n        )\n        plane.center()\n        line_graph = plane.plot_line_graph(\n            x_values = [0, 1.5, 2, 2.8, 4, 6.25],\n            y_values = [1, 3, 2.25, 4, 2.5, 1.75],\n            line_color=GOLD_E,\n            vertex_dot_style=dict(stroke_width=3,  fill_color=PURPLE),\n            stroke_width = 4,\n        )\n        self.add(plane, line_graph)", "code_sha1": "18c9395617afab67667a136e2dfcc3a063429cec"}
{"url": "https://docs.manim.community/en/stable/reference/manim.mobject.graphing.coordinate_systems.Axes.html", "depth": 1, "instruction": "A coordinate system with axes labeled from 0 to 10, a circle positioned at the upper right, a dot at the circle's rightmost point, and a matrix label displaying the circle's coordinates appears next to the circle. The label is scaled down and positioned to the right of the circle.", "code": "class PointToCoordsExample(Scene):\n    def construct(self):\n        ax = Axes(x_range=[0, 10, 2]).add_coordinates()\n        circ = Circle(radius=0.5).shift(UR * 2)\n\n        # get the coordinates of the circle with respect to the axes\n        coords = np.around(ax.point_to_coords(circ.get_right()), decimals=2)\n\n        label = (\n            Matrix([[coords[0]], [coords[1]]]).scale(0.75).next_to(circ, RIGHT)\n        )\n\n        self.add(ax, circ, label, Dot(circ.get_right()))", "code_sha1": "9eae04f607339e64bf7d5079d94b9bb10f2a1f67"}
{"url": "https://docs.manim.community/en/stable/reference/manim.mobject.graphing.coordinate_systems.ComplexPlane.html", "depth": 1, "instruction": "A complex plane is displayed with coordinate labels, featuring two yellow dots at (2, 1) and (-3, -2), each accompanied by their respective labels \"2+i\" and \"-3-2i\" positioned slightly above and to the right of the dots.", "code": "from manim import *\n\nclass ComplexPlaneExample(Scene):\n    def construct(self):\n        plane = ComplexPlane().add_coordinates()\n        self.add(plane)\n        d1 = Dot(plane.n2p(2 + 1j), color=YELLOW)\n        d2 = Dot(plane.n2p(-3 - 2j), color=YELLOW)\n        label1 = MathTex(\"2+i\").next_to(d1, UR, 0.1)\n        label2 = MathTex(\"-3-2i\").next_to(d2, UR, 0.1)\n        self.add(\n            d1,\n            label1,\n            d2,\n            label2,\n        )", "code_sha1": "4c0a355e46d56ae9cf0c05529afcaecf52f1f1d3"}
{"url": "https://docs.manim.community/en/stable/reference/manim.mobject.graphing.coordinate_systems.ComplexPlane.html", "depth": 1, "instruction": "A complex plane with coordinate labels is displayed, featuring two yellow dots at (2, 1) and (-3, -2) representing the complex numbers 2+i and -3-2i, respectively. Each dot has a corresponding label positioned slightly above and to the right.", "code": "class ComplexPlaneExample(Scene):\n    def construct(self):\n        plane = ComplexPlane().add_coordinates()\n        self.add(plane)\n        d1 = Dot(plane.n2p(2 + 1j), color=YELLOW)\n        d2 = Dot(plane.n2p(-3 - 2j), color=YELLOW)\n        label1 = MathTex(\"2+i\").next_to(d1, UR, 0.1)\n        label2 = MathTex(\"-3-2i\").next_to(d2, UR, 0.1)\n        self.add(\n            d1,\n            label1,\n            d2,\n            label2,\n        )", "code_sha1": "30c896047e8e7cc1458017c3c561112701828c4b"}
{"url": "https://docs.manim.community/en/stable/reference/manim.mobject.graphing.coordinate_systems.CoordinateSystem.html", "depth": 1, "instruction": "The scene displays a 2D coordinate grid with labeled axes (x and y) and plots multiple curves representing \\(y = x^n\\) and \\(y = x^{1/n}\\) in white. A blue horizontal and vertical line intersect at the point (1,1), marked by a yellow dot and a label. A title is centered above the grid.", "code": "from manim import *\n\nclass CoordSysExample(Scene):\n    def construct(self):\n        # the location of the ticks depends on the x_range and y_range.\n        grid = Axes(\n            x_range=[0, 1, 0.05],  # step size determines num_decimal_places.\n            y_range=[0, 1, 0.05],\n            x_length=9,\n            y_length=5.5,\n            axis_config={\n                \"numbers_to_include\": np.arange(0, 1 + 0.1, 0.1),\n                \"font_size\": 24,\n            },\n            tips=False,\n        )\n\n        # Labels for the x-axis and y-axis.\n        y_label = grid.get_y_axis_label(\"y\", edge=LEFT, direction=LEFT, buff=0.4)\n        x_label = grid.get_x_axis_label(\"x\")\n        grid_labels = VGroup(x_label, y_label)\n\n        graphs = VGroup()\n        for n in np.arange(1, 20 + 0.5, 0.5):\n            graphs += grid.plot(lambda x: x ** n, color=WHITE)\n            graphs += grid.plot(\n                lambda x: x ** (1 / n), color=WHITE, use_smoothing=False\n            )\n\n        # Extra lines and labels for point (1,1)\n        graphs += grid.get_horizontal_line(grid @ (1, 1, 0), color=BLUE)\n        graphs += grid.get_vertical_line(grid @ (1, 1, 0), color=BLUE)\n        graphs += Dot(point=grid @ (1, 1, 0), color=YELLOW)\n        graphs += Tex(\"(1,1)\").scale(0.75).next_to(grid @ (1, 1, 0))\n        title = Title(\n            # spaces between braces to prevent SyntaxError\n            r\"Graphs of $y=x^{ {1}\\over{n} }$ and $y=x^n (n=1,2,3,...,20)$\",\n            include_underline=False,\n            font_size=40,\n        )\n\n        self.add(title, graphs, grid, grid_labels)", "code_sha1": "051fdca7aebc2ba01e089fcbc9aa8cc003755f4a"}
{"url": "https://docs.manim.community/en/stable/reference/manim.mobject.graphing.coordinate_systems.CoordinateSystem.html", "depth": 1, "instruction": "A blue linear graph representing \\(y = x\\) is plotted on a coordinate system with axes. A label \"x-value\" is positioned at \\(x = 4\\) along the graph, visually indicating the x-coordinate. The scene includes the axes, the graph, and the label, all displayed simultaneously without animations.", "code": "from manim import *\n\nclass TLabelExample(Scene):\n    def construct(self):\n        # defines the axes and linear function\n        axes = Axes(x_range=[-1, 10], y_range=[-1, 10], x_length=9, y_length=6)\n        func = axes.plot(lambda x: x, color=BLUE)\n        # creates the T_label\n        t_label = axes.get_T_label(x_val=4, graph=func, label=Tex(\"x-value\"))\n        self.add(axes, func, t_label)", "code_sha1": "3326a037319a80cc767814ae2cc1439ef367f96a"}
{"url": "https://docs.manim.community/en/stable/reference/manim.mobject.graphing.coordinate_systems.CoordinateSystem.html", "depth": 1, "instruction": "The scene displays a coordinate system with labeled axes, a dark blue sine curve, and a shaded area in a gradient from green to dark green between \\( \\frac{\\pi}{2} \\) and \\( \\frac{3\\pi}{2} \\). All elements are static, with no animations or camera operations.", "code": "from manim import *\n\nclass GetAreaExample(Scene):\n    def construct(self):\n        ax = Axes().add_coordinates()\n        curve = ax.plot(lambda x: 2 * np.sin(x), color=DARK_BLUE)\n        area = ax.get_area(\n            curve,\n            x_range=(PI / 2, 3 * PI / 2),\n            color=(GREEN_B, GREEN_D),\n            opacity=1,\n        )\n\n        self.add(ax, curve, area)", "code_sha1": "cbe96e8520828b13ea733310b067ea0a499a1ffe"}
{"url": "https://docs.manim.community/en/stable/reference/manim.mobject.graphing.coordinate_systems.CoordinateSystem.html", "depth": 1, "instruction": "A purple sine wave is plotted on a set of axes, with a label \\(\\frac{\\pi}{2}\\) positioned at the point \\((\\frac{\\pi}{2}, 1)\\) and a dot marking this point. The label is directed upwards to the right (UR). All elements are added to the scene simultaneously.", "code": "from manim import *\n\nclass GetGraphLabelExample(Scene):\n    def construct(self):\n        ax = Axes()\n        sin = ax.plot(lambda x: np.sin(x), color=PURPLE_B)\n        label = ax.get_graph_label(\n            graph=sin,\n            label= MathTex(r\"\\frac{\\pi}{2}\"),\n            x_val=PI / 2,\n            dot=True,\n            direction=UR,\n        )\n\n        self.add(ax, sin, label)", "code_sha1": "1ab0e208f1d105b6fdb0b0fcfcc7297e31a56c71"}
{"url": "https://docs.manim.community/en/stable/reference/manim.mobject.graphing.coordinate_systems.CoordinateSystem.html", "depth": 1, "instruction": "A horizontal line extends from the y-axis to the point (-4, 1.5), accompanied by a dot at that point. The axes are displayed with coordinates, and the line is rendered in the default color and stroke width. All elements are added to the scene simultaneously without animations.", "code": "from manim import *\n\nclass GetHorizontalLineExample(Scene):\n    def construct(self):\n        ax = Axes().add_coordinates()\n        point = ax @ (-4, 1.5)\n\n        dot = Dot(point)\n        line = ax.get_horizontal_line(point, line_func=Line)\n\n        self.add(ax, line, dot)", "code_sha1": "0f95f08d73c8e94609372c0ba32a3a916a98d610"}
{"url": "https://docs.manim.community/en/stable/reference/manim.mobject.graphing.coordinate_systems.CoordinateSystem.html", "depth": 1, "instruction": "The scene displays a set of axes with a green line extending to the right edge of a small circle and a blue line extending to the bottom-left corner of the circle, both positioned at [-4, -1.5, 0]. The axes, circle, and lines are all visible simultaneously.", "code": "from manim import *\n\nclass GetLinesToPointExample(Scene):\n    def construct(self):\n        ax = Axes()\n        circ = Circle(radius=0.5).move_to([-4, -1.5, 0])\n\n        lines_1 = ax.get_lines_to_point(circ.get_right(), color=GREEN_B)\n        lines_2 = ax.get_lines_to_point(circ.get_corner(DL), color=BLUE_B)\n        self.add(ax, lines_1, lines_2, circ)", "code_sha1": "7594ae24a28ef061c8a23201a423fbed415e417b"}
{"url": "https://docs.manim.community/en/stable/reference/manim.mobject.graphing.coordinate_systems.CoordinateSystem.html", "depth": 1, "instruction": "The scene displays a coordinate system with a quadratic curve, featuring three sets of Riemann rectangles: teal to dark blue on the right, yellow on the left, and maroon to purple over a bounding line. The rectangles are animated with distinct colors, positioned according to their respective x-ranges, creating a visually engaging representation of area under the curve.", "code": "from manim import *\n\nclass GetRiemannRectanglesExample(Scene):\n    def construct(self):\n        ax = Axes(y_range=[-2, 10])\n        quadratic = ax.plot(lambda x: 0.5 * x ** 2 - 0.5)\n\n        # the rectangles are constructed from their top right corner.\n        # passing an iterable to `color` produces a gradient\n        rects_right = ax.get_riemann_rectangles(\n            quadratic,\n            x_range=[-4, -3],\n            dx=0.25,\n            color=(TEAL, BLUE_B, DARK_BLUE),\n            input_sample_type=\"right\",\n        )\n\n        # the colour of rectangles below the x-axis is inverted\n        # due to show_signed_area\n        rects_left = ax.get_riemann_rectangles(\n            quadratic, x_range=[-1.5, 1.5], dx=0.15, color=YELLOW\n        )\n\n        bounding_line = ax.plot(\n            lambda x: 1.5 * x, color=BLUE_B, x_range=[3.3, 6]\n        )\n        bounded_rects = ax.get_riemann_rectangles(\n            bounding_line,\n            bounded_graph=quadratic,\n            dx=0.15,\n            x_range=[4, 5],\n            show_signed_area=False,\n            color=(MAROON_A, RED_B, PURPLE_D),\n        )\n\n        self.add(\n            ax, bounding_line, quadratic, rects_right, rects_left, bounded_rects\n        )", "code_sha1": "2ec979063b23aa14656f3e90d957a0996d7b7be1"}
{"url": "https://docs.manim.community/en/stable/reference/manim.mobject.graphing.coordinate_systems.CoordinateSystem.html", "depth": 1, "instruction": "The scene features a coordinate axes with a blue parabolic graph. A green secant line segment (dx_line) extends horizontally from x=2 to x=3, labeled \"dx = 1.0\". A red secant line (secant_line) connects the graph at these points, illustrating the slope. The elements are arranged neatly, enhancing clarity and visual appeal.", "code": "from manim import *\n\nclass GetSecantSlopeGroupExample(Scene):\n    def construct(self):\n        ax = Axes(y_range=[-1, 7])\n        graph = ax.plot(lambda x: 1 / 4 * x ** 2, color=BLUE)\n        slopes = ax.get_secant_slope_group(\n            x=2.0,\n            graph=graph,\n            dx=1.0,\n            dx_label=Tex(\"dx = 1.0\"),\n            dy_label=\"dy\",\n            dx_line_color=GREEN_B,\n            secant_line_length=4,\n            secant_line_color=RED_D,\n        )\n\n        self.add(ax, graph, slopes)", "code_sha1": "b55ac7fa87bfaeaf7cae40c4df87c98100887a83"}
{"url": "https://docs.manim.community/en/stable/reference/manim.mobject.graphing.coordinate_systems.CoordinateSystem.html", "depth": 1, "instruction": "A vertical dashed line extends from the x-axis to the point (-3.5, 2) on a coordinate plane, accompanied by a dot at the point. The axes are displayed with coordinates, and all elements are added simultaneously without animations.", "code": "from manim import *\n\nclass GetVerticalLineExample(Scene):\n    def construct(self):\n        ax = Axes().add_coordinates()\n        point = ax.coords_to_point(-3.5, 2)\n\n        dot = Dot(point)\n        line = ax.get_vertical_line(point, line_config={\"dashed_ratio\": 0.85})\n\n        self.add(ax, line, dot)", "code_sha1": "87925b896b311f1027b0c28a7d141c24588103f4"}
{"url": "https://docs.manim.community/en/stable/reference/manim.mobject.graphing.coordinate_systems.CoordinateSystem.html", "depth": 1, "instruction": "The scene displays a set of 30 evenly spaced vertical blue lines extending from the x-axis to a sine curve, plotted on a coordinate system with axes labeled and a range from 0 to 4 on the x-axis. The axes and curve are added to the scene without animations.", "code": "from manim import *\n\nclass GetVerticalLinesToGraph(Scene):\n    def construct(self):\n        ax = Axes(\n            x_range=[0, 8.0, 1],\n            y_range=[-1, 1, 0.2],\n            axis_config={\"font_size\": 24},\n        ).add_coordinates()\n\n        curve = ax.plot(lambda x: np.sin(x) / np.e ** 2 * x)\n\n        lines = ax.get_vertical_lines_to_graph(\n            curve, x_range=[0, 4], num_lines=30, color=BLUE\n        )\n\n        self.add(ax, curve, lines)", "code_sha1": "69a881b9b7ca1bb46dbb961368f2e285b3054620"}
{"url": "https://docs.manim.community/en/stable/reference/manim.mobject.graphing.coordinate_systems.CoordinateSystem.html", "depth": 1, "instruction": "A 2D coordinate system is displayed with axes ranging from 0 to 8 on the x-axis and 0 to 5 on the y-axis. The x-axis is labeled \"$x$-values\" in a scaled-down font, positioned below the axis with a slight buffer. The scene includes both the axes and the label without any animations.", "code": "from manim import *\n\nclass GetXAxisLabelExample(Scene):\n    def construct(self):\n        ax = Axes(x_range=(0, 8), y_range=(0, 5), x_length=8, y_length=5)\n        x_label = ax.get_x_axis_label(\n            Tex(\"$x$-values\").scale(0.65), edge=DOWN, direction=DOWN, buff=0.5\n        )\n        self.add(ax, x_label)", "code_sha1": "e30a8749375a801f10a16292d8ebe7794ea078ba"}
{"url": "https://docs.manim.community/en/stable/reference/manim.mobject.graphing.coordinate_systems.CoordinateSystem.html", "depth": 1, "instruction": "A 2D coordinate system is displayed with axes labeled, featuring a vertical label \"$y$-values\" in a small font (0.65 scale), rotated 90 degrees, positioned to the left of the y-axis with a slight buffer (0.3). The axes are clearly defined, creating a structured visual representation.", "code": "from manim import *\n\nclass GetYAxisLabelExample(Scene):\n    def construct(self):\n        ax = Axes(x_range=(0, 8), y_range=(0, 5), x_length=8, y_length=5)\n        y_label = ax.get_y_axis_label(\n            Tex(\"$y$-values\").scale(0.65).rotate(90 * DEGREES),\n            edge=LEFT,\n            direction=LEFT,\n            buff=0.3,\n        )\n        self.add(ax, y_label)", "code_sha1": "900cb57135b0dbd2cc6509ffd1f47f9a1a056b87"}
{"url": "https://docs.manim.community/en/stable/reference/manim.mobject.graphing.coordinate_systems.CoordinateSystem.html", "depth": 1, "instruction": "A coordinate point (3, 9) is visually represented on a 2D graph with axes, where the parabola \\(y = x^2\\) is plotted. The axes are labeled, and the parabola curves upward, intersecting the point (3, 9) prominently.", "code": "from manim import Axes\nax = Axes()\nparabola = ax.plot(lambda x: x**2)\nax.input_to_graph_coords(x=3, graph=parabola)\n(3, 9)", "code_sha1": "f1dbd1f6eb07d71cef71319a2ced4ecc922b2dec"}
{"url": "https://docs.manim.community/en/stable/reference/manim.mobject.graphing.coordinate_systems.CoordinateSystem.html", "depth": 1, "instruction": "The scene displays a set of axes with a cosine curve plotted in blue. A yellow square, positioned at the point corresponding to \\( x = \\pi \\) on the curve, is prominently displayed. The square is centered on the curve, emphasizing its location.", "code": "from manim import *\n\nclass InputToGraphPointExample(Scene):\n    def construct(self):\n        ax = Axes()\n        curve = ax.plot(lambda x : np.cos(x))\n\n        # move a square to PI on the cosine curve.\n        position = ax.input_to_graph_point(x=PI, graph=curve)\n        sq = Square(side_length=1, color=YELLOW).move_to(position)\n\n        self.add(ax, curve, sq)", "code_sha1": "068a64fd06a6204ffd091add80a9ced35a7ea449"}
{"url": "https://docs.manim.community/en/stable/reference/manim.mobject.graphing.coordinate_systems.CoordinateSystem.html", "depth": 1, "instruction": "Three logarithmic curves are plotted on three axes: a red curve with poor interpolation, an orange curve without smoothing, and a green curve with fine sampling. The axes are positioned in the upper left, upper right, and bottom edge of the scene, respectively, creating a visually distinct comparison of the curves' rendering quality.", "code": "from manim import *\n\nclass PlotExample(Scene):\n    def construct(self):\n        # construct the axes\n        ax_1 = Axes(\n            x_range=[0.001, 6],\n            y_range=[-8, 2],\n            x_length=5,\n            y_length=3,\n            tips=False,\n        )\n        ax_2 = ax_1.copy()\n        ax_3 = ax_1.copy()\n\n        # position the axes\n        ax_1.to_corner(UL)\n        ax_2.to_corner(UR)\n        ax_3.to_edge(DOWN)\n        axes = VGroup(ax_1, ax_2, ax_3)\n\n        # create the logarithmic curves\n        def log_func(x):\n            return np.log(x)\n\n        # a curve without adjustments; poor interpolation.\n        curve_1 = ax_1.plot(log_func, color=PURE_RED)\n\n        # disabling interpolation makes the graph look choppy as not enough\n        # inputs are available\n        curve_2 = ax_2.plot(log_func, use_smoothing=False, color=ORANGE)\n\n        # taking more inputs of the curve by specifying a step for the\n        # x_range yields expected results, but increases rendering time.\n        curve_3 = ax_3.plot(\n            log_func, x_range=(0.001, 6, 0.001), color=PURE_GREEN\n        )\n\n        curves = VGroup(curve_1, curve_2, curve_3)\n\n        self.add(axes, curves)", "code_sha1": "f7bbb0b24744ca1e4c3664f396c3ee5e286e9a88"}
{"url": "https://docs.manim.community/en/stable/reference/manim.mobject.graphing.coordinate_systems.CoordinateSystem.html", "depth": 1, "instruction": "The scene displays a coordinate system with a red parabola representing the function \\( \\frac{x^2 - 2}{3} \\) and a blue curve depicting its antiderivative. Both graphs are static, with the axes clearly visible, creating a visual contrast between the two functions.", "code": "from manim import *\n\nclass AntiderivativeExample(Scene):\n    def construct(self):\n        ax = Axes()\n        graph1 = ax.plot(\n            lambda x: (x ** 2 - 2) / 3,\n            color=RED,\n        )\n        graph2 = ax.plot_antiderivative_graph(graph1, color=BLUE)\n        self.add(ax, graph1, graph2)", "code_sha1": "701551393d141ad9028e98215115975bd00c9b70"}
{"url": "https://docs.manim.community/en/stable/reference/manim.mobject.graphing.coordinate_systems.CoordinateSystem.html", "depth": 1, "instruction": "The scene displays a purple parabolic curve representing \\(x^2\\) and its derivative \\(2x\\) in blue, both plotted on a number plane with a light background. Labels for each curve are positioned at specified coordinates, with the axes and curves added simultaneously to the scene.", "code": "from manim import *\n\nclass DerivativeGraphExample(Scene):\n    def construct(self):\n        ax = NumberPlane(y_range=[-1, 7], background_line_style={\"stroke_opacity\": 0.4})\n\n        curve_1 = ax.plot(lambda x: x ** 2, color=PURPLE_B)\n        curve_2 = ax.plot_derivative_graph(curve_1)\n        curves = VGroup(curve_1, curve_2)\n\n        label_1 = ax.get_graph_label(curve_1, \"x^2\", x_val=-2, direction=DL)\n        label_2 = ax.get_graph_label(curve_2, \"2x\", x_val=3, direction=RIGHT)\n        labels = VGroup(label_1, label_2)\n\n        self.add(ax, curves, labels)", "code_sha1": "22915313ade6ef9f546e3aeb885af42fcb599107"}
{"url": "https://docs.manim.community/en/stable/reference/manim.mobject.graphing.coordinate_systems.CoordinateSystem.html", "depth": 1, "instruction": "The scene displays a blue implicit curve defined by the equation \\( y(x - y)^2 - 4x - 8 = 0 \\) plotted on a coordinate system with axes. The axes are added first, followed by the curve, creating a static visual without animations.", "code": "from manim import *\n\nclass ImplicitExample(Scene):\n    def construct(self):\n        ax = Axes()\n        a = ax.plot_implicit_curve(\n            lambda x, y: y * (x - y) ** 2 - 4 * x - 8, color=BLUE\n        )\n        self.add(ax, a)", "code_sha1": "6701c5b4bf12ee0cd06adefe8f8fc21f8496df61"}
{"url": "https://docs.manim.community/en/stable/reference/manim.mobject.graphing.coordinate_systems.CoordinateSystem.html", "depth": 1, "instruction": "A scene displays a coordinate axes with a cardioid curve plotted in a vibrant cyan color, extending from the origin. The curve is defined parametrically over the range from 0 to \\(2\\pi\\), and both the axes and the curve are added to the scene without any animations or camera operations.", "code": "from manim import *\n\nclass ParametricCurveExample(Scene):\n    def construct(self):\n        ax = Axes()\n        cardioid = ax.plot_parametric_curve(\n            lambda t: np.array(\n                [\n                    np.exp(1) * np.cos(t) * (1 - np.cos(t)),\n                    np.exp(1) * np.sin(t) * (1 - np.cos(t)),\n                    0,\n                ]\n            ),\n            t_range=[0, 2 * PI],\n            color=\"#0FF1CE\",\n        )\n        self.add(ax, cardioid)", "code_sha1": "302d28f072db76668b3f6c050e8ab358d0beadba"}
{"url": "https://docs.manim.community/en/stable/reference/manim.mobject.graphing.coordinate_systems.CoordinateSystem.html", "depth": 1, "instruction": "A polar graph is displayed on a PolarPlane, featuring an orange curve representing the function \\( r = 2 \\sin(5\\theta) \\) over the interval \\( [0, 2\\pi] \\). The graph and plane are added simultaneously without animations, creating a static visual representation.", "code": "from manim import *\n\nclass PolarGraphExample(Scene):\n    def construct(self):\n        plane = PolarPlane()\n        r = lambda theta: 2 * np.sin(theta * 5)\n        graph = plane.plot_polar_graph(r, [0, 2 * PI], color=ORANGE)\n        self.add(plane, graph)", "code_sha1": "67989311d0ca82d9dbcbbe05331e50ad3372adad"}
{"url": "https://docs.manim.community/en/stable/reference/manim.mobject.graphing.coordinate_systems.CoordinateSystem.html", "depth": 1, "instruction": "A 3D scene displays a colorful surface defined by \\( z = 2 \\sin(x) + 2 \\cos(y) \\) over a grid, with axes ranging from -3 to 3 in both x and y, and -5 to 5 in z. The surface transitions through a gradient of colors from blue to red, viewed from a 75-degree elevation and -60-degree azimuth.", "code": "from manim import *\n\nclass PlotSurfaceExample(ThreeDScene):\n    def construct(self):\n        resolution_fa = 16\n        self.set_camera_orientation(phi=75 * DEGREES, theta=-60 * DEGREES)\n        axes = ThreeDAxes(x_range=(-3, 3, 1), y_range=(-3, 3, 1), z_range=(-5, 5, 1))\n        def param_trig(u, v):\n            x = u\n            y = v\n            z = 2 * np.sin(x) + 2 * np.cos(y)\n            return z\n        trig_plane = axes.plot_surface(\n            param_trig,\n            resolution=(resolution_fa, resolution_fa),\n            u_range = (-3, 3),\n            v_range = (-3, 3),\n            colorscale = [BLUE, GREEN, YELLOW, ORANGE, RED],\n            )\n        self.add(axes, trig_plane)", "code_sha1": "83b93467dbf3216eb07a5846d4a85f6ca49f6879"}
{"url": "https://docs.manim.community/en/stable/reference/manim.mobject.graphing.coordinate_systems.CoordinateSystem.html", "depth": 1, "instruction": "A polar plane with azimuth units in \"PI radians\" is displayed, sized at 6. A vector originating from the center points to the coordinates corresponding to a radius of 3 and an angle of π/4, visually illustrating the conversion from polar to Cartesian coordinates.", "code": "from manim import *\n\nclass PolarToPointExample(Scene):\n    def construct(self):\n        polarplane_pi = PolarPlane(azimuth_units=\"PI radians\", size=6)\n        polartopoint_vector = Vector(polarplane_pi.polar_to_point(3, PI/4))\n        self.add(polarplane_pi)\n        self.add(polartopoint_vector)", "code_sha1": "37d6507f71bb6ba0fc6938e626e31397baafdf4a"}
{"url": "https://docs.manim.community/en/stable/reference/manim.mobject.graphing.coordinate_systems.CoordinateSystem.html", "depth": 1, "instruction": "The scene displays a 2D coordinate grid with labeled axes (x and y) and plots multiple curves representing \\(y = x^n\\) and \\(y = x^{1/n}\\) in white. A blue crosshair highlights the point (1,1) marked by a yellow dot and a label. A title above describes the graphs, all elements smoothly integrated.", "code": "class CoordSysExample(Scene):\n    def construct(self):\n        # the location of the ticks depends on the x_range and y_range.\n        grid = Axes(\n            x_range=[0, 1, 0.05],  # step size determines num_decimal_places.\n            y_range=[0, 1, 0.05],\n            x_length=9,\n            y_length=5.5,\n            axis_config={\n                \"numbers_to_include\": np.arange(0, 1 + 0.1, 0.1),\n                \"font_size\": 24,\n            },\n            tips=False,\n        )\n\n        # Labels for the x-axis and y-axis.\n        y_label = grid.get_y_axis_label(\"y\", edge=LEFT, direction=LEFT, buff=0.4)\n        x_label = grid.get_x_axis_label(\"x\")\n        grid_labels = VGroup(x_label, y_label)\n\n        graphs = VGroup()\n        for n in np.arange(1, 20 + 0.5, 0.5):\n            graphs += grid.plot(lambda x: x ** n, color=WHITE)\n            graphs += grid.plot(\n                lambda x: x ** (1 / n), color=WHITE, use_smoothing=False\n            )\n\n        # Extra lines and labels for point (1,1)\n        graphs += grid.get_horizontal_line(grid @ (1, 1, 0), color=BLUE)\n        graphs += grid.get_vertical_line(grid @ (1, 1, 0), color=BLUE)\n        graphs += Dot(point=grid @ (1, 1, 0), color=YELLOW)\n        graphs += Tex(\"(1,1)\").scale(0.75).next_to(grid @ (1, 1, 0))\n        title = Title(\n            # spaces between braces to prevent SyntaxError\n            r\"Graphs of $y=x^{ {1}\\over{n} }$ and $y=x^n (n=1,2,3,...,20)$\",\n            include_underline=False,\n            font_size=40,\n        )\n\n        self.add(title, graphs, grid, grid_labels)", "code_sha1": "6b656e51cb69c608e9a29014c7f8886b688a31c8"}
{"url": "https://docs.manim.community/en/stable/reference/manim.mobject.graphing.coordinate_systems.CoordinateSystem.html", "depth": 1, "instruction": "The scene displays a coordinate system with axes, a blue linear function graph, and a labeled point \"x-value\" at x=4. The axes and graph are static, while the label is positioned above the graph, creating a clear visual representation of the function at that specific x-value.", "code": "class TLabelExample(Scene):\n    def construct(self):\n        # defines the axes and linear function\n        axes = Axes(x_range=[-1, 10], y_range=[-1, 10], x_length=9, y_length=6)\n        func = axes.plot(lambda x: x, color=BLUE)\n        # creates the T_label\n        t_label = axes.get_T_label(x_val=4, graph=func, label=Tex(\"x-value\"))\n        self.add(axes, func, t_label)", "code_sha1": "d306bbd9a0880ef88e71653fab1a69a80d2b89b3"}
{"url": "https://docs.manim.community/en/stable/reference/manim.mobject.graphing.coordinate_systems.CoordinateSystem.html", "depth": 1, "instruction": "The scene displays a coordinate axes with labeled axes, a dark blue sine curve, and a shaded green area between the curve and the x-axis from π/2 to 3π/2, all added simultaneously without animations.", "code": "class GetAreaExample(Scene):\n    def construct(self):\n        ax = Axes().add_coordinates()\n        curve = ax.plot(lambda x: 2 * np.sin(x), color=DARK_BLUE)\n        area = ax.get_area(\n            curve,\n            x_range=(PI / 2, 3 * PI / 2),\n            color=(GREEN_B, GREEN_D),\n            opacity=1,\n        )\n\n        self.add(ax, curve, area)", "code_sha1": "f21788e8edfbcf57c820abf216424f756a306c38"}
{"url": "https://docs.manim.community/en/stable/reference/manim.mobject.graphing.coordinate_systems.CoordinateSystem.html", "depth": 1, "instruction": "A purple sine wave is plotted on a set of axes, with a label \\(\\frac{\\pi}{2}\\) positioned at the point \\((\\frac{\\pi}{2}, 1)\\) and a dot at that location, both directed upwards. The axes, sine wave, and label are all displayed simultaneously.", "code": "class GetGraphLabelExample(Scene):\n    def construct(self):\n        ax = Axes()\n        sin = ax.plot(lambda x: np.sin(x), color=PURPLE_B)\n        label = ax.get_graph_label(\n            graph=sin,\n            label= MathTex(r\"\\frac{\\pi}{2}\"),\n            x_val=PI / 2,\n            dot=True,\n            direction=UR,\n        )\n\n        self.add(ax, sin, label)", "code_sha1": "359395eeb920ccfe84146952b71cf1a07ca903e8"}
{"url": "https://docs.manim.community/en/stable/reference/manim.mobject.graphing.coordinate_systems.CoordinateSystem.html", "depth": 1, "instruction": "A horizontal line extends from the y-axis to the point (-4, 1.5), accompanied by a dot at that point. The axes are displayed with coordinates, and the line is solid with a stroke width of 2. The scene includes the axes, line, and dot without any animations or camera operations.", "code": "class GetHorizontalLineExample(Scene):\n    def construct(self):\n        ax = Axes().add_coordinates()\n        point = ax @ (-4, 1.5)\n\n        dot = Dot(point)\n        line = ax.get_horizontal_line(point, line_func=Line)\n\n        self.add(ax, line, dot)", "code_sha1": "b07629c6127f13ecd60fc5179981aee721a3e95c"}
{"url": "https://docs.manim.community/en/stable/reference/manim.mobject.graphing.coordinate_systems.CoordinateSystem.html", "depth": 1, "instruction": "The scene displays a set of axes with a green line extending from the right edge of a small circle positioned at (-4, -1.5) and a blue line from the bottom-left corner of the circle. The circle is filled with a default color and is centered at the specified coordinates.", "code": "class GetLinesToPointExample(Scene):\n    def construct(self):\n        ax = Axes()\n        circ = Circle(radius=0.5).move_to([-4, -1.5, 0])\n\n        lines_1 = ax.get_lines_to_point(circ.get_right(), color=GREEN_B)\n        lines_2 = ax.get_lines_to_point(circ.get_corner(DL), color=BLUE_B)\n        self.add(ax, lines_1, lines_2, circ)", "code_sha1": "445fb7a31d19d899bc3df6208800453cec8d5d62"}
{"url": "https://docs.manim.community/en/stable/reference/manim.mobject.graphing.coordinate_systems.CoordinateSystem.html", "depth": 1, "instruction": "The scene displays a coordinate system with a quadratic curve, three sets of Riemann rectangles in varying colors (TEAL to DARK_BLUE, YELLOW, and MAROON_A to PURPLE_D), and a blue bounding line. The rectangles are positioned under the curve, with some showing signed areas, creating a visually dynamic representation of integration.", "code": "class GetRiemannRectanglesExample(Scene):\n    def construct(self):\n        ax = Axes(y_range=[-2, 10])\n        quadratic = ax.plot(lambda x: 0.5 * x ** 2 - 0.5)\n\n        # the rectangles are constructed from their top right corner.\n        # passing an iterable to `color` produces a gradient\n        rects_right = ax.get_riemann_rectangles(\n            quadratic,\n            x_range=[-4, -3],\n            dx=0.25,\n            color=(TEAL, BLUE_B, DARK_BLUE),\n            input_sample_type=\"right\",\n        )\n\n        # the colour of rectangles below the x-axis is inverted\n        # due to show_signed_area\n        rects_left = ax.get_riemann_rectangles(\n            quadratic, x_range=[-1.5, 1.5], dx=0.15, color=YELLOW\n        )\n\n        bounding_line = ax.plot(\n            lambda x: 1.5 * x, color=BLUE_B, x_range=[3.3, 6]\n        )\n        bounded_rects = ax.get_riemann_rectangles(\n            bounding_line,\n            bounded_graph=quadratic,\n            dx=0.15,\n            x_range=[4, 5],\n            show_signed_area=False,\n            color=(MAROON_A, RED_B, PURPLE_D),\n        )\n\n        self.add(\n            ax, bounding_line, quadratic, rects_right, rects_left, bounded_rects\n        )", "code_sha1": "cca9068ef50f995018b6a01369381f815145308c"}
{"url": "https://docs.manim.community/en/stable/reference/manim.mobject.graphing.coordinate_systems.CoordinateSystem.html", "depth": 1, "instruction": "The scene displays a coordinate axes with a blue parabolic graph. A green secant line segment is drawn from (2, 0) to (3, 1.25), labeled \"dx = 1.0\" in white, while a red secant line connects the endpoints of the secant segment. The axes and graph are added to the scene.", "code": "class GetSecantSlopeGroupExample(Scene):\n    def construct(self):\n        ax = Axes(y_range=[-1, 7])\n        graph = ax.plot(lambda x: 1 / 4 * x ** 2, color=BLUE)\n        slopes = ax.get_secant_slope_group(\n            x=2.0,\n            graph=graph,\n            dx=1.0,\n            dx_label=Tex(\"dx = 1.0\"),\n            dy_label=\"dy\",\n            dx_line_color=GREEN_B,\n            secant_line_length=4,\n            secant_line_color=RED_D,\n        )\n\n        self.add(ax, graph, slopes)", "code_sha1": "b26e5137a78ca0139c6638902efe0653282d7c48"}
{"url": "https://docs.manim.community/en/stable/reference/manim.mobject.graphing.coordinate_systems.CoordinateSystem.html", "depth": 1, "instruction": "The scene displays a coordinate system with a vertical dashed line extending from the x-axis to the point (-3.5, 2), accompanied by a dot at that point. The axes are labeled, and the line is styled with a dashed appearance, emphasizing the connection between the x-axis and the specified point.", "code": "class GetVerticalLineExample(Scene):\n    def construct(self):\n        ax = Axes().add_coordinates()\n        point = ax.coords_to_point(-3.5, 2)\n\n        dot = Dot(point)\n        line = ax.get_vertical_line(point, line_config={\"dashed_ratio\": 0.85})\n\n        self.add(ax, line, dot)", "code_sha1": "13d7cdc3d9aca698e67ff9cda899112e1b6c2c25"}
{"url": "https://docs.manim.community/en/stable/reference/manim.mobject.graphing.coordinate_systems.CoordinateSystem.html", "depth": 1, "instruction": "The scene displays a set of 30 evenly spaced vertical blue lines extending from the x-axis to the sine curve, plotted on a coordinate system with axes labeled and a sine curve drawn. The axes are configured with a font size of 24, and the lines are positioned between x-values 0 and 4.", "code": "class GetVerticalLinesToGraph(Scene):\n    def construct(self):\n        ax = Axes(\n            x_range=[0, 8.0, 1],\n            y_range=[-1, 1, 0.2],\n            axis_config={\"font_size\": 24},\n        ).add_coordinates()\n\n        curve = ax.plot(lambda x: np.sin(x) / np.e ** 2 * x)\n\n        lines = ax.get_vertical_lines_to_graph(\n            curve, x_range=[0, 4], num_lines=30, color=BLUE\n        )\n\n        self.add(ax, curve, lines)", "code_sha1": "38c0123529aab3a2856a80497fd11660a3e93880"}
{"url": "https://docs.manim.community/en/stable/reference/manim.mobject.graphing.coordinate_systems.CoordinateSystem.html", "depth": 1, "instruction": "A coordinate system with axes ranging from (0, 8) on the x-axis and (0, 5) on the y-axis is displayed, featuring a scaled label \"$x$-values\" positioned below the x-axis, centered and slightly offset downward. The axes are clearly visible, and the label is styled in a standard font.", "code": "class GetXAxisLabelExample(Scene):\n    def construct(self):\n        ax = Axes(x_range=(0, 8), y_range=(0, 5), x_length=8, y_length=5)\n        x_label = ax.get_x_axis_label(\n            Tex(\"$x$-values\").scale(0.65), edge=DOWN, direction=DOWN, buff=0.5\n        )\n        self.add(ax, x_label)", "code_sha1": "5f11acbdd3e250baed350ebae32c8efa95cbd99c"}
{"url": "https://docs.manim.community/en/stable/reference/manim.mobject.graphing.coordinate_systems.CoordinateSystem.html", "depth": 1, "instruction": "The scene displays a 2D coordinate system with axes, featuring a vertically oriented label \"$y$-values\" positioned to the left of the y-axis. The label is scaled to 0.65 and slightly offset from the axis, creating a clear visual distinction. The axes are prominently displayed, occupying the full scene dimensions.", "code": "class GetYAxisLabelExample(Scene):\n    def construct(self):\n        ax = Axes(x_range=(0, 8), y_range=(0, 5), x_length=8, y_length=5)\n        y_label = ax.get_y_axis_label(\n            Tex(\"$y$-values\").scale(0.65).rotate(90 * DEGREES),\n            edge=LEFT,\n            direction=LEFT,\n            buff=0.3,\n        )\n        self.add(ax, y_label)", "code_sha1": "260e80db513e840d1f03e71e6bce4133edbdd0f0"}
{"url": "https://docs.manim.community/en/stable/reference/manim.mobject.graphing.coordinate_systems.CoordinateSystem.html", "depth": 1, "instruction": "A yellow square is positioned at the point on a cosine curve corresponding to \\( x = \\pi \\), displayed on a coordinate axes. The scene includes the axes and the curve, with the square prominently placed at the calculated graph point.", "code": "class InputToGraphPointExample(Scene):\n    def construct(self):\n        ax = Axes()\n        curve = ax.plot(lambda x : np.cos(x))\n\n        # move a square to PI on the cosine curve.\n        position = ax.input_to_graph_point(x=PI, graph=curve)\n        sq = Square(side_length=1, color=YELLOW).move_to(position)\n\n        self.add(ax, curve, sq)", "code_sha1": "86aedceb9d37e4bf052b5975cb291156e2645667"}
{"url": "https://docs.manim.community/en/stable/reference/manim.mobject.graphing.coordinate_systems.CoordinateSystem.html", "depth": 1, "instruction": "Three logarithmic curves are plotted on three axes: a red curve with poor interpolation, an orange curve without smoothing, and a green curve with fine sampling. The axes are positioned in the upper left, upper right, and bottom edge of the scene, respectively, creating a visually distinct comparison of the curves' accuracy.", "code": "class PlotExample(Scene):\n    def construct(self):\n        # construct the axes\n        ax_1 = Axes(\n            x_range=[0.001, 6],\n            y_range=[-8, 2],\n            x_length=5,\n            y_length=3,\n            tips=False,\n        )\n        ax_2 = ax_1.copy()\n        ax_3 = ax_1.copy()\n\n        # position the axes\n        ax_1.to_corner(UL)\n        ax_2.to_corner(UR)\n        ax_3.to_edge(DOWN)\n        axes = VGroup(ax_1, ax_2, ax_3)\n\n        # create the logarithmic curves\n        def log_func(x):\n            return np.log(x)\n\n        # a curve without adjustments; poor interpolation.\n        curve_1 = ax_1.plot(log_func, color=PURE_RED)\n\n        # disabling interpolation makes the graph look choppy as not enough\n        # inputs are available\n        curve_2 = ax_2.plot(log_func, use_smoothing=False, color=ORANGE)\n\n        # taking more inputs of the curve by specifying a step for the\n        # x_range yields expected results, but increases rendering time.\n        curve_3 = ax_3.plot(\n            log_func, x_range=(0.001, 6, 0.001), color=PURE_GREEN\n        )\n\n        curves = VGroup(curve_1, curve_2, curve_3)\n\n        self.add(axes, curves)", "code_sha1": "9baccfad45f35a3123547c241c1da5fde1bcf77e"}
{"url": "https://docs.manim.community/en/stable/reference/manim.mobject.graphing.coordinate_systems.CoordinateSystem.html", "depth": 1, "instruction": "The scene displays a coordinate axes with a red curve representing the function \\( \\frac{x^2 - 2}{3} \\) and a blue curve depicting its antiderivative. Both curves are static, with no animations, and are positioned within the axes, showcasing their relationship visually.", "code": "class AntiderivativeExample(Scene):\n    def construct(self):\n        ax = Axes()\n        graph1 = ax.plot(\n            lambda x: (x ** 2 - 2) / 3,\n            color=RED,\n        )\n        graph2 = ax.plot_antiderivative_graph(graph1, color=BLUE)\n        self.add(ax, graph1, graph2)", "code_sha1": "9ec54bf75774cc0ae4e9480347eadd030b7414e0"}
{"url": "https://docs.manim.community/en/stable/reference/manim.mobject.graphing.coordinate_systems.CoordinateSystem.html", "depth": 1, "instruction": "A purple parabola representing \\(x^2\\) and its blue derivative line \\(2x\\) are plotted on a NumberPlane, with labels positioned at specific points. The scene includes a semi-transparent background grid, enhancing visibility, and all elements are added simultaneously without animations.", "code": "class DerivativeGraphExample(Scene):\n    def construct(self):\n        ax = NumberPlane(y_range=[-1, 7], background_line_style={\"stroke_opacity\": 0.4})\n\n        curve_1 = ax.plot(lambda x: x ** 2, color=PURPLE_B)\n        curve_2 = ax.plot_derivative_graph(curve_1)\n        curves = VGroup(curve_1, curve_2)\n\n        label_1 = ax.get_graph_label(curve_1, \"x^2\", x_val=-2, direction=DL)\n        label_2 = ax.get_graph_label(curve_2, \"2x\", x_val=3, direction=RIGHT)\n        labels = VGroup(label_1, label_2)\n\n        self.add(ax, curves, labels)", "code_sha1": "634df5cd43c9e64eb9b32b114005417676374fdd"}
{"url": "https://docs.manim.community/en/stable/reference/manim.mobject.graphing.coordinate_systems.CoordinateSystem.html", "depth": 1, "instruction": "A blue implicit curve defined by the equation \\( y(x - y)^2 - 4x - 8 = 0 \\) is plotted on a coordinate system with axes, showcasing the curve's shape against a white background.", "code": "class ImplicitExample(Scene):\n    def construct(self):\n        ax = Axes()\n        a = ax.plot_implicit_curve(\n            lambda x, y: y * (x - y) ** 2 - 4 * x - 8, color=BLUE\n        )\n        self.add(ax, a)", "code_sha1": "5aa2f00931fe4d4b8b68f6fde24916dfec3ce482"}
{"url": "https://docs.manim.community/en/stable/reference/manim.mobject.graphing.coordinate_systems.CoordinateSystem.html", "depth": 1, "instruction": "A green cardioid shape is plotted on a coordinate system, with the axes displayed in the background. The cardioid is defined parametrically and spans from \\( t = 0 \\) to \\( t = 2\\pi \\), showcasing a smooth curve in a vibrant cyan color.", "code": "class ParametricCurveExample(Scene):\n    def construct(self):\n        ax = Axes()\n        cardioid = ax.plot_parametric_curve(\n            lambda t: np.array(\n                [\n                    np.exp(1) * np.cos(t) * (1 - np.cos(t)),\n                    np.exp(1) * np.sin(t) * (1 - np.cos(t)),\n                    0,\n                ]\n            ),\n            t_range=[0, 2 * PI],\n            color=\"#0FF1CE\",\n        )\n        self.add(ax, cardioid)", "code_sha1": "225def312661ceef5b5e68961a75c0983308f548"}
{"url": "https://docs.manim.community/en/stable/reference/manim.mobject.graphing.coordinate_systems.CoordinateSystem.html", "depth": 1, "instruction": "A polar graph is displayed on a PolarPlane, featuring an orange curve representing the function \\( r = 2 \\sin(5\\theta) \\) over the interval \\( [0, 2\\pi] \\). The graph is smoothly added to the scene alongside the polar plane.", "code": "class PolarGraphExample(Scene):\n    def construct(self):\n        plane = PolarPlane()\n        r = lambda theta: 2 * np.sin(theta * 5)\n        graph = plane.plot_polar_graph(r, [0, 2 * PI], color=ORANGE)\n        self.add(plane, graph)", "code_sha1": "e82bdcb5e746c24f32d86f3a99dc0d27f3e5df01"}
{"url": "https://docs.manim.community/en/stable/reference/manim.mobject.graphing.coordinate_systems.CoordinateSystem.html", "depth": 1, "instruction": "A 3D scene displays a colorful surface plot defined by the function \\( z = 2\\sin(x) + 2\\cos(y) \\), with axes ranging from -3 to 3 in both x and y directions and -5 to 5 in z. The camera is positioned at a 75-degree elevation and -60-degree azimuth, showcasing a gradient color scheme from blue to red.", "code": "class PlotSurfaceExample(ThreeDScene):\n    def construct(self):\n        resolution_fa = 16\n        self.set_camera_orientation(phi=75 * DEGREES, theta=-60 * DEGREES)\n        axes = ThreeDAxes(x_range=(-3, 3, 1), y_range=(-3, 3, 1), z_range=(-5, 5, 1))\n        def param_trig(u, v):\n            x = u\n            y = v\n            z = 2 * np.sin(x) + 2 * np.cos(y)\n            return z\n        trig_plane = axes.plot_surface(\n            param_trig,\n            resolution=(resolution_fa, resolution_fa),\n            u_range = (-3, 3),\n            v_range = (-3, 3),\n            colorscale = [BLUE, GREEN, YELLOW, ORANGE, RED],\n            )\n        self.add(axes, trig_plane)", "code_sha1": "97f93ad88df690782c483f43828e919dc41bc829"}
{"url": "https://docs.manim.community/en/stable/reference/manim.mobject.graphing.coordinate_systems.CoordinateSystem.html", "depth": 1, "instruction": "A polar plane with azimuth units in \"PI radians\" and a size of 6 is displayed, along with a vector originating from the center pointing to the coordinates (3, 3√2) at a 45-degree angle. The polar plane is static, while the vector is dynamically added to the scene.", "code": "class PolarToPointExample(Scene):\n    def construct(self):\n        polarplane_pi = PolarPlane(azimuth_units=\"PI radians\", size=6)\n        polartopoint_vector = Vector(polarplane_pi.polar_to_point(3, PI/4))\n        self.add(polarplane_pi)\n        self.add(polartopoint_vector)", "code_sha1": "4d5f719122d2aa60f91c6a3d29a2c949301a255d"}
{"url": "https://docs.manim.community/en/stable/reference/manim.mobject.graphing.coordinate_systems.NumberPlane.html", "depth": 1, "instruction": "A teal NumberPlane with a stroke width of 4 and 60% opacity is displayed as the background of the scene.", "code": "from manim import *\n\nclass NumberPlaneExample(Scene):\n    def construct(self):\n        number_plane = NumberPlane(\n            background_line_style={\n                \"stroke_color\": TEAL,\n                \"stroke_width\": 4,\n                \"stroke_opacity\": 0.6\n            }\n        )\n        self.add(number_plane)", "code_sha1": "1b203e1efe7bddbb1821b53d94da20fed7fb1d52"}
{"url": "https://docs.manim.community/en/stable/reference/manim.mobject.graphing.coordinate_systems.NumberPlane.html", "depth": 1, "instruction": "The scene displays two number planes: the first, positioned left, has a width of 5 units and height of 2 units, while the second, positioned right, has the same width but a height of 4 units. Both planes are centered vertically, with the left plane lower than the right.", "code": "from manim import *\n\nclass NumberPlaneScaled(Scene):\n    def construct(self):\n        number_plane = NumberPlane(\n            x_range=(-4, 11, 1),\n            y_range=(-3, 3, 1),\n            x_length=5,\n            y_length=2,\n        ).move_to(LEFT*3)\n\n        number_plane_scaled_y = NumberPlane(\n            x_range=(-4, 11, 1),\n            x_length=5,\n            y_length=4,\n        ).move_to(RIGHT*3)\n\n        self.add(number_plane)\n        self.add(number_plane_scaled_y)", "code_sha1": "15c87710b83c2e3697de5207d2b5c296bcb2b6af"}
{"url": "https://docs.manim.community/en/stable/reference/manim.mobject.graphing.coordinate_systems.NumberPlane.html", "depth": 1, "instruction": "A teal NumberPlane with a stroke width of 4 and 60% opacity is displayed as the background of the scene.", "code": "class NumberPlaneExample(Scene):\n    def construct(self):\n        number_plane = NumberPlane(\n            background_line_style={\n                \"stroke_color\": TEAL,\n                \"stroke_width\": 4,\n                \"stroke_opacity\": 0.6\n            }\n        )\n        self.add(number_plane)", "code_sha1": "9c7a56a5801becc8ea4691769dd17f8c381834b7"}
{"url": "https://docs.manim.community/en/stable/reference/manim.mobject.graphing.coordinate_systems.NumberPlane.html", "depth": 1, "instruction": "The scene displays two number planes: the first, positioned left, has a width of 5 units and height of 2 units, while the second, positioned right, has the same width but a height of 4 units. Both planes are visually distinct, showcasing different vertical scales.", "code": "class NumberPlaneScaled(Scene):\n    def construct(self):\n        number_plane = NumberPlane(\n            x_range=(-4, 11, 1),\n            y_range=(-3, 3, 1),\n            x_length=5,\n            y_length=2,\n        ).move_to(LEFT*3)\n\n        number_plane_scaled_y = NumberPlane(\n            x_range=(-4, 11, 1),\n            x_length=5,\n            y_length=4,\n        ).move_to(RIGHT*3)\n\n        self.add(number_plane)\n        self.add(number_plane_scaled_y)", "code_sha1": "f68086e14480268695c59139327f3e90c54c21b6"}
{"url": "https://docs.manim.community/en/stable/reference/manim.mobject.graphing.coordinate_systems.PolarPlane.html", "depth": 1, "instruction": "A polar coordinate plane with a radius of 6 units is displayed, featuring azimuth labels in \"PI radians\" and a font size of 33.6. The coordinate grid is visible, enhancing the visual clarity of the polar system.", "code": "from manim import *\n\nclass PolarPlaneExample(Scene):\n    def construct(self):\n        polarplane_pi = PolarPlane(\n            azimuth_units=\"PI radians\",\n            size=6,\n            azimuth_label_font_size=33.6,\n            radius_config={\"font_size\": 33.6},\n        ).add_coordinates()\n        self.add(polarplane_pi)", "code_sha1": "b50b39cf6c1e44fad49cb8f3812a8cf4b7a475ba"}
{"url": "https://docs.manim.community/en/stable/reference/manim.mobject.graphing.coordinate_systems.PolarPlane.html", "depth": 1, "instruction": "A PolarPlane is displayed with a size of 6, featuring azimuth units labeled in \"PI radians\" and coordinates added. The azimuth labels and radius labels are both set to a font size of 33.6. The scene showcases a clear, labeled polar coordinate system without animations or camera operations.", "code": "class PolarPlaneExample(Scene):\n    def construct(self):\n        polarplane_pi = PolarPlane(\n            azimuth_units=\"PI radians\",\n            size=6,\n            azimuth_label_font_size=33.6,\n            radius_config={\"font_size\": 33.6},\n        ).add_coordinates()\n        self.add(polarplane_pi)", "code_sha1": "5b85df752831442e75736ab8523e74c1dd3aba84"}
{"url": "https://docs.manim.community/en/stable/reference/manim.mobject.graphing.coordinate_systems.ThreeDAxes.html", "depth": 1, "instruction": "A 3D scene displays a set of axes with labeled x, y, and z axes. The x-axis label is larger (0.7 scale) and positioned prominently, while the y and z-axis labels are smaller (0.45 scale). The camera is oriented at an angle, enhancing the 3D perspective.", "code": "from manim import *\n\nclass GetAxisLabelsExample(ThreeDScene):\n    def construct(self):\n        self.set_camera_orientation(phi=2*PI/5, theta=PI/5)\n        axes = ThreeDAxes()\n        labels = axes.get_axis_labels(\n            Text(\"x-axis\").scale(0.7), Text(\"y-axis\").scale(0.45), Text(\"z-axis\").scale(0.45)\n        )\n        self.add(axes, labels)", "code_sha1": "60bb728c8123bfe666a9f5b4167677d2cd010b82"}
{"url": "https://docs.manim.community/en/stable/reference/manim.mobject.graphing.coordinate_systems.ThreeDAxes.html", "depth": 1, "instruction": "A 3D scene displays a set of axes with a labeled y-axis, featuring a \"y-label\" in LaTeX format. The camera is positioned at an angle (phi = 72° and theta = 36°), showcasing the axes in perspective. The y-label is placed near the y-axis, enhancing clarity in the 3D space.", "code": "from manim import *\n\nclass GetYAxisLabelExample(ThreeDScene):\n    def construct(self):\n        ax = ThreeDAxes()\n        lab = ax.get_y_axis_label(Tex(\"$y$-label\"))\n        self.set_camera_orientation(phi=2*PI/5, theta=PI/5)\n        self.add(ax, lab)", "code_sha1": "ce53f6e5619dfb6ac98d5d3f89264eba9d60c0ad"}
{"url": "https://docs.manim.community/en/stable/reference/manim.mobject.graphing.coordinate_systems.ThreeDAxes.html", "depth": 1, "instruction": "A 3D coordinate system is displayed with labeled axes, featuring a prominent \"$z$-label\" positioned along the z-axis. The camera is oriented at an angle, providing a dynamic perspective of the axes. The axes are rendered in standard colors, enhancing visibility and clarity.", "code": "from manim import *\n\nclass GetZAxisLabelExample(ThreeDScene):\n    def construct(self):\n        ax = ThreeDAxes()\n        lab = ax.get_z_axis_label(Tex(\"$z$-label\"))\n        self.set_camera_orientation(phi=2*PI/5, theta=PI/5)\n        self.add(ax, lab)", "code_sha1": "1f811f4a9c6c55177ee7b2e4675edbd32261aa42"}
{"url": "https://docs.manim.community/en/stable/reference/manim.mobject.graphing.coordinate_systems.ThreeDAxes.html", "depth": 1, "instruction": "A 3D scene displays a set of axes with labeled x, y, and z axes. The x-axis label is a scaled Text object (\"x-axis\") at 0.7 size, while the y and z-axis labels are smaller at 0.45 size. The camera is oriented at a specific angle, enhancing the 3D perspective.", "code": "class GetAxisLabelsExample(ThreeDScene):\n    def construct(self):\n        self.set_camera_orientation(phi=2*PI/5, theta=PI/5)\n        axes = ThreeDAxes()\n        labels = axes.get_axis_labels(\n            Text(\"x-axis\").scale(0.7), Text(\"y-axis\").scale(0.45), Text(\"z-axis\").scale(0.45)\n        )\n        self.add(axes, labels)", "code_sha1": "c354ec9757b2ff5d0502e2419811340e53e0e11f"}
{"url": "https://docs.manim.community/en/stable/reference/manim.mobject.graphing.coordinate_systems.ThreeDAxes.html", "depth": 1, "instruction": "A 3D scene displays a set of axes with a labeled y-axis, featuring a \"y-label\" in LaTeX format. The camera is positioned at an angle (phi = 72° and theta = 36°), providing a dynamic perspective of the axes and label. The axes are rendered in standard colors, while the label is distinctively highlighted.", "code": "class GetYAxisLabelExample(ThreeDScene):\n    def construct(self):\n        ax = ThreeDAxes()\n        lab = ax.get_y_axis_label(Tex(\"$y$-label\"))\n        self.set_camera_orientation(phi=2*PI/5, theta=PI/5)\n        self.add(ax, lab)", "code_sha1": "5a6ec853c3d9f07ad5914a6f4de6ea120eb86fd3"}
{"url": "https://docs.manim.community/en/stable/reference/manim.mobject.graphing.coordinate_systems.ThreeDAxes.html", "depth": 1, "instruction": "A 3D coordinate system is displayed with axes labeled, including a prominent \"$z$-label\" positioned along the z-axis. The camera is oriented at an angle, providing a dynamic perspective of the axes.", "code": "class GetZAxisLabelExample(ThreeDScene):\n    def construct(self):\n        ax = ThreeDAxes()\n        lab = ax.get_z_axis_label(Tex(\"$z$-label\"))\n        self.set_camera_orientation(phi=2*PI/5, theta=PI/5)\n        self.add(ax, lab)", "code_sha1": "404e0ff3a61be0df7e24333b21ad12e67af13a30"}
{"url": "https://docs.manim.community/en/stable/reference/manim.mobject.graphing.functions.FunctionGraph.html", "depth": 1, "instruction": "The scene displays three function graphs: a red cosine wave, a blue sine wave, and a green sine wave positioned at (0, 1, 0). The cosine wave spans the entire scene, while the sine waves are shorter, with the green wave limited to the x-range of [-4, 4]. All graphs are smoothly rendered without animations.", "code": "from manim import *\n\nclass ExampleFunctionGraph(Scene):\n    def construct(self):\n        cos_func = FunctionGraph(\n            lambda t: np.cos(t) + 0.5 * np.cos(7 * t) + (1 / 7) * np.cos(14 * t),\n            color=RED,\n        )\n\n        sin_func_1 = FunctionGraph(\n            lambda t: np.sin(t) + 0.5 * np.sin(7 * t) + (1 / 7) * np.sin(14 * t),\n            color=BLUE,\n        )\n\n        sin_func_2 = FunctionGraph(\n            lambda t: np.sin(t) + 0.5 * np.sin(7 * t) + (1 / 7) * np.sin(14 * t),\n            x_range=[-4, 4],\n            color=GREEN,\n        ).move_to([0, 1, 0])\n\n        self.add(cos_func, sin_func_1, sin_func_2)", "code_sha1": "4a1d89e26a9abe0e5900dd54d3b089000926f7dc"}
{"url": "https://docs.manim.community/en/stable/reference/manim.mobject.graphing.functions.FunctionGraph.html", "depth": 1, "instruction": "Three parametric function graphs are displayed: a red cosine wave, a blue sine wave, and a green sine wave (shifted up by 1 unit). The graphs span the scene horizontally, with the green sine wave limited to the x-range of [-4, 4]. All functions are added simultaneously without animations.", "code": "class ExampleFunctionGraph(Scene):\n    def construct(self):\n        cos_func = FunctionGraph(\n            lambda t: np.cos(t) + 0.5 * np.cos(7 * t) + (1 / 7) * np.cos(14 * t),\n            color=RED,\n        )\n\n        sin_func_1 = FunctionGraph(\n            lambda t: np.sin(t) + 0.5 * np.sin(7 * t) + (1 / 7) * np.sin(14 * t),\n            color=BLUE,\n        )\n\n        sin_func_2 = FunctionGraph(\n            lambda t: np.sin(t) + 0.5 * np.sin(7 * t) + (1 / 7) * np.sin(14 * t),\n            x_range=[-4, 4],\n            color=GREEN,\n        ).move_to([0, 1, 0])\n\n        self.add(cos_func, sin_func_1, sin_func_2)", "code_sha1": "e7e6213f2cde29a52bf405b066c942aeff3485e0"}
{"url": "https://docs.manim.community/en/stable/reference/manim.mobject.graphing.functions.ImplicitFunction.html", "depth": 1, "instruction": "A yellow implicit function graph is displayed on a number plane, showcasing a mathematical curve defined by the equation \\(xy^2 - x^2y - 2 = 0\\). The graph is smoothly rendered, emphasizing its shape against the grid of the number plane.", "code": "from manim import *\n\nclass ImplicitFunctionExample(Scene):\n    def construct(self):\n        graph = ImplicitFunction(\n            lambda x, y: x * y ** 2 - x ** 2 * y - 2,\n            color=YELLOW\n        )\n        self.add(NumberPlane(), graph)", "code_sha1": "89047deec9e8039e5415d083dc8523a0f1927ae0"}
{"url": "https://docs.manim.community/en/stable/reference/manim.mobject.graphing.functions.ImplicitFunction.html", "depth": 1, "instruction": "A yellow implicit function graph is displayed on a number plane, showcasing a mathematical curve defined by the equation \\(x \\cdot y^2 - x^2 \\cdot y - 2 = 0\\). The graph is centered and rendered with smooth curves, emphasizing its mathematical properties against the grid background.", "code": "class ImplicitFunctionExample(Scene):\n    def construct(self):\n        graph = ImplicitFunction(\n            lambda x, y: x * y ** 2 - x ** 2 * y - 2,\n            color=YELLOW\n        )\n        self.add(NumberPlane(), graph)", "code_sha1": "2807beb751b85888f4327d9895dd08fbe56d11f5"}
{"url": "https://docs.manim.community/en/stable/reference/manim.mobject.graphing.functions.ParametricFunction.html", "depth": 1, "instruction": "A red, scaled parametric curve representing the function \\( (\\sin(2t), \\sin(3t), 0) \\) is displayed in a 3D scene, with no fill opacity, emphasizing its outline against a plain background.", "code": "from manim import *\n\nclass PlotParametricFunction(Scene):\n    def func(self, t):\n        return (np.sin(2 * t), np.sin(3 * t), 0)\n\n    def construct(self):\n        func = ParametricFunction(self.func, t_range = (0, TAU), fill_opacity=0).set_color(RED)\n        self.add(func.scale(3))", "code_sha1": "201da3fa6fe0f2937c731087214a39082c1f4b86"}
{"url": "https://docs.manim.community/en/stable/reference/manim.mobject.graphing.functions.ParametricFunction.html", "depth": 1, "instruction": "A 3D parametric spring curve in red spirals upward, displayed against a 3D axes system. The camera orbits at a high angle (80°) and a slight horizontal tilt (-60°), creating a dynamic perspective. The scene holds still for a moment, allowing viewers to appreciate the structure.", "code": "from manim import *\n\nclass ThreeDParametricSpring(ThreeDScene):\n    def construct(self):\n        curve1 = ParametricFunction(\n            lambda u: (\n                1.2 * np.cos(u),\n                1.2 * np.sin(u),\n                u * 0.05\n            ), color=RED, t_range = (-3*TAU, 5*TAU, 0.01)\n        ).set_shade_in_3d(True)\n        axes = ThreeDAxes()\n        self.add(axes, curve1)\n        self.set_camera_orientation(phi=80 * DEGREES, theta=-60 * DEGREES)\n        self.wait()", "code_sha1": "ac64afe14ce134abfdc414b3379f47983c36bfa8"}
{"url": "https://docs.manim.community/en/stable/reference/manim.mobject.graphing.functions.ParametricFunction.html", "depth": 1, "instruction": "Two NumberPlanes are displayed side by side; the left shows a red curve representing a discontinuous function, while the right shows a green curve accurately depicting the same function with discontinuities at x = -2 and x = 2. Both axes are labeled, and the curves are plotted simultaneously without animations.", "code": "from manim import *\n\nclass DiscontinuousExample(Scene):\n    def construct(self):\n        ax1 = NumberPlane((-3, 3), (-4, 4))\n        ax2 = NumberPlane((-3, 3), (-4, 4))\n        VGroup(ax1, ax2).arrange()\n        discontinuous_function = lambda x: (x ** 2 - 2) / (x ** 2 - 4)\n        incorrect = ax1.plot(discontinuous_function, color=RED)\n        correct = ax2.plot(\n            discontinuous_function,\n            discontinuities=[-2, 2],  # discontinuous points\n            dt=0.1,  # left and right tolerance of discontinuity\n            color=GREEN,\n        )\n        self.add(ax1, ax2, incorrect, correct)", "code_sha1": "7568677d91cbe0b78f9015037254775d241e507f"}
{"url": "https://docs.manim.community/en/stable/reference/manim.mobject.graphing.functions.ParametricFunction.html", "depth": 1, "instruction": "A red, scaled-up parametric curve representing the function \\( (\\sin(2t), \\sin(3t), 0) \\) is displayed in a 3D scene, with no fill opacity, emphasizing its outline.", "code": "class PlotParametricFunction(Scene):\n    def func(self, t):\n        return (np.sin(2 * t), np.sin(3 * t), 0)\n\n    def construct(self):\n        func = ParametricFunction(self.func, t_range = (0, TAU), fill_opacity=0).set_color(RED)\n        self.add(func.scale(3))", "code_sha1": "ce1a8eb277cb6048940a8fbf3a5a5ab3180c185d"}
{"url": "https://docs.manim.community/en/stable/reference/manim.mobject.graphing.functions.ParametricFunction.html", "depth": 1, "instruction": "A 3D parametric spring is displayed in red, spiraling upwards with a smooth curve, set against a ThreeDAxes backdrop. The camera is oriented at an elevation of 80 degrees and a horizontal angle of -60 degrees, creating a dynamic perspective. The scene holds still for a moment, allowing for observation.", "code": "class ThreeDParametricSpring(ThreeDScene):\n    def construct(self):\n        curve1 = ParametricFunction(\n            lambda u: (\n                1.2 * np.cos(u),\n                1.2 * np.sin(u),\n                u * 0.05\n            ), color=RED, t_range = (-3*TAU, 5*TAU, 0.01)\n        ).set_shade_in_3d(True)\n        axes = ThreeDAxes()\n        self.add(axes, curve1)\n        self.set_camera_orientation(phi=80 * DEGREES, theta=-60 * DEGREES)\n        self.wait()", "code_sha1": "31081aefe55a7dd67e41a10edaf2d1dc86794885"}
{"url": "https://docs.manim.community/en/stable/reference/manim.mobject.graphing.functions.ParametricFunction.html", "depth": 1, "instruction": "The scene displays two overlapping NumberPlanes, one with a red curve representing an incorrect plot of a discontinuous function and another with a green curve accurately depicting the function's discontinuities at x = -2 and x = 2. Both axes are centered, and the curves are plotted simultaneously without animations.", "code": "class DiscontinuousExample(Scene):\n    def construct(self):\n        ax1 = NumberPlane((-3, 3), (-4, 4))\n        ax2 = NumberPlane((-3, 3), (-4, 4))\n        VGroup(ax1, ax2).arrange()\n        discontinuous_function = lambda x: (x ** 2 - 2) / (x ** 2 - 4)\n        incorrect = ax1.plot(discontinuous_function, color=RED)\n        correct = ax2.plot(\n            discontinuous_function,\n            discontinuities=[-2, 2],  # discontinuous points\n            dt=0.1,  # left and right tolerance of discontinuity\n            color=GREEN,\n        )\n        self.add(ax1, ax2, incorrect, correct)", "code_sha1": "fd3984eddcd9e08b673045a37c025160c0477600"}
{"url": "https://docs.manim.community/en/stable/reference/manim.mobject.graphing.number_line.NumberLine.html", "depth": 1, "instruction": "The scene displays four vertically arranged blue NumberLines with varying properties: the first has standard ticks and numbers, the second features elongated ticks at -2 and 4 with a red number at 4, the third shows decimal numbers, and the fourth is rotated 10 degrees with a tip. Each line is spaced evenly.", "code": "from manim import *\n\nclass NumberLineExample(Scene):\n    def construct(self):\n        l0 = NumberLine(\n            x_range=[-10, 10, 2],\n            length=10,\n            color=BLUE,\n            include_numbers=True,\n            label_direction=UP,\n        )\n\n        l1 = NumberLine(\n            x_range=[-10, 10, 2],\n            unit_size=0.5,\n            numbers_with_elongated_ticks=[-2, 4],\n            include_numbers=True,\n            font_size=24,\n        )\n        num6 = l1.numbers[8]\n        num6.set_color(RED)\n\n        l2 = NumberLine(\n            x_range=[-2.5, 2.5 + 0.5, 0.5],\n            length=12,\n            decimal_number_config={\"num_decimal_places\": 2},\n            include_numbers=True,\n        )\n\n        l3 = NumberLine(\n            x_range=[-5, 5 + 1, 1],\n            length=6,\n            include_tip=True,\n            include_numbers=True,\n            rotation=10 * DEGREES,\n        )\n\n        line_group = VGroup(l0, l1, l2, l3).arrange(DOWN, buff=1)\n        self.add(line_group)", "code_sha1": "abbe0a670b20ebfee487cc0ca2a47f46e0904012"}
{"url": "https://docs.manim.community/en/stable/reference/manim.mobject.graphing.number_line.NumberLine.html", "depth": 1, "instruction": "A horizontal NumberLine is displayed, with points at coordinates (0,0,0), (1,0,0), (2,0,0), and (3,0,0) marked along it. Each point is represented as a dot, positioned at their respective x-values, with no animations or camera operations applied.", "code": "from manim import NumberLine\nnumber_line = NumberLine()\nnumber_line.number_to_point(0)\narray([0., 0., 0.])\nnumber_line.number_to_point(1)\narray([1., 0., 0.])\nnumber_line @ 1\narray([1., 0., 0.])\nnumber_line.number_to_point([1, 2, 3])\narray([[1., 0., 0.],\n       [2., 0., 0.],\n       [3., 0., 0.]])", "code_sha1": "199266da97c0177e37de6189b1d1e40d74908a14"}
{"url": "https://docs.manim.community/en/stable/reference/manim.mobject.graphing.number_line.NumberLine.html", "depth": 1, "instruction": "A horizontal number line is displayed, with points marked at 0.0, 1.0, and 0.5, 1.0, 1.5, visually representing their corresponding float values. The points are positioned along the line, with labels indicating their values. No animations or camera operations are applied.", "code": "from manim import NumberLine\nnumber_line = NumberLine()\nnumber_line.point_to_number((0, 0, 0))\nnp.float64(0.0)\nnumber_line.point_to_number((1, 0, 0))\nnp.float64(1.0)\nnumber_line.point_to_number([[0.5, 0, 0], [1, 0, 0], [1.5, 0, 0]])\narray([0.5, 1. , 1.5])", "code_sha1": "cf58dca217ba822fab46de3e23a85c94d589ca98"}
{"url": "https://docs.manim.community/en/stable/reference/manim.mobject.graphing.number_line.NumberLine.html", "depth": 1, "instruction": "The scene displays four vertically arranged blue NumberLines with varying properties: the first has standard ticks and numbers, the second features elongated ticks at -2 and 4 with a red number, the third shows decimal numbers, and the fourth is rotated 10 degrees with a tip. Each line is spaced evenly.", "code": "class NumberLineExample(Scene):\n    def construct(self):\n        l0 = NumberLine(\n            x_range=[-10, 10, 2],\n            length=10,\n            color=BLUE,\n            include_numbers=True,\n            label_direction=UP,\n        )\n\n        l1 = NumberLine(\n            x_range=[-10, 10, 2],\n            unit_size=0.5,\n            numbers_with_elongated_ticks=[-2, 4],\n            include_numbers=True,\n            font_size=24,\n        )\n        num6 = l1.numbers[8]\n        num6.set_color(RED)\n\n        l2 = NumberLine(\n            x_range=[-2.5, 2.5 + 0.5, 0.5],\n            length=12,\n            decimal_number_config={\"num_decimal_places\": 2},\n            include_numbers=True,\n        )\n\n        l3 = NumberLine(\n            x_range=[-5, 5 + 1, 1],\n            length=6,\n            include_tip=True,\n            include_numbers=True,\n            rotation=10 * DEGREES,\n        )\n\n        line_group = VGroup(l0, l1, l2, l3).arrange(DOWN, buff=1)\n        self.add(line_group)", "code_sha1": "78c240f32ed00bc4572f89cb43e5aaa464dcf458"}
{"url": "https://docs.manim.community/en/stable/reference/manim.mobject.graphing.probability.BarChart.html", "depth": 1, "instruction": "A vertical bar chart displays five bars with heights corresponding to values [-5, 40, -10, 20, -3], labeled \"one\" to \"five.\" The y-axis ranges from -20 to 50, with a height of 6 and width of 10. Bar labels are in a large font size of 48, positioned above each bar.", "code": "from manim import *\n\nclass BarChartExample(Scene):\n    def construct(self):\n        chart = BarChart(\n            values=[-5, 40, -10, 20, -3],\n            bar_names=[\"one\", \"two\", \"three\", \"four\", \"five\"],\n            y_range=[-20, 50, 10],\n            y_length=6,\n            x_length=10,\n            x_axis_config={\"font_size\": 36},\n        )\n\n        c_bar_lbls = chart.get_bar_labels(font_size=48)\n\n        self.add(chart, c_bar_lbls)", "code_sha1": "c00bf98d772e1de3724777eb94d42596f6f1de64"}
{"url": "https://docs.manim.community/en/stable/reference/manim.mobject.graphing.probability.BarChart.html", "depth": 1, "instruction": "A bar chart displays vertical bars representing values from -10 to 10, with a y-axis labeled from -10 to 10. The bars are initially in ascending order, then animated to reverse their heights. Each bar is annotated with its corresponding value in a font size of 24, maintaining the bar colors.", "code": "from manim import *\n\nclass ChangeBarValuesExample(Scene):\n    def construct(self):\n        values=[-10, -8, -6, -4, -2, 0, 2, 4, 6, 8, 10]\n\n        chart = BarChart(\n            values,\n            y_range=[-10, 10, 2],\n            y_axis_config={\"font_size\": 24},\n        )\n        self.add(chart)\n\n        chart.change_bar_values(list(reversed(values)))\n        self.add(chart.get_bar_labels(font_size=24))", "code_sha1": "c3c6ab59f68b6c264eaaf3e628e1cab94d894a26"}
{"url": "https://docs.manim.community/en/stable/reference/manim.mobject.graphing.probability.BarChart.html", "depth": 1, "instruction": "A BarChart with ten vertical bars, each labeled with descending values from 10 to 1, appears on screen. The bars are colored with a default scheme, while the labels are in white MathTex font, sized 36, positioned above each bar, and the scene is static without animations.", "code": "from manim import *\n\nclass GetBarLabelsExample(Scene):\n    def construct(self):\n        chart = BarChart(values=[10, 9, 8, 7, 6, 5, 4, 3, 2, 1], y_range=[0, 10, 1])\n\n        c_bar_lbls = chart.get_bar_labels(\n            color=WHITE, label_constructor=MathTex, font_size=36\n        )\n\n        self.add(chart, c_bar_lbls)", "code_sha1": "0e4043ef8ce87eadec15b5a750d40d8830876c4d"}
{"url": "https://docs.manim.community/en/stable/reference/manim.mobject.graphing.probability.BarChart.html", "depth": 1, "instruction": "A vertical bar chart displays five bars with varying heights corresponding to values [-5, 40, -10, 20, -3], labeled \"one\" to \"five.\" The y-axis ranges from -20 to 50, with a height of 6 and width of 10. Bar labels are in a large font size of 48, enhancing visibility.", "code": "class BarChartExample(Scene):\n    def construct(self):\n        chart = BarChart(\n            values=[-5, 40, -10, 20, -3],\n            bar_names=[\"one\", \"two\", \"three\", \"four\", \"five\"],\n            y_range=[-20, 50, 10],\n            y_length=6,\n            x_length=10,\n            x_axis_config={\"font_size\": 36},\n        )\n\n        c_bar_lbls = chart.get_bar_labels(font_size=48)\n\n        self.add(chart, c_bar_lbls)", "code_sha1": "f117322d60a35d79b8159cc1c9882c4303295149"}
{"url": "https://docs.manim.community/en/stable/reference/manim.mobject.graphing.probability.BarChart.html", "depth": 1, "instruction": "A bar chart displays vertical bars representing values from -10 to 10, with a y-axis labeled from -10 to 10. The bars are initially in ascending order, then animated to reverse their heights. Each bar is annotated with its corresponding value in a font size of 24, positioned above the bars.", "code": "class ChangeBarValuesExample(Scene):\n    def construct(self):\n        values=[-10, -8, -6, -4, -2, 0, 2, 4, 6, 8, 10]\n\n        chart = BarChart(\n            values,\n            y_range=[-10, 10, 2],\n            y_axis_config={\"font_size\": 24},\n        )\n        self.add(chart)\n\n        chart.change_bar_values(list(reversed(values)))\n        self.add(chart.get_bar_labels(font_size=24))", "code_sha1": "23c82d11e78d7246e4c570f83429689f1ed991c1"}
{"url": "https://docs.manim.community/en/stable/reference/manim.mobject.graphing.probability.BarChart.html", "depth": 1, "instruction": "A vertical bar chart displays ten bars in descending order from left to right, each labeled with corresponding values (1 to 10) in white MathTex font, size 36, positioned above the bars.", "code": "class GetBarLabelsExample(Scene):\n    def construct(self):\n        chart = BarChart(values=[10, 9, 8, 7, 6, 5, 4, 3, 2, 1], y_range=[0, 10, 1])\n\n        c_bar_lbls = chart.get_bar_labels(\n            color=WHITE, label_constructor=MathTex, font_size=36\n        )\n\n        self.add(chart, c_bar_lbls)", "code_sha1": "d45866fffe1fff140ea1453835fa234bc2d2928a"}
{"url": "https://docs.manim.community/en/stable/reference/manim.mobject.graphing.probability.SampleSpace.html", "depth": 1, "instruction": "Three rectangular sampling spaces are displayed side by side: a thick, fully opaque dark gray rectangle (poly1), a medium-thick, semi-transparent light gray rectangle (poly2), and a thin, mostly transparent rectangle (poly3) divided vertically into three sections colored black, white, and gray.", "code": "from manim import *\n\nclass ExampleSampleSpace(Scene):\n    def construct(self):\n        poly1 = SampleSpace(stroke_width=15, fill_opacity=1)\n        poly2 = SampleSpace(width=5, height=3, stroke_width=5, fill_opacity=0.5)\n        poly3 = SampleSpace(width=2, height=2, stroke_width=5, fill_opacity=0.1)\n        poly3.divide_vertically(p_list=np.array([0.37, 0.13, 0.5]), colors=[BLACK, WHITE, GRAY], vect=RIGHT)\n        poly_group = VGroup(poly1, poly2, poly3).arrange()\n        self.add(poly_group)", "code_sha1": "2f60720e03993352f5d955c007cd2e228379732a"}
{"url": "https://docs.manim.community/en/stable/reference/manim.mobject.graphing.probability.SampleSpace.html", "depth": 1, "instruction": "Three rectangular sampling spaces are displayed: a large opaque gray rectangle (stroke width 15), a medium semi-transparent gray rectangle (stroke width 5), and a small rectangle divided into three vertical sections (black, white, gray) with low opacity (stroke width 5). They are arranged horizontally in a group.", "code": "class ExampleSampleSpace(Scene):\n    def construct(self):\n        poly1 = SampleSpace(stroke_width=15, fill_opacity=1)\n        poly2 = SampleSpace(width=5, height=3, stroke_width=5, fill_opacity=0.5)\n        poly3 = SampleSpace(width=2, height=2, stroke_width=5, fill_opacity=0.1)\n        poly3.divide_vertically(p_list=np.array([0.37, 0.13, 0.5]), colors=[BLACK, WHITE, GRAY], vect=RIGHT)\n        poly_group = VGroup(poly1, poly2, poly3).arrange()\n        self.add(poly_group)", "code_sha1": "b504204646099de6d7f9820edd54099be35233ad"}
{"url": "https://docs.manim.community/en/stable/reference/manim.mobject.logo.ManimBanner.html", "depth": 1, "instruction": "A dark-themed banner with light text is created and expanded, followed by a pause, then the banner is unwrapped, disappearing smoothly.", "code": "from manim import *\n\nclass DarkThemeBanner(Scene):\n    def construct(self):\n        banner = ManimBanner()\n        self.play(banner.create())\n        self.play(banner.expand())\n        self.wait()\n        self.play(Unwrite(banner))", "code_sha1": "6eaeb96f3987ef216209b6d875af76871e340632"}
{"url": "https://docs.manim.community/en/stable/reference/manim.mobject.logo.ManimBanner.html", "depth": 1, "instruction": "A light-themed Manim logo banner appears against a light background (#ece6e2), with dark text. The banner is created, expands smoothly, remains visible briefly, and then is unwrapped, disappearing from the scene.", "code": "from manim import *\n\nclass LightThemeBanner(Scene):\n    def construct(self):\n        self.camera.background_color = \"#ece6e2\"\n        banner = ManimBanner(dark_theme=False)\n        self.play(banner.create())\n        self.play(banner.expand())\n        self.wait()\n        self.play(Unwrite(banner))", "code_sha1": "7a1909ce3f51fe3d8d89e2c98c9f8754357e0b70"}
{"url": "https://docs.manim.community/en/stable/reference/manim.mobject.logo.ManimBanner.html", "depth": 1, "instruction": "Three banners, each scaled to half size, are positioned vertically at -2, 0, and 2 units on the y-axis. They expand simultaneously: the first to the right, the second to the center, and the third to the left, creating a dynamic visual effect.", "code": "from manim import *\n\nclass ExpandDirections(Scene):\n    def construct(self):\n        banners = [ManimBanner().scale(0.5).shift(UP*x) for x in [-2, 0, 2]]\n        self.play(\n            banners[0].expand(direction=\"right\"),\n            banners[1].expand(direction=\"center\"),\n            banners[2].expand(direction=\"left\"),\n        )", "code_sha1": "0512dd7433e0d7f3591aba0bc24a0755723ea274"}
{"url": "https://docs.manim.community/en/stable/reference/manim.mobject.logo.ManimBanner.html", "depth": 1, "instruction": "A dark-themed banner with light text is created and expanded on screen, followed by a pause, then the banner is unwrapped, disappearing smoothly.", "code": "class DarkThemeBanner(Scene):\n    def construct(self):\n        banner = ManimBanner()\n        self.play(banner.create())\n        self.play(banner.expand())\n        self.wait()\n        self.play(Unwrite(banner))", "code_sha1": "dfc873b7fc48f649356073135d5034fa0ef22304"}
{"url": "https://docs.manim.community/en/stable/reference/manim.mobject.logo.ManimBanner.html", "depth": 1, "instruction": "A light-themed banner with dark text appears against a light gray background, expands into view, and then is unwrapped, disappearing smoothly. The scene includes a wait period after the expansion before the unwriting animation.", "code": "class LightThemeBanner(Scene):\n    def construct(self):\n        self.camera.background_color = \"#ece6e2\"\n        banner = ManimBanner(dark_theme=False)\n        self.play(banner.create())\n        self.play(banner.expand())\n        self.wait()\n        self.play(Unwrite(banner))", "code_sha1": "e7d4195a9c2f93f6491ca70b2b1c2627947fa991"}
{"url": "https://docs.manim.community/en/stable/reference/manim.mobject.logo.ManimBanner.html", "depth": 1, "instruction": "Three banners, each scaled to half size, are positioned vertically at -2, 0, and 2 units on the y-axis. They expand simultaneously: the top banner expands right, the middle expands center, and the bottom expands left, creating a dynamic visual effect.", "code": "class ExpandDirections(Scene):\n    def construct(self):\n        banners = [ManimBanner().scale(0.5).shift(UP*x) for x in [-2, 0, 2]]\n        self.play(\n            banners[0].expand(direction=\"right\"),\n            banners[1].expand(direction=\"center\"),\n            banners[2].expand(direction=\"left\"),\n        )", "code_sha1": "ffb350a4f39171e3ec50e77f70bc42e4293d805e"}
{"url": "https://docs.manim.community/en/stable/reference/manim.mobject.matrix.html", "depth": 1, "instruction": "Four matrices are displayed in a grid: a LaTeX matrix with symbols, an integer matrix with brackets, a decimal matrix with two decimal places, and a mixed mobject matrix with shapes and a math symbol. Each matrix is spaced evenly with a buffer of 2 units.", "code": "from manim import *\n\nclass MatrixExamples(Scene):\n    def construct(self):\n        m0 = Matrix([[\"\\\\pi\", 0], [-1, 1]])\n        m1 = IntegerMatrix([[1.5, 0.], [12, -1.3]],\n            left_bracket=\"(\",\n            right_bracket=\")\")\n        m2 = DecimalMatrix(\n            [[3.456, 2.122], [33.2244, 12.33]],\n            element_to_mobject_config={\"num_decimal_places\": 2},\n            left_bracket=r\"\\{\",\n            right_bracket=r\"\\}\")\n        m3 = MobjectMatrix(\n            [[Circle().scale(0.3), Square().scale(0.3)],\n            [MathTex(\"\\\\pi\").scale(2), Star().scale(0.3)]],\n            left_bracket=\"\\\\langle\",\n            right_bracket=\"\\\\rangle\")\n        g = Group(m0, m1, m2, m3).arrange_in_grid(buff=2)\n        self.add(g)", "code_sha1": "33a35f12fa82c51bbd0f7725594cf36f33027f82"}
{"url": "https://docs.manim.community/en/stable/reference/manim.mobject.matrix.html", "depth": 1, "instruction": "The scene displays a 2x2 matrix in the center, with the determinant text \"det = 3\" scaled down and positioned below the matrix. Both elements are added to the scene without animations, maintaining their default colors and sizes.", "code": "from manim import *\n\nclass DeterminantOfAMatrix(Scene):\n    def construct(self):\n        matrix = Matrix([\n            [2, 0],\n            [-1, 1]\n        ])\n\n        # scaling down the `det` string\n        det = get_det_text(matrix,\n                    determinant=3,\n                    initial_scale_factor=1)\n\n        # must add the matrix\n        self.add(matrix)\n        self.add(det)", "code_sha1": "568f122fad764f08f32bda377a02a7c242c1b340"}
{"url": "https://docs.manim.community/en/stable/reference/manim.mobject.matrix.html", "depth": 1, "instruction": "Four matrices are displayed in a grid: a LaTeX matrix with symbols, an integer matrix with brackets, a decimal matrix with two decimal places, and a mixed mobject matrix containing shapes and a math symbol. Each matrix is visually distinct, with appropriate scaling and spacing, arranged neatly with a buffer of 2 units between them.", "code": "class MatrixExamples(Scene):\n    def construct(self):\n        m0 = Matrix([[\"\\\\pi\", 0], [-1, 1]])\n        m1 = IntegerMatrix([[1.5, 0.], [12, -1.3]],\n            left_bracket=\"(\",\n            right_bracket=\")\")\n        m2 = DecimalMatrix(\n            [[3.456, 2.122], [33.2244, 12.33]],\n            element_to_mobject_config={\"num_decimal_places\": 2},\n            left_bracket=r\"\\{\",\n            right_bracket=r\"\\}\")\n        m3 = MobjectMatrix(\n            [[Circle().scale(0.3), Square().scale(0.3)],\n            [MathTex(\"\\\\pi\").scale(2), Star().scale(0.3)]],\n            left_bracket=\"\\\\langle\",\n            right_bracket=\"\\\\rangle\")\n        g = Group(m0, m1, m2, m3).arrange_in_grid(buff=2)\n        self.add(g)", "code_sha1": "d44d3e65afae5546626d63a0edc4195897f4ac9f"}
{"url": "https://docs.manim.community/en/stable/reference/manim.mobject.matrix.html", "depth": 1, "instruction": "A scene displays a 2x2 matrix with elements [2, 0] and [-1, 1] in the center, accompanied by a smaller \"det\" text indicating a determinant value of 3, both added to the scene without animations or camera operations.", "code": "class DeterminantOfAMatrix(Scene):\n    def construct(self):\n        matrix = Matrix([\n            [2, 0],\n            [-1, 1]\n        ])\n\n        # scaling down the `det` string\n        det = get_det_text(matrix,\n                    determinant=3,\n                    initial_scale_factor=1)\n\n        # must add the matrix\n        self.add(matrix)\n        self.add(det)", "code_sha1": "7cfa1f3eb4673c745d2438ea09a51e551bff97e5"}
{"url": "https://docs.manim.community/en/stable/reference/manim.mobject.matrix.DecimalMatrix.html", "depth": 1, "instruction": "A 2x2 matrix displaying the numbers 3.46, 2.12, 33.22, and 12, rounded to two decimal places, enclosed in curly brackets. The matrix is centered on the screen with default styling.", "code": "from manim import *\n\nclass DecimalMatrixExample(Scene):\n    def construct(self):\n        m0 = DecimalMatrix(\n            [[3.456, 2.122], [33.2244, 12]],\n            element_to_mobject_config={\"num_decimal_places\": 2},\n            left_bracket=\"\\\\{\",\n            right_bracket=\"\\\\}\")\n        self.add(m0)", "code_sha1": "196dec441d4437f979263fad58011fbd2198ca86"}
{"url": "https://docs.manim.community/en/stable/reference/manim.mobject.matrix.DecimalMatrix.html", "depth": 1, "instruction": "A 2x2 matrix displaying the rounded decimal values 3.46, 2.12, 33.22, and 12, enclosed in curly brackets, appears centered on the screen. The matrix elements are formatted with two decimal places.", "code": "class DecimalMatrixExample(Scene):\n    def construct(self):\n        m0 = DecimalMatrix(\n            [[3.456, 2.122], [33.2244, 12]],\n            element_to_mobject_config={\"num_decimal_places\": 2},\n            left_bracket=\"\\\\{\",\n            right_bracket=\"\\\\}\")\n        self.add(m0)", "code_sha1": "a6b601bd351fa1e987e6aacf423417463c53cf93"}
{"url": "https://docs.manim.community/en/stable/reference/manim.mobject.matrix.IntegerMatrix.html", "depth": 1, "instruction": "A matrix displaying the integers 4, 2, 42, and 12, enclosed in parentheses, appears centered on the screen with default styling.", "code": "from manim import *\n\nclass IntegerMatrixExample(Scene):\n    def construct(self):\n        m0 = IntegerMatrix(\n            [[3.7, 2], [42.2, 12]],\n            left_bracket=\"(\",\n            right_bracket=\")\")\n        self.add(m0)", "code_sha1": "b553f9d8dcea50e909e3b6a85af510235c2baf7a"}
{"url": "https://docs.manim.community/en/stable/reference/manim.mobject.matrix.IntegerMatrix.html", "depth": 1, "instruction": "A matrix displaying the integers 4, 2, 42, and 12, enclosed in parentheses, appears centered on the screen with default styling.", "code": "class IntegerMatrixExample(Scene):\n    def construct(self):\n        m0 = IntegerMatrix(\n            [[3.7, 2], [42.2, 12]],\n            left_bracket=\"(\",\n            right_bracket=\")\")\n        self.add(m0)", "code_sha1": "2389448130269ba68fa01ede70b26f7b41757d3c"}
{"url": "https://docs.manim.community/en/stable/reference/manim.mobject.matrix.Matrix.html", "depth": 1, "instruction": "The scene displays six matrices arranged in a grid, each with distinct properties: m0 has curly brackets, m1 features a surrounding rectangle on the second column, m2 uses parentheses, m3 employs angled brackets, m4 has red and green column colors, and m5 has red and green row colors. The matrices are spaced evenly with a buffer of 2.", "code": "from manim import *\n\nclass MatrixExamples(Scene):\n    def construct(self):\n        m0 = Matrix([[2, r\"\\pi\"], [-1, 1]])\n        m1 = Matrix([[2, 0, 4], [-1, 1, 5]],\n            v_buff=1.3,\n            h_buff=0.8,\n            bracket_h_buff=SMALL_BUFF,\n            bracket_v_buff=SMALL_BUFF,\n            left_bracket=r\"\\{\",\n            right_bracket=r\"\\}\")\n        m1.add(SurroundingRectangle(m1.get_columns()[1]))\n        m2 = Matrix([[2, 1], [-1, 3]],\n            element_alignment_corner=UL,\n            left_bracket=\"(\",\n            right_bracket=\")\")\n        m3 = Matrix([[2, 1], [-1, 3]],\n            left_bracket=r\"\\langle\",\n            right_bracket=r\"\\rangle\")\n        m4 = Matrix([[2, 1], [-1, 3]],\n        ).set_column_colors(RED, GREEN)\n        m5 = Matrix([[2, 1], [-1, 3]],\n        ).set_row_colors(RED, GREEN)\n        g = Group(\n            m0,m1,m2,m3,m4,m5\n        ).arrange_in_grid(buff=2)\n        self.add(g)", "code_sha1": "4025c6f84655a7238651f9d0ec2fbf350f7ad273"}
{"url": "https://docs.manim.community/en/stable/reference/manim.mobject.matrix.Matrix.html", "depth": 1, "instruction": "A scene displays a semi-transparent, colorful rectangle as a background, with three matrices arranged horizontally. The first matrix has individual entry backgrounds, the second has a unified background, and the third has no background. The matrices are spaced evenly with a buffer of 2 units.", "code": "from manim import *\n\nclass BackgroundRectanglesExample(Scene):\n    def construct(self):\n        background= Rectangle().scale(3.2)\n        background.set_fill(opacity=.5)\n        background.set_color([TEAL, RED, YELLOW])\n        self.add(background)\n        m0 = Matrix([[12, -30], [-1, 15]],\n            add_background_rectangles_to_entries=True)\n        m1 = Matrix([[2, 0], [-1, 1]],\n            include_background_rectangle=True)\n        m2 = Matrix([[12, -30], [-1, 15]])\n        g = Group(m0, m1, m2).arrange(buff=2)\n        self.add(g)", "code_sha1": "cb06c570ecec78cc15ba037e708a5c854aa6b8ef"}
{"url": "https://docs.manim.community/en/stable/reference/manim.mobject.matrix.Matrix.html", "depth": 1, "instruction": "The scene displays a matrix with elements \\(\\pi\\), 3, 1, and 5, where the first column is highlighted with a blue surrounding rectangle, while the matrix itself is added to the scene.", "code": "from manim import *\n\nclass GetBracketsExample(Scene):\n    def construct(self):\n        m0 = Matrix([[\"\\\\pi\", 3], [1, 5]])\n        bra = m0.get_brackets()\n        colors = [BLUE, GREEN]\n        for k in range(len(colors)):\n            bra[k].set_color(colors[k])\n        self.add(m0)", "code_sha1": "95ee8d757ff29c40ed72bcd998c4ffb0c93fa3d7"}
{"url": "https://docs.manim.community/en/stable/reference/manim.mobject.matrix.Matrix.html", "depth": 1, "instruction": "A matrix with entries \\(\\pi\\), 3, 1, and 5 is displayed, with the second column highlighted by a surrounding rectangle. The matrix is centered on the screen, and the rectangle animates in as the matrix is added to the scene.", "code": "from manim import *\n\nclass GetColumnsExample(Scene):\n    def construct(self):\n        m0 = Matrix([[r\"\\pi\", 3], [1, 5]])\n        m0.add(SurroundingRectangle(m0.get_columns()[1]))\n        self.add(m0)", "code_sha1": "1f0de062da030cc8ed55e33a664d903d0c770c7a"}
{"url": "https://docs.manim.community/en/stable/reference/manim.mobject.matrix.Matrix.html", "depth": 1, "instruction": "A 2x2 matrix is displayed with the entries colored in a sequence of blue, green, yellow, and red. The matrix is centered on the screen, and no animations or camera operations are applied.", "code": "from manim import *\n\nclass GetEntriesExample(Scene):\n    def construct(self):\n        m0 = Matrix([[2, 3], [1, 5]])\n        ent = m0.get_entries()\n        colors = [BLUE, GREEN, YELLOW, RED]\n        for k in range(len(colors)):\n            ent[k].set_color(colors[k])\n        self.add(m0)", "code_sha1": "f132bee3d679fc8964754213dca447aa62326d40"}
{"url": "https://docs.manim.community/en/stable/reference/manim.mobject.matrix.Matrix.html", "depth": 1, "instruction": "A matrix with two rows and two columns is displayed, where the second row is highlighted with a surrounding rectangle. The matrix elements include the symbols \"\\\\pi\" and numbers, with no specific colors or animations applied.", "code": "from manim import *\n\nclass GetRowsExample(Scene):\n    def construct(self):\n        m0 = Matrix([[\"\\\\pi\", 3], [1, 5]])\n        m0.add(SurroundingRectangle(m0.get_rows()[1]))\n        self.add(m0)", "code_sha1": "a672789b22cac4e6f1672c573d33dd08638416b5"}
{"url": "https://docs.manim.community/en/stable/reference/manim.mobject.matrix.Matrix.html", "depth": 1, "instruction": "A 2x2 matrix displaying \\(\\pi\\), 1, -1, and 3, with the first column colored red and blue, and the second column colored green, is added to the scene. The matrix is centered on the screen.", "code": "from manim import *\n\nclass SetColumnColorsExample(Scene):\n    def construct(self):\n        m0 = Matrix([[\"\\\\pi\", 1], [-1, 3]],\n        ).set_column_colors([RED,BLUE], GREEN)\n        self.add(m0)", "code_sha1": "174e17a4cbd700e11fa9f2f1c1dfe80c0ba471b9"}
{"url": "https://docs.manim.community/en/stable/reference/manim.mobject.matrix.Matrix.html", "depth": 1, "instruction": "A 2x2 matrix is displayed with the top row colored red and blue, respectively, while the entire matrix has a green background. The matrix is centered on the screen without any animations or camera operations.", "code": "from manim import *\n\nclass SetRowColorsExample(Scene):\n    def construct(self):\n        m0 = Matrix([[\"\\\\pi\", 1], [-1, 3]],\n        ).set_row_colors([RED,BLUE], GREEN)\n        self.add(m0)", "code_sha1": "90df523cfa0e39bfd870e1f7abcbe2f61d418cf2"}
{"url": "https://docs.manim.community/en/stable/reference/manim.mobject.matrix.Matrix.html", "depth": 1, "instruction": "The scene displays a grid of six matrices, each with distinct properties: m0 has curly brackets, m1 features a surrounding rectangle on the second column, m2 uses round brackets, m3 employs angled brackets, m4 colors the first column red and second green, while m5 colors the first row red and second green. The matrices are evenly spaced with a buffer of 2.", "code": "class MatrixExamples(Scene):\n    def construct(self):\n        m0 = Matrix([[2, r\"\\pi\"], [-1, 1]])\n        m1 = Matrix([[2, 0, 4], [-1, 1, 5]],\n            v_buff=1.3,\n            h_buff=0.8,\n            bracket_h_buff=SMALL_BUFF,\n            bracket_v_buff=SMALL_BUFF,\n            left_bracket=r\"\\{\",\n            right_bracket=r\"\\}\")\n        m1.add(SurroundingRectangle(m1.get_columns()[1]))\n        m2 = Matrix([[2, 1], [-1, 3]],\n            element_alignment_corner=UL,\n            left_bracket=\"(\",\n            right_bracket=\")\")\n        m3 = Matrix([[2, 1], [-1, 3]],\n            left_bracket=r\"\\langle\",\n            right_bracket=r\"\\rangle\")\n        m4 = Matrix([[2, 1], [-1, 3]],\n        ).set_column_colors(RED, GREEN)\n        m5 = Matrix([[2, 1], [-1, 3]],\n        ).set_row_colors(RED, GREEN)\n        g = Group(\n            m0,m1,m2,m3,m4,m5\n        ).arrange_in_grid(buff=2)\n        self.add(g)", "code_sha1": "badc02859b1f0ff4473060f1d9ed64d4016486bc"}
{"url": "https://docs.manim.community/en/stable/reference/manim.mobject.matrix.Matrix.html", "depth": 1, "instruction": "The scene displays a semi-transparent, colorful rectangle as a background, with three matrices arranged horizontally, each with distinct background rectangles: the first matrix has individual entry backgrounds, the second has a single background, and the third has no background. The matrices are spaced evenly with a buffer of 2 units.", "code": "class BackgroundRectanglesExample(Scene):\n    def construct(self):\n        background= Rectangle().scale(3.2)\n        background.set_fill(opacity=.5)\n        background.set_color([TEAL, RED, YELLOW])\n        self.add(background)\n        m0 = Matrix([[12, -30], [-1, 15]],\n            add_background_rectangles_to_entries=True)\n        m1 = Matrix([[2, 0], [-1, 1]],\n            include_background_rectangle=True)\n        m2 = Matrix([[12, -30], [-1, 15]])\n        g = Group(m0, m1, m2).arrange(buff=2)\n        self.add(g)", "code_sha1": "4bca2989cc97e26b9f0665f96596c4a4bd2daf12"}
{"url": "https://docs.manim.community/en/stable/reference/manim.mobject.matrix.Matrix.html", "depth": 1, "instruction": "A matrix displaying elements \\(\\pi\\), 3, 1, and 5, with the first column bracketed in blue and the second in green, is added to the scene. The brackets are visually distinct, enhancing the matrix's structure.", "code": "class GetBracketsExample(Scene):\n    def construct(self):\n        m0 = Matrix([[\"\\\\pi\", 3], [1, 5]])\n        bra = m0.get_brackets()\n        colors = [BLUE, GREEN]\n        for k in range(len(colors)):\n            bra[k].set_color(colors[k])\n        self.add(m0)", "code_sha1": "af9aeb9fe4c7b42a4e66a76be9d6522db7068e15"}
{"url": "https://docs.manim.community/en/stable/reference/manim.mobject.matrix.Matrix.html", "depth": 1, "instruction": "A matrix with entries \\(\\pi\\), 3, 1, and 5 is displayed, with the second column highlighted by a surrounding rectangle. The matrix is centered on the screen, and no animations or camera operations are applied.", "code": "class GetColumnsExample(Scene):\n    def construct(self):\n        m0 = Matrix([[r\"\\pi\", 3], [1, 5]])\n        m0.add(SurroundingRectangle(m0.get_columns()[1]))\n        self.add(m0)", "code_sha1": "a830f0521f456b65f6a0916102c94fed3274702d"}
{"url": "https://docs.manim.community/en/stable/reference/manim.mobject.matrix.Matrix.html", "depth": 1, "instruction": "A 2x2 matrix is displayed with the entries colored in a sequence of blue, green, yellow, and red. The matrix is centered on the screen, and no animations or camera operations are applied.", "code": "class GetEntriesExample(Scene):\n    def construct(self):\n        m0 = Matrix([[2, 3], [1, 5]])\n        ent = m0.get_entries()\n        colors = [BLUE, GREEN, YELLOW, RED]\n        for k in range(len(colors)):\n            ent[k].set_color(colors[k])\n        self.add(m0)", "code_sha1": "3e381fb6efe4dc7ebe1cb5be3368af2d16e61201"}
{"url": "https://docs.manim.community/en/stable/reference/manim.mobject.matrix.Matrix.html", "depth": 1, "instruction": "A matrix displaying two rows, with the second row highlighted by a surrounding rectangle. The matrix elements include \"\\\\pi\", 3, 1, and 5, rendered in default colors and sizes, positioned centrally in the scene.", "code": "class GetRowsExample(Scene):\n    def construct(self):\n        m0 = Matrix([[\"\\\\pi\", 3], [1, 5]])\n        m0.add(SurroundingRectangle(m0.get_rows()[1]))\n        self.add(m0)", "code_sha1": "f3d0fd9e04c38c3f9c39c340310d0f67713dd758"}
{"url": "https://docs.manim.community/en/stable/reference/manim.mobject.matrix.Matrix.html", "depth": 1, "instruction": "A 2x2 matrix displaying the elements \\(\\pi\\), 1, -1, and 3, with the first column colored red and blue, and the second column colored green. The matrix is added to the scene without any animations or camera operations.", "code": "class SetColumnColorsExample(Scene):\n    def construct(self):\n        m0 = Matrix([[\"\\\\pi\", 1], [-1, 3]],\n        ).set_column_colors([RED,BLUE], GREEN)\n        self.add(m0)", "code_sha1": "b594bdc39af2af57c642188c2ea0977f1b15069f"}
{"url": "https://docs.manim.community/en/stable/reference/manim.mobject.matrix.Matrix.html", "depth": 1, "instruction": "A 2x2 matrix is displayed with the top row colored red and blue, and the bottom row colored green. The matrix entries are formatted with LaTeX, showing \\(\\pi\\), 1, -1, and 3. The matrix is centered on the screen without any animations or camera operations.", "code": "class SetRowColorsExample(Scene):\n    def construct(self):\n        m0 = Matrix([[\"\\\\pi\", 1], [-1, 3]],\n        ).set_row_colors([RED,BLUE], GREEN)\n        self.add(m0)", "code_sha1": "6b6ef2f2317abffe7e040459668f11385b71a201"}
{"url": "https://docs.manim.community/en/stable/reference/manim.mobject.matrix.MobjectMatrix.html", "depth": 1, "instruction": "A 2x2 matrix displays a small circle, small square, large π symbol, and small star, arranged in a grid. The circle, square, and star are scaled to 0.3, while the π symbol is scaled to 2, creating a visually striking contrast. The matrix is added to the scene without any animations.", "code": "from manim import *\n\nclass MobjectMatrixExample(Scene):\n    def construct(self):\n        a = Circle().scale(0.3)\n        b = Square().scale(0.3)\n        c = MathTex(\"\\\\pi\").scale(2)\n        d = Star().scale(0.3)\n        m0 = MobjectMatrix([[a, b], [c, d]])\n        self.add(m0)", "code_sha1": "7e66a9826677838909720b7047efb8c6844d0af2"}
{"url": "https://docs.manim.community/en/stable/reference/manim.mobject.matrix.MobjectMatrix.html", "depth": 1, "instruction": "A 2x2 matrix displays a small circle, small square, large pi symbol, and small star, arranged in a grid. The circle, square, and star are scaled to 0.3, while the pi symbol is scaled to 2. The matrix is added to the scene without any animations or camera operations.", "code": "class MobjectMatrixExample(Scene):\n    def construct(self):\n        a = Circle().scale(0.3)\n        b = Square().scale(0.3)\n        c = MathTex(\"\\\\pi\").scale(2)\n        d = Star().scale(0.3)\n        m0 = MobjectMatrix([[a, b], [c, d]])\n        self.add(m0)", "code_sha1": "2a4fdf4b7b44c8a9af023f115896e93a2a63d93f"}
{"url": "https://docs.manim.community/en/stable/reference/manim.mobject.mobject.html", "depth": 1, "instruction": "A circle with a \"hello!\" text inside is created, then the text is animated to uncreate (fade out) while the circle remains visible, followed by a brief pause.", "code": "from manim import *\n\nclass CircleWithContent(VGroup):\n    def __init__(self, content):\n        super().__init__()\n        self.circle = Circle()\n        self.content = content\n        self.add(self.circle, content)\n        content.move_to(self.circle.get_center())\n\n    def clear_content(self):\n        self.remove(self.content)\n        self.content = None\n\n    @override_animate(clear_content)\n    def _clear_content_animation(self, anim_args=None):\n        if anim_args is None:\n            anim_args = {}\n        anim = Uncreate(self.content, **anim_args)\n        self.clear_content()\n        return anim\n\nclass AnimationOverrideExample(Scene):\n    def construct(self):\n        t = Text(\"hello!\")\n        my_mobject = CircleWithContent(t)\n        self.play(Create(my_mobject))\n        self.play(my_mobject.animate.clear_content())\n        self.wait()", "code_sha1": "8b65bb2069fa79ce403ab70006f9fec16646809b"}
{"url": "https://docs.manim.community/en/stable/reference/manim.mobject.mobject.html", "depth": 1, "instruction": "A circle with a \"hello!\" text inside is created, then the text is animated to uncreate (fade out) while the circle remains visible, followed by a pause.", "code": "class CircleWithContent(VGroup):\n    def __init__(self, content):\n        super().__init__()\n        self.circle = Circle()\n        self.content = content\n        self.add(self.circle, content)\n        content.move_to(self.circle.get_center())\n\n    def clear_content(self):\n        self.remove(self.content)\n        self.content = None\n\n    @override_animate(clear_content)\n    def _clear_content_animation(self, anim_args=None):\n        if anim_args is None:\n            anim_args = {}\n        anim = Uncreate(self.content, **anim_args)\n        self.clear_content()\n        return anim\n\nclass AnimationOverrideExample(Scene):\n    def construct(self):\n        t = Text(\"hello!\")\n        my_mobject = CircleWithContent(t)\n        self.play(Create(my_mobject))\n        self.play(my_mobject.animate.clear_content())\n        self.wait()", "code_sha1": "ea0b659438077055e041a7b58881fe263a960828"}
{"url": "https://docs.manim.community/en/stable/reference/manim.mobject.mobject.Mobject.html", "depth": 1, "instruction": "A rotating dot is positioned at (3, 0, 0) with a label that follows its movement, updating its position continuously. The dot completes a full rotation around the origin in a linear motion over a duration of 6 seconds, while the label reflects the dot's x-coordinate.", "code": "from manim import *\n\nclass NextToUpdater(Scene):\n    def construct(self):\n        def dot_position(mobject):\n            mobject.set_value(dot.get_center()[0])\n            mobject.next_to(dot)\n\n        dot = Dot(RIGHT*3)\n        label = DecimalNumber()\n        label.add_updater(dot_position)\n        self.add(dot, label)\n\n        self.play(Rotating(dot, about_point=ORIGIN, angle=TAU, run_time=TAU, rate_func=linear))", "code_sha1": "fa86050b93f122be7e04a4fbd339d65e7c8ad9d7"}
{"url": "https://docs.manim.community/en/stable/reference/manim.mobject.mobject.Mobject.html", "depth": 1, "instruction": "A blue square rotates continuously at a rate of 90 degrees per second, displayed in the center of the scene for 2 seconds.", "code": "from manim import *\n\nclass DtUpdater(Scene):\n    def construct(self):\n        square = Square()\n\n        #Let the square rotate 90° per second\n        square.add_updater(lambda mobject, dt: mobject.rotate(dt*90*DEGREES))\n        self.add(square)\n        self.wait(2)", "code_sha1": "dd20924ea096d3fc45d890db760fa1fa41426dcd"}
{"url": "https://docs.manim.community/en/stable/reference/manim.mobject.mobject.Mobject.html", "depth": 1, "instruction": "A square is created, then animated to shift right, scale to double its size, and rotate 90 degrees clockwise, before being uncreated, with each animation occurring sequentially.", "code": "from manim import *\n\nclass AnimateExample(Scene):\n    def construct(self):\n        s = Square()\n        self.play(Create(s))\n        self.play(s.animate.shift(RIGHT))\n        self.play(s.animate.scale(2))\n        self.play(s.animate.rotate(PI / 2))\n        self.play(Uncreate(s))", "code_sha1": "60cc69966f206a2e8c326fa963ec99ff051eba14"}
{"url": "https://docs.manim.community/en/stable/reference/manim.mobject.mobject.Mobject.html", "depth": 1, "instruction": "A square is created, then animated to shift right, scale to double its size, and rotate 90 degrees, all in a single smooth motion. Finally, the square is uncreated, disappearing from the scene.", "code": "from manim import *\n\nclass AnimateChainExample(Scene):\n    def construct(self):\n        s = Square()\n        self.play(Create(s))\n        self.play(s.animate.shift(RIGHT).scale(2).rotate(PI / 2))\n        self.play(Uncreate(s))", "code_sha1": "6da95afada644c23032d1c01e4aea1e0b97dea0d"}
{"url": "https://docs.manim.community/en/stable/reference/manim.mobject.mobject.Mobject.html", "depth": 1, "instruction": "A square rotates 90 degrees over 2 seconds while a circle shifts right and back, using a \"there and back\" rate function. Both shapes are arranged horizontally with a 2-unit buffer between them.", "code": "from manim import *\n\nclass AnimateWithArgsExample(Scene):\n    def construct(self):\n        s = Square()\n        c = Circle()\n\n        VGroup(s, c).arrange(RIGHT, buff=2)\n        self.add(s, c)\n\n        self.play(\n            s.animate(run_time=2).rotate(PI / 2),\n            c.animate(rate_func=there_and_back).shift(RIGHT),\n        )", "code_sha1": "f5c42b69bd1d374df9320fe36b225f1c666b8080"}
{"url": "https://docs.manim.community/en/stable/reference/manim.mobject.mobject.Mobject.html", "depth": 1, "instruction": "A blue circle morphs into a dynamic shape as it applies the complex exponential function, with a reference circle remaining static. The transformation occurs over 3 seconds, while the shape continuously updates based on a value tracker that animates from 0 to \\(2\\pi\\).", "code": "from manim import *\n\nclass ApplyFuncExample(Scene):\n    def construct(self):\n        circ = Circle().scale(1.5)\n        circ_ref = circ.copy()\n        circ.apply_complex_function(\n            lambda x: np.exp(x*1j)\n        )\n        t = ValueTracker(0)\n        circ.add_updater(\n            lambda x: x.become(circ_ref.copy().apply_complex_function(\n                lambda x: np.exp(x+t.get_value()*1j)\n            )).set_color(BLUE)\n        )\n        self.add(circ_ref)\n        self.play(TransformFromCopy(circ_ref, circ))\n        self.play(t.animate.set_value(TAU), run_time=3)", "code_sha1": "2e321d334c673d297248ddf644bc4439c7030ebd"}
{"url": "https://docs.manim.community/en/stable/reference/manim.mobject.mobject.Mobject.html", "depth": 1, "instruction": "Four squares are arranged horizontally with a uniform spacing of 1 unit between them, centered on the x-axis. The squares are added to the scene without any animations or camera operations.", "code": "from manim import *\n\nclass Example(Scene):\n    def construct(self):\n        s1 = Square()\n        s2 = Square()\n        s3 = Square()\n        s4 = Square()\n        x = VGroup(s1, s2, s3, s4).set_x(0).arrange(buff=1.0)\n        self.add(x)", "code_sha1": "72b786f57da69c457571c8784090e72f1cef1924"}
{"url": "https://docs.manim.community/en/stable/reference/manim.mobject.mobject.Mobject.html", "depth": 1, "instruction": "Six squares are arranged in a 2-row grid with a small buffer between them, centered in the scene. The squares are of equal size and default color, with no animations or camera operations applied.", "code": "from manim import *\n\nclass ExampleBoxes(Scene):\n    def construct(self):\n        boxes=VGroup(*[Square() for s in range(0,6)])\n        boxes.arrange_in_grid(rows=2, buff=0.1)\n        self.add(boxes)", "code_sha1": "4356e3e1519e8436a3ec6609fad273e1c10d5c94"}
{"url": "https://docs.manim.community/en/stable/reference/manim.mobject.mobject.Mobject.html", "depth": 1, "instruction": "The scene displays 24 rectangles arranged in a grid with varying column widths and row heights, featuring centered text labels from 1 to 24. The grid has a horizontal buffer of 0.25 and a vertical buffer of 0.5, with specific alignments for columns and rows, creating a structured layout.", "code": "from manim import *\n\nclass ArrangeInGrid(Scene):\n    def construct(self):\n        boxes = VGroup(*[\n            Rectangle(WHITE, 0.5, 0.5).add(Text(str(i+1)).scale(0.5))\n            for i in range(24)\n        ])\n        self.add(boxes)\n\n        boxes.arrange_in_grid(\n            buff=(0.25,0.5),\n            col_alignments=\"lccccr\",\n            row_alignments=\"uccd\",\n            col_widths=[1, *[None]*4, 1],\n            row_heights=[1, None, None, 1],\n            flow_order=\"dr\"\n        )", "code_sha1": "1af0833323d4279151470285f4f885095a57a509"}
{"url": "https://docs.manim.community/en/stable/reference/manim.mobject.mobject.Mobject.html", "depth": 1, "instruction": "Two groups of 15 blue and red dots are displayed, with the blue dots randomly positioned above and the red dots arranged in a line below them. The blue dots are shifted upward, while the red dots are arranged with a small buffer and shifted downward, creating a clear visual distinction between the two groups.", "code": "from manim import *\n\nclass ArrangeSumobjectsExample(Scene):\n    def construct(self):\n        s= VGroup(*[Dot().shift(i*0.1*RIGHT*np.random.uniform(-1,1)+UP*np.random.uniform(-1,1)) for i in range(0,15)])\n        s.shift(UP).set_color(BLUE)\n        s2= s.copy().set_color(RED)\n        s2.arrange_submobjects()\n        s2.shift(DOWN)\n        self.add(s,s2)", "code_sha1": "e4c1b1b9773649accd735d2c95589274ecc3f898"}
{"url": "https://docs.manim.community/en/stable/reference/manim.mobject.mobject.Mobject.html", "depth": 1, "instruction": "A red circle with 80% opacity appears, then transforms into a blue square with 20% opacity after a 0.5-second wait, followed by another 0.5-second pause. The circle and square are centered in the scene.", "code": "from manim import *\n\nclass BecomeScene(Scene):\n    def construct(self):\n        circ = Circle(fill_color=RED, fill_opacity=0.8)\n        square = Square(fill_color=BLUE, fill_opacity=0.2)\n        self.add(circ)\n        self.wait(0.5)\n        circ.become(square)\n        self.wait(0.5)", "code_sha1": "88936b5cfff007e730f485cf7e7b95052e364416"}
{"url": "https://docs.manim.community/en/stable/reference/manim.mobject.mobject.Mobject.html", "depth": 1, "instruction": "A rectangle (2 units high, 4 units wide) transforms into an ellipse (height 2, width 4) with a smooth animation, maintaining its center position. The ellipse visually represents the deformation from the original rectangle, demonstrating the match properties in a clear, engaging manner.", "code": "from manim import Rectangle, Circle\nimport numpy as np\nrect = Rectangle(height=2, width=4)\ncirc = Circle(radius=3)", "code_sha1": "4c55df7b0da195dfebf4bdbad751554403c066fa"}
{"url": "https://docs.manim.community/en/stable/reference/manim.mobject.mobject.Mobject.html", "depth": 1, "instruction": "A horizontal line is drawn on the left side of the screen, and a mirrored copy of this line appears directly to the right of the original, creating a symmetrical effect. Both lines are the same color and thickness, positioned parallel to each other.", "code": "from manim import *\n\nclass FlipExample(Scene):\n    def construct(self):\n        s= Line(LEFT, RIGHT+UP).shift(4*LEFT)\n        self.add(s)\n        s2= s.copy().flip()\n        self.add(s2)", "code_sha1": "a640888d2c5eed709b056f719856e622ec2620df"}
{"url": "https://docs.manim.community/en/stable/reference/manim.mobject.mobject.Mobject.html", "depth": 1, "instruction": "The code checks if a red square's color property equals RED, confirming the square is visually represented in red. No animations or camera operations are involved.", "code": "from manim import Square, RED\nSquare(color=RED).get_color() == RED\nTrue", "code_sha1": "e8ab9d2707d8e505b2f2325221aec8ee81ef1c82"}
{"url": "https://docs.manim.community/en/stable/reference/manim.mobject.mobject.Mobject.html", "depth": 1, "instruction": "The scene displays two lines originating from the same point, forming an angle, with the angle highlighted. A red dot marks the midpoint of the angle's arc. The elements are static, with a brief pause at the end.", "code": "from manim import *\n\nclass AngleMidPoint(Scene):\n    def construct(self):\n        line1 = Line(ORIGIN, 2*RIGHT)\n        line2 = Line(ORIGIN, 2*RIGHT).rotate_about_origin(80*DEGREES)\n\n        a = Angle(line1, line2, radius=1.5, other_angle=False)\n        d = Dot(a.get_midpoint()).set_color(RED)\n\n        self.add(line1, line2, a, d)\n        self.wait()", "code_sha1": "7f6ca92d42d6560a7b81b315a4c86f53c6848a8a"}
{"url": "https://docs.manim.community/en/stable/reference/manim.mobject.mobject.Mobject.html", "depth": 1, "instruction": "A blue rectangle animates to a height of 5, while a gray copy with reduced opacity remains static. A decimal number at the top updates dynamically to reflect the rectangle's height throughout the animation. The scene concludes with a brief pause.", "code": "from manim import *\n\nclass HeightExample(Scene):\n    def construct(self):\n        decimal = DecimalNumber().to_edge(UP)\n        rect = Rectangle(color=BLUE)\n        rect_copy = rect.copy().set_stroke(GRAY, opacity=0.5)\n\n        decimal.add_updater(lambda d: d.set_value(rect.height))\n\n        self.add(rect_copy, rect, decimal)\n        self.play(rect.animate.set(height=5))\n        self.wait()", "code_sha1": "4b7faf5bdb0a014f194d8a149e51f119ac918f06"}
{"url": "https://docs.manim.community/en/stable/reference/manim.mobject.mobject.Mobject.html", "depth": 1, "instruction": "The scene displays two dots: a white dot on the left and a dark grey dot on the right, with a middle dot interpolated between them, appearing slightly closer to the white dot. All dots are stationary, with no animations or camera operations.", "code": "from manim import *\n\nclass DotInterpolation(Scene):\n    def construct(self):\n        dotR = Dot(color=DARK_GREY)\n        dotR.shift(2 * RIGHT)\n        dotL = Dot(color=WHITE)\n        dotL.shift(2 * LEFT)\n\n        dotMiddle = VMobject().interpolate(dotL, dotR, alpha=0.3)\n\n        self.add(dotL, dotR, dotMiddle)", "code_sha1": "c30a870756309d73ea352147f79c44ff91e7c59a"}
{"url": "https://docs.manim.community/en/stable/reference/manim.mobject.mobject.Mobject.html", "depth": 1, "instruction": "The scene displays two rows of dots: the first row is a series of evenly spaced dots moving from left to right, while the second row, inverted and shifted down, mirrors the first row's arrangement but with inverted colors. Both rows are animated with a writing effect.", "code": "from manim import *\n\nclass InvertSumobjectsExample(Scene):\n    def construct(self):\n        s = VGroup(*[Dot().shift(i*0.1*RIGHT) for i in range(-20,20)])\n        s2 = s.copy()\n        s2.invert()\n        s2.shift(DOWN)\n        self.play(Write(s), Write(s2))", "code_sha1": "1f60ac8b3fa0d1bb20f1ec86245bfe70abc36740"}
{"url": "https://docs.manim.community/en/stable/reference/manim.mobject.mobject.Mobject.html", "depth": 1, "instruction": "A red circle with 80% opacity morphs its shape and position to match a blue square with 20% opacity, following a brief pause before and after the transformation.", "code": "from manim import *\n\nclass MatchPointsScene(Scene):\n    def construct(self):\n        circ = Circle(fill_color=RED, fill_opacity=0.8)\n        square = Square(fill_color=BLUE, fill_opacity=0.2)\n        self.add(circ)\n        self.wait(0.5)\n        self.play(circ.animate.match_points(square))\n        self.wait(0.5)", "code_sha1": "68fc5e1c23bb0a16e4c7681b492d3e21618cbd22"}
{"url": "https://docs.manim.community/en/stable/reference/manim.mobject.mobject.Mobject.html", "depth": 1, "instruction": "A dot is positioned to the right, a square to the left, and a triangle below a central circle, all centered in the scene. The dot, circle, square, and triangle are distinct geometric shapes, with no specific colors or sizes mentioned, and they are added simultaneously without animations.", "code": "from manim import *\n\nclass GeometricShapes(Scene):\n    def construct(self):\n        d = Dot()\n        c = Circle()\n        s = Square()\n        t = Triangle()\n        d.next_to(c, RIGHT)\n        s.next_to(c, LEFT)\n        t.next_to(c, DOWN)\n        self.add(d, c, s, t)", "code_sha1": "248a4737c594fec3d380f8047239c066b05a36d9"}
{"url": "https://docs.manim.community/en/stable/reference/manim.mobject.mobject.Mobject.html", "depth": 1, "instruction": "A horizontal arrangement of four \"F\" text objects appears, with sizes 1x, 2x, 0.5x, and -1x, respectively. The objects are evenly spaced 6 units apart, with the first three in standard orientation and the last flipped horizontally.", "code": "from manim import *\n\nclass MobjectScaleExample(Scene):\n    def construct(self):\n        f1 = Text(\"F\")\n        f2 = Text(\"F\").scale(2)\n        f3 = Text(\"F\").scale(0.5)\n        f4 = Text(\"F\").scale(-1)\n\n        vgroup = VGroup(f1, f2, f3, f4).arrange(6 * RIGHT)\n        self.add(vgroup)", "code_sha1": "f398a3f57eb06eba6f9636cb26ed5dc1d19aa31e"}
{"url": "https://docs.manim.community/en/stable/reference/manim.mobject.mobject.Mobject.html", "depth": 1, "instruction": "A square is displayed, scaled to a height of 5 units, maintaining a width of 5 units, centered on the screen.", "code": "from manim import *\nsq = Square()\nsq.width\nnp.float64(2.0)\nsq.scale_to_fit_height(5)\nSquare\nsq.height\nnp.float64(5.0)\nsq.width\nnp.float64(5.0)", "code_sha1": "1d7f226e1f688d765e678e79bf36017b30fc3649"}
{"url": "https://docs.manim.community/en/stable/reference/manim.mobject.mobject.Mobject.html", "depth": 1, "instruction": "A square with a width and height of 5 units is displayed, centered on the screen, without any animations or camera operations.", "code": "from manim import *\nsq = Square()\nsq.height\nnp.float64(2.0)\nsq.scale_to_fit_width(5)\nSquare\nsq.width\nnp.float64(5.0)\nsq.height\nnp.float64(5.0)", "code_sha1": "8efe9d48c6aef0baf24727eb4210aa2472fdd546"}
{"url": "https://docs.manim.community/en/stable/reference/manim.mobject.mobject.Mobject.html", "depth": 1, "instruction": "A green square with 25% fill opacity appears on screen, then resets to a white square with 0% fill opacity, demonstrating the change in default properties.", "code": "from manim import Square, GREEN\nSquare.set_default(color=GREEN, fill_opacity=0.25)\ns = Square(); s.color, s.fill_opacity\n(ManimColor('#83C167'), 0.25)\nSquare.set_default()\ns = Square(); s.color, s.fill_opacity\n(ManimColor('#FFFFFF'), 0.0)", "code_sha1": "e23917b0dd5836e46bc50c2b2d72a33b40c0d9ad"}
{"url": "https://docs.manim.community/en/stable/reference/manim.mobject.mobject.Mobject.html", "depth": 1, "instruction": "A black text saying \"Changing default values is easy!\" appears centered on a white background. The text is added without any animations, and the scene concludes with the text color reset to white to maintain default settings.", "code": "from manim import *\n\nconfig.background_color = WHITE\n\nclass ChangedDefaultTextcolor(Scene):\n    def construct(self):\n        Text.set_default(color=BLACK)\n        self.add(Text(\"Changing default values is easy!\"))\n\n        # we revert the colour back to the default to prevent a bug in the docs.\n        Text.set_default(color=WHITE)", "code_sha1": "9d2d36c7124b6be181815a79bb464598bba25b1d"}
{"url": "https://docs.manim.community/en/stable/reference/manim.mobject.mobject.Mobject.html", "depth": 1, "instruction": "The scene displays a red text \"z_index = 3\" at the top, a blue Tex \"zIndex = 1\" at the bottom, a green circle in the center, and a large square below the text, all layered according to their z-index values, with the text on top, followed by the square, Tex, and circle.", "code": "from manim import *\n\nclass SetZIndex(Scene):\n    def construct(self):\n        text = Text('z_index = 3', color = PURE_RED).shift(UP).set_z_index(3)\n        square = Square(2, fill_opacity=1).set_z_index(2)\n        tex = Tex(r'zIndex = 1', color = PURE_BLUE).shift(DOWN).set_z_index(1)\n        circle = Circle(radius = 1.7, color = GREEN, fill_opacity = 1) # z_index = 0\n\n        # Displaying order is now defined by z_index values\n        self.add(text)\n        self.add(square)\n        self.add(tex)\n        self.add(circle)", "code_sha1": "60793a01f45c3229c5de81f3f39cdbb5b2341d8a"}
{"url": "https://docs.manim.community/en/stable/reference/manim.mobject.mobject.Mobject.html", "depth": 1, "instruction": "Two rows of dots are displayed: the first row (s) is a straight line of evenly spaced dots, while the second row (s2) is a shuffled version of the first, positioned directly below it. Both rows are written in sequence with a smooth animation.", "code": "from manim import *\n\nclass ShuffleSubmobjectsExample(Scene):\n    def construct(self):\n        s= VGroup(*[Dot().shift(i*0.1*RIGHT) for i in range(-20,20)])\n        s2= s.copy()\n        s2.shuffle_submobjects()\n        s2.shift(DOWN)\n        self.play(Write(s), Write(s2))", "code_sha1": "d17ac05b8c4b24f6132a06d4100b5ce64b3381e8"}
{"url": "https://docs.manim.community/en/stable/reference/manim.mobject.mobject.Mobject.html", "depth": 1, "instruction": "A square is transformed into a rectangle with a height of 5 units and a width of 2 units, maintaining its original width while stretching its height.", "code": "from manim import *\nsq = Square()\nsq.width\nnp.float64(2.0)\nsq.stretch_to_fit_height(5)\nSquare\nsq.height\nnp.float64(5.0)\nsq.width\nnp.float64(2.0)", "code_sha1": "7df8ecf36e10ebecafb4134627413603ea5f206a"}
{"url": "https://docs.manim.community/en/stable/reference/manim.mobject.mobject.Mobject.html", "depth": 1, "instruction": "A square with a width of 5 units and a height of 2 units is created, maintaining its original height while stretching to fit the new width.", "code": "from manim import *\nsq = Square()\nsq.height\nnp.float64(2.0)\nsq.stretch_to_fit_width(5)\nSquare\nsq.width\nnp.float64(5.0)\nsq.height\nnp.float64(2.0)", "code_sha1": "d790c02b6df53af5dd26e4eb7a6fa4fba773c345"}
{"url": "https://docs.manim.community/en/stable/reference/manim.mobject.mobject.Mobject.html", "depth": 1, "instruction": "A circle is positioned in the upper right corner, while the text \"To the corner!\" moves to the lower left corner with no buffer, and \"x^3\" shifts to the upper left corner with a 1.5 buffer. All objects are displayed simultaneously without animations.", "code": "from manim import *\n\nclass ToCornerExample(Scene):\n    def construct(self):\n        c = Circle()\n        c.to_corner(UR)\n        t = Tex(\"To the corner!\")\n        t2 = MathTex(\"x^3\").shift(DOWN)\n        self.add(c,t,t2)\n        t.to_corner(DL, buff=0)\n        t2.to_corner(UL, buff=1.5)", "code_sha1": "0919677c202c4ea274531656c26ba616a31d530a"}
{"url": "https://docs.manim.community/en/stable/reference/manim.mobject.mobject.Mobject.html", "depth": 1, "instruction": "The scene displays two text objects: \"I am at the top!\" positioned at the top and \"I am moving to the side!\" initially centered, later moved to the left. A circle is placed at the bottom, shifted to the right edge with no buffer. All elements are static with no animations.", "code": "from manim import *\n\nclass ToEdgeExample(Scene):\n    def construct(self):\n        tex_top = Tex(\"I am at the top!\")\n        tex_top.to_edge(UP)\n        tex_side = Tex(\"I am moving to the side!\")\n        c = Circle().shift(2*DOWN)\n        self.add(tex_top, tex_side, c)\n        tex_side.to_edge(LEFT)\n        c.to_edge(RIGHT, buff=0)", "code_sha1": "e3fe333baed717896f32f9c8eebd33e06477e7e6"}
{"url": "https://docs.manim.community/en/stable/reference/manim.mobject.mobject.Mobject.html", "depth": 1, "instruction": "A blue rectangle expands to a width of 7 while a gray, semi-transparent copy remains static. A decimal number above updates in real-time to reflect the rectangle's width. The animation occurs smoothly, followed by a brief pause.", "code": "from manim import *\n\nclass WidthExample(Scene):\n    def construct(self):\n        decimal = DecimalNumber().to_edge(UP)\n        rect = Rectangle(color=BLUE)\n        rect_copy = rect.copy().set_stroke(GRAY, opacity=0.5)\n\n        decimal.add_updater(lambda d: d.set_value(rect.width))\n\n        self.add(rect_copy, rect, decimal)\n        self.play(rect.animate.set(width=7))\n        self.wait()", "code_sha1": "8760d07e0f2ad1bc19baac19e18990e20b762f7c"}
{"url": "https://docs.manim.community/en/stable/reference/manim.mobject.mobject.Mobject.html", "depth": 1, "instruction": "A rotating dot is displayed at the right of the screen, while a decimal number label follows its position, updating continuously. The dot rotates around the origin in a full circle over a duration of one second, with a linear animation.", "code": "class NextToUpdater(Scene):\n    def construct(self):\n        def dot_position(mobject):\n            mobject.set_value(dot.get_center()[0])\n            mobject.next_to(dot)\n\n        dot = Dot(RIGHT*3)\n        label = DecimalNumber()\n        label.add_updater(dot_position)\n        self.add(dot, label)\n\n        self.play(Rotating(dot, about_point=ORIGIN, angle=TAU, run_time=TAU, rate_func=linear))", "code_sha1": "d268acc97c5301a5c4bebf999f2fe6fc8dab53d7"}
{"url": "https://docs.manim.community/en/stable/reference/manim.mobject.mobject.Mobject.html", "depth": 1, "instruction": "A blue square continuously rotates at 90 degrees per second, displayed in the center of the scene, for a duration of 2 seconds.", "code": "class DtUpdater(Scene):\n    def construct(self):\n        square = Square()\n\n        #Let the square rotate 90° per second\n        square.add_updater(lambda mobject, dt: mobject.rotate(dt*90*DEGREES))\n        self.add(square)\n        self.wait(2)", "code_sha1": "3314a9dad2d422f4177a335ef4ef70df4a6a1414"}
{"url": "https://docs.manim.community/en/stable/reference/manim.mobject.mobject.Mobject.html", "depth": 1, "instruction": "A square is created, then animated to shift right, scale to double its size, and rotate 90 degrees clockwise, before being uncreated. Each animation occurs sequentially, with the square's properties changing visibly during each step.", "code": "class AnimateExample(Scene):\n    def construct(self):\n        s = Square()\n        self.play(Create(s))\n        self.play(s.animate.shift(RIGHT))\n        self.play(s.animate.scale(2))\n        self.play(s.animate.rotate(PI / 2))\n        self.play(Uncreate(s))", "code_sha1": "9f31b06fb254b5c64dc71056eb1ccf90b8c4ea4a"}
{"url": "https://docs.manim.community/en/stable/reference/manim.mobject.mobject.Mobject.html", "depth": 1, "instruction": "A square is created, then animated to shift right, scale to double its size, and rotate 90 degrees, all in one smooth motion. Finally, the square is uncreated, disappearing from the scene.", "code": "class AnimateChainExample(Scene):\n    def construct(self):\n        s = Square()\n        self.play(Create(s))\n        self.play(s.animate.shift(RIGHT).scale(2).rotate(PI / 2))\n        self.play(Uncreate(s))", "code_sha1": "bcd4fdd977f0cbc397c0a80b529e91aff401d246"}
{"url": "https://docs.manim.community/en/stable/reference/manim.mobject.mobject.Mobject.html", "depth": 1, "instruction": "A square rotates 90 degrees over 2 seconds while a circle shifts right and back, using a \"there and back\" rate function. Both shapes are arranged horizontally with a 2-unit buffer between them.", "code": "class AnimateWithArgsExample(Scene):\n    def construct(self):\n        s = Square()\n        c = Circle()\n\n        VGroup(s, c).arrange(RIGHT, buff=2)\n        self.add(s, c)\n\n        self.play(\n            s.animate(run_time=2).rotate(PI / 2),\n            c.animate(rate_func=there_and_back).shift(RIGHT),\n        )", "code_sha1": "54413a0cd0cf7fa9b59398f686800990aec35025"}
{"url": "https://docs.manim.community/en/stable/reference/manim.mobject.mobject.Mobject.html", "depth": 1, "instruction": "A blue circle morphs into a dynamic shape based on the complex exponential function, while a reference circle remains static. The transformation occurs over 3 seconds, with the circle's shape continuously updating as a value tracker animates from 0 to \\(2\\pi\\).", "code": "class ApplyFuncExample(Scene):\n    def construct(self):\n        circ = Circle().scale(1.5)\n        circ_ref = circ.copy()\n        circ.apply_complex_function(\n            lambda x: np.exp(x*1j)\n        )\n        t = ValueTracker(0)\n        circ.add_updater(\n            lambda x: x.become(circ_ref.copy().apply_complex_function(\n                lambda x: np.exp(x+t.get_value()*1j)\n            )).set_color(BLUE)\n        )\n        self.add(circ_ref)\n        self.play(TransformFromCopy(circ_ref, circ))\n        self.play(t.animate.set_value(TAU), run_time=3)", "code_sha1": "cee1d8b25464ba62793601b2eade27c0b13c60cb"}
{"url": "https://docs.manim.community/en/stable/reference/manim.mobject.mobject.Mobject.html", "depth": 1, "instruction": "Four squares are arranged horizontally with a uniform spacing of 1 unit between them, centered on the x-axis. The squares are added to the scene without any animations or camera operations.", "code": "class Example(Scene):\n    def construct(self):\n        s1 = Square()\n        s2 = Square()\n        s3 = Square()\n        s4 = Square()\n        x = VGroup(s1, s2, s3, s4).set_x(0).arrange(buff=1.0)\n        self.add(x)", "code_sha1": "fbb4f391ffe47b93a9ea6197bb4f529cddcef8e2"}
{"url": "https://docs.manim.community/en/stable/reference/manim.mobject.mobject.Mobject.html", "depth": 1, "instruction": "Six squares are arranged in a 2-row grid with a small buffer between them, centered in the scene. The squares are uniformly sized and positioned, creating a neat, organized layout.", "code": "class ExampleBoxes(Scene):\n    def construct(self):\n        boxes=VGroup(*[Square() for s in range(0,6)])\n        boxes.arrange_in_grid(rows=2, buff=0.1)\n        self.add(boxes)", "code_sha1": "ed0b61cbcbaaaf7e7fb4d6e7a98c4b0d92267530"}
{"url": "https://docs.manim.community/en/stable/reference/manim.mobject.mobject.Mobject.html", "depth": 1, "instruction": "The scene displays 24 rectangles arranged in a grid with specified column and row alignments, featuring a mix of left, center, and right alignments. The rectangles are white with centered text, and the grid has a buffer of 0.25 horizontally and 0.5 vertically, flowing from the bottom-right to the top-left.", "code": "class ArrangeInGrid(Scene):\n    def construct(self):\n        boxes = VGroup(*[\n            Rectangle(WHITE, 0.5, 0.5).add(Text(str(i+1)).scale(0.5))\n            for i in range(24)\n        ])\n        self.add(boxes)\n\n        boxes.arrange_in_grid(\n            buff=(0.25,0.5),\n            col_alignments=\"lccccr\",\n            row_alignments=\"uccd\",\n            col_widths=[1, *[None]*4, 1],\n            row_heights=[1, None, None, 1],\n            flow_order=\"dr\"\n        )", "code_sha1": "55463044e84c0453b170f36a50ba88cb02b321e0"}
{"url": "https://docs.manim.community/en/stable/reference/manim.mobject.mobject.Mobject.html", "depth": 1, "instruction": "The scene displays two groups of dots: the first group, colored blue, is randomly scattered above the center, while the second group, colored red, is arranged in a neat row below it. Both groups are added to the scene simultaneously, creating a visually striking contrast between the chaotic blue dots and the orderly red arrangement.", "code": "class ArrangeSumobjectsExample(Scene):\n    def construct(self):\n        s= VGroup(*[Dot().shift(i*0.1*RIGHT*np.random.uniform(-1,1)+UP*np.random.uniform(-1,1)) for i in range(0,15)])\n        s.shift(UP).set_color(BLUE)\n        s2= s.copy().set_color(RED)\n        s2.arrange_submobjects()\n        s2.shift(DOWN)\n        self.add(s,s2)", "code_sha1": "d94bc57c7d55c8d740602357e6e4a35588bdd09d"}
{"url": "https://docs.manim.community/en/stable/reference/manim.mobject.mobject.Mobject.html", "depth": 1, "instruction": "A red circle with 80% opacity appears, then transforms into a blue square with 20% opacity after a 0.5-second wait, followed by another 0.5-second pause. The circle and square are centered in the scene.", "code": "class BecomeScene(Scene):\n    def construct(self):\n        circ = Circle(fill_color=RED, fill_opacity=0.8)\n        square = Square(fill_color=BLUE, fill_opacity=0.2)\n        self.add(circ)\n        self.wait(0.5)\n        circ.become(square)\n        self.wait(0.5)", "code_sha1": "db17b923a7516c412cc4aa18f9a4a62300e5556b"}
{"url": "https://docs.manim.community/en/stable/reference/manim.mobject.mobject.Mobject.html", "depth": 1, "instruction": "A horizontal line is drawn, shifted left, and a mirrored copy of the line is displayed directly beside it, creating a symmetrical effect. Both lines are black and of equal length, positioned parallel to each other.", "code": "class FlipExample(Scene):\n    def construct(self):\n        s= Line(LEFT, RIGHT+UP).shift(4*LEFT)\n        self.add(s)\n        s2= s.copy().flip()\n        self.add(s2)", "code_sha1": "a6e8d95fb5ee912ed2fc6f0187a3f8dfdbe7e5e3"}
{"url": "https://docs.manim.community/en/stable/reference/manim.mobject.mobject.Mobject.html", "depth": 1, "instruction": "The scene displays two lines originating from the same point, forming an angle, with the angle highlighted. A red dot marks the midpoint of the angle's arc. The elements are static, with a brief pause at the end.", "code": "class AngleMidPoint(Scene):\n    def construct(self):\n        line1 = Line(ORIGIN, 2*RIGHT)\n        line2 = Line(ORIGIN, 2*RIGHT).rotate_about_origin(80*DEGREES)\n\n        a = Angle(line1, line2, radius=1.5, other_angle=False)\n        d = Dot(a.get_midpoint()).set_color(RED)\n\n        self.add(line1, line2, a, d)\n        self.wait()", "code_sha1": "8f6f7947472714a9fe2cd34682e732374edd5704"}
{"url": "https://docs.manim.community/en/stable/reference/manim.mobject.mobject.Mobject.html", "depth": 1, "instruction": "A blue rectangle increases its height to 5 units while a gray, semi-transparent copy remains static. A decimal number above updates in real-time to reflect the rectangle's height, creating a dynamic visual effect. The scene concludes with a brief pause.", "code": "class HeightExample(Scene):\n    def construct(self):\n        decimal = DecimalNumber().to_edge(UP)\n        rect = Rectangle(color=BLUE)\n        rect_copy = rect.copy().set_stroke(GRAY, opacity=0.5)\n\n        decimal.add_updater(lambda d: d.set_value(rect.height))\n\n        self.add(rect_copy, rect, decimal)\n        self.play(rect.animate.set(height=5))\n        self.wait()", "code_sha1": "c81ee6bb5b2797552d489f9ac8cb5a8367249566"}
{"url": "https://docs.manim.community/en/stable/reference/manim.mobject.mobject.Mobject.html", "depth": 1, "instruction": "Two dots are displayed: a white dot on the left and a dark grey dot on the right, with a third dot (interpolated) positioned slightly to the right of the center, colored a mix of both. All dots are static, with no animations or camera operations.", "code": "class DotInterpolation(Scene):\n    def construct(self):\n        dotR = Dot(color=DARK_GREY)\n        dotR.shift(2 * RIGHT)\n        dotL = Dot(color=WHITE)\n        dotL.shift(2 * LEFT)\n\n        dotMiddle = VMobject().interpolate(dotL, dotR, alpha=0.3)\n\n        self.add(dotL, dotR, dotMiddle)", "code_sha1": "cff69db832a151b128a430bee74669ce71d8c553"}
{"url": "https://docs.manim.community/en/stable/reference/manim.mobject.mobject.Mobject.html", "depth": 1, "instruction": "Display two rows of dots: the first row (s) consists of 40 evenly spaced dots along the x-axis, while the second row (s2) is an inverted version of the first, shifted downwards. Both rows are animated with a writing effect.", "code": "class InvertSumobjectsExample(Scene):\n    def construct(self):\n        s = VGroup(*[Dot().shift(i*0.1*RIGHT) for i in range(-20,20)])\n        s2 = s.copy()\n        s2.invert()\n        s2.shift(DOWN)\n        self.play(Write(s), Write(s2))", "code_sha1": "540be503b409a0c288efb83804ac217f23fe4a06"}
{"url": "https://docs.manim.community/en/stable/reference/manim.mobject.mobject.Mobject.html", "depth": 1, "instruction": "A red circle with 80% opacity morphs to match the shape and position of a blue square with 20% opacity, following a brief pause before and after the transformation.", "code": "class MatchPointsScene(Scene):\n    def construct(self):\n        circ = Circle(fill_color=RED, fill_opacity=0.8)\n        square = Square(fill_color=BLUE, fill_opacity=0.2)\n        self.add(circ)\n        self.wait(0.5)\n        self.play(circ.animate.match_points(square))\n        self.wait(0.5)", "code_sha1": "53ef552ec25fc1f4646d89a39b4c28107b7210da"}
{"url": "https://docs.manim.community/en/stable/reference/manim.mobject.mobject.Mobject.html", "depth": 1, "instruction": "A dot is positioned to the right, a square to the left, and a triangle below a central circle, all centered at the origin. The dot, circle, square, and triangle are distinct geometric shapes, with default colors and sizes, arranged with a slight buffer between them.", "code": "class GeometricShapes(Scene):\n    def construct(self):\n        d = Dot()\n        c = Circle()\n        s = Square()\n        t = Triangle()\n        d.next_to(c, RIGHT)\n        s.next_to(c, LEFT)\n        t.next_to(c, DOWN)\n        self.add(d, c, s, t)", "code_sha1": "8d353b3866c0f88af0fc064e2252b1d174af71c8"}
{"url": "https://docs.manim.community/en/stable/reference/manim.mobject.mobject.Mobject.html", "depth": 1, "instruction": "Four \"F\" text objects are arranged horizontally with equal spacing: the first at normal size, the second scaled to twice its size, the third scaled down to half, and the fourth flipped horizontally.", "code": "class MobjectScaleExample(Scene):\n    def construct(self):\n        f1 = Text(\"F\")\n        f2 = Text(\"F\").scale(2)\n        f3 = Text(\"F\").scale(0.5)\n        f4 = Text(\"F\").scale(-1)\n\n        vgroup = VGroup(f1, f2, f3, f4).arrange(6 * RIGHT)\n        self.add(vgroup)", "code_sha1": "76059596d70c4be52a4fde8b477765f2aadc3403"}
{"url": "https://docs.manim.community/en/stable/reference/manim.mobject.mobject.Mobject.html", "depth": 1, "instruction": "A white background scene displays a black text saying \"Changing default values is easy!\" centered on the screen. The text appears without any animations.", "code": "config.background_color = WHITE\n\nclass ChangedDefaultTextcolor(Scene):\n    def construct(self):\n        Text.set_default(color=BLACK)\n        self.add(Text(\"Changing default values is easy!\"))\n\n        # we revert the colour back to the default to prevent a bug in the docs.\n        Text.set_default(color=WHITE)", "code_sha1": "f033359184ace3965377964fa55dfbb7c9caabd7"}
{"url": "https://docs.manim.community/en/stable/reference/manim.mobject.mobject.Mobject.html", "depth": 1, "instruction": "Four objects are displayed: a red text \"z_index = 3\" at the top, a blue Tex \"zIndex = 1\" at the bottom, a green circle in the middle, and a square in between. The stacking order is determined by their z_index values, with the red text on top, followed by the square, the circle, and the blue Tex at the bottom.", "code": "class SetZIndex(Scene):\n    def construct(self):\n        text = Text('z_index = 3', color = PURE_RED).shift(UP).set_z_index(3)\n        square = Square(2, fill_opacity=1).set_z_index(2)\n        tex = Tex(r'zIndex = 1', color = PURE_BLUE).shift(DOWN).set_z_index(1)\n        circle = Circle(radius = 1.7, color = GREEN, fill_opacity = 1) # z_index = 0\n\n        # Displaying order is now defined by z_index values\n        self.add(text)\n        self.add(square)\n        self.add(tex)\n        self.add(circle)", "code_sha1": "3b1d1d3d989b593ca01edee69bf43c4f7f7d2ef7"}
{"url": "https://docs.manim.community/en/stable/reference/manim.mobject.mobject.Mobject.html", "depth": 1, "instruction": "Two rows of dots are displayed: the first row (s) appears from left to right, while the second row (s2), shuffled and shifted downwards, is written below the first. Both rows consist of small dots, evenly spaced, with the second row's order randomized.", "code": "class ShuffleSubmobjectsExample(Scene):\n    def construct(self):\n        s= VGroup(*[Dot().shift(i*0.1*RIGHT) for i in range(-20,20)])\n        s2= s.copy()\n        s2.shuffle_submobjects()\n        s2.shift(DOWN)\n        self.play(Write(s), Write(s2))", "code_sha1": "14aae1bf84d171267c7b57816b4bfde43cc885e3"}
{"url": "https://docs.manim.community/en/stable/reference/manim.mobject.mobject.Mobject.html", "depth": 1, "instruction": "A circle is positioned in the upper right corner, while the text \"To the corner!\" is placed in the lower left corner with no buffer, and \"x^3\" is positioned in the upper left corner with a 1.5 buffer. All objects are displayed simultaneously without animations.", "code": "class ToCornerExample(Scene):\n    def construct(self):\n        c = Circle()\n        c.to_corner(UR)\n        t = Tex(\"To the corner!\")\n        t2 = MathTex(\"x^3\").shift(DOWN)\n        self.add(c,t,t2)\n        t.to_corner(DL, buff=0)\n        t2.to_corner(UL, buff=1.5)", "code_sha1": "10c7dc60624f4f1342764e6ccaae972d735cf2c7"}
{"url": "https://docs.manim.community/en/stable/reference/manim.mobject.mobject.Mobject.html", "depth": 1, "instruction": "The scene displays two text objects: \"I am at the top!\" positioned at the top and \"I am moving to the side!\" positioned on the left. A circle is centered at the bottom and shifted to the right edge. The text and circle are added simultaneously without animations.", "code": "class ToEdgeExample(Scene):\n    def construct(self):\n        tex_top = Tex(\"I am at the top!\")\n        tex_top.to_edge(UP)\n        tex_side = Tex(\"I am moving to the side!\")\n        c = Circle().shift(2*DOWN)\n        self.add(tex_top, tex_side, c)\n        tex_side.to_edge(LEFT)\n        c.to_edge(RIGHT, buff=0)", "code_sha1": "640ce48d9457bbdaf2b8a99b598a3b7cd10b337b"}
{"url": "https://docs.manim.community/en/stable/reference/manim.mobject.mobject.Mobject.html", "depth": 1, "instruction": "A blue rectangle expands to a width of 7, while a gray, semi-transparent copy remains static. A decimal number above updates in real-time to reflect the rectangle's width. The scene includes a smooth animation for the rectangle's width change, followed by a brief pause.", "code": "class WidthExample(Scene):\n    def construct(self):\n        decimal = DecimalNumber().to_edge(UP)\n        rect = Rectangle(color=BLUE)\n        rect_copy = rect.copy().set_stroke(GRAY, opacity=0.5)\n\n        decimal.add_updater(lambda d: d.set_value(rect.width))\n\n        self.add(rect_copy, rect, decimal)\n        self.play(rect.animate.set(width=7))\n        self.wait()", "code_sha1": "787b8e794e337539769bedb52800d71cf9e41ed6"}
{"url": "https://docs.manim.community/en/stable/reference/manim.mobject.svg.brace.ArcBrace.html", "depth": 1, "instruction": "The scene displays four groups of arcs and their corresponding braces, arranged in a grid. The arcs are colored red, yellow, blue, and green, with varying radii. Each brace faces the arcs appropriately, with the first brace oriented left. The entire arrangement is centered on the screen.", "code": "from manim import *\n\nclass ArcBraceExample(Scene):\n    def construct(self):\n        arc_1 = Arc(radius=1.5,start_angle=0,angle=2*PI/3).set_color(RED)\n        brace_1 = ArcBrace(arc_1,LEFT)\n        group_1 = VGroup(arc_1,brace_1)\n\n        arc_2 = Arc(radius=3,start_angle=0,angle=5*PI/6).set_color(YELLOW)\n        brace_2 = ArcBrace(arc_2)\n        group_2 = VGroup(arc_2,brace_2)\n\n        arc_3 = Arc(radius=0.5,start_angle=-0,angle=PI).set_color(BLUE)\n        brace_3 = ArcBrace(arc_3)\n        group_3 = VGroup(arc_3,brace_3)\n\n        arc_4 = Arc(radius=0.2,start_angle=0,angle=3*PI/2).set_color(GREEN)\n        brace_4 = ArcBrace(arc_4)\n        group_4 = VGroup(arc_4,brace_4)\n\n        arc_group = VGroup(group_1, group_2, group_3, group_4).arrange_in_grid(buff=1.5)\n        self.add(arc_group.center())", "code_sha1": "ebcb98aa7a2717f2308bc6efad1139e2f853a8d5"}
{"url": "https://docs.manim.community/en/stable/reference/manim.mobject.svg.brace.ArcBrace.html", "depth": 1, "instruction": "Four colored arcs (red, yellow, blue, green) with corresponding braces are arranged in a grid. The arcs have varying radii (0.2 to 3) and angles, while the braces face different directions. The entire group is centered on the screen, creating a visually appealing composition of shapes.", "code": "class ArcBraceExample(Scene):\n    def construct(self):\n        arc_1 = Arc(radius=1.5,start_angle=0,angle=2*PI/3).set_color(RED)\n        brace_1 = ArcBrace(arc_1,LEFT)\n        group_1 = VGroup(arc_1,brace_1)\n\n        arc_2 = Arc(radius=3,start_angle=0,angle=5*PI/6).set_color(YELLOW)\n        brace_2 = ArcBrace(arc_2)\n        group_2 = VGroup(arc_2,brace_2)\n\n        arc_3 = Arc(radius=0.5,start_angle=-0,angle=PI).set_color(BLUE)\n        brace_3 = ArcBrace(arc_3)\n        group_3 = VGroup(arc_3,brace_3)\n\n        arc_4 = Arc(radius=0.2,start_angle=0,angle=3*PI/2).set_color(GREEN)\n        brace_4 = ArcBrace(arc_4)\n        group_4 = VGroup(arc_4,brace_4)\n\n        arc_group = VGroup(group_1, group_2, group_3, group_4).arrange_in_grid(buff=1.5)\n        self.add(arc_group.center())", "code_sha1": "b0d6a8acd4b1db1a9e7ad5eff9a59a81a01ab7b5"}
{"url": "https://docs.manim.community/en/stable/reference/manim.mobject.svg.brace.Brace.html", "depth": 1, "instruction": "A square is displayed with four braces of varying sharpness, each accompanied by a text label indicating the sharpness value. The braces and text are arranged vertically with a small vertical spacing between them.", "code": "from manim import *\n\nclass BraceExample(Scene):\n    def construct(self):\n        s = Square()\n        self.add(s)\n        for i in np.linspace(0.1,1.0,4):\n            br = Brace(s, sharpness=i)\n            t = Text(f\"sharpness= {i}\").next_to(br, RIGHT)\n            self.add(t)\n            self.add(br)\n        VGroup(*self.mobjects).arrange(DOWN, buff=0.2)", "code_sha1": "5dcb99eceaeafb728348325107503fe855bd77d6"}
{"url": "https://docs.manim.community/en/stable/reference/manim.mobject.svg.brace.Brace.html", "depth": 1, "instruction": "The scene displays a square with four braces of varying sharpness, each accompanied by a text label indicating the sharpness value. The braces and text are arranged vertically with a small gap between them, creating a clear visual progression of sharpness.", "code": "class BraceExample(Scene):\n    def construct(self):\n        s = Square()\n        self.add(s)\n        for i in np.linspace(0.1,1.0,4):\n            br = Brace(s, sharpness=i)\n            t = Text(f\"sharpness= {i}\").next_to(br, RIGHT)\n            self.add(t)\n            self.add(br)\n        VGroup(*self.mobjects).arrange(DOWN, buff=0.2)", "code_sha1": "eaeb8f4b7aba8c1bd51b1f3756207f6f739da019"}
{"url": "https://docs.manim.community/en/stable/reference/manim.mobject.svg.brace.BraceBetweenPoints.html", "depth": 1, "instruction": "A 3D brace appears between the points (0,0,0) and (1,2,0) on a NumberPlane, which is created first. The brace is animated into view, followed by a 2-second pause.", "code": "from manim import *\n\nclass BraceBPExample(Scene):\n    def construct(self):\n        p1 = [0,0,0]\n        p2 = [1,2,0]\n        brace = BraceBetweenPoints(p1,p2)\n        self.play(Create(NumberPlane()))\n        self.play(Create(brace))\n        self.wait(2)", "code_sha1": "d76c8a90a00b9c5117a8bbcf9eba5a7c24e33ef1"}
{"url": "https://docs.manim.community/en/stable/reference/manim.mobject.svg.brace.BraceBetweenPoints.html", "depth": 1, "instruction": "A 3D brace is created between points (0,0,0) and (1,2,0) on a NumberPlane, which is displayed first. The brace appears with a smooth animation, followed by a 2-second pause.", "code": "class BraceBPExample(Scene):\n    def construct(self):\n        p1 = [0,0,0]\n        p2 = [1,2,0]\n        brace = BraceBetweenPoints(p1,p2)\n        self.play(Create(NumberPlane()))\n        self.play(Create(brace))\n        self.wait(2)", "code_sha1": "d483b5f75ab3a05ba4ca0d59d11b52609ceb9046"}
{"url": "https://docs.manim.community/en/stable/reference/manim.mobject.table.html", "depth": 1, "instruction": "The scene displays four tables: a standard table with highlighted cells, a decimal table with a highlighted cell in red, a math table with blue lines, and a mobject table featuring red and blue shapes. The tables are arranged in two groups, scaled to half size, with the first group at the top and the second at the bottom.", "code": "from manim import *\n\nclass TableExamples(Scene):\n    def construct(self):\n        t0 = Table(\n            [[\"First\", \"Second\"],\n            [\"Third\",\"Fourth\"]],\n            row_labels=[Text(\"R1\"), Text(\"R2\")],\n            col_labels=[Text(\"C1\"), Text(\"C2\")],\n            top_left_entry=Text(\"TOP\"))\n        t0.add_highlighted_cell((2,2), color=GREEN)\n        x_vals = np.linspace(-2,2,5)\n        y_vals = np.exp(x_vals)\n        t1 = DecimalTable(\n            [x_vals, y_vals],\n            row_labels=[MathTex(\"x\"), MathTex(\"f(x)\")],\n            include_outer_lines=True)\n        t1.add(t1.get_cell((2,2), color=RED))\n        t2 = MathTable(\n            [[\"+\", 0, 5, 10],\n            [0, 0, 5, 10],\n            [2, 2, 7, 12],\n            [4, 4, 9, 14]],\n            include_outer_lines=True)\n        t2.get_horizontal_lines()[:3].set_color(BLUE)\n        t2.get_vertical_lines()[:3].set_color(BLUE)\n        t2.get_horizontal_lines()[:3].set_z_index(1)\n        cross = VGroup(\n            Line(UP + LEFT, DOWN + RIGHT),\n            Line(UP + RIGHT, DOWN + LEFT))\n        a = Circle().set_color(RED).scale(0.5)\n        b = cross.set_color(BLUE).scale(0.5)\n        t3 = MobjectTable(\n            [[a.copy(),b.copy(),a.copy()],\n            [b.copy(),a.copy(),a.copy()],\n            [a.copy(),b.copy(),b.copy()]])\n        t3.add(Line(\n            t3.get_corner(DL), t3.get_corner(UR)\n        ).set_color(RED))\n        vals = np.arange(1,21).reshape(5,4)\n        t4 = IntegerTable(\n            vals,\n            include_outer_lines=True\n        )\n        g1 = Group(t0, t1).scale(0.5).arrange(buff=1).to_edge(UP, buff=1)\n        g2 = Group(t2, t3, t4).scale(0.5).arrange(buff=1).to_edge(DOWN, buff=1)\n        self.add(g1, g2)", "code_sha1": "a460af8504aecf200f1a1ddfafdaf968229a49d0"}
{"url": "https://docs.manim.community/en/stable/reference/manim.mobject.table.html", "depth": 1, "instruction": "The scene displays two groups of tables: the top group features a standard table with highlighted cells and labels, while the bottom group includes a decimal table, a math table with colored lines, a custom object table with shapes, and an integer table. All tables are scaled to half size and arranged vertically with spacing.", "code": "class TableExamples(Scene):\n    def construct(self):\n        t0 = Table(\n            [[\"First\", \"Second\"],\n            [\"Third\",\"Fourth\"]],\n            row_labels=[Text(\"R1\"), Text(\"R2\")],\n            col_labels=[Text(\"C1\"), Text(\"C2\")],\n            top_left_entry=Text(\"TOP\"))\n        t0.add_highlighted_cell((2,2), color=GREEN)\n        x_vals = np.linspace(-2,2,5)\n        y_vals = np.exp(x_vals)\n        t1 = DecimalTable(\n            [x_vals, y_vals],\n            row_labels=[MathTex(\"x\"), MathTex(\"f(x)\")],\n            include_outer_lines=True)\n        t1.add(t1.get_cell((2,2), color=RED))\n        t2 = MathTable(\n            [[\"+\", 0, 5, 10],\n            [0, 0, 5, 10],\n            [2, 2, 7, 12],\n            [4, 4, 9, 14]],\n            include_outer_lines=True)\n        t2.get_horizontal_lines()[:3].set_color(BLUE)\n        t2.get_vertical_lines()[:3].set_color(BLUE)\n        t2.get_horizontal_lines()[:3].set_z_index(1)\n        cross = VGroup(\n            Line(UP + LEFT, DOWN + RIGHT),\n            Line(UP + RIGHT, DOWN + LEFT))\n        a = Circle().set_color(RED).scale(0.5)\n        b = cross.set_color(BLUE).scale(0.5)\n        t3 = MobjectTable(\n            [[a.copy(),b.copy(),a.copy()],\n            [b.copy(),a.copy(),a.copy()],\n            [a.copy(),b.copy(),b.copy()]])\n        t3.add(Line(\n            t3.get_corner(DL), t3.get_corner(UR)\n        ).set_color(RED))\n        vals = np.arange(1,21).reshape(5,4)\n        t4 = IntegerTable(\n            vals,\n            include_outer_lines=True\n        )\n        g1 = Group(t0, t1).scale(0.5).arrange(buff=1).to_edge(UP, buff=1)\n        g2 = Group(t2, t3, t4).scale(0.5).arrange(buff=1).to_edge(DOWN, buff=1)\n        self.add(g1, g2)", "code_sha1": "93fc821d21b0878c7371706831a242feac2d4565"}
{"url": "https://docs.manim.community/en/stable/reference/manim.mobject.table.DecimalTable.html", "depth": 1, "instruction": "A table displays two rows: the first row labeled \"x\" with values -2, -1, 0, 1, 2, and the second row labeled \"f(x)=e^{x}\" with corresponding exponential values rounded to two decimal places, all centered and spaced evenly.", "code": "from manim import *\n\nclass DecimalTableExample(Scene):\n    def construct(self):\n        x_vals = [-2,-1,0,1,2]\n        y_vals = np.exp(x_vals)\n        t0 = DecimalTable(\n            [x_vals, y_vals],\n            row_labels=[MathTex(\"x\"), MathTex(\"f(x)=e^{x}\")],\n            h_buff=1,\n            element_to_mobject_config={\"num_decimal_places\": 2})\n        self.add(t0)", "code_sha1": "f86b934ce3828b5f4d226913a48a35c9a5971f98"}
{"url": "https://docs.manim.community/en/stable/reference/manim.mobject.table.DecimalTable.html", "depth": 1, "instruction": "A table displays two rows: the first row shows x-values (-2, -1, 0, 1, 2) and the second row shows their corresponding exponential values (rounded to two decimal places). Each entry is formatted as a DecimalNumber, with row labels \"x\" and \"f(x)=e^{x}\" in LaTeX. The table is centered with horizontal spacing of 1.", "code": "class DecimalTableExample(Scene):\n    def construct(self):\n        x_vals = [-2,-1,0,1,2]\n        y_vals = np.exp(x_vals)\n        t0 = DecimalTable(\n            [x_vals, y_vals],\n            row_labels=[MathTex(\"x\"), MathTex(\"f(x)=e^{x}\")],\n            h_buff=1,\n            element_to_mobject_config={\"num_decimal_places\": 2})\n        self.add(t0)", "code_sha1": "4ffec9326883c5e87ccbacad2e07b71b15c00e91"}
{"url": "https://docs.manim.community/en/stable/reference/manim.mobject.table.IntegerTable.html", "depth": 1, "instruction": "A grid-like table displays two rows labeled \"sin\" and \"cos\" with five columns labeled \\(\\frac{\\sqrt{0}}{2}\\) to \\(\\frac{\\sqrt{4}}{2}\\). Each cell contains integers (0, 30, 45, 60, 90, 90, 60, 45, 30, 0) with degree units. The table is neatly arranged with horizontal spacing of 1 unit.", "code": "from manim import *\n\nclass IntegerTableExample(Scene):\n    def construct(self):\n        t0 = IntegerTable(\n            [[0,30,45,60,90],\n            [90,60,45,30,0]],\n            col_labels=[\n                MathTex(r\"\\frac{\\sqrt{0}}{2}\"),\n                MathTex(r\"\\frac{\\sqrt{1}}{2}\"),\n                MathTex(r\"\\frac{\\sqrt{2}}{2}\"),\n                MathTex(r\"\\frac{\\sqrt{3}}{2}\"),\n                MathTex(r\"\\frac{\\sqrt{4}}{2}\")],\n            row_labels=[MathTex(r\"\\sin\"), MathTex(r\"\\cos\")],\n            h_buff=1,\n            element_to_mobject_config={\"unit\": r\"^{\\circ}\"})\n        self.add(t0)", "code_sha1": "6a3c021ce4e35832946fef72e6674a37237c7dbf"}
{"url": "https://docs.manim.community/en/stable/reference/manim.mobject.table.IntegerTable.html", "depth": 1, "instruction": "A table displaying two rows labeled \"sin\" and \"cos\" with five columns labeled \\(\\frac{\\sqrt{0}}{2}\\) to \\(\\frac{\\sqrt{4}}{2}\\), containing integer values (0, 30, 45, 60, 90 in the first row and 90, 60, 45, 30, 0 in the second), all rendered in a grid format with horizontal spacing of 1 unit.", "code": "class IntegerTableExample(Scene):\n    def construct(self):\n        t0 = IntegerTable(\n            [[0,30,45,60,90],\n            [90,60,45,30,0]],\n            col_labels=[\n                MathTex(r\"\\frac{\\sqrt{0}}{2}\"),\n                MathTex(r\"\\frac{\\sqrt{1}}{2}\"),\n                MathTex(r\"\\frac{\\sqrt{2}}{2}\"),\n                MathTex(r\"\\frac{\\sqrt{3}}{2}\"),\n                MathTex(r\"\\frac{\\sqrt{4}}{2}\")],\n            row_labels=[MathTex(r\"\\sin\"), MathTex(r\"\\cos\")],\n            h_buff=1,\n            element_to_mobject_config={\"unit\": r\"^{\\circ}\"})\n        self.add(t0)", "code_sha1": "8b7125ba59d1062632146ea78f552e3d7bc84c65"}
{"url": "https://docs.manim.community/en/stable/reference/manim.mobject.table.MathTable.html", "depth": 1, "instruction": "A LaTeX-styled table is displayed with four rows and four columns, containing mathematical symbols and numbers. The table has outer lines, and each entry is formatted using MathTex. The table is centered in the scene without any animations or camera operations.", "code": "from manim import *\n\nclass MathTableExample(Scene):\n    def construct(self):\n        t0 = MathTable(\n            [[\"+\", 0, 5, 10],\n            [0, 0, 5, 10],\n            [2, 2, 7, 12],\n            [4, 4, 9, 14]],\n            include_outer_lines=True)\n        self.add(t0)", "code_sha1": "6e1df600768e4005b8a3b343515f48e0096206dd"}
{"url": "https://docs.manim.community/en/stable/reference/manim.mobject.table.MathTable.html", "depth": 1, "instruction": "A table is displayed with four rows and four columns, containing mathematical symbols and numbers formatted using LaTeX. The table has outer lines, and all entries are centered. The overall appearance is clean and structured, suitable for mathematical presentations.", "code": "class MathTableExample(Scene):\n    def construct(self):\n        t0 = MathTable(\n            [[\"+\", 0, 5, 10],\n            [0, 0, 5, 10],\n            [2, 2, 7, 12],\n            [4, 4, 9, 14]],\n            include_outer_lines=True)\n        self.add(t0)", "code_sha1": "54dcb028c1bf9ab435a758effb50b6d0e010563a"}
{"url": "https://docs.manim.community/en/stable/reference/manim.mobject.table.MobjectTable.html", "depth": 1, "instruction": "A 3x3 grid of red circles and blue crosses is displayed, with red lines crossing from the bottom-left to the top-right corners of the grid. The circles are scaled to half size, and the crosses are formed by intersecting lines. The entire arrangement is centered in the scene.", "code": "from manim import *\n\nclass MobjectTableExample(Scene):\n    def construct(self):\n        cross = VGroup(\n            Line(UP + LEFT, DOWN + RIGHT),\n            Line(UP + RIGHT, DOWN + LEFT),\n        )\n        a = Circle().set_color(RED).scale(0.5)\n        b = cross.set_color(BLUE).scale(0.5)\n        t0 = MobjectTable(\n            [[a.copy(),b.copy(),a.copy()],\n            [b.copy(),a.copy(),a.copy()],\n            [a.copy(),b.copy(),b.copy()]]\n        )\n        line = Line(\n            t0.get_corner(DL), t0.get_corner(UR)\n        ).set_color(RED)\n        self.add(t0, line)", "code_sha1": "14a8aa1e4a8820fedc2da68203169e35f4a3133f"}
{"url": "https://docs.manim.community/en/stable/reference/manim.mobject.table.MobjectTable.html", "depth": 1, "instruction": "A 3x3 grid of red circles and blue crosses is displayed, with the red circles occupying the corners and the blue crosses in the center. A red diagonal line connects the bottom-left to the top-right corners of the grid. The grid and line are added to the scene simultaneously.", "code": "class MobjectTableExample(Scene):\n    def construct(self):\n        cross = VGroup(\n            Line(UP + LEFT, DOWN + RIGHT),\n            Line(UP + RIGHT, DOWN + LEFT),\n        )\n        a = Circle().set_color(RED).scale(0.5)\n        b = cross.set_color(BLUE).scale(0.5)\n        t0 = MobjectTable(\n            [[a.copy(),b.copy(),a.copy()],\n            [b.copy(),a.copy(),a.copy()],\n            [a.copy(),b.copy(),b.copy()]]\n        )\n        line = Line(\n            t0.get_corner(DL), t0.get_corner(UR)\n        ).set_color(RED)\n        self.add(t0, line)", "code_sha1": "0cbeb647d777a88a0d073217fb1476a769471cbf"}
{"url": "https://docs.manim.community/en/stable/reference/manim.mobject.table.Table.html", "depth": 1, "instruction": "The scene displays four tables arranged in a grid, each with varying configurations: the first is simple, the second highlights a cell in yellow, the third includes a red cell, and the fourth has yellow outer lines with vertical lines removed. All tables are scaled down to 70% size.", "code": "from manim import *\n\nclass TableExamples(Scene):\n    def construct(self):\n        t0 = Table(\n            [[\"This\", \"is a\"],\n            [\"simple\", \"Table in \\\\n Manim.\"]])\n        t1 = Table(\n            [[\"This\", \"is a\"],\n            [\"simple\", \"Table.\"]],\n            row_labels=[Text(\"R1\"), Text(\"R2\")],\n            col_labels=[Text(\"C1\"), Text(\"C2\")])\n        t1.add_highlighted_cell((2,2), color=YELLOW)\n        t2 = Table(\n            [[\"This\", \"is a\"],\n            [\"simple\", \"Table.\"]],\n            row_labels=[Text(\"R1\"), Text(\"R2\")],\n            col_labels=[Text(\"C1\"), Text(\"C2\")],\n            top_left_entry=Star().scale(0.3),\n            include_outer_lines=True,\n            arrange_in_grid_config={\"cell_alignment\": RIGHT})\n        t2.add(t2.get_cell((2,2), color=RED))\n        t3 = Table(\n            [[\"This\", \"is a\"],\n            [\"simple\", \"Table.\"]],\n            row_labels=[Text(\"R1\"), Text(\"R2\")],\n            col_labels=[Text(\"C1\"), Text(\"C2\")],\n            top_left_entry=Star().scale(0.3),\n            include_outer_lines=True,\n            line_config={\"stroke_width\": 1, \"color\": YELLOW})\n        t3.remove(*t3.get_vertical_lines())\n        g = Group(\n            t0,t1,t2,t3\n        ).scale(0.7).arrange_in_grid(buff=1)\n        self.add(g)", "code_sha1": "35fce6382d1ea1249e04751fb8cdf7984cabb2ce"}
{"url": "https://docs.manim.community/en/stable/reference/manim.mobject.table.Table.html", "depth": 1, "instruction": "A semi-transparent background rectangle in teal, red, and yellow fills the scene, with two scaled-down tables arranged horizontally, each containing the text \"This is a\" and \"simple Table.\" The tables have background rectangles behind their entries, enhancing visibility.", "code": "from manim import *\n\nclass BackgroundRectanglesExample(Scene):\n    def construct(self):\n        background = Rectangle(height=6.5, width=13)\n        background.set_fill(opacity=.5)\n        background.set_color([TEAL, RED, YELLOW])\n        self.add(background)\n        t0 = Table(\n            [[\"This\", \"is a\"],\n            [\"simple\", \"Table.\"]],\n            add_background_rectangles_to_entries=True)\n        t1 = Table(\n            [[\"This\", \"is a\"],\n            [\"simple\", \"Table.\"]],\n            include_background_rectangle=True)\n        g = Group(t0, t1).scale(0.7).arrange(buff=0.5)\n        self.add(g)", "code_sha1": "b09ab96c745ce01e8d068851c9d3604d8662145d"}
{"url": "https://docs.manim.community/en/stable/reference/manim.mobject.table.Table.html", "depth": 1, "instruction": "A 2x2 table with labeled rows (\"R1\", \"R2\") and columns (\"C1\", \"C2\") appears on screen, with the bottom-right cell highlighted in green. The table is created with a sequential animation, where lines and labels fade in, and the highlighted cell is emphasized during the animation.", "code": "from manim import *\n\nclass AddHighlightedCellExample(Scene):\n    def construct(self):\n        table = Table(\n            [[\"First\", \"Second\"],\n            [\"Third\",\"Fourth\"]],\n            row_labels=[Text(\"R1\"), Text(\"R2\")],\n            col_labels=[Text(\"C1\"), Text(\"C2\")])\n        table.add_highlighted_cell((2,2), color=GREEN)\n        self.add(table)", "code_sha1": "eb2c90a7bb7f52ef51ba140d2682069ad0c39201"}
{"url": "https://docs.manim.community/en/stable/reference/manim.mobject.table.Table.html", "depth": 1, "instruction": "A table with two rows and two columns is displayed, featuring labeled rows (\"R1\", \"R2\") and columns (\"C1\", \"C2\"). The entire table is created with an animation, followed by a pause. Additionally, the bottom-right cell is highlighted in red, visually emphasizing its position within the table.", "code": "from manim import *\n\nclass CreateTableExample(Scene):\n    def construct(self):\n        table = Table(\n            [[\"First\", \"Second\"],\n            [\"Third\",\"Fourth\"]],\n            row_labels=[Text(\"R1\"), Text(\"R2\")],\n            col_labels=[Text(\"C1\"), Text(\"C2\")],\n            include_outer_lines=True)\n        self.play(table.create())\n        self.wait()", "code_sha1": "773cb98f9f4fc61202f9a8ec85735f0e24eafafe"}
{"url": "https://docs.manim.community/en/stable/reference/manim.mobject.table.Table.html", "depth": 1, "instruction": "A table with two rows and two columns is displayed, labeled \"R1\", \"R2\" for rows and \"C1\", \"C2\" for columns. The column labels are randomly colored and added to the scene, while the table remains unchanged in its original position.", "code": "from manim import *\n\nclass GetCellExample(Scene):\n    def construct(self):\n        table = Table(\n            [[\"First\", \"Second\"],\n            [\"Third\",\"Fourth\"]],\n            row_labels=[Text(\"R1\"), Text(\"R2\")],\n            col_labels=[Text(\"C1\"), Text(\"C2\")])\n        cell = table.get_cell((2,2), color=RED)\n        self.add(table, cell)", "code_sha1": "8bad86a0bf20906c03b9bc6b406aebf46d465cfe"}
{"url": "https://docs.manim.community/en/stable/reference/manim.mobject.table.Table.html", "depth": 1, "instruction": "A table with two rows and two columns is displayed, featuring column labels \"C1\" and \"C2\" in random bright colors. The table includes row labels \"R1\" and \"R2\". The entire table is added to the scene without any animations or camera operations.", "code": "from manim import *\n\nclass GetColLabelsExample(Scene):\n    def construct(self):\n        table = Table(\n            [[\"First\", \"Second\"],\n            [\"Third\",\"Fourth\"]],\n            row_labels=[Text(\"R1\"), Text(\"R2\")],\n            col_labels=[Text(\"C1\"), Text(\"C2\")])\n        lab = table.get_col_labels()\n        for item in lab:\n            item.set_color(random_bright_color())\n        self.add(table)", "code_sha1": "8038bd14002864b430fef681951aee9897541abf"}
{"url": "https://docs.manim.community/en/stable/reference/manim.mobject.table.Table.html", "depth": 1, "instruction": "A table with two rows and two columns displays labeled entries. Each entry is colored randomly. The entry in the second row and second column rotates 180 degrees. The scene features a static camera view, showcasing the entire table with vibrant colors on the text.", "code": "from manim import *\n\nclass GetColumnsExample(Scene):\n    def construct(self):\n        table = Table(\n            [[\"First\", \"Second\"],\n            [\"Third\",\"Fourth\"]],\n            row_labels=[Text(\"R1\"), Text(\"R2\")],\n            col_labels=[Text(\"C1\"), Text(\"C2\")])\n        table.add(SurroundingRectangle(table.get_columns()[1]))\n        self.add(table)", "code_sha1": "59463681c10bed9e902df6b850ffb2a511708bbc"}
{"url": "https://docs.manim.community/en/stable/reference/manim.mobject.table.Table.html", "depth": 1, "instruction": "A table with two rows and two columns displays labels \"R1\", \"R2\", \"C1\", and \"C2\". Each entry is randomly colored, while the entry at position (2,2) is rotated by 180 degrees. The entire table is added to the scene without any animations or camera operations.", "code": "from manim import *\n\nclass GetEntriesExample(Scene):\n    def construct(self):\n        table = Table(\n            [[\"First\", \"Second\"],\n            [\"Third\",\"Fourth\"]],\n            row_labels=[Text(\"R1\"), Text(\"R2\")],\n            col_labels=[Text(\"C1\"), Text(\"C2\")])\n        ent = table.get_entries()\n        for item in ent:\n            item.set_color(random_bright_color())\n        table.get_entries((2,2)).rotate(PI)\n        self.add(table)", "code_sha1": "ccd745b78db8622a56ec37f77d00eb6a86e0e756"}
{"url": "https://docs.manim.community/en/stable/reference/manim.mobject.table.Table.html", "depth": 1, "instruction": "A table with two rows and two columns is displayed, where each entry is colored: the first entry is blue, the second green, the third yellow, and the fourth red. The entry at position (2,2) is rotated 180 degrees. The table is added to the scene without any animations or camera operations.", "code": "from manim import *\n\nclass GetEntriesWithoutLabelsExample(Scene):\n    def construct(self):\n        table = Table(\n            [[\"First\", \"Second\"],\n            [\"Third\",\"Fourth\"]],\n            row_labels=[Text(\"R1\"), Text(\"R2\")],\n            col_labels=[Text(\"C1\"), Text(\"C2\")])\n        ent = table.get_entries_without_labels()\n        colors = [BLUE, GREEN, YELLOW, RED]\n        for k in range(len(colors)):\n            ent[k].set_color(colors[k])\n        table.get_entries_without_labels((2,2)).rotate(PI)\n        self.add(table)", "code_sha1": "6e961f894a0556f9fdbcce947cf10e3a4aeb507b"}
{"url": "https://docs.manim.community/en/stable/reference/manim.mobject.table.Table.html", "depth": 1, "instruction": "A table with two rows and two columns is displayed, featuring row labels \"R1\" and \"R2\" and column labels \"C1\" and \"C2\". The cell at the second row and second column is highlighted in green, positioned behind the table.", "code": "from manim import *\n\nclass GetHighlightedCellExample(Scene):\n    def construct(self):\n        table = Table(\n            [[\"First\", \"Second\"],\n            [\"Third\",\"Fourth\"]],\n            row_labels=[Text(\"R1\"), Text(\"R2\")],\n            col_labels=[Text(\"C1\"), Text(\"C2\")])\n        highlight = table.get_highlighted_cell((2,2), color=GREEN)\n        table.add_to_back(highlight)\n        self.add(table)", "code_sha1": "09f94ec4117bb14952af69c5d610d16a07055673"}
{"url": "https://docs.manim.community/en/stable/reference/manim.mobject.table.Table.html", "depth": 1, "instruction": "A table with two rows and two columns is displayed, featuring red horizontal lines separating the rows. Row labels \"R1\" and \"R2\" and column labels \"C1\" and \"C2\" are included, all in default colors. The scene focuses on the table without any animations or camera operations.", "code": "from manim import *\n\nclass GetHorizontalLinesExample(Scene):\n    def construct(self):\n        table = Table(\n            [[\"First\", \"Second\"],\n            [\"Third\",\"Fourth\"]],\n            row_labels=[Text(\"R1\"), Text(\"R2\")],\n            col_labels=[Text(\"C1\"), Text(\"C2\")])\n        table.get_horizontal_lines().set_color(RED)\n        self.add(table)", "code_sha1": "4d29fe7afc9069599ef91f1723322cda6f4793db"}
{"url": "https://docs.manim.community/en/stable/reference/manim.mobject.table.Table.html", "depth": 1, "instruction": "A table with two rows and two columns displays labels \"R1\" and \"R2\" in random bright colors, positioned alongside the table. The table is added to the scene without any animations or camera operations.", "code": "from manim import *\n\nclass GetLabelsExample(Scene):\n    def construct(self):\n        table = Table(\n            [[\"First\", \"Second\"],\n            [\"Third\",\"Fourth\"]],\n            row_labels=[Text(\"R1\"), Text(\"R2\")],\n            col_labels=[Text(\"C1\"), Text(\"C2\")])\n        lab = table.get_labels()\n        colors = [BLUE, GREEN, YELLOW, RED]\n        for k in range(len(colors)):\n            lab[k].set_color(colors[k])\n        self.add(table)", "code_sha1": "92e7d7a6213ce4244741ff776aae08218980b117"}
{"url": "https://docs.manim.community/en/stable/reference/manim.mobject.table.Table.html", "depth": 1, "instruction": "A table with two rows and two columns is displayed, featuring row labels \"R1\" and \"R2\" in random bright colors. The table is added to the scene without animations or camera operations.", "code": "from manim import *\n\nclass GetRowLabelsExample(Scene):\n    def construct(self):\n        table = Table(\n            [[\"First\", \"Second\"],\n            [\"Third\",\"Fourth\"]],\n            row_labels=[Text(\"R1\"), Text(\"R2\")],\n            col_labels=[Text(\"C1\"), Text(\"C2\")])\n        lab = table.get_row_labels()\n        for item in lab:\n            item.set_color(random_bright_color())\n        self.add(table)", "code_sha1": "07abcd7d78602499b7917cb412b9d8600250b39f"}
{"url": "https://docs.manim.community/en/stable/reference/manim.mobject.table.Table.html", "depth": 1, "instruction": "A table with two rows and two columns is displayed, labeled \"R1\", \"R2\", \"C1\", and \"C2\". The first vertical line of the table is highlighted in red.", "code": "from manim import *\n\nclass GetRowsExample(Scene):\n    def construct(self):\n        table = Table(\n            [[\"First\", \"Second\"],\n            [\"Third\",\"Fourth\"]],\n            row_labels=[Text(\"R1\"), Text(\"R2\")],\n            col_labels=[Text(\"C1\"), Text(\"C2\")])\n        table.add(SurroundingRectangle(table.get_rows()[1]))\n        self.add(table)", "code_sha1": "3a7afdc3b88c8937115a3d70bf7e7ea8ede70353"}
{"url": "https://docs.manim.community/en/stable/reference/manim.mobject.table.Table.html", "depth": 1, "instruction": "A table with two rows and two columns is displayed, where the first vertical line is highlighted in red. The table includes row labels \"R1\" and \"R2\" and column labels \"C1\" and \"C2.\" The scene features a static view without any animations or camera operations.", "code": "from manim import *\n\nclass GetVerticalLinesExample(Scene):\n    def construct(self):\n        table = Table(\n            [[\"First\", \"Second\"],\n            [\"Third\",\"Fourth\"]],\n            row_labels=[Text(\"R1\"), Text(\"R2\")],\n            col_labels=[Text(\"C1\"), Text(\"C2\")])\n        table.get_vertical_lines()[0].set_color(RED)\n        self.add(table)", "code_sha1": "ae124a0f75a3c7eb3ec6e1dae11a2228073de763"}
{"url": "https://docs.manim.community/en/stable/reference/manim.mobject.table.Table.html", "depth": 1, "instruction": "Two circles, one red and one green, are positioned at (-1, 0) and (1, 0) respectively. Both circles have a thick stroke width of 50. The red circle scales down to 25% of its size, while the green circle scales down to 25% with its stroke width also adjusting accordingly, during a simultaneous animation.", "code": "from manim import *\n\nclass MobjectScaleExample(Scene):\n    def construct(self):\n        c1 = Circle(1, RED).set_x(-1)\n        c2 = Circle(1, GREEN).set_x(1)\n\n        vg = VGroup(c1, c2)\n        vg.set_stroke(width=50)\n        self.add(vg)\n\n        self.play(\n            c1.animate.scale(.25),\n            c2.animate.scale(.25,\n                scale_stroke=True)\n        )", "code_sha1": "dfc7400d4d0771db4fe4d58f46a1914ffbbdcdd8"}
{"url": "https://docs.manim.community/en/stable/reference/manim.mobject.table.Table.html", "depth": 1, "instruction": "A table with two rows and two columns is displayed, where the first column is colored red and the second column is blue. The row labels \"R1\" and \"R2\" are positioned on the left, while the column labels \"C1\" and \"C2\" are at the top. The entire table has a green background.", "code": "from manim import *\n\nclass SetColumnColorsExample(Scene):\n    def construct(self):\n        table = Table(\n            [[\"First\", \"Second\"],\n            [\"Third\",\"Fourth\"]],\n            row_labels=[Text(\"R1\"), Text(\"R2\")],\n            col_labels=[Text(\"C1\"), Text(\"C2\")]\n        ).set_column_colors([RED,BLUE], GREEN)\n        self.add(table)", "code_sha1": "ffd0a4a42e42095c545e7ff4318cdf8db7d6d0ef"}
{"url": "https://docs.manim.community/en/stable/reference/manim.mobject.table.Table.html", "depth": 1, "instruction": "A table with two rows and two columns is displayed, where the first row is colored red and the second row is colored blue, while the background is green. Row labels \"R1\" and \"R2\" and column labels \"C1\" and \"C2\" are included. The table is static without animations.", "code": "from manim import *\n\nclass SetRowColorsExample(Scene):\n    def construct(self):\n        table = Table(\n            [[\"First\", \"Second\"],\n            [\"Third\",\"Fourth\"]],\n            row_labels=[Text(\"R1\"), Text(\"R2\")],\n            col_labels=[Text(\"C1\"), Text(\"C2\")]\n        ).set_row_colors([RED,BLUE], GREEN)\n        self.add(table)", "code_sha1": "a6112ce801071200deab7b880272db48cb6ddcb5"}
{"url": "https://docs.manim.community/en/stable/reference/manim.mobject.table.Table.html", "depth": 1, "instruction": "The scene displays four tables arranged in a grid, each with varying configurations: the first is simple, the second highlights a cell in yellow, the third includes a red-highlighted cell, and the fourth has yellow outer lines with vertical lines removed. All tables are scaled to 70% size.", "code": "class TableExamples(Scene):\n    def construct(self):\n        t0 = Table(\n            [[\"This\", \"is a\"],\n            [\"simple\", \"Table in \\\\n Manim.\"]])\n        t1 = Table(\n            [[\"This\", \"is a\"],\n            [\"simple\", \"Table.\"]],\n            row_labels=[Text(\"R1\"), Text(\"R2\")],\n            col_labels=[Text(\"C1\"), Text(\"C2\")])\n        t1.add_highlighted_cell((2,2), color=YELLOW)\n        t2 = Table(\n            [[\"This\", \"is a\"],\n            [\"simple\", \"Table.\"]],\n            row_labels=[Text(\"R1\"), Text(\"R2\")],\n            col_labels=[Text(\"C1\"), Text(\"C2\")],\n            top_left_entry=Star().scale(0.3),\n            include_outer_lines=True,\n            arrange_in_grid_config={\"cell_alignment\": RIGHT})\n        t2.add(t2.get_cell((2,2), color=RED))\n        t3 = Table(\n            [[\"This\", \"is a\"],\n            [\"simple\", \"Table.\"]],\n            row_labels=[Text(\"R1\"), Text(\"R2\")],\n            col_labels=[Text(\"C1\"), Text(\"C2\")],\n            top_left_entry=Star().scale(0.3),\n            include_outer_lines=True,\n            line_config={\"stroke_width\": 1, \"color\": YELLOW})\n        t3.remove(*t3.get_vertical_lines())\n        g = Group(\n            t0,t1,t2,t3\n        ).scale(0.7).arrange_in_grid(buff=1)\n        self.add(g)", "code_sha1": "ac9ca825164350ad618c9c674aec477c3093051b"}
{"url": "https://docs.manim.community/en/stable/reference/manim.mobject.table.Table.html", "depth": 1, "instruction": "The scene displays a semi-transparent, colorful background rectangle (TEAL, RED, YELLOW) behind two scaled-down tables arranged closely together, with the first table having individual background rectangles for each entry. The overall composition is visually balanced and centered within the scene.", "code": "class BackgroundRectanglesExample(Scene):\n    def construct(self):\n        background = Rectangle(height=6.5, width=13)\n        background.set_fill(opacity=.5)\n        background.set_color([TEAL, RED, YELLOW])\n        self.add(background)\n        t0 = Table(\n            [[\"This\", \"is a\"],\n            [\"simple\", \"Table.\"]],\n            add_background_rectangles_to_entries=True)\n        t1 = Table(\n            [[\"This\", \"is a\"],\n            [\"simple\", \"Table.\"]],\n            include_background_rectangle=True)\n        g = Group(t0, t1).scale(0.7).arrange(buff=0.5)\n        self.add(g)", "code_sha1": "037eef72639836e40eea0b4c6183c8efddb3305f"}
{"url": "https://docs.manim.community/en/stable/reference/manim.mobject.table.Table.html", "depth": 1, "instruction": "A 2x2 table with labeled rows (\"R1\", \"R2\") and columns (\"C1\", \"C2\") is displayed, with the bottom-right cell highlighted in green. The table is animated into view with a creation effect, while the labels are written in sequentially.", "code": "class AddHighlightedCellExample(Scene):\n    def construct(self):\n        table = Table(\n            [[\"First\", \"Second\"],\n            [\"Third\",\"Fourth\"]],\n            row_labels=[Text(\"R1\"), Text(\"R2\")],\n            col_labels=[Text(\"C1\"), Text(\"C2\")])\n        table.add_highlighted_cell((2,2), color=GREEN)\n        self.add(table)", "code_sha1": "9273f104c3ad42f352999f432e432c0684dfe7d7"}
{"url": "https://docs.manim.community/en/stable/reference/manim.mobject.table.Table.html", "depth": 1, "instruction": "A table with two rows and two columns is displayed, featuring labeled rows (\"R1\", \"R2\") and columns (\"C1\", \"C2\"). The table is created with outer lines, and after a brief pause, a red rectangular cell highlighting the entry \"Fourth\" appears over the table.", "code": "class CreateTableExample(Scene):\n    def construct(self):\n        table = Table(\n            [[\"First\", \"Second\"],\n            [\"Third\",\"Fourth\"]],\n            row_labels=[Text(\"R1\"), Text(\"R2\")],\n            col_labels=[Text(\"C1\"), Text(\"C2\")],\n            include_outer_lines=True)\n        self.play(table.create())\n        self.wait()", "code_sha1": "15851291c8d307a91a0f380cc94c7264d7614ccd"}
{"url": "https://docs.manim.community/en/stable/reference/manim.mobject.table.Table.html", "depth": 1, "instruction": "A table with two rows and two columns is displayed, featuring labeled rows (\"R1\", \"R2\") and columns (\"C1\", \"C2\"). The column labels are randomly colored, while the table itself remains unchanged.", "code": "class GetCellExample(Scene):\n    def construct(self):\n        table = Table(\n            [[\"First\", \"Second\"],\n            [\"Third\",\"Fourth\"]],\n            row_labels=[Text(\"R1\"), Text(\"R2\")],\n            col_labels=[Text(\"C1\"), Text(\"C2\")])\n        cell = table.get_cell((2,2), color=RED)\n        self.add(table, cell)", "code_sha1": "b9b2589e1c7199b631b979077af4d5d650a497a5"}
{"url": "https://docs.manim.community/en/stable/reference/manim.mobject.table.Table.html", "depth": 1, "instruction": "A table with two rows and two columns displays labels \"C1\" and \"C2\" at the top, with \"R1\" and \"R2\" on the left. The column labels are randomly colored. The entire table is added to the scene without any animations or camera operations.", "code": "class GetColLabelsExample(Scene):\n    def construct(self):\n        table = Table(\n            [[\"First\", \"Second\"],\n            [\"Third\",\"Fourth\"]],\n            row_labels=[Text(\"R1\"), Text(\"R2\")],\n            col_labels=[Text(\"C1\"), Text(\"C2\")])\n        lab = table.get_col_labels()\n        for item in lab:\n            item.set_color(random_bright_color())\n        self.add(table)", "code_sha1": "d7c6b0144480142d98c680338793de1a7e39553a"}
{"url": "https://docs.manim.community/en/stable/reference/manim.mobject.table.Table.html", "depth": 1, "instruction": "A table with two rows and two columns displays labeled entries. Each entry is assigned a random bright color, while the entry in the second row and second column is rotated 180 degrees. The scene features a static view of the table without any animations or camera operations.", "code": "class GetColumnsExample(Scene):\n    def construct(self):\n        table = Table(\n            [[\"First\", \"Second\"],\n            [\"Third\",\"Fourth\"]],\n            row_labels=[Text(\"R1\"), Text(\"R2\")],\n            col_labels=[Text(\"C1\"), Text(\"C2\")])\n        table.add(SurroundingRectangle(table.get_columns()[1]))\n        self.add(table)", "code_sha1": "728831db22fb1733d3ab1abe1d8ee53bd2c6f5b0"}
{"url": "https://docs.manim.community/en/stable/reference/manim.mobject.table.Table.html", "depth": 1, "instruction": "A table with two rows and two columns is displayed, labeled \"R1\", \"R2\", \"C1\", and \"C2\". Each entry is randomly colored, while the entry at position (2,2) is rotated 180 degrees. The entire table is added to the scene without any animations or camera operations.", "code": "class GetEntriesExample(Scene):\n    def construct(self):\n        table = Table(\n            [[\"First\", \"Second\"],\n            [\"Third\",\"Fourth\"]],\n            row_labels=[Text(\"R1\"), Text(\"R2\")],\n            col_labels=[Text(\"C1\"), Text(\"C2\")])\n        ent = table.get_entries()\n        for item in ent:\n            item.set_color(random_bright_color())\n        table.get_entries((2,2)).rotate(PI)\n        self.add(table)", "code_sha1": "803e2ee748802e36f41f1a7d2b9f453f1f66b06b"}
{"url": "https://docs.manim.community/en/stable/reference/manim.mobject.table.Table.html", "depth": 1, "instruction": "A table with two rows and two columns is displayed, with the entries colored in a sequence of blue, green, yellow, and red. The entry at position (2,2) is rotated by 180 degrees. The scene includes the table without any labels, showcasing the colored entries prominently.", "code": "class GetEntriesWithoutLabelsExample(Scene):\n    def construct(self):\n        table = Table(\n            [[\"First\", \"Second\"],\n            [\"Third\",\"Fourth\"]],\n            row_labels=[Text(\"R1\"), Text(\"R2\")],\n            col_labels=[Text(\"C1\"), Text(\"C2\")])\n        ent = table.get_entries_without_labels()\n        colors = [BLUE, GREEN, YELLOW, RED]\n        for k in range(len(colors)):\n            ent[k].set_color(colors[k])\n        table.get_entries_without_labels((2,2)).rotate(PI)\n        self.add(table)", "code_sha1": "d80bf83f05c082d2fabb3a42cf6b329f26299161"}
{"url": "https://docs.manim.community/en/stable/reference/manim.mobject.table.Table.html", "depth": 1, "instruction": "A table with two rows and two columns is displayed, featuring row labels \"R1\" and \"R2\" and column labels \"C1\" and \"C2\". The cell at the second row and second column is highlighted in green, positioned behind the table.", "code": "class GetHighlightedCellExample(Scene):\n    def construct(self):\n        table = Table(\n            [[\"First\", \"Second\"],\n            [\"Third\",\"Fourth\"]],\n            row_labels=[Text(\"R1\"), Text(\"R2\")],\n            col_labels=[Text(\"C1\"), Text(\"C2\")])\n        highlight = table.get_highlighted_cell((2,2), color=GREEN)\n        table.add_to_back(highlight)\n        self.add(table)", "code_sha1": "cd8ed6d97cb38a19cf474e8b099f535b504c97f7"}
{"url": "https://docs.manim.community/en/stable/reference/manim.mobject.table.Table.html", "depth": 1, "instruction": "A table with two rows and two columns is displayed, featuring red horizontal lines separating the rows. Row labels \"R1\" and \"R2\" and column labels \"C1\" and \"C2\" are included, but no animations or camera operations are specified. The overall visual is static with a clear focus on the table structure.", "code": "class GetHorizontalLinesExample(Scene):\n    def construct(self):\n        table = Table(\n            [[\"First\", \"Second\"],\n            [\"Third\",\"Fourth\"]],\n            row_labels=[Text(\"R1\"), Text(\"R2\")],\n            col_labels=[Text(\"C1\"), Text(\"C2\")])\n        table.get_horizontal_lines().set_color(RED)\n        self.add(table)", "code_sha1": "14adf04126af0bf00743954ccb5e9864e31d5981"}
{"url": "https://docs.manim.community/en/stable/reference/manim.mobject.table.Table.html", "depth": 1, "instruction": "A table with two rows and two columns is displayed, featuring row labels \"R1\" and \"R2\" in random bright colors. The table is added to the scene without any animations or camera operations.", "code": "class GetLabelsExample(Scene):\n    def construct(self):\n        table = Table(\n            [[\"First\", \"Second\"],\n            [\"Third\",\"Fourth\"]],\n            row_labels=[Text(\"R1\"), Text(\"R2\")],\n            col_labels=[Text(\"C1\"), Text(\"C2\")])\n        lab = table.get_labels()\n        colors = [BLUE, GREEN, YELLOW, RED]\n        for k in range(len(colors)):\n            lab[k].set_color(colors[k])\n        self.add(table)", "code_sha1": "fc2f532da515c7e09324c99b39cdc06ef37a3633"}
{"url": "https://docs.manim.community/en/stable/reference/manim.mobject.table.Table.html", "depth": 1, "instruction": "A table with two rows and two columns is displayed, featuring row labels \"R1\" and \"R2\" in random bright colors. The table is added to the scene without any animations or camera operations.", "code": "class GetRowLabelsExample(Scene):\n    def construct(self):\n        table = Table(\n            [[\"First\", \"Second\"],\n            [\"Third\",\"Fourth\"]],\n            row_labels=[Text(\"R1\"), Text(\"R2\")],\n            col_labels=[Text(\"C1\"), Text(\"C2\")])\n        lab = table.get_row_labels()\n        for item in lab:\n            item.set_color(random_bright_color())\n        self.add(table)", "code_sha1": "fe6f4c10496f69975826699c878bf9c1bb4c22d9"}
{"url": "https://docs.manim.community/en/stable/reference/manim.mobject.table.Table.html", "depth": 1, "instruction": "A table with two rows and two columns is displayed, labeled \"R1\", \"R2\", \"C1\", and \"C2\". The first vertical line of the table is highlighted in red.", "code": "class GetRowsExample(Scene):\n    def construct(self):\n        table = Table(\n            [[\"First\", \"Second\"],\n            [\"Third\",\"Fourth\"]],\n            row_labels=[Text(\"R1\"), Text(\"R2\")],\n            col_labels=[Text(\"C1\"), Text(\"C2\")])\n        table.add(SurroundingRectangle(table.get_rows()[1]))\n        self.add(table)", "code_sha1": "d145209837cc13b5591ccde83f61d221fa40e7a7"}
{"url": "https://docs.manim.community/en/stable/reference/manim.mobject.table.Table.html", "depth": 1, "instruction": "A table with two rows and two columns is displayed, featuring red vertical lines separating the columns. Row labels \"R1\" and \"R2\" and column labels \"C1\" and \"C2\" are included. The table is centered on the screen without any animations or camera operations.", "code": "class GetVerticalLinesExample(Scene):\n    def construct(self):\n        table = Table(\n            [[\"First\", \"Second\"],\n            [\"Third\",\"Fourth\"]],\n            row_labels=[Text(\"R1\"), Text(\"R2\")],\n            col_labels=[Text(\"C1\"), Text(\"C2\")])\n        table.get_vertical_lines()[0].set_color(RED)\n        self.add(table)", "code_sha1": "be5698153e01efadd40b9533a774c74b34945fb1"}
{"url": "https://docs.manim.community/en/stable/reference/manim.mobject.table.Table.html", "depth": 1, "instruction": "Two circles, one red and one green, are positioned at (-1, 0) and (1, 0) respectively, with a thick stroke. The red circle scales down to 25% of its size, while the green circle scales down to 25% with its stroke width also adjusted, all occurring simultaneously in a smooth animation.", "code": "class MobjectScaleExample(Scene):\n    def construct(self):\n        c1 = Circle(1, RED).set_x(-1)\n        c2 = Circle(1, GREEN).set_x(1)\n\n        vg = VGroup(c1, c2)\n        vg.set_stroke(width=50)\n        self.add(vg)\n\n        self.play(\n            c1.animate.scale(.25),\n            c2.animate.scale(.25,\n                scale_stroke=True)\n        )", "code_sha1": "46c1df040cc2fe0277582e8e7f61c2377c691bee"}
{"url": "https://docs.manim.community/en/stable/reference/manim.mobject.table.Table.html", "depth": 1, "instruction": "A table with two rows and two columns is displayed, where the first column is colored red and the second column is blue. Row labels \"R1\" and \"R2\" are positioned on the left, while column labels \"C1\" and \"C2\" are at the top. The entire table has a green background.", "code": "class SetColumnColorsExample(Scene):\n    def construct(self):\n        table = Table(\n            [[\"First\", \"Second\"],\n            [\"Third\",\"Fourth\"]],\n            row_labels=[Text(\"R1\"), Text(\"R2\")],\n            col_labels=[Text(\"C1\"), Text(\"C2\")]\n        ).set_column_colors([RED,BLUE], GREEN)\n        self.add(table)", "code_sha1": "215ad5444c91d3abb6e10d14a02ac79c2290f622"}
{"url": "https://docs.manim.community/en/stable/reference/manim.mobject.table.Table.html", "depth": 1, "instruction": "A table with two rows and two columns is displayed, where the first row is colored red and the second row is blue, while the background of the entire table is green. Row labels \"R1\" and \"R2\" and column labels \"C1\" and \"C2\" are included, all presented without animations.", "code": "class SetRowColorsExample(Scene):\n    def construct(self):\n        table = Table(\n            [[\"First\", \"Second\"],\n            [\"Third\",\"Fourth\"]],\n            row_labels=[Text(\"R1\"), Text(\"R2\")],\n            col_labels=[Text(\"C1\"), Text(\"C2\")]\n        ).set_row_colors([RED,BLUE], GREEN)\n        self.add(table)", "code_sha1": "1c4d57236029f47ea5367d8b91573f7447ebf22b"}
{"url": "https://docs.manim.community/en/stable/reference/manim.mobject.text.code_mobject.Code.html", "depth": 1, "instruction": "A Python code snippet is displayed on a window-like background with maroon borders, featuring syntax highlighting. The code is centered on the screen, with line numbers shown. The scene remains static, allowing viewers to read the code without animations or camera movements.", "code": "from manim import *\n\nclass CodeFromString(Scene):\n    def construct(self):\n        code = '''from manim import Scene, Square\n\nclass FadeInSquare(Scene):\n    def construct(self):\n        s = Square()\n        self.play(FadeIn(s))\n        self.play(s.animate.scale(2))\n        self.wait()'''\n\n        rendered_code = Code(\n            code_string=code,\n            language=\"python\",\n            background=\"window\",\n            background_config={\"stroke_color\": \"maroon\"},\n        )\n        self.add(rendered_code)", "code_sha1": "d58782797129411578cf55f5febab6f995099c93"}
{"url": "https://docs.manim.community/en/stable/reference/manim.mobject.text.code_mobject.Code.html", "depth": 1, "instruction": "A Python code snippet is displayed on a window-like background with a maroon stroke. The code is highlighted in a \"vim\" style, with line numbers shown. The scene remains static, focusing on the rendered code without any animations or camera movements.", "code": "class CodeFromString(Scene):\n    def construct(self):\n        code = '''from manim import Scene, Square\n\nclass FadeInSquare(Scene):\n    def construct(self):\n        s = Square()\n        self.play(FadeIn(s))\n        self.play(s.animate.scale(2))\n        self.wait()'''\n\n        rendered_code = Code(\n            code_string=code,\n            language=\"python\",\n            background=\"window\",\n            background_config={\"stroke_color\": \"maroon\"},\n        )\n        self.add(rendered_code)", "code_sha1": "47281d494ce0e85469ff58bac8b9f87606a4a461"}
{"url": "https://docs.manim.community/en/stable/reference/manim.mobject.text.numbers.DecimalNumber.html", "depth": 1, "instruction": "A square moves vertically from the top to the bottom of the screen and back, while a decimal number updates its value to reflect the square's vertical position, displayed to the right of the square. The animation lasts 5 seconds with a \"there and back\" motion, and the decimal shows three decimal places with a unit label.", "code": "from manim import *\n\nclass MovingSquareWithUpdaters(Scene):\n    def construct(self):\n        decimal = DecimalNumber(\n            0,\n            show_ellipsis=True,\n            num_decimal_places=3,\n            include_sign=True,\n            unit=r\"\\text{M-Units}\",\n            unit_buff_per_font_unit=0.003\n        )\n        square = Square().to_edge(UP)\n\n        decimal.add_updater(lambda d: d.next_to(square, RIGHT))\n        decimal.add_updater(lambda d: d.set_value(square.get_center()[1]))\n        self.add(square, decimal)\n        self.play(\n            square.animate.to_edge(DOWN),\n            rate_func=there_and_back,\n            run_time=5,\n        )\n        self.wait()", "code_sha1": "35acd15c93d3ad446ce19dbabf87827ec09978bc"}
{"url": "https://docs.manim.community/en/stable/reference/manim.mobject.text.numbers.DecimalNumber.html", "depth": 1, "instruction": "A square moves vertically from the top to the bottom of the screen and back, while a decimal number updates its value to reflect the square's vertical position, positioned to the right of the square. The animation lasts 5 seconds with a \"there and back\" motion, and the decimal displays three decimal places with a unit label.", "code": "class MovingSquareWithUpdaters(Scene):\n    def construct(self):\n        decimal = DecimalNumber(\n            0,\n            show_ellipsis=True,\n            num_decimal_places=3,\n            include_sign=True,\n            unit=r\"\\text{M-Units}\",\n            unit_buff_per_font_unit=0.003\n        )\n        square = Square().to_edge(UP)\n\n        decimal.add_updater(lambda d: d.next_to(square, RIGHT))\n        decimal.add_updater(lambda d: d.set_value(square.get_center()[1]))\n        self.add(square, decimal)\n        self.play(\n            square.animate.to_edge(DOWN),\n            rate_func=there_and_back,\n            run_time=5,\n        )\n        self.wait()", "code_sha1": "b462dae5b993467dc1f9bebb1436041935bec875"}
{"url": "https://docs.manim.community/en/stable/reference/manim.mobject.text.numbers.Integer.html", "depth": 1, "instruction": "Four integers are displayed in a scene: 2.5 (orange, large, positioned at (-0.5, 0.8)), 3.14159 (ellipsis, positioned at (3, 3.3)), 42 (gradient from blue to teal, positioned at (2.5, -2.3)), and 6.28 (yellow, positioned at (-1.5, -2)). Each integer is scaled differently.", "code": "from manim import *\n\nclass IntegerExample(Scene):\n    def construct(self):\n        self.add(Integer(number=2.5).set_color(ORANGE).scale(2.5).set_x(-0.5).set_y(0.8))\n        self.add(Integer(number=3.14159, show_ellipsis=True).set_x(3).set_y(3.3).scale(3.14159))\n        self.add(Integer(number=42).set_x(2.5).set_y(-2.3).set_color_by_gradient(BLUE, TEAL).scale(1.7))\n        self.add(Integer(number=6.28).set_x(-1.5).set_y(-2).set_color(YELLOW).scale(1.4))", "code_sha1": "7b77141389293b5b06b8589db4a68e4bc4497fc0"}
{"url": "https://docs.manim.community/en/stable/reference/manim.mobject.text.numbers.Integer.html", "depth": 1, "instruction": "Four integers are displayed in a scene: 2.5 (orange, large, positioned at (-0.5, 0.8)), 3.14159 (ellipsis, positioned at (3, 3.3)), 42 (gradient from blue to teal, positioned at (2.5, -2.3)), and 6.28 (yellow, positioned at (-1.5, -2)). Each integer is scaled differently.", "code": "class IntegerExample(Scene):\n    def construct(self):\n        self.add(Integer(number=2.5).set_color(ORANGE).scale(2.5).set_x(-0.5).set_y(0.8))\n        self.add(Integer(number=3.14159, show_ellipsis=True).set_x(3).set_y(3.3).scale(3.14159))\n        self.add(Integer(number=42).set_x(2.5).set_y(-2.3).set_color_by_gradient(BLUE, TEAL).scale(1.7))\n        self.add(Integer(number=6.28).set_x(-1.5).set_y(-2).set_color(YELLOW).scale(1.4))", "code_sha1": "d65129766ff7712f856f81c5b55628505208894b"}
{"url": "https://docs.manim.community/en/stable/reference/manim.mobject.text.numbers.Variable.html", "depth": 1, "instruction": "The visual result displays two variable representations: a decimal variable labeled \"var\" with a value of 0.500 and an integer variable labeled \"int_var\" with a value of 0. Both are positioned prominently on the screen, with the decimal variable in a distinct color and size, and the integer variable formatted in math mode.", "code": "# DecimalNumber type\nvar = 0.5\non_screen_var = Variable(var, Text(\"var\"), num_decimal_places=3)\n# Integer type\nint_var = 0\non_screen_int_var = Variable(int_var, Text(\"int_var\"), var_type=Integer)\n# Using math mode for the label\non_screen_int_var = Variable(int_var, \"{a}_{i}\", var_type=Integer)", "code_sha1": "8d5ecd7bae915a1ade81938f6c7174ec837305e3"}
{"url": "https://docs.manim.community/en/stable/reference/manim.mobject.text.numbers.Variable.html", "depth": 1, "instruction": "The scene displays two variables, \"var\" and \"int_var,\" with red labels and green values, animated sequentially. \"var\" starts at 0.5 and updates to 10.5, while \"int_var\" starts at 0 and also updates to 10.5. A third variable with a subscript label appears below \"int_var.\" Each variable is written onto the screen with pauses in between.", "code": "from manim import *\n\nclass VariablesWithValueTracker(Scene):\n    def construct(self):\n        var = 0.5\n        on_screen_var = Variable(var, Text(\"var\"), num_decimal_places=3)\n\n        # You can also change the colours for the label and value\n        on_screen_var.label.set_color(RED)\n        on_screen_var.value.set_color(GREEN)\n\n        self.play(Write(on_screen_var))\n        # The above line will just display the variable with\n        # its initial value on the screen. If you also wish to\n        # update it, you can do so by accessing the `tracker` attribute\n        self.wait()\n        var_tracker = on_screen_var.tracker\n        var = 10.5\n        self.play(var_tracker.animate.set_value(var))\n        self.wait()\n\n        int_var = 0\n        on_screen_int_var = Variable(\n            int_var, Text(\"int_var\"), var_type=Integer\n        ).next_to(on_screen_var, DOWN)\n        on_screen_int_var.label.set_color(RED)\n        on_screen_int_var.value.set_color(GREEN)\n\n        self.play(Write(on_screen_int_var))\n        self.wait()\n        var_tracker = on_screen_int_var.tracker\n        var = 10.5\n        self.play(var_tracker.animate.set_value(var))\n        self.wait()\n\n        # If you wish to have a somewhat more complicated label for your\n        # variable with subscripts, superscripts, etc. the default class\n        # for the label is MathTex\n        subscript_label_var = 10\n        on_screen_subscript_var = Variable(subscript_label_var, \"{a}_{i}\").next_to(\n            on_screen_int_var, DOWN\n        )\n        self.play(Write(on_screen_subscript_var))\n        self.wait()", "code_sha1": "42742c09f1b941c1aa556a45b47b2b21143aa359"}
{"url": "https://docs.manim.community/en/stable/reference/manim.mobject.text.numbers.Variable.html", "depth": 1, "instruction": "The scene displays two vertically arranged variables, \"x\" and \"x²\", both in white. As \"x\" animates from 2.0 to 5.0 over 2 seconds, \"x²\" updates in real-time, reflecting the square of \"x\". The background remains black throughout the animation.", "code": "from manim import *\n\nclass VariableExample(Scene):\n    def construct(self):\n        start = 2.0\n\n        x_var = Variable(start, 'x', num_decimal_places=3)\n        sqr_var = Variable(start**2, 'x^2', num_decimal_places=3)\n        Group(x_var, sqr_var).arrange(DOWN)\n\n        sqr_var.add_updater(lambda v: v.tracker.set_value(x_var.tracker.get_value()**2))\n\n        self.add(x_var, sqr_var)\n        self.play(x_var.tracker.animate.set_value(5), run_time=2, rate_func=linear)\n        self.wait(0.1)", "code_sha1": "1c252b69c237d6aee25b55a237dc9a0e94ccf062"}
{"url": "https://docs.manim.community/en/stable/reference/manim.mobject.text.numbers.Variable.html", "depth": 1, "instruction": "The scene displays three variables: a decimal variable labeled \"var\" in red and green, an integer variable \"int_var\" below it, and a subscript variable \"{a}_{i}\" below that. Each variable is animated with a write effect, and their values are updated to 10.5, with pauses in between for emphasis.", "code": "class VariablesWithValueTracker(Scene):\n    def construct(self):\n        var = 0.5\n        on_screen_var = Variable(var, Text(\"var\"), num_decimal_places=3)\n\n        # You can also change the colours for the label and value\n        on_screen_var.label.set_color(RED)\n        on_screen_var.value.set_color(GREEN)\n\n        self.play(Write(on_screen_var))\n        # The above line will just display the variable with\n        # its initial value on the screen. If you also wish to\n        # update it, you can do so by accessing the `tracker` attribute\n        self.wait()\n        var_tracker = on_screen_var.tracker\n        var = 10.5\n        self.play(var_tracker.animate.set_value(var))\n        self.wait()\n\n        int_var = 0\n        on_screen_int_var = Variable(\n            int_var, Text(\"int_var\"), var_type=Integer\n        ).next_to(on_screen_var, DOWN)\n        on_screen_int_var.label.set_color(RED)\n        on_screen_int_var.value.set_color(GREEN)\n\n        self.play(Write(on_screen_int_var))\n        self.wait()\n        var_tracker = on_screen_int_var.tracker\n        var = 10.5\n        self.play(var_tracker.animate.set_value(var))\n        self.wait()\n\n        # If you wish to have a somewhat more complicated label for your\n        # variable with subscripts, superscripts, etc. the default class\n        # for the label is MathTex\n        subscript_label_var = 10\n        on_screen_subscript_var = Variable(subscript_label_var, \"{a}_{i}\").next_to(\n            on_screen_int_var, DOWN\n        )\n        self.play(Write(on_screen_subscript_var))\n        self.wait()", "code_sha1": "5a368bde04a313ab13e4b04734894373c1b6c527"}
{"url": "https://docs.manim.community/en/stable/reference/manim.mobject.text.numbers.Variable.html", "depth": 1, "instruction": "The scene displays two vertically arranged variables: \"x\" (initially 2.0) and \"x²\" (initially 4.0), both with three decimal places. As \"x\" animates to 5 over 2 seconds, \"x²\" updates dynamically, reflecting the square of \"x\". The animation progresses linearly, with a brief pause afterward.", "code": "class VariableExample(Scene):\n    def construct(self):\n        start = 2.0\n\n        x_var = Variable(start, 'x', num_decimal_places=3)\n        sqr_var = Variable(start**2, 'x^2', num_decimal_places=3)\n        Group(x_var, sqr_var).arrange(DOWN)\n\n        sqr_var.add_updater(lambda v: v.tracker.set_value(x_var.tracker.get_value()**2))\n\n        self.add(x_var, sqr_var)\n        self.play(x_var.tracker.animate.set_value(5), run_time=2, rate_func=linear)\n        self.wait(0.1)", "code_sha1": "ed11c6a26f321d59d2559c4da549da8ed0bef493"}
{"url": "https://docs.manim.community/en/stable/reference/manim.mobject.text.tex_mobject.BulletedList.html", "depth": 1, "instruction": "A bulleted list displaying three items (\"Item 1\" in red, \"Item 2\" in green, \"Item 3\" in blue) is centered on the screen, with each item sized to fit within a height and width of 2 units.", "code": "from manim import *\n\nclass BulletedListExample(Scene):\n    def construct(self):\n        blist = BulletedList(\"Item 1\", \"Item 2\", \"Item 3\", height=2, width=2)\n        blist.set_color_by_tex(\"Item 1\", RED)\n        blist.set_color_by_tex(\"Item 2\", GREEN)\n        blist.set_color_by_tex(\"Item 3\", BLUE)\n        self.add(blist)", "code_sha1": "815f36ab27f79baa31701ef058e0505aaa0a772d"}
{"url": "https://docs.manim.community/en/stable/reference/manim.mobject.text.tex_mobject.BulletedList.html", "depth": 1, "instruction": "A bulleted list displaying \"Item 1\" in red, \"Item 2\" in green, and \"Item 3\" in blue, all sized to a height and width of 2. The list is centered in the scene with no animations or camera operations applied.", "code": "class BulletedListExample(Scene):\n    def construct(self):\n        blist = BulletedList(\"Item 1\", \"Item 2\", \"Item 3\", height=2, width=2)\n        blist.set_color_by_tex(\"Item 1\", RED)\n        blist.set_color_by_tex(\"Item 2\", GREEN)\n        blist.set_color_by_tex(\"Item 3\", BLUE)\n        self.add(blist)", "code_sha1": "491bc782d3446c4c668a497428bf59ab5e8be617"}
{"url": "https://docs.manim.community/en/stable/reference/manim.mobject.text.tex_mobject.MathTex.html", "depth": 1, "instruction": "A LaTeX integral equation appears centered on the screen, displaying \"\\(\\int_a^b f'(x) dx = f(b)- f(a)\\)\" in standard math font, with no animations or camera operations applied. The text is rendered in a default color and size, maintaining typical mathematical formatting.", "code": "from manim import *\n\nclass Formula(Scene):\n    def construct(self):\n        t = MathTex(r\"\\int_a^b f'(x) dx = f(b)- f(a)\")\n        self.add(t)", "code_sha1": "de4e7b4798cc4a424d0330ab981064a7de1b39c6"}
{"url": "https://docs.manim.community/en/stable/reference/manim.mobject.text.tex_mobject.MathTex.html", "depth": 1, "instruction": "The visual result displays two mathematical expressions: the first, \"{{ a }} + {{ b }} = {{ c }}\" in a standard size and color, split into five subcomponents; the second, \"\\frac{1}{a+b\\sqrt{2}}\" as a single cohesive unit. Both are rendered in LaTeX style, showcasing their structure and components.", "code": "t1 = MathTex('{{ a }} + {{ b }} = {{ c }}')\nlen(t1.submobjects)\n5\nt2 = MathTex(r\"\\frac{1}{a+b\\sqrt{2}}\")\nlen(t2.submobjects)\n1", "code_sha1": "66d0d8e304e157de6efd3cbd97276b21458c4b86"}
{"url": "https://docs.manim.community/en/stable/reference/manim.mobject.text.tex_mobject.MathTex.html", "depth": 1, "instruction": "A LaTeX integral equation appears centered on the screen, displaying \"\\(\\int_a^b f'(x) dx = f(b)- f(a)\\)\" in standard math font. The text is rendered in white against a black background, with no animations or camera operations applied.", "code": "class Formula(Scene):\n    def construct(self):\n        t = MathTex(r\"\\int_a^b f'(x) dx = f(b)- f(a)\")\n        self.add(t)", "code_sha1": "c64d377d71fefec8791d9547db0fba94e9768fa6"}
{"url": "https://docs.manim.community/en/stable/reference/manim.mobject.text.tex_mobject.Title.html", "depth": 1, "instruction": "The scene displays a \"Manim version X.X\" title underlined, positioned above a ManimBanner. The title is centered and visually prominent, while the banner serves as a backdrop, enhancing the overall presentation.", "code": "from manim import *\n\nimport manim\n\nclass TitleExample(Scene):\n    def construct(self):\n        banner = ManimBanner()\n        title = Title(f\"Manim version {manim.__version__}\")\n        self.add(banner, title)", "code_sha1": "c32a5c277d92355945f994aa34c2bfa12680c5e2"}
{"url": "https://docs.manim.community/en/stable/reference/manim.mobject.text.tex_mobject.Title.html", "depth": 1, "instruction": "A scene displays a \"Manim version X.Y.Z\" title underlined, positioned above a ManimBanner. The title is styled with default font size and color, while the banner serves as a background element. Both objects are static without animations or camera operations.", "code": "import manim\n\nclass TitleExample(Scene):\n    def construct(self):\n        banner = ManimBanner()\n        title = Title(f\"Manim version {manim.__version__}\")\n        self.add(banner, title)", "code_sha1": "6d1f628d22bbae9747dedbb782604000f85e6e0c"}
{"url": "https://docs.manim.community/en/stable/reference/manim.mobject.text.text_mobject.html", "depth": 1, "instruction": "A large \"Hello world\" text is displayed at the center of the screen, scaled to three times its normal size.", "code": "from manim import *\n\nclass HelloWorld(Scene):\n    def construct(self):\n        text = Text('Hello world').scale(3)\n        self.add(text)", "code_sha1": "62b7df4e3ef47a211f98bc2a8dff09086be736e3"}
{"url": "https://docs.manim.community/en/stable/reference/manim.mobject.text.text_mobject.html", "depth": 1, "instruction": "The scene displays a white title text at the top, reading \"K-means clustering and Logistic Regression,\" scaled to 75% size. Below, four vertically arranged, semi-transparent white texts (\"1. Measuring,\" \"2. Clustering,\" \"3. Regression,\" \"4. Prediction\") are aligned left, with the second item fully opaque, creating a layered visual effect.", "code": "from manim import *\n\nclass TextAlignment(Scene):\n    def construct(self):\n        title = Text(\"K-means clustering and Logistic Regression\", color=WHITE)\n        title.scale(0.75)\n        self.add(title.to_edge(UP))\n\n        t1 = Text(\"1. Measuring\").set_color(WHITE)\n\n        t2 = Text(\"2. Clustering\").set_color(WHITE)\n\n        t3 = Text(\"3. Regression\").set_color(WHITE)\n\n        t4 = Text(\"4. Prediction\").set_color(WHITE)\n\n        x = VGroup(t1, t2, t3, t4).arrange(direction=DOWN, aligned_edge=LEFT).scale(0.7).next_to(ORIGIN,DR)\n        x.set_opacity(0.5)\n        x.submobjects[1].set_opacity(1)\n        self.add(x)", "code_sha1": "0c7fa274db4bad8dff8d2c82a95f4001ee02d754"}
{"url": "https://docs.manim.community/en/stable/reference/manim.mobject.text.text_mobject.html", "depth": 1, "instruction": "A large \"Hello world\" text is displayed in the center of the scene, scaled to three times its normal size.", "code": "class HelloWorld(Scene):\n    def construct(self):\n        text = Text('Hello world').scale(3)\n        self.add(text)", "code_sha1": "6253b840c51e950f897249b423ef7b36747af589"}
{"url": "https://docs.manim.community/en/stable/reference/manim.mobject.text.text_mobject.html", "depth": 1, "instruction": "The scene displays a white title text \"K-means clustering and Logistic Regression\" at the top, scaled down to 75%. Below, four vertically arranged, semi-transparent white texts (\"1. Measuring\", \"2. Clustering\", \"3. Regression\", \"4. Prediction\") are aligned left, with full opacity for the second item, creating a layered effect.", "code": "class TextAlignment(Scene):\n    def construct(self):\n        title = Text(\"K-means clustering and Logistic Regression\", color=WHITE)\n        title.scale(0.75)\n        self.add(title.to_edge(UP))\n\n        t1 = Text(\"1. Measuring\").set_color(WHITE)\n\n        t2 = Text(\"2. Clustering\").set_color(WHITE)\n\n        t3 = Text(\"3. Regression\").set_color(WHITE)\n\n        t4 = Text(\"4. Prediction\").set_color(WHITE)\n\n        x = VGroup(t1, t2, t3, t4).arrange(direction=DOWN, aligned_edge=LEFT).scale(0.7).next_to(ORIGIN,DR)\n        x.set_opacity(0.5)\n        x.submobjects[1].set_opacity(1)\n        self.add(x)", "code_sha1": "5d87ae4e06774d90f34d6c56eb2b37d4c120d48e"}
{"url": "https://docs.manim.community/en/stable/reference/manim.mobject.text.text_mobject.MarkupText.html", "depth": 1, "instruction": "Display a text object with the phrase \"Blue text is cool!\" where \"Blue text\" is large and blue, and \"cool\" is italicized. The text appears centered on the screen without any animations.", "code": "from manim import *\n\nclass MarkupExample(Scene):\n    def construct(self):\n        text = MarkupText('<span foreground=\"blue\" size=\"x-large\">Blue text</span> is <i>cool</i>!\"')\n        self.add(text)", "code_sha1": "c6f97f29e924dbd4103bfb5435e8cf3e9694af58"}
{"url": "https://docs.manim.community/en/stable/reference/manim.mobject.text.text_mobject.MarkupText.html", "depth": 1, "instruction": "The scene displays a colorful Arabic text rendered with MarkupText, featuring individual letters in purple, red, blue, and green. Each letter is styled with specific foreground colors, creating a vibrant visual effect. The text appears centered on the screen without any animations or camera operations.", "code": "from manim import *\n\nclass MarkupElaborateExample(Scene):\n    def construct(self):\n        text = MarkupText(\n            '<span foreground=\"purple\">ا</span><span foreground=\"red\">َ</span>'\n            'ل<span foreground=\"blue\">ْ</span>ع<span foreground=\"red\">َ</span>ر'\n            '<span foreground=\"red\">َ</span>ب<span foreground=\"red\">ِ</span>ي'\n            '<span foreground=\"green\">ّ</span><span foreground=\"red\">َ</span>ة'\n            '<span foreground=\"blue\">ُ</span>'\n        )\n        self.add(text)", "code_sha1": "d1dc37bdb559675e0bfeea69f342a46ddd42b74d"}
{"url": "https://docs.manim.community/en/stable/reference/manim.mobject.text.text_mobject.MarkupText.html", "depth": 1, "instruction": "A vertical arrangement of five styled text objects, each showcasing different markup features: bold, italic, strikethrough, underline, superscript, subscript, and monospace. The colors and sizes vary, with the group positioned centrally on the screen.", "code": "from manim import *\n\nclass BasicMarkupExample(Scene):\n    def construct(self):\n        text1 = MarkupText(\"<b>foo</b> <i>bar</i> <b><i>foobar</i></b>\")\n        text2 = MarkupText(\"<s>foo</s> <u>bar</u> <big>big</big> <small>small</small>\")\n        text3 = MarkupText(\"H<sub>2</sub>O and H<sub>3</sub>O<sup>+</sup>\")\n        text4 = MarkupText(\"type <tt>help</tt> for help\")\n        text5 = MarkupText(\n            '<span underline=\"double\">foo</span> <span underline=\"error\">bar</span>'\n        )\n        group = VGroup(text1, text2, text3, text4, text5).arrange(DOWN)\n        self.add(group)", "code_sha1": "cdfd1750c96c6b8dd010f75219838b64c50f8fe7"}
{"url": "https://docs.manim.community/en/stable/reference/manim.mobject.text.text_mobject.MarkupText.html", "depth": 1, "instruction": "The scene displays a vertical arrangement of seven `MarkupText` objects, featuring various text styles: red text with yellow highlights, a blue-green gradient, and multiple ligature effects with gradients. Each text element is clearly legible, with distinct colors and effects, creating a visually engaging composition.", "code": "from manim import *\n\nclass ColorExample(Scene):\n    def construct(self):\n        text1 = MarkupText(\n            f'all in red <span fgcolor=\"{YELLOW}\">except this</span>', color=RED\n        )\n        text2 = MarkupText(\"nice gradient\", gradient=(BLUE, GREEN))\n        text3 = MarkupText(\n            'nice <gradient from=\"RED\" to=\"YELLOW\">intermediate</gradient> gradient',\n            gradient=(BLUE, GREEN),\n        )\n        text4 = MarkupText(\n            'fl ligature <gradient from=\"RED\" to=\"YELLOW\">causing trouble</gradient> here'\n        )\n        text5 = MarkupText(\n            'fl ligature <gradient from=\"RED\" to=\"YELLOW\" offset=\"1\">defeated</gradient> with offset'\n        )\n        text6 = MarkupText(\n            'fl ligature <gradient from=\"RED\" to=\"YELLOW\" offset=\"1\">floating</gradient> inside'\n        )\n        text7 = MarkupText(\n            'fl ligature <gradient from=\"RED\" to=\"YELLOW\" offset=\"1,1\">floating</gradient> inside'\n        )\n        group = VGroup(text1, text2, text3, text4, text5, text6, text7).arrange(DOWN)\n        self.add(group)", "code_sha1": "7da2a43bc00171ed6dd55040934f4a2631446753"}
{"url": "https://docs.manim.community/en/stable/reference/manim.mobject.text.text_mobject.MarkupText.html", "depth": 1, "instruction": "The scene displays five lines of styled text, each with varying underline styles (single/double) in green and gradients transitioning from yellow to red. The text is arranged vertically, with each line positioned below the previous one, creating a visually appealing stacked effect.", "code": "from manim import *\n\nclass UnderlineExample(Scene):\n    def construct(self):\n        text1 = MarkupText(\n            '<span underline=\"double\" underline_color=\"green\">bla</span>'\n        )\n        text2 = MarkupText(\n            '<span underline=\"single\" underline_color=\"green\">xxx</span><gradient from=\"#ffff00\" to=\"RED\">aabb</gradient>y'\n        )\n        text3 = MarkupText(\n            '<span underline=\"single\" underline_color=\"green\">xxx</span><gradient from=\"#ffff00\" to=\"RED\" offset=\"-1\">aabb</gradient>y'\n        )\n        text4 = MarkupText(\n            '<span underline=\"double\" underline_color=\"green\">xxx</span><gradient from=\"#ffff00\" to=\"RED\">aabb</gradient>y'\n        )\n        text5 = MarkupText(\n            '<span underline=\"double\" underline_color=\"green\">xxx</span><gradient from=\"#ffff00\" to=\"RED\" offset=\"-2\">aabb</gradient>y'\n        )\n        group = VGroup(text1, text2, text3, text4, text5).arrange(DOWN)\n        self.add(group)", "code_sha1": "0b2b7e2b3532170a2ea14a797096a62eb75b8b8f"}
{"url": "https://docs.manim.community/en/stable/reference/manim.mobject.text.text_mobject.MarkupText.html", "depth": 1, "instruction": "The scene displays four lines of text arranged vertically, showcasing different font styles: the first in sans-serif with one serif exception, the second mixing serif, sans-serif, and monospace, and the last two demonstrating special characters. The text is centered on the screen with no animations or camera operations.", "code": "from manim import *\n\nclass FontExample(Scene):\n    def construct(self):\n        text1 = MarkupText(\n            'all in sans <span font_family=\"serif\">except this</span>', font=\"sans\"\n        )\n        text2 = MarkupText(\n            '<span font_family=\"serif\">mixing</span> <span font_family=\"sans\">fonts</span> <span font_family=\"monospace\">is ugly</span>'\n        )\n        text3 = MarkupText(\"special char > or &gt;\")\n        text4 = MarkupText(\"special char &lt; and &amp;\")\n        group = VGroup(text1, text2, text3, text4).arrange(DOWN)\n        self.add(group)", "code_sha1": "87f46cda2eaaefc9c59e7db229c3986f16d618c1"}
{"url": "https://docs.manim.community/en/stable/reference/manim.mobject.text.text_mobject.MarkupText.html", "depth": 1, "instruction": "A scene displays the text \"foooo\" in default color, followed by \"oo\" and \"baa\" in red, with \"baa\" on a new line, all centered on the screen.", "code": "from manim import *\n\nclass NewlineExample(Scene):\n    def construct(self):\n        text = MarkupText('foooo<span foreground=\"red\">oo\\nbaa</span>aar')\n        self.add(text)", "code_sha1": "22f859008ff58132a66c816e84b725705e166fce"}
{"url": "https://docs.manim.community/en/stable/reference/manim.mobject.text.text_mobject.MarkupText.html", "depth": 1, "instruction": "Two lines of text are displayed vertically, with the first line showing \"floating\" with a red-to-green gradient on \"oat,\" and the second line showing the same text without ligatures, maintaining the gradient. The text is centered on the screen.", "code": "from manim import *\n\nclass NoLigaturesExample(Scene):\n    def construct(self):\n        text1 = MarkupText('fl<gradient from=\"RED\" to=\"GREEN\">oat</gradient>ing')\n        text2 = MarkupText('fl<gradient from=\"RED\" to=\"GREEN\">oat</gradient>ing', disable_ligatures=True)\n        group = VGroup(text1, text2).arrange(DOWN)\n        self.add(group)", "code_sha1": "4b5855b65e665e85b5e58a17377b781ee0e0460d"}
{"url": "https://docs.manim.community/en/stable/reference/manim.mobject.text.text_mobject.MarkupText.html", "depth": 1, "instruction": "The scene displays a vertical arrangement of six text elements in various languages, including Tamil, Japanese, Russian, Hindi, and Chinese, with \"Multi-Language\" in bold. Each text is rendered in a sans-serif font, with the Japanese text highlighted in blue. The group is centered on the screen.", "code": "from manim import *\n\nclass MultiLanguage(Scene):\n    def construct(self):\n        morning = MarkupText(\"வணக்கம்\", font=\"sans-serif\")\n        japanese = MarkupText(\n            '<span fgcolor=\"blue\">日本</span>へようこそ'\n        )  # works as in ``Text``.\n        mess = MarkupText(\"Multi-Language\", weight=BOLD)\n        russ = MarkupText(\"Здравствуйте मस नम म \", font=\"sans-serif\")\n        hin = MarkupText(\"नमस्ते\", font=\"sans-serif\")\n        chinese = MarkupText(\"臂猿「黛比」帶著孩子\", font=\"sans-serif\")\n        group = VGroup(morning, japanese, mess, russ, hin, chinese).arrange(DOWN)\n        self.add(group)", "code_sha1": "7793d1e93158ff8401bfc12d07df775073a10e7d"}
{"url": "https://docs.manim.community/en/stable/reference/manim.mobject.text.text_mobject.MarkupText.html", "depth": 1, "instruction": "The scene displays two titles (\"Justified\" and \"Not Justified\") with corresponding text blocks. Initially, the \"Not Justified\" title and text appear, then fade out as the \"Justified\" title and text fade in, all scaled to 0.4. The transition lasts briefly before a 1-second pause.", "code": "from manim import *\n\nclass JustifyText(Scene):\n    def construct(self):\n        ipsum_text = (\n            \"Lorem ipsum dolor sit amet, consectetur adipiscing elit.\"\n            \"Praesent feugiat metus sit amet iaculis pulvinar. Nulla posuere \"\n            \"quam a ex aliquam, eleifend consectetur tellus viverra. Aliquam \"\n            \"fermentum interdum justo, nec rutrum elit pretium ac. Nam quis \"\n            \"leo pulvinar, dignissim est at, venenatis nisi.\"\n        )\n        justified_text = MarkupText(ipsum_text, justify=True).scale(0.4)\n        not_justified_text = MarkupText(ipsum_text, justify=False).scale(0.4)\n        just_title = Title(\"Justified\")\n        njust_title = Title(\"Not Justified\")\n        self.add(njust_title, not_justified_text)\n        self.play(\n            FadeOut(not_justified_text),\n            FadeIn(justified_text),\n            FadeOut(njust_title),\n            FadeIn(just_title),\n        )\n        self.wait(1)", "code_sha1": "87ba5ac7ab592b6f011caf97c31991322eb8f8ad"}
{"url": "https://docs.manim.community/en/stable/reference/manim.mobject.text.text_mobject.MarkupText.html", "depth": 1, "instruction": "A scene displays the text \"Blue text is cool!\" in a default color and font style, centered on the screen. The text appears instantly without any animations or transformations.", "code": "class MarkupExample(Scene):\n    def construct(self):\n        text = MarkupText('Blue text is cool!\"')\n        self.add(text)", "code_sha1": "f36939a9a5e18a6edddfec57b8eda12d7ac4bc65"}
{"url": "https://docs.manim.community/en/stable/reference/manim.mobject.text.text_mobject.MarkupText.html", "depth": 1, "instruction": "A single Arabic word \"العربية\" is displayed in a large, bold font at the center of the screen, with each letter appearing sequentially in a smooth animation, creating a visually engaging effect.", "code": "class MarkupElaborateExample(Scene):\n    def construct(self):\n        text = MarkupText(\n            'اَ'\n            'لْعَر'\n            'َبِي'\n            'َّة'\n            'ُ'\n        )\n        self.add(text)", "code_sha1": "362b5cf56577050df28736c75fff133a4d4c127b"}
{"url": "https://docs.manim.community/en/stable/reference/manim.mobject.text.text_mobject.MarkupText.html", "depth": 1, "instruction": "A vertical arrangement of five MarkupText objects displaying various text strings, with default colors and sizes, is added to the scene. Each text line is positioned one below the other, creating a clean, stacked appearance.", "code": "class BasicMarkupExample(Scene):\n    def construct(self):\n        text1 = MarkupText(\"foo bar foobar\")\n        text2 = MarkupText(\"foo bar big small\")\n        text3 = MarkupText(\"H2O and H3O+\")\n        text4 = MarkupText(\"type help for help\")\n        text5 = MarkupText(\n            'foo bar'\n        )\n        group = VGroup(text1, text2, text3, text4, text5).arrange(DOWN)\n        self.add(group)", "code_sha1": "0e385f644854aff2891bdc45bcdb55a34a95238c"}
{"url": "https://docs.manim.community/en/stable/reference/manim.mobject.text.text_mobject.MarkupText.html", "depth": 1, "instruction": "The scene displays a vertical arrangement of seven `MarkupText` objects, featuring various colors and gradients: the first in red, the second and third with blue-green gradients, and the last four demonstrating different treatments of the \"fl\" ligature. The texts are neatly aligned and grouped.", "code": "class ColorExample(Scene):\n    def construct(self):\n        text1 = MarkupText(\n            f'all in red except this', color=RED\n        )\n        text2 = MarkupText(\"nice gradient\", gradient=(BLUE, GREEN))\n        text3 = MarkupText(\n            'nice intermediate gradient',\n            gradient=(BLUE, GREEN),\n        )\n        text4 = MarkupText(\n            'fl ligature causing trouble here'\n        )\n        text5 = MarkupText(\n            'fl ligature defeated with offset'\n        )\n        text6 = MarkupText(\n            'fl ligature floating inside'\n        )\n        text7 = MarkupText(\n            'fl ligature floating inside'\n        )\n        group = VGroup(text1, text2, text3, text4, text5, text6, text7).arrange(DOWN)\n        self.add(group)", "code_sha1": "345d30c0b4c00f0f8daaf2a3aa8adfd3ebbca451"}
{"url": "https://docs.manim.community/en/stable/reference/manim.mobject.text.text_mobject.MarkupText.html", "depth": 1, "instruction": "Five instances of `MarkupText` displaying the text \"bla\" and \"xxxaabby\" are vertically arranged in a group, with no specific colors or animations applied, resulting in a static display of text elements.", "code": "class UnderlineExample(Scene):\n    def construct(self):\n        text1 = MarkupText(\n            'bla'\n        )\n        text2 = MarkupText(\n            'xxxaabby'\n        )\n        text3 = MarkupText(\n            'xxxaabby'\n        )\n        text4 = MarkupText(\n            'xxxaabby'\n        )\n        text5 = MarkupText(\n            'xxxaabby'\n        )\n        group = VGroup(text1, text2, text3, text4, text5).arrange(DOWN)\n        self.add(group)", "code_sha1": "97db1ab1b814179e8f2433849ef2069607ab60af"}
{"url": "https://docs.manim.community/en/stable/reference/manim.mobject.text.text_mobject.MarkupText.html", "depth": 1, "instruction": "The scene displays four lines of text arranged vertically, with the first line in a sans-serif font, while the others use the default font. The text includes special characters and is grouped together for a cohesive presentation.", "code": "class FontExample(Scene):\n    def construct(self):\n        text1 = MarkupText(\n            'all in sans except this', font=\"sans\"\n        )\n        text2 = MarkupText(\n            'mixing fonts is ugly'\n        )\n        text3 = MarkupText(\"special char > or >\")\n        text4 = MarkupText(\"special char < and &\")\n        group = VGroup(text1, text2, text3, text4).arrange(DOWN)\n        self.add(group)", "code_sha1": "a8a05666312d08b8face9c6ea59f2a87eed2f5a5"}
{"url": "https://docs.manim.community/en/stable/reference/manim.mobject.text.text_mobject.MarkupText.html", "depth": 1, "instruction": "A scene displays the text \"foooooo\" on the first line and \"baaaar\" on the second line, rendered using MarkupText. The text is positioned at the center of the screen with default font properties and colors.", "code": "class NewlineExample(Scene):\n    def construct(self):\n        text = MarkupText('foooooo\\nbaaaar')\n        self.add(text)", "code_sha1": "1692eb9d09428e2cc67ab17476ac894f6dcce237"}
{"url": "https://docs.manim.community/en/stable/reference/manim.mobject.text.text_mobject.MarkupText.html", "depth": 1, "instruction": "Display two vertically arranged text objects: the first shows \"floating\" with ligatures, and the second shows \"floating\" without ligatures, both in default colors and sizes.", "code": "class NoLigaturesExample(Scene):\n    def construct(self):\n        text1 = MarkupText('floating')\n        text2 = MarkupText('floating', disable_ligatures=True)\n        group = VGroup(text1, text2).arrange(DOWN)\n        self.add(group)", "code_sha1": "6aa3219ed7679abf91193501d04a4fd684fc1cbb"}
{"url": "https://docs.manim.community/en/stable/reference/manim.mobject.text.text_mobject.MarkupText.html", "depth": 1, "instruction": "The scene displays a vertical arrangement of six text objects in various languages, including Tamil, Japanese, Russian, Hindi, and Chinese, with \"Multi-Language\" in bold. All texts are rendered in a sans-serif font, positioned evenly down the center of the screen.", "code": "class MultiLanguage(Scene):\n    def construct(self):\n        morning = MarkupText(\"வணக்கம்\", font=\"sans-serif\")\n        japanese = MarkupText(\n            '日本へようこそ'\n        )  # works as in ``Text``.\n        mess = MarkupText(\"Multi-Language\", weight=BOLD)\n        russ = MarkupText(\"Здравствуйте मस नम म \", font=\"sans-serif\")\n        hin = MarkupText(\"नमस्ते\", font=\"sans-serif\")\n        chinese = MarkupText(\"臂猿「黛比」帶著孩子\", font=\"sans-serif\")\n        group = VGroup(morning, japanese, mess, russ, hin, chinese).arrange(DOWN)\n        self.add(group)", "code_sha1": "f5dc911eaa97bd2323c7dc0e8e4dd295126915a9"}
{"url": "https://docs.manim.community/en/stable/reference/manim.mobject.text.text_mobject.MarkupText.html", "depth": 1, "instruction": "The scene displays two titles, \"Justified\" and \"Not Justified,\" with corresponding text blocks. Initially, the \"Not Justified\" title and text appear, then fade out as the \"Justified\" title and text fade in, all scaled to 0.4. The transition lasts briefly before a 1-second pause.", "code": "class JustifyText(Scene):\n    def construct(self):\n        ipsum_text = (\n            \"Lorem ipsum dolor sit amet, consectetur adipiscing elit.\"\n            \"Praesent feugiat metus sit amet iaculis pulvinar. Nulla posuere \"\n            \"quam a ex aliquam, eleifend consectetur tellus viverra. Aliquam \"\n            \"fermentum interdum justo, nec rutrum elit pretium ac. Nam quis \"\n            \"leo pulvinar, dignissim est at, venenatis nisi.\"\n        )\n        justified_text = MarkupText(ipsum_text, justify=True).scale(0.4)\n        not_justified_text = MarkupText(ipsum_text, justify=False).scale(0.4)\n        just_title = Title(\"Justified\")\n        njust_title = Title(\"Not Justified\")\n        self.add(njust_title, not_justified_text)\n        self.play(\n            FadeOut(not_justified_text),\n            FadeIn(justified_text),\n            FadeOut(njust_title),\n            FadeIn(just_title),\n        )\n        self.wait(1)", "code_sha1": "6ecced0fd0bba2e9fa4be6e64c505cb32aed6898"}
{"url": "https://docs.manim.community/en/stable/reference/manim.mobject.text.text_mobject.Text.html", "depth": 1, "instruction": "A large \"Hello world\" text is displayed in the center of the scene, scaled to three times its normal size.", "code": "from manim import *\n\nclass Example1Text(Scene):\n    def construct(self):\n        text = Text('Hello world').scale(3)\n        self.add(text)", "code_sha1": "5e3bfe5b9fa1e21364ce7c7f4df1384ad34a18da"}
{"url": "https://docs.manim.community/en/stable/reference/manim.mobject.text.text_mobject.Text.html", "depth": 1, "instruction": "The scene displays two large text objects saying \"Hello world\": the first in solid blue, and the second in a blue-to-green gradient, positioned directly below the first. Both texts are scaled to three times their normal size.", "code": "from manim import *\n\nclass TextColorExample(Scene):\n    def construct(self):\n        text1 = Text('Hello world', color=BLUE).scale(3)\n        text2 = Text('Hello world', gradient=(BLUE, GREEN)).scale(3).next_to(text1, DOWN)\n        self.add(text1, text2)", "code_sha1": "b793e0813063b099b8700c455f0f613a1702885b"}
{"url": "https://docs.manim.community/en/stable/reference/manim.mobject.text.text_mobject.Text.html", "depth": 1, "instruction": "The scene displays six lines of text arranged vertically, featuring various styles: italic, bold, and color highlights (yellow). The last line is larger and shifted down. The overall height of the group is set to fit within the frame, with a slight vertical spacing between each line.", "code": "from manim import *\n\nclass TextItalicAndBoldExample(Scene):\n    def construct(self):\n        text1 = Text(\"Hello world\", slant=ITALIC)\n        text2 = Text(\"Hello world\", t2s={'world':ITALIC})\n        text3 = Text(\"Hello world\", weight=BOLD)\n        text4 = Text(\"Hello world\", t2w={'world':BOLD})\n        text5 = Text(\"Hello world\", t2c={'o':YELLOW}, disable_ligatures=True)\n        text6 = Text(\n            \"Visit us at docs.manim.community\",\n            t2c={\"docs.manim.community\": YELLOW},\n            disable_ligatures=True,\n       )\n        text6.scale(1.3).shift(DOWN)\n        self.add(text1, text2, text3, text4, text5 , text6)\n        Group(*self.mobjects).arrange(DOWN, buff=.8).set(height=config.frame_height-LARGE_BUFF)", "code_sha1": "07ac3ca2a6ea37e7939704f8e7320a395a150317"}
{"url": "https://docs.manim.community/en/stable/reference/manim.mobject.text.text_mobject.Text.html", "depth": 1, "instruction": "The scene displays the word \"Google\" in a large, colorful font (size 174) with each letter in a different color: blue, red, yellow, blue, green, and red, respectively. The text is centered on the screen without any animations or camera operations.", "code": "from manim import *\n\nclass TextMoreCustomization(Scene):\n    def construct(self):\n        text1 = Text(\n            'Google',\n            t2c={'[:1]': '#3174f0', '[1:2]': '#e53125',\n                 '[2:3]': '#fbb003', '[3:4]': '#3174f0',\n                 '[4:5]': '#269a43', '[5:]': '#e53125'}, font_size=58).scale(3)\n        self.add(text1)", "code_sha1": "f14fd3eadb66535cb9ff823198afc16ad3b7710e"}
{"url": "https://docs.manim.community/en/stable/reference/manim.mobject.text.text_mobject.Text.html", "depth": 1, "instruction": "The scene displays seven text objects in various languages, each rendered in a sans-serif font. They are vertically arranged, with the first object at the center and others shifted downwards. The Japanese text features the word \"日本\" in blue. The overall layout creates a visually diverse representation of multilingual text.", "code": "from manim import *\n\nclass MultipleFonts(Scene):\n    def construct(self):\n        morning = Text(\"வணக்கம்\", font=\"sans-serif\")\n        japanese = Text(\n            \"日本へようこそ\", t2c={\"日本\": BLUE}\n        )  # works same as ``Text``.\n        mess = Text(\"Multi-Language\", weight=BOLD)\n        russ = Text(\"Здравствуйте मस नम म \", font=\"sans-serif\")\n        hin = Text(\"नमस्ते\", font=\"sans-serif\")\n        arb = Text(\n            \"صباح الخير \\n تشرفت بمقابلتك\", font=\"sans-serif\"\n        )  # don't mix RTL and LTR languages nothing shows up then ;-)\n        chinese = Text(\"臂猿「黛比」帶著孩子\", font=\"sans-serif\")\n        self.add(morning, japanese, mess, russ, hin, arb, chinese)\n        for i,mobj in enumerate(self.mobjects):\n            mobj.shift(DOWN*(i-3))", "code_sha1": "35a2dcbc3797c90a58e46443990b1abd1a362e90"}
{"url": "https://docs.manim.community/en/stable/reference/manim.mobject.text.text_mobject.Text.html", "depth": 1, "instruction": "The scene displays the Tamil word \"வணக்கம்\" rendered in a sans-serif font, animated with a writing effect. The text appears on the screen, followed by a 2-second pause before the scene ends.", "code": "from manim import *\n\nclass PangoRender(Scene):\n    def construct(self):\n        morning = Text(\"வணக்கம்\", font=\"sans-serif\")\n        self.play(Write(morning))\n        self.wait(2)", "code_sha1": "7dd0740eaf67b1869681b8f8f3153a1a042d3532"}
{"url": "https://docs.manim.community/en/stable/reference/manim.mobject.text.text_mobject.Text.html", "depth": 1, "instruction": "A large \"Hello world\" text is displayed in the center of the scene, scaled to three times its original size.", "code": "class Example1Text(Scene):\n    def construct(self):\n        text = Text('Hello world').scale(3)\n        self.add(text)", "code_sha1": "1de18a35c0983d229d2b360f1e3c293be5880f25"}
{"url": "https://docs.manim.community/en/stable/reference/manim.mobject.text.text_mobject.Text.html", "depth": 1, "instruction": "Display two large text objects saying \"Hello world\": the first in solid blue, and the second with a blue-to-green gradient positioned directly below the first. Both texts are scaled to three times their normal size.", "code": "class TextColorExample(Scene):\n    def construct(self):\n        text1 = Text('Hello world', color=BLUE).scale(3)\n        text2 = Text('Hello world', gradient=(BLUE, GREEN)).scale(3).next_to(text1, DOWN)\n        self.add(text1, text2)", "code_sha1": "aa0a15c8810542c26ead3abbc16d22c41935a8ce"}
{"url": "https://docs.manim.community/en/stable/reference/manim.mobject.text.text_mobject.Text.html", "depth": 1, "instruction": "The scene displays six text objects arranged vertically, each with distinct styles: italic, bold, and colored elements. The last text is larger and shifted down, with \"docs.manim.community\" highlighted in yellow. The overall height of the arrangement fills the scene, with a slight buffer between each text element.", "code": "class TextItalicAndBoldExample(Scene):\n    def construct(self):\n        text1 = Text(\"Hello world\", slant=ITALIC)\n        text2 = Text(\"Hello world\", t2s={'world':ITALIC})\n        text3 = Text(\"Hello world\", weight=BOLD)\n        text4 = Text(\"Hello world\", t2w={'world':BOLD})\n        text5 = Text(\"Hello world\", t2c={'o':YELLOW}, disable_ligatures=True)\n        text6 = Text(\n            \"Visit us at docs.manim.community\",\n            t2c={\"docs.manim.community\": YELLOW},\n            disable_ligatures=True,\n       )\n        text6.scale(1.3).shift(DOWN)\n        self.add(text1, text2, text3, text4, text5 , text6)\n        Group(*self.mobjects).arrange(DOWN, buff=.8).set(height=config.frame_height-LARGE_BUFF)", "code_sha1": "08c377dfdfdfefa35c5f805b49c08ba4ab6dedbc"}
{"url": "https://docs.manim.community/en/stable/reference/manim.mobject.text.text_mobject.Text.html", "depth": 1, "instruction": "A large, colorful text reading \"Google\" appears, with each letter in a different color: blue, red, yellow, blue, green, and red, scaled to three times its original size. The text is centered in the scene.", "code": "class TextMoreCustomization(Scene):\n    def construct(self):\n        text1 = Text(\n            'Google',\n            t2c={'[:1]': '#3174f0', '[1:2]': '#e53125',\n                 '[2:3]': '#fbb003', '[3:4]': '#3174f0',\n                 '[4:5]': '#269a43', '[5:]': '#e53125'}, font_size=58).scale(3)\n        self.add(text1)", "code_sha1": "944be05bb71f019ba47b395a561fa3268127a9b1"}
{"url": "https://docs.manim.community/en/stable/reference/manim.mobject.text.text_mobject.Text.html", "depth": 1, "instruction": "The scene displays seven text objects in various languages, each centered and vertically spaced. The colors include blue for part of the Japanese text, and the \"Multi-Language\" text is bold. Each text object is shifted downwards, creating a staggered effect, with the camera focused on the center of the arrangement.", "code": "class MultipleFonts(Scene):\n    def construct(self):\n        morning = Text(\"வணக்கம்\", font=\"sans-serif\")\n        japanese = Text(\n            \"日本へようこそ\", t2c={\"日本\": BLUE}\n        )  # works same as ``Text``.\n        mess = Text(\"Multi-Language\", weight=BOLD)\n        russ = Text(\"Здравствуйте मस नम म \", font=\"sans-serif\")\n        hin = Text(\"नमस्ते\", font=\"sans-serif\")\n        arb = Text(\n            \"صباح الخير \\n تشرفت بمقابلتك\", font=\"sans-serif\"\n        )  # don't mix RTL and LTR languages nothing shows up then ;-)\n        chinese = Text(\"臂猿「黛比」帶著孩子\", font=\"sans-serif\")\n        self.add(morning, japanese, mess, russ, hin, arb, chinese)\n        for i,mobj in enumerate(self.mobjects):\n            mobj.shift(DOWN*(i-3))", "code_sha1": "100fc8e90df8fd7bc901c2f76716d9208787711f"}
{"url": "https://docs.manim.community/en/stable/reference/manim.mobject.text.text_mobject.Text.html", "depth": 1, "instruction": "The scene displays the Tamil word \"வணக்கம்\" rendered in a sans-serif font, smoothly written onto the screen with a writing animation, followed by a 2-second pause before the scene ends.", "code": "class PangoRender(Scene):\n    def construct(self):\n        morning = Text(\"வணக்கம்\", font=\"sans-serif\")\n        self.play(Write(morning))\n        self.wait(2)", "code_sha1": "4281ca3ae2faf43bb2401e61ae6b0184c072d8c1"}
{"url": "https://docs.manim.community/en/stable/reference/manim.mobject.three_d.polyhedra.ConvexHull3D.html", "depth": 1, "instruction": "The scene displays a 3D convex hull formed by a set of points represented as blue edges with low opacity, alongside distinct 3D dots at each point's location. The camera is oriented at a 75-degree elevation and 30-degree azimuth, providing a dynamic perspective of the structure.", "code": "from manim import *\n\nclass ConvexHull3DExample(ThreeDScene):\n    def construct(self):\n        self.set_camera_orientation(phi=75 * DEGREES, theta=30 * DEGREES)\n        points = [\n            [ 1.93192757,  0.44134585, -1.52407061],\n            [-0.93302521,  1.23206983,  0.64117067],\n            [-0.44350918, -0.61043677,  0.21723705],\n            [-0.42640268, -1.05260843,  1.61266094],\n            [-1.84449637,  0.91238739, -1.85172623],\n            [ 1.72068132, -0.11880457,  0.51881751],\n            [ 0.41904805,  0.44938012, -1.86440686],\n            [ 0.83864666,  1.66653337,  1.88960123],\n            [ 0.22240514, -0.80986286,  1.34249326],\n            [-1.29585759,  1.01516189,  0.46187522],\n            [ 1.7776499,  -1.59550796, -1.70240747],\n            [ 0.80065226, -0.12530398,  1.70063977],\n            [ 1.28960948, -1.44158255,  1.39938582],\n            [-0.93538943,  1.33617705, -0.24852643],\n            [-1.54868271,  1.7444399,  -0.46170734]\n        ]\n        hull = ConvexHull3D(\n            *points,\n            faces_config = {\"stroke_opacity\": 0},\n            graph_config = {\n                \"vertex_type\": Dot3D,\n                \"edge_config\": {\n                    \"stroke_color\": BLUE,\n                    \"stroke_width\": 2,\n                    \"stroke_opacity\": 0.05,\n                }\n            }\n        )\n        dots = VGroup(*[Dot3D(point) for point in points])\n        self.add(hull)\n        self.add(dots)", "code_sha1": "1e96cbdabf8e7f95b1a71d778381acaa8f9b4bb1"}
{"url": "https://docs.manim.community/en/stable/reference/manim.mobject.three_d.polyhedra.ConvexHull3D.html", "depth": 1, "instruction": "The scene displays a 3D convex hull formed by a set of points represented as blue edges with low opacity, alongside distinct colored dots at each point's location. The camera is oriented at a 75-degree elevation and 30-degree azimuth, providing a dynamic perspective of the structure.", "code": "class ConvexHull3DExample(ThreeDScene):\n    def construct(self):\n        self.set_camera_orientation(phi=75 * DEGREES, theta=30 * DEGREES)\n        points = [\n            [ 1.93192757,  0.44134585, -1.52407061],\n            [-0.93302521,  1.23206983,  0.64117067],\n            [-0.44350918, -0.61043677,  0.21723705],\n            [-0.42640268, -1.05260843,  1.61266094],\n            [-1.84449637,  0.91238739, -1.85172623],\n            [ 1.72068132, -0.11880457,  0.51881751],\n            [ 0.41904805,  0.44938012, -1.86440686],\n            [ 0.83864666,  1.66653337,  1.88960123],\n            [ 0.22240514, -0.80986286,  1.34249326],\n            [-1.29585759,  1.01516189,  0.46187522],\n            [ 1.7776499,  -1.59550796, -1.70240747],\n            [ 0.80065226, -0.12530398,  1.70063977],\n            [ 1.28960948, -1.44158255,  1.39938582],\n            [-0.93538943,  1.33617705, -0.24852643],\n            [-1.54868271,  1.7444399,  -0.46170734]\n        ]\n        hull = ConvexHull3D(\n            *points,\n            faces_config = {\"stroke_opacity\": 0},\n            graph_config = {\n                \"vertex_type\": Dot3D,\n                \"edge_config\": {\n                    \"stroke_color\": BLUE,\n                    \"stroke_width\": 2,\n                    \"stroke_opacity\": 0.05,\n                }\n            }\n        )\n        dots = VGroup(*[Dot3D(point) for point in points])\n        self.add(hull)\n        self.add(dots)", "code_sha1": "1edd5c51a9a70db45fc88b0dc920dbbc9b60696d"}
{"url": "https://docs.manim.community/en/stable/reference/manim.mobject.three_d.polyhedra.Dodecahedron.html", "depth": 1, "instruction": "A 3D dodecahedron is displayed, positioned at the center of the scene with a camera angle set at 75 degrees elevation and 30 degrees azimuth, showcasing its geometric structure without any animations or color changes.", "code": "from manim import *\n\nclass DodecahedronScene(ThreeDScene):\n    def construct(self):\n        self.set_camera_orientation(phi=75 * DEGREES, theta=30 * DEGREES)\n        obj = Dodecahedron()\n        self.add(obj)", "code_sha1": "9cba3e3dae51358cff737258f646053f532f8d0c"}
{"url": "https://docs.manim.community/en/stable/reference/manim.mobject.three_d.polyhedra.Dodecahedron.html", "depth": 1, "instruction": "A 3D dodecahedron is displayed, positioned at the center of the scene, with a camera oriented at a 75-degree elevation and a 30-degree azimuth, showcasing its geometric structure.", "code": "class DodecahedronScene(ThreeDScene):\n    def construct(self):\n        self.set_camera_orientation(phi=75 * DEGREES, theta=30 * DEGREES)\n        obj = Dodecahedron()\n        self.add(obj)", "code_sha1": "3e85df877f9acbefea645028875b68acc9329deb"}
{"url": "https://docs.manim.community/en/stable/reference/manim.mobject.three_d.polyhedra.Icosahedron.html", "depth": 1, "instruction": "A 3D scene displays a white icosahedron, set against a dark background, with the camera oriented at a 75-degree elevation and 30-degree azimuth. The icosahedron is static, showcasing its geometric structure without any animations or movements.", "code": "from manim import *\n\nclass IcosahedronScene(ThreeDScene):\n    def construct(self):\n        self.set_camera_orientation(phi=75 * DEGREES, theta=30 * DEGREES)\n        obj = Icosahedron()\n        self.add(obj)", "code_sha1": "26825940be0a485b7c6d3ece4bda01185defb8a6"}
{"url": "https://docs.manim.community/en/stable/reference/manim.mobject.three_d.polyhedra.Icosahedron.html", "depth": 1, "instruction": "A 3D scene displays a white icosahedron with a defined edge length, positioned at the center. The camera is oriented at a 75-degree elevation and a 30-degree azimuth, providing a dynamic perspective of the solid.", "code": "class IcosahedronScene(ThreeDScene):\n    def construct(self):\n        self.set_camera_orientation(phi=75 * DEGREES, theta=30 * DEGREES)\n        obj = Icosahedron()\n        self.add(obj)", "code_sha1": "c6dc14668a0b091c1c6974728f081134740d12f9"}
{"url": "https://docs.manim.community/en/stable/reference/manim.mobject.three_d.polyhedra.Octahedron.html", "depth": 1, "instruction": "A 3D octahedron is displayed with a camera orientation set at 75 degrees elevation and 30 degrees azimuth, showcasing its geometric structure. The octahedron is added to the scene without any animations or transformations.", "code": "from manim import *\n\nclass OctahedronScene(ThreeDScene):\n    def construct(self):\n        self.set_camera_orientation(phi=75 * DEGREES, theta=30 * DEGREES)\n        obj = Octahedron()\n        self.add(obj)", "code_sha1": "93020062cae06446fe21dd24b3e4f7b319c2b1ef"}
{"url": "https://docs.manim.community/en/stable/reference/manim.mobject.three_d.polyhedra.Octahedron.html", "depth": 1, "instruction": "A 3D octahedron is displayed with a camera orientation set at 75 degrees elevation and 30 degrees azimuth, showcasing its geometric structure in a visually appealing perspective.", "code": "class OctahedronScene(ThreeDScene):\n    def construct(self):\n        self.set_camera_orientation(phi=75 * DEGREES, theta=30 * DEGREES)\n        obj = Octahedron()\n        self.add(obj)", "code_sha1": "b3b8591eb9fb5e661cf71bdc25bffaf69f00dba6"}
{"url": "https://docs.manim.community/en/stable/reference/manim.mobject.three_d.polyhedra.Polyhedron.html", "depth": 1, "instruction": "A 3D square pyramid is displayed with a camera angle of 75 degrees elevation and 30 degrees azimuth. The pyramid features a square base and four triangular faces, rendered in a default color. The scene includes no animations or transitions, simply presenting the static polyhedron in the specified orientation.", "code": "from manim import *\n\nclass SquarePyramidScene(ThreeDScene):\n    def construct(self):\n        self.set_camera_orientation(phi=75 * DEGREES, theta=30 * DEGREES)\n        vertex_coords = [\n            [1, 1, 0],\n            [1, -1, 0],\n            [-1, -1, 0],\n            [-1, 1, 0],\n            [0, 0, 2]\n        ]\n        faces_list = [\n            [0, 1, 4],\n            [1, 2, 4],\n            [2, 3, 4],\n            [3, 0, 4],\n            [0, 1, 2, 3]\n        ]\n        pyramid = Polyhedron(vertex_coords, faces_list)\n        self.add(pyramid)", "code_sha1": "c9ee5c0812d29395822711eafc1e765824932fb9"}
{"url": "https://docs.manim.community/en/stable/reference/manim.mobject.three_d.polyhedra.Polyhedron.html", "depth": 1, "instruction": "A 3D scene displays a red octahedron with a yellow face, set against a backdrop with a camera angled at 75 degrees elevation and 30 degrees azimuth. The octahedron is centered in the view, showcasing its geometric structure.", "code": "from manim import *\n\nclass PolyhedronSubMobjects(ThreeDScene):\n    def construct(self):\n        self.set_camera_orientation(phi=75 * DEGREES, theta=30 * DEGREES)\n        octahedron = Octahedron(edge_length = 3)\n        octahedron.graph[0].set_color(RED)\n        octahedron.faces[2].set_color(YELLOW)\n        self.add(octahedron)", "code_sha1": "3ca8dde728ffa81bd8f99a274643d77ede57d909"}
{"url": "https://docs.manim.community/en/stable/reference/manim.mobject.three_d.polyhedra.Polyhedron.html", "depth": 1, "instruction": "A 3D square pyramid is displayed with a camera angle of 75 degrees elevation and 30 degrees azimuth. The pyramid features a square base and four triangular faces, rendered in a default color. The scene includes no animations or transitions, focusing solely on the static representation of the polyhedron.", "code": "class SquarePyramidScene(ThreeDScene):\n    def construct(self):\n        self.set_camera_orientation(phi=75 * DEGREES, theta=30 * DEGREES)\n        vertex_coords = [\n            [1, 1, 0],\n            [1, -1, 0],\n            [-1, -1, 0],\n            [-1, 1, 0],\n            [0, 0, 2]\n        ]\n        faces_list = [\n            [0, 1, 4],\n            [1, 2, 4],\n            [2, 3, 4],\n            [3, 0, 4],\n            [0, 1, 2, 3]\n        ]\n        pyramid = Polyhedron(vertex_coords, faces_list)\n        self.add(pyramid)", "code_sha1": "c134cd6e354ba2b9e275cfa85e56f38197b0db2c"}
{"url": "https://docs.manim.community/en/stable/reference/manim.mobject.three_d.polyhedra.Polyhedron.html", "depth": 1, "instruction": "A 3D scene displays a red octahedron with an edge length of 3, oriented at a 75-degree elevation and 30-degree rotation. One of its triangular faces is colored yellow, while the rest remain red. The octahedron is centered in the scene, showcasing its geometric structure.", "code": "class PolyhedronSubMobjects(ThreeDScene):\n    def construct(self):\n        self.set_camera_orientation(phi=75 * DEGREES, theta=30 * DEGREES)\n        octahedron = Octahedron(edge_length = 3)\n        octahedron.graph[0].set_color(RED)\n        octahedron.faces[2].set_color(YELLOW)\n        self.add(octahedron)", "code_sha1": "98c807be6b7211eb17c9b3cb255b3d13eea99523"}
{"url": "https://docs.manim.community/en/stable/reference/manim.mobject.three_d.polyhedra.Tetrahedron.html", "depth": 1, "instruction": "A 3D tetrahedron is displayed with a camera orientation set at 75 degrees elevation and 30 degrees azimuth, showcasing its four triangular faces. The tetrahedron is added to the scene without any animations or transformations applied.", "code": "from manim import *\n\nclass TetrahedronScene(ThreeDScene):\n    def construct(self):\n        self.set_camera_orientation(phi=75 * DEGREES, theta=30 * DEGREES)\n        obj = Tetrahedron()\n        self.add(obj)", "code_sha1": "6542cb2e1269204b98fcf7221e592666775956f2"}
{"url": "https://docs.manim.community/en/stable/reference/manim.mobject.three_d.polyhedra.Tetrahedron.html", "depth": 1, "instruction": "A 3D tetrahedron is displayed with a camera orientation set at 75 degrees elevation and 30 degrees azimuth, showcasing its four triangular faces and edges in a solid color. The scene is static, without animations or transformations.", "code": "class TetrahedronScene(ThreeDScene):\n    def construct(self):\n        self.set_camera_orientation(phi=75 * DEGREES, theta=30 * DEGREES)\n        obj = Tetrahedron()\n        self.add(obj)", "code_sha1": "7e525e362df017ee2967f912f4b1cf091d754f1e"}
{"url": "https://docs.manim.community/en/stable/reference/manim.mobject.three_d.three_dimensions.Arrow3D.html", "depth": 1, "instruction": "A 3D scene displays a set of axes and a green arrow originating from the origin (0,0,0) to the point (2,2,2), with a resolution of 8. The camera is positioned at a 75-degree elevation and a 30-degree azimuth, providing a dynamic perspective of the objects.", "code": "from manim import *\n\nclass ExampleArrow3D(ThreeDScene):\n    def construct(self):\n        axes = ThreeDAxes()\n        arrow = Arrow3D(\n            start=np.array([0, 0, 0]),\n            end=np.array([2, 2, 2]),\n            resolution=8\n        )\n        self.set_camera_orientation(phi=75 * DEGREES, theta=30 * DEGREES)\n        self.add(axes, arrow)", "code_sha1": "f572a13deb65d001ab287ac9414d20ea71b4c2c2"}
{"url": "https://docs.manim.community/en/stable/reference/manim.mobject.three_d.three_dimensions.Arrow3D.html", "depth": 1, "instruction": "A 3D scene displays a set of axes and a diagonal arrow from the origin (0,0,0) to (2,2,2), with a resolution of 8. The camera is positioned at a 75-degree elevation and 30-degree azimuth, providing a dynamic perspective of the objects.", "code": "class ExampleArrow3D(ThreeDScene):\n    def construct(self):\n        axes = ThreeDAxes()\n        arrow = Arrow3D(\n            start=np.array([0, 0, 0]),\n            end=np.array([2, 2, 2]),\n            resolution=8\n        )\n        self.set_camera_orientation(phi=75 * DEGREES, theta=30 * DEGREES)\n        self.add(axes, arrow)", "code_sha1": "fbc1339567e64d3c7554ddac03197db69fbe580f"}
{"url": "https://docs.manim.community/en/stable/reference/manim.mobject.three_d.three_dimensions.Cone.html", "depth": 1, "instruction": "A 3D scene displays a cone oriented diagonally in space, positioned above a set of axes. The camera is set at a specific angle, providing a clear view of the cone's shape and the axes below it.", "code": "from manim import *\n\nclass ExampleCone(ThreeDScene):\n    def construct(self):\n        axes = ThreeDAxes()\n        cone = Cone(direction=X_AXIS+Y_AXIS+2*Z_AXIS, resolution=8)\n        self.set_camera_orientation(phi=5*PI/11, theta=PI/9)\n        self.add(axes, cone)", "code_sha1": "c129bd17e21fee4a209e4f797412ce1bd1dfb3bd"}
{"url": "https://docs.manim.community/en/stable/reference/manim.mobject.three_d.three_dimensions.Cone.html", "depth": 1, "instruction": "A 3D scene displays a cone oriented diagonally in space, with axes in the background. The camera is positioned at a specific angle, providing a clear view of the cone's shape and orientation. The cone has a resolution of 8, enhancing its visual detail.", "code": "class ExampleCone(ThreeDScene):\n    def construct(self):\n        axes = ThreeDAxes()\n        cone = Cone(direction=X_AXIS+Y_AXIS+2*Z_AXIS, resolution=8)\n        self.set_camera_orientation(phi=5*PI/11, theta=PI/9)\n        self.add(axes, cone)", "code_sha1": "b09fb9b28c412f3c720484267107a0bfb7fb4685"}
{"url": "https://docs.manim.community/en/stable/reference/manim.mobject.three_d.three_dimensions.Cube.html", "depth": 1, "instruction": "A semi-transparent blue cube with a side length of 3 is positioned in a 3D space, viewed from a camera angle of 75 degrees elevation and -45 degrees azimuth, alongside a set of 3D axes.", "code": "from manim import *\n\nclass CubeExample(ThreeDScene):\n    def construct(self):\n        self.set_camera_orientation(phi=75*DEGREES, theta=-45*DEGREES)\n\n        axes = ThreeDAxes()\n        cube = Cube(side_length=3, fill_opacity=0.7, fill_color=BLUE)\n        self.add(cube)", "code_sha1": "c81d1d35bef1d15b6f1f2768134c085285b399b5"}
{"url": "https://docs.manim.community/en/stable/reference/manim.mobject.three_d.three_dimensions.Cube.html", "depth": 1, "instruction": "A 3D scene displays a semi-transparent blue cube with a side length of 3 units, positioned in a 3D coordinate system, while the camera is oriented at a 75-degree elevation and -45-degree azimuth.", "code": "class CubeExample(ThreeDScene):\n    def construct(self):\n        self.set_camera_orientation(phi=75*DEGREES, theta=-45*DEGREES)\n\n        axes = ThreeDAxes()\n        cube = Cube(side_length=3, fill_opacity=0.7, fill_color=BLUE)\n        self.add(cube)", "code_sha1": "2cb66703fe53ec1a931a2767aa3d5e2d1b31e1a6"}
{"url": "https://docs.manim.community/en/stable/reference/manim.mobject.three_d.three_dimensions.Cylinder.html", "depth": 1, "instruction": "A 3D scene displays a cylinder with a radius of 2 and height of 3, positioned above a set of 3D axes. The camera is oriented at a 75-degree elevation and 30-degree azimuth, showcasing the cylinder's dimensions without end caps.", "code": "from manim import *\n\nclass ExampleCylinder(ThreeDScene):\n    def construct(self):\n        axes = ThreeDAxes()\n        cylinder = Cylinder(radius=2, height=3)\n        self.set_camera_orientation(phi=75 * DEGREES, theta=30 * DEGREES)\n        self.add(axes, cylinder)", "code_sha1": "afb61eeec9c9502c13670c2c06fafa1fc8a6e165"}
{"url": "https://docs.manim.community/en/stable/reference/manim.mobject.three_d.three_dimensions.Cylinder.html", "depth": 1, "instruction": "A 3D scene displays a blue cylinder with a radius of 2 and height of 3, positioned above a set of 3D axes. The camera is oriented at a 75-degree elevation and 30-degree azimuth, providing a dynamic perspective of the objects.", "code": "class ExampleCylinder(ThreeDScene):\n    def construct(self):\n        axes = ThreeDAxes()\n        cylinder = Cylinder(radius=2, height=3)\n        self.set_camera_orientation(phi=75 * DEGREES, theta=30 * DEGREES)\n        self.add(axes, cylinder)", "code_sha1": "faa4dea66559b8918ef00a4e9c1d4a177d5e9235"}
{"url": "https://docs.manim.community/en/stable/reference/manim.mobject.three_d.three_dimensions.Dot3D.html", "depth": 1, "instruction": "The scene features a 3D axes system with three colored dots: a red dot at (0, 0, 1), a blue dot at (2, 0, 0) with a radius of 0.1, and an orange dot at the origin, also with a radius of 0.1. The camera is oriented at a 75-degree elevation and -45-degree azimuth.", "code": "from manim import *\n\nclass Dot3DExample(ThreeDScene):\n    def construct(self):\n        self.set_camera_orientation(phi=75*DEGREES, theta=-45*DEGREES)\n\n        axes = ThreeDAxes()\n        dot_1 = Dot3D(point=axes.coords_to_point(0, 0, 1), color=RED)\n        dot_2 = Dot3D(point=axes.coords_to_point(2, 0, 0), radius=0.1, color=BLUE)\n        dot_3 = Dot3D(point=[0, 0, 0], radius=0.1, color=ORANGE)\n        self.add(axes, dot_1, dot_2,dot_3)", "code_sha1": "dacc43c520f5c84bbe5440b1c2c003e2f6e82d43"}
{"url": "https://docs.manim.community/en/stable/reference/manim.mobject.three_d.three_dimensions.Dot3D.html", "depth": 1, "instruction": "The scene displays a 3D coordinate system with axes, featuring three colored dots: a red dot at (0, 0, 1), a blue dot at (2, 0, 0) with a radius of 0.1, and an orange dot at the origin, all positioned in a perspective view with the camera oriented at 75 degrees elevation and -45 degrees azimuth.", "code": "class Dot3DExample(ThreeDScene):\n    def construct(self):\n        self.set_camera_orientation(phi=75*DEGREES, theta=-45*DEGREES)\n\n        axes = ThreeDAxes()\n        dot_1 = Dot3D(point=axes.coords_to_point(0, 0, 1), color=RED)\n        dot_2 = Dot3D(point=axes.coords_to_point(2, 0, 0), radius=0.1, color=BLUE)\n        dot_3 = Dot3D(point=[0, 0, 0], radius=0.1, color=ORANGE)\n        self.add(axes, dot_1, dot_2,dot_3)", "code_sha1": "4d4df82e35d3489960404ea3c468b2c98c3aeb87"}
{"url": "https://docs.manim.community/en/stable/reference/manim.mobject.three_d.three_dimensions.Line3D.html", "depth": 1, "instruction": "A 3D scene displays a set of axes and a diagonal line from the origin (0,0,0) to (2,2,2), with the camera oriented at 75 degrees elevation and 30 degrees azimuth, creating a dynamic perspective.", "code": "from manim import *\n\nclass ExampleLine3D(ThreeDScene):\n    def construct(self):\n        axes = ThreeDAxes()\n        line = Line3D(start=np.array([0, 0, 0]), end=np.array([2, 2, 2]))\n        self.set_camera_orientation(phi=75 * DEGREES, theta=30 * DEGREES)\n        self.add(axes, line)", "code_sha1": "a989098f3a077a1929db01d3db3685f99ea5fedc"}
{"url": "https://docs.manim.community/en/stable/reference/manim.mobject.three_d.three_dimensions.Line3D.html", "depth": 1, "instruction": "A 3D scene displays a red line extending diagonally from (2, 0, 0) to (0, 1, 1) and a yellow line parallel to it, both positioned within a 3D axes grid. The camera is oriented at a 60-degree elevation and a -45-degree azimuth.", "code": "from manim import *\n\nclass ParallelLineExample(ThreeDScene):\n    def construct(self):\n        self.set_camera_orientation(PI / 3, -PI / 4)\n        ax = ThreeDAxes((-5, 5), (-5, 5), (-5, 5), 10, 10, 10)\n        line1 = Line3D(RIGHT * 2, UP + OUT, color=RED)\n        line2 = Line3D.parallel_to(line1, color=YELLOW)\n        self.add(ax, line1, line2)", "code_sha1": "9d4c43e7ec59ef0d1c19d5419e6e0c2d6aaf6b98"}
{"url": "https://docs.manim.community/en/stable/reference/manim.mobject.three_d.three_dimensions.Line3D.html", "depth": 1, "instruction": "A 3D scene displays a red line extending diagonally in space, with a blue line perpendicular to it, both positioned within a 3D coordinate system represented by axes. The camera is oriented at an angle, providing a dynamic perspective of the lines and axes.", "code": "from manim import *\n\nclass PerpLineExample(ThreeDScene):\n    def construct(self):\n        self.set_camera_orientation(PI / 3, -PI / 4)\n        ax = ThreeDAxes((-5, 5), (-5, 5), (-5, 5), 10, 10, 10)\n        line1 = Line3D(RIGHT * 2, UP + OUT, color=RED)\n        line2 = Line3D.perpendicular_to(line1, color=BLUE)\n        self.add(ax, line1, line2)", "code_sha1": "c292447e444681510e72f2769ea64ca0615f6fe7"}
{"url": "https://docs.manim.community/en/stable/reference/manim.mobject.three_d.three_dimensions.Line3D.html", "depth": 1, "instruction": "A 3D scene displays a set of axes and a diagonal line from the origin to the point (2, 2, 2), with the camera oriented at a 75-degree elevation and a 30-degree azimuth, creating a dynamic perspective.", "code": "class ExampleLine3D(ThreeDScene):\n    def construct(self):\n        axes = ThreeDAxes()\n        line = Line3D(start=np.array([0, 0, 0]), end=np.array([2, 2, 2]))\n        self.set_camera_orientation(phi=75 * DEGREES, theta=30 * DEGREES)\n        self.add(axes, line)", "code_sha1": "7c1cd1ad644e28a32aeb19d7b9e2e5c0ca296bc8"}
{"url": "https://docs.manim.community/en/stable/reference/manim.mobject.three_d.three_dimensions.Line3D.html", "depth": 1, "instruction": "A 3D scene displays a red line and a yellow line, both positioned in space with the yellow line parallel to the red line. The camera is oriented at an angle, providing a perspective view of the ThreeDAxes grid.", "code": "class ParallelLineExample(ThreeDScene):\n    def construct(self):\n        self.set_camera_orientation(PI / 3, -PI / 4)\n        ax = ThreeDAxes((-5, 5), (-5, 5), (-5, 5), 10, 10, 10)\n        line1 = Line3D(RIGHT * 2, UP + OUT, color=RED)\n        line2 = Line3D.parallel_to(line1, color=YELLOW)\n        self.add(ax, line1, line2)", "code_sha1": "dbcf159eb612706897ea8f460d5cdab50cbf33ec"}
{"url": "https://docs.manim.community/en/stable/reference/manim.mobject.three_d.three_dimensions.Line3D.html", "depth": 1, "instruction": "A 3D scene displays a red line extending diagonally in space, with a blue line perpendicular to it, both positioned within a 3D axes grid. The camera is oriented at a 45-degree angle above and to the side, providing a clear view of the intersection.", "code": "class PerpLineExample(ThreeDScene):\n    def construct(self):\n        self.set_camera_orientation(PI / 3, -PI / 4)\n        ax = ThreeDAxes((-5, 5), (-5, 5), (-5, 5), 10, 10, 10)\n        line1 = Line3D(RIGHT * 2, UP + OUT, color=RED)\n        line2 = Line3D.perpendicular_to(line1, color=BLUE)\n        self.add(ax, line1, line2)", "code_sha1": "ffcfbb6a2b5864c2ed36d53a317b93ebe75a8fc0"}
{"url": "https://docs.manim.community/en/stable/reference/manim.mobject.three_d.three_dimensions.Prism.html", "depth": 1, "instruction": "The scene features two 3D rectangular prisms: a smaller one (1x2x3) rotated 90 degrees and a larger one (1.5x3x4.5) positioned at (2, 0, 0). The camera is oriented at a 60-degree elevation and 150-degree azimuth, providing a dynamic perspective of the prisms.", "code": "from manim import *\n\nclass ExamplePrism(ThreeDScene):\n    def construct(self):\n        self.set_camera_orientation(phi=60 * DEGREES, theta=150 * DEGREES)\n        prismSmall = Prism(dimensions=[1, 2, 3]).rotate(PI / 2)\n        prismLarge = Prism(dimensions=[1.5, 3, 4.5]).move_to([2, 0, 0])\n        self.add(prismSmall, prismLarge)", "code_sha1": "8277ff9acd6b8c2ad3044bc21cd3fa33700ebcc5"}
{"url": "https://docs.manim.community/en/stable/reference/manim.mobject.three_d.three_dimensions.Prism.html", "depth": 1, "instruction": "Display two rectangular prisms: a smaller one (1x2x3) rotated 90 degrees and a larger one (1.5x3x4.5) positioned at (2, 0, 0). The camera is oriented at a 60-degree elevation and 150-degree azimuth, showcasing the 3D perspective.", "code": "class ExamplePrism(ThreeDScene):\n    def construct(self):\n        self.set_camera_orientation(phi=60 * DEGREES, theta=150 * DEGREES)\n        prismSmall = Prism(dimensions=[1, 2, 3]).rotate(PI / 2)\n        prismLarge = Prism(dimensions=[1.5, 3, 4.5]).move_to([2, 0, 0])\n        self.add(prismSmall, prismLarge)", "code_sha1": "48b1266f740b9bc966df21f18456f3a02e559c66"}
{"url": "https://docs.manim.community/en/stable/reference/manim.mobject.three_d.three_dimensions.Sphere.html", "depth": 1, "instruction": "The scene displays three spheres: a red sphere at (3, 0, 0) with a radius of 1, a green sphere at (-1, -3, 0) with a radius of 2, and a blue sphere at (-1, 2, 0) with a radius of 2. The camera is oriented at an angle of π/6 for both phi and theta.", "code": "from manim import *\n\nclass ExampleSphere(ThreeDScene):\n    def construct(self):\n        self.set_camera_orientation(phi=PI / 6, theta=PI / 6)\n        sphere1 = Sphere(\n            center=(3, 0, 0),\n            radius=1,\n            resolution=(20, 20),\n            u_range=[0.001, PI - 0.001],\n            v_range=[0, TAU]\n        )\n        sphere1.set_color(RED)\n        self.add(sphere1)\n        sphere2 = Sphere(center=(-1, -3, 0), radius=2, resolution=(18, 18))\n        sphere2.set_color(GREEN)\n        self.add(sphere2)\n        sphere3 = Sphere(center=(-1, 2, 0), radius=2, resolution=(16, 16))\n        sphere3.set_color(BLUE)\n        self.add(sphere3)", "code_sha1": "2a5cf903ab30340180f44c1d540aa9f02f4634ff"}
{"url": "https://docs.manim.community/en/stable/reference/manim.mobject.three_d.three_dimensions.Sphere.html", "depth": 1, "instruction": "The scene displays three spheres: a red sphere at (3, 0, 0) with a radius of 1, a green sphere at (-1, -3, 0) with a radius of 2, and a blue sphere at (-1, 2, 0) also with a radius of 2. The camera is oriented at a slight angle (phi=π/6, theta=π/6).", "code": "class ExampleSphere(ThreeDScene):\n    def construct(self):\n        self.set_camera_orientation(phi=PI / 6, theta=PI / 6)\n        sphere1 = Sphere(\n            center=(3, 0, 0),\n            radius=1,\n            resolution=(20, 20),\n            u_range=[0.001, PI - 0.001],\n            v_range=[0, TAU]\n        )\n        sphere1.set_color(RED)\n        self.add(sphere1)\n        sphere2 = Sphere(center=(-1, -3, 0), radius=2, resolution=(18, 18))\n        sphere2.set_color(GREEN)\n        self.add(sphere2)\n        sphere3 = Sphere(center=(-1, 2, 0), radius=2, resolution=(16, 16))\n        sphere3.set_color(BLUE)\n        self.add(sphere3)", "code_sha1": "5f9550be798bd99fb94ce190f08a3e05c26ce850"}
{"url": "https://docs.manim.community/en/stable/reference/manim.mobject.three_d.three_dimensions.Surface.html", "depth": 1, "instruction": "A 3D scene displays a surface defined by a cosine function, positioned above a set of axes. The camera orients at a 70-degree elevation and 75-degree azimuth. The surface is rendered with a resolution of 8, while the axes extend from -4 to 4 along the x-axis, creating a visually dynamic mathematical representation.", "code": "from manim import *\n\nclass ParaSurface(ThreeDScene):\n    def func(self, u, v):\n        return np.array([np.cos(u) * np.cos(v), np.cos(u) * np.sin(v), u])\n\n    def construct(self):\n        axes = ThreeDAxes(x_range=[-4,4], x_length=8)\n        surface = Surface(\n            lambda u, v: axes.c2p(*self.func(u, v)),\n            u_range=[-PI, PI],\n            v_range=[0, TAU],\n            resolution=8,\n        )\n        self.set_camera_orientation(theta=70 * DEGREES, phi=75 * DEGREES)\n        self.add(axes, surface)", "code_sha1": "bdf5d3cf7b158f30d4b34e2a2a3e55d7e35c0e15"}
{"url": "https://docs.manim.community/en/stable/reference/manim.mobject.three_d.three_dimensions.Surface.html", "depth": 1, "instruction": "A 3D surface representing the function \\( z = \\sin(x) \\cos(y) \\) is displayed over a grid defined by axes, colored with a gradient from red to green based on the z-value, with full opacity. The camera is positioned at a 75-degree elevation and -160-degree azimuth, providing a dynamic view of the surface.", "code": "from manim import *\n\nclass FillByValueExample(ThreeDScene):\n    def construct(self):\n        resolution_fa = 8\n        self.set_camera_orientation(phi=75 * DEGREES, theta=-160 * DEGREES)\n        axes = ThreeDAxes(x_range=(0, 5, 1), y_range=(0, 5, 1), z_range=(-1, 1, 0.5))\n        def param_surface(u, v):\n            x = u\n            y = v\n            z = np.sin(x) * np.cos(y)\n            return z\n        surface_plane = Surface(\n            lambda u, v: axes.c2p(u, v, param_surface(u, v)),\n            resolution=(resolution_fa, resolution_fa),\n            v_range=[0, 5],\n            u_range=[0, 5],\n            )\n        surface_plane.set_style(fill_opacity=1)\n        surface_plane.set_fill_by_value(axes=axes, colorscale=[(RED, -0.5), (YELLOW, 0), (GREEN, 0.5)], axis=2)\n        self.add(axes, surface_plane)", "code_sha1": "bb5e347cd241cd720ddcb234d2990ce27ad5cdce"}
{"url": "https://docs.manim.community/en/stable/reference/manim.mobject.three_d.three_dimensions.Surface.html", "depth": 1, "instruction": "A 3D scene displays a surface defined by a cosine function, positioned above a set of axes. The camera orients at 70° theta and 75° phi, showcasing the surface's curvature and the axes' grid. The surface is rendered with a resolution of 8, emphasizing its smoothness and dimensionality.", "code": "class ParaSurface(ThreeDScene):\n    def func(self, u, v):\n        return np.array([np.cos(u) * np.cos(v), np.cos(u) * np.sin(v), u])\n\n    def construct(self):\n        axes = ThreeDAxes(x_range=[-4,4], x_length=8)\n        surface = Surface(\n            lambda u, v: axes.c2p(*self.func(u, v)),\n            u_range=[-PI, PI],\n            v_range=[0, TAU],\n            resolution=8,\n        )\n        self.set_camera_orientation(theta=70 * DEGREES, phi=75 * DEGREES)\n        self.add(axes, surface)", "code_sha1": "e3d8935be642ad6eb2484653a59220926f9ea673"}
{"url": "https://docs.manim.community/en/stable/reference/manim.mobject.three_d.three_dimensions.Surface.html", "depth": 1, "instruction": "A 3D surface is displayed, colored with a gradient from red to yellow to green based on the sine-cosine function, with axes visible. The camera is oriented at a 75-degree elevation and -160-degree azimuth, providing a dynamic perspective of the surface's undulating shape.", "code": "class FillByValueExample(ThreeDScene):\n    def construct(self):\n        resolution_fa = 8\n        self.set_camera_orientation(phi=75 * DEGREES, theta=-160 * DEGREES)\n        axes = ThreeDAxes(x_range=(0, 5, 1), y_range=(0, 5, 1), z_range=(-1, 1, 0.5))\n        def param_surface(u, v):\n            x = u\n            y = v\n            z = np.sin(x) * np.cos(y)\n            return z\n        surface_plane = Surface(\n            lambda u, v: axes.c2p(u, v, param_surface(u, v)),\n            resolution=(resolution_fa, resolution_fa),\n            v_range=[0, 5],\n            u_range=[0, 5],\n            )\n        surface_plane.set_style(fill_opacity=1)\n        surface_plane.set_fill_by_value(axes=axes, colorscale=[(RED, -0.5), (YELLOW, 0), (GREEN, 0.5)], axis=2)\n        self.add(axes, surface_plane)", "code_sha1": "5903f35a880b94cf64a155a9f5c767df5b3ebc83"}
{"url": "https://docs.manim.community/en/stable/reference/manim.mobject.three_d.three_dimensions.Torus.html", "depth": 1, "instruction": "A 3D scene displays a torus centered at the origin, with a set of 3D axes. The camera is positioned at a 75-degree elevation and 30-degree rotation, providing a dynamic perspective of the torus and axes without any animations.", "code": "from manim import *\n\nclass ExampleTorus(ThreeDScene):\n    def construct(self):\n        axes = ThreeDAxes()\n        torus = Torus()\n        self.set_camera_orientation(phi=75 * DEGREES, theta=30 * DEGREES)\n        self.add(axes, torus)", "code_sha1": "0cf15b65df457ad567144d2e4e226c43d07b02ce"}
{"url": "https://docs.manim.community/en/stable/reference/manim.mobject.three_d.three_dimensions.Torus.html", "depth": 1, "instruction": "A 3D scene displays a torus centered in space, with a set of axes for reference. The camera is positioned at a 75-degree elevation and a 30-degree rotation, providing a clear view of the torus. The torus and axes are rendered in default colors and sizes, with no animations applied.", "code": "class ExampleTorus(ThreeDScene):\n    def construct(self):\n        axes = ThreeDAxes()\n        torus = Torus()\n        self.set_camera_orientation(phi=75 * DEGREES, theta=30 * DEGREES)\n        self.add(axes, torus)", "code_sha1": "5b2fa979fac9002af7b61ce2bbc29e00c67c283c"}
{"url": "https://docs.manim.community/en/stable/reference/manim.mobject.types.image_mobject.ImageMobject.html", "depth": 1, "instruction": "A 7-unit tall image is displayed, composed of a 2x4 pixel grid with varying grayscale values, positioned at the center of the scene.", "code": "from manim import *\n\nclass ImageFromArray(Scene):\n    def construct(self):\n        image = ImageMobject(np.uint8([[0, 100, 30, 200],\n                                       [255, 0, 5, 33]]))\n        image.height = 7\n        self.add(image)", "code_sha1": "64821c59a4edf9c0c3c8287049f255bfe1b82fa8"}
{"url": "https://docs.manim.community/en/stable/reference/manim.mobject.types.image_mobject.ImageMobject.html", "depth": 1, "instruction": "Five images of a 2x2 pixel grid, each labeled with different resampling algorithms (\"nearest,\" \"lanczos,\" \"linear,\" \"cubic,\" \"box\"), are arranged horizontally. Each image has a height of 2 units, with labels positioned above them. The scene displays the images without animations or camera operations.", "code": "from manim import *\n\nclass ImageInterpolationEx(Scene):\n    def construct(self):\n        img = ImageMobject(np.uint8([[63, 0, 0, 0],\n                                        [0, 127, 0, 0],\n                                        [0, 0, 191, 0],\n                                        [0, 0, 0, 255]\n                                        ]))\n\n        img.height = 2\n        img1 = img.copy()\n        img2 = img.copy()\n        img3 = img.copy()\n        img4 = img.copy()\n        img5 = img.copy()\n\n        img1.set_resampling_algorithm(RESAMPLING_ALGORITHMS[\"nearest\"])\n        img2.set_resampling_algorithm(RESAMPLING_ALGORITHMS[\"lanczos\"])\n        img3.set_resampling_algorithm(RESAMPLING_ALGORITHMS[\"linear\"])\n        img4.set_resampling_algorithm(RESAMPLING_ALGORITHMS[\"cubic\"])\n        img5.set_resampling_algorithm(RESAMPLING_ALGORITHMS[\"box\"])\n        img1.add(Text(\"nearest\").scale(0.5).next_to(img1,UP))\n        img2.add(Text(\"lanczos\").scale(0.5).next_to(img2,UP))\n        img3.add(Text(\"linear\").scale(0.5).next_to(img3,UP))\n        img4.add(Text(\"cubic\").scale(0.5).next_to(img4,UP))\n        img5.add(Text(\"box\").scale(0.5).next_to(img5,UP))\n\n        x= Group(img1,img2,img3,img4,img5)\n        x.arrange()\n        self.add(x)", "code_sha1": "10c00f1598edacb377dd51e8e21847d9a92eb7f7"}
{"url": "https://docs.manim.community/en/stable/reference/manim.mobject.types.image_mobject.ImageMobject.html", "depth": 1, "instruction": "A 7-unit tall image is displayed, composed of a 2x4 pixel array with varying colors based on the provided values. The image is added to the scene without any animations or camera operations.", "code": "class ImageFromArray(Scene):\n    def construct(self):\n        image = ImageMobject(np.uint8([[0, 100, 30, 200],\n                                       [255, 0, 5, 33]]))\n        image.height = 7\n        self.add(image)", "code_sha1": "0be6cc2066eb0ad37bfbc74c67903c9eb14015be"}
{"url": "https://docs.manim.community/en/stable/reference/manim.mobject.types.image_mobject.ImageMobject.html", "depth": 1, "instruction": "Five images, each labeled with different resampling algorithms (\"nearest,\" \"lanczos,\" \"linear,\" \"cubic,\" \"box\"), are arranged horizontally, each with a height of 2. The images display varying pixelation effects based on their resampling methods, with text positioned above each image. The scene is static without animations or camera operations.", "code": "class ImageInterpolationEx(Scene):\n    def construct(self):\n        img = ImageMobject(np.uint8([[63, 0, 0, 0],\n                                        [0, 127, 0, 0],\n                                        [0, 0, 191, 0],\n                                        [0, 0, 0, 255]\n                                        ]))\n\n        img.height = 2\n        img1 = img.copy()\n        img2 = img.copy()\n        img3 = img.copy()\n        img4 = img.copy()\n        img5 = img.copy()\n\n        img1.set_resampling_algorithm(RESAMPLING_ALGORITHMS[\"nearest\"])\n        img2.set_resampling_algorithm(RESAMPLING_ALGORITHMS[\"lanczos\"])\n        img3.set_resampling_algorithm(RESAMPLING_ALGORITHMS[\"linear\"])\n        img4.set_resampling_algorithm(RESAMPLING_ALGORITHMS[\"cubic\"])\n        img5.set_resampling_algorithm(RESAMPLING_ALGORITHMS[\"box\"])\n        img1.add(Text(\"nearest\").scale(0.5).next_to(img1,UP))\n        img2.add(Text(\"lanczos\").scale(0.5).next_to(img2,UP))\n        img3.add(Text(\"linear\").scale(0.5).next_to(img3,UP))\n        img4.add(Text(\"cubic\").scale(0.5).next_to(img4,UP))\n        img5.add(Text(\"box\").scale(0.5).next_to(img5,UP))\n\n        x= Group(img1,img2,img3,img4,img5)\n        x.arrange()\n        self.add(x)", "code_sha1": "b4bad9ac66ffaf5f70e4a9ecc3550dae43ca0821"}
{"url": "https://docs.manim.community/en/stable/reference/manim.mobject.types.point_cloud_mobject.PGroup.html", "depth": 1, "instruction": "A group of three PointCloudDots is displayed: one blue dot (radius 1) on the left, a default dot in the center, and a pink dot (radius 1.5, stroke width 2.5) on the right, all added to the scene without animations.", "code": "from manim import *\n\nclass PgroupExample(Scene):\n    def construct(self):\n\n        p1 = PointCloudDot(radius=1, density=20, color=BLUE)\n        p1.move_to(4.5 * LEFT)\n        p2 = PointCloudDot()\n        p3 = PointCloudDot(radius=1.5, stroke_width=2.5, color=PINK)\n        p3.move_to(4.5 * RIGHT)\n        pList = PGroup(p1, p2, p3)\n\n        self.add(pList)", "code_sha1": "0ace621b7470e1280803b70d0a9456ecafcab3e3"}
{"url": "https://docs.manim.community/en/stable/reference/manim.mobject.types.point_cloud_mobject.PGroup.html", "depth": 1, "instruction": "A group of three PointCloudDots is displayed: a blue dot on the left with a radius of 1, a default dot in the center, and a pink dot on the right with a radius of 1.5 and a stroke width of 2.5, all added to the scene.", "code": "class PgroupExample(Scene):\n    def construct(self):\n\n        p1 = PointCloudDot(radius=1, density=20, color=BLUE)\n        p1.move_to(4.5 * LEFT)\n        p2 = PointCloudDot()\n        p3 = PointCloudDot(radius=1.5, stroke_width=2.5, color=PINK)\n        p3.move_to(4.5 * RIGHT)\n        pList = PGroup(p1, p2, p3)\n\n        self.add(pList)", "code_sha1": "598a13b9aad947c46ea53209fcebc95c02a8ab9b"}
{"url": "https://docs.manim.community/en/stable/reference/manim.mobject.types.point_cloud_mobject.PMobject.html", "depth": 1, "instruction": "A grid of PointCloudDots, each progressively thinned out from a dense cloud to sparse, is displayed. The dots are uniformly sized with a radius of 1 and arranged neatly in a grid layout. The overall visual effect showcases a gradient of density across the grid, emphasizing the thinning effect as the scale factor increases.", "code": "from manim import *\n\nclass PMobjectExample(Scene):\n    def construct(self):\n\n        pG = PGroup()  # This is just a collection of PMobject's\n\n        # As the scale factor increases, the number of points\n        # removed increases.\n        for sf in range(1, 9 + 1):\n            p = PointCloudDot(density=20, radius=1).thin_out(sf)\n            # PointCloudDot is a type of PMobject\n            # and can therefore be added to a PGroup\n            pG.add(p)\n\n        # This organizes all the shapes in a grid.\n        pG.arrange_in_grid()\n\n        self.add(pG)", "code_sha1": "db54db6a72d2d6f83d40361b2358bdffbebc6709"}
{"url": "https://docs.manim.community/en/stable/reference/manim.mobject.types.point_cloud_mobject.PMobject.html", "depth": 1, "instruction": "A grid of PointCloudDots appears, with each dot's density decreasing as the scale factor increases from 1 to 9. The dots are arranged neatly in a grid formation, showcasing a gradient effect of point removal, creating a visually striking pattern.", "code": "class PMobjectExample(Scene):\n    def construct(self):\n\n        pG = PGroup()  # This is just a collection of PMobject's\n\n        # As the scale factor increases, the number of points\n        # removed increases.\n        for sf in range(1, 9 + 1):\n            p = PointCloudDot(density=20, radius=1).thin_out(sf)\n            # PointCloudDot is a type of PMobject\n            # and can therefore be added to a PGroup\n            pG.add(p)\n\n        # This organizes all the shapes in a grid.\n        pG.arrange_in_grid()\n\n        self.add(pG)", "code_sha1": "072d29330bdf95a78dcf39507ef8b4603e6924ab"}
{"url": "https://docs.manim.community/en/stable/reference/manim.mobject.types.point_cloud_mobject.Point.html", "depth": 1, "instruction": "The scene displays 400 randomly positioned points in a 2D plane, each colored randomly from a palette of red, green, blue, and yellow. Points are scattered within a range of -4 to 4 on both axes, creating a vibrant, chaotic visual effect without any animations or camera operations.", "code": "from manim import *\n\nclass ExamplePoint(Scene):\n    def construct(self):\n        colorList = [RED, GREEN, BLUE, YELLOW]\n        for i in range(200):\n            point = Point(location=[0.63 * np.random.randint(-4, 4), 0.37 * np.random.randint(-4, 4), 0], color=np.random.choice(colorList))\n            self.add(point)\n        for i in range(200):\n            point = Point(location=[0.37 * np.random.randint(-4, 4), 0.63 * np.random.randint(-4, 4), 0], color=np.random.choice(colorList))\n            self.add(point)\n        self.add(point)", "code_sha1": "0a26f68ce3ac9004f3f7585895353568fd66f8fd"}
{"url": "https://docs.manim.community/en/stable/reference/manim.mobject.types.point_cloud_mobject.Point.html", "depth": 1, "instruction": "The scene displays 400 randomly positioned points in a 2D plane, each colored in red, green, blue, or yellow. The points are scattered within a defined range, creating a vibrant, chaotic pattern without any animations or camera operations.", "code": "class ExamplePoint(Scene):\n    def construct(self):\n        colorList = [RED, GREEN, BLUE, YELLOW]\n        for i in range(200):\n            point = Point(location=[0.63 * np.random.randint(-4, 4), 0.37 * np.random.randint(-4, 4), 0], color=np.random.choice(colorList))\n            self.add(point)\n        for i in range(200):\n            point = Point(location=[0.37 * np.random.randint(-4, 4), 0.63 * np.random.randint(-4, 4), 0], color=np.random.choice(colorList))\n            self.add(point)\n        self.add(point)", "code_sha1": "e6c461e33f13b21bd91c62dce48dbb3b76e4c102"}
{"url": "https://docs.manim.community/en/stable/reference/manim.mobject.types.point_cloud_mobject.PointCloudDot.html", "depth": 1, "instruction": "Three PointCloudDots are arranged horizontally: one is red, another has a stroke width of 4 and a radius of 1, and the third has a density of 15. The group of dots is added to the scene without any animations or camera operations.", "code": "from manim import *\n\nclass PointCloudDotExample(Scene):\n    def construct(self):\n        cloud_1 = PointCloudDot(color=RED)\n        cloud_2 = PointCloudDot(stroke_width=4, radius=1)\n        cloud_3 = PointCloudDot(density=15)\n\n        group = Group(cloud_1, cloud_2, cloud_3).arrange()\n        self.add(group)", "code_sha1": "01adefc873829793b134c5d4afa88d3e9f1eee53"}
{"url": "https://docs.manim.community/en/stable/reference/manim.mobject.types.point_cloud_mobject.PointCloudDot.html", "depth": 1, "instruction": "A red PointCloudDot is displayed on a ComplexPlane, followed by a wait. The cloud then animates, transforming its shape according to the complex exponential function, creating a dynamic visual effect.", "code": "from manim import *\n\nclass PointCloudDotExample2(Scene):\n    def construct(self):\n        plane = ComplexPlane()\n        cloud = PointCloudDot(color=RED)\n        self.add(\n            plane, cloud\n        )\n        self.wait()\n        self.play(\n            cloud.animate.apply_complex_function(lambda z: np.exp(z))\n        )", "code_sha1": "26e0e3234dc4e5788adf5aa30954c91cc9c57e7b"}
{"url": "https://docs.manim.community/en/stable/reference/manim.mobject.types.point_cloud_mobject.PointCloudDot.html", "depth": 1, "instruction": "Three PointCloudDots are arranged horizontally: one is red, another has a stroke width of 4 and a radius of 1, and the third has a density of 15. The group of dots is added to the scene without any animations or camera operations.", "code": "class PointCloudDotExample(Scene):\n    def construct(self):\n        cloud_1 = PointCloudDot(color=RED)\n        cloud_2 = PointCloudDot(stroke_width=4, radius=1)\n        cloud_3 = PointCloudDot(density=15)\n\n        group = Group(cloud_1, cloud_2, cloud_3).arrange()\n        self.add(group)", "code_sha1": "6b1d36d54be90ff293cbcdbecf0f3fbd5b97e6bc"}
{"url": "https://docs.manim.community/en/stable/reference/manim.mobject.types.point_cloud_mobject.PointCloudDot.html", "depth": 1, "instruction": "A red PointCloudDot is displayed over a ComplexPlane, followed by a wait. The cloud then animates, transforming its shape according to the complex exponential function, creating a dynamic visual effect.", "code": "class PointCloudDotExample2(Scene):\n    def construct(self):\n        plane = ComplexPlane()\n        cloud = PointCloudDot(color=RED)\n        self.add(\n            plane, cloud\n        )\n        self.wait()\n        self.play(\n            cloud.animate.apply_complex_function(lambda z: np.exp(z))\n        )", "code_sha1": "a7adbba6c77451b612f45d81be8f001e48a28f44"}
{"url": "https://docs.manim.community/en/stable/reference/manim.mobject.types.vectorized_mobject.CurvesAsSubmobjects.html", "depth": 1, "instruction": "A sinusoidal curve is displayed in two versions: the original in black and a gradient version transitioning from blue to red, shifted upward. Both curves are thick (stroke width of 10) and are shown simultaneously on the screen.", "code": "from manim import *\n\nclass LineGradientExample(Scene):\n    def construct(self):\n        curve = ParametricFunction(lambda t: [t, np.sin(t), 0], t_range=[-PI, PI, 0.01], stroke_width=10)\n        new_curve = CurvesAsSubmobjects(curve)\n        new_curve.set_color_by_gradient(BLUE, RED)\n        self.add(new_curve.shift(UP), curve)", "code_sha1": "ad529fd2438d2816af1e59af65e2aa652a1f72d7"}
{"url": "https://docs.manim.community/en/stable/reference/manim.mobject.types.vectorized_mobject.CurvesAsSubmobjects.html", "depth": 1, "instruction": "A sinusoidal curve is displayed in two versions: the original in a default color and a gradient version shifted upwards, transitioning from blue to red. Both curves are visible simultaneously, emphasizing the gradient effect on the new curve.", "code": "class LineGradientExample(Scene):\n    def construct(self):\n        curve = ParametricFunction(lambda t: [t, np.sin(t), 0], t_range=[-PI, PI, 0.01], stroke_width=10)\n        new_curve = CurvesAsSubmobjects(curve)\n        new_curve.set_color_by_gradient(BLUE, RED)\n        self.add(new_curve.shift(UP), curve)", "code_sha1": "052b0e3c8d6c1f2b56b637c56a94ac498c990c8a"}
{"url": "https://docs.manim.community/en/stable/reference/manim.mobject.types.vectorized_mobject.DashedVMobject.html", "depth": 1, "instruction": "The scene displays three rows of dashed circles and a function graph. The top row features circles with increasing dashes, the middle row shows circles with varying dashed ratios, and the bottom row contrasts two dashed function graphs. All objects are white, arranged vertically with specified spacing, creating a structured layout.", "code": "from manim import *\n\nclass DashedVMobjectExample(Scene):\n    def construct(self):\n        r = 0.5\n\n        top_row = VGroup()  # Increasing num_dashes\n        for dashes in range(1, 12):\n            circ = DashedVMobject(Circle(radius=r, color=WHITE), num_dashes=dashes)\n            top_row.add(circ)\n\n        middle_row = VGroup()  # Increasing dashed_ratio\n        for ratio in np.arange(1 / 11, 1, 1 / 11):\n            circ = DashedVMobject(\n                Circle(radius=r, color=WHITE), dashed_ratio=ratio\n            )\n            middle_row.add(circ)\n\n        func1 = FunctionGraph(lambda t: t**5,[-1,1],color=WHITE)\n        func_even = DashedVMobject(func1,num_dashes=6,equal_lengths=True)\n        func_stretched = DashedVMobject(func1, num_dashes=6, equal_lengths=False)\n        bottom_row = VGroup(func_even,func_stretched)\n\n        top_row.arrange(buff=0.3)\n        middle_row.arrange()\n        bottom_row.arrange(buff=1)\n        everything = VGroup(top_row, middle_row, bottom_row).arrange(DOWN, buff=1)\n        self.add(everything)", "code_sha1": "bfe74969346424d35b3970a2baaba56a369c2579"}
{"url": "https://docs.manim.community/en/stable/reference/manim.mobject.types.vectorized_mobject.DashedVMobject.html", "depth": 1, "instruction": "The scene displays three rows of dashed circles and a function graph. The top row shows circles with increasing numbers of dashes, the middle row features circles with varying dashed ratios, and the bottom row presents a function graph with two dashed versions. All objects are white, arranged vertically with specified spacing.", "code": "class DashedVMobjectExample(Scene):\n    def construct(self):\n        r = 0.5\n\n        top_row = VGroup()  # Increasing num_dashes\n        for dashes in range(1, 12):\n            circ = DashedVMobject(Circle(radius=r, color=WHITE), num_dashes=dashes)\n            top_row.add(circ)\n\n        middle_row = VGroup()  # Increasing dashed_ratio\n        for ratio in np.arange(1 / 11, 1, 1 / 11):\n            circ = DashedVMobject(\n                Circle(radius=r, color=WHITE), dashed_ratio=ratio\n            )\n            middle_row.add(circ)\n\n        func1 = FunctionGraph(lambda t: t**5,[-1,1],color=WHITE)\n        func_even = DashedVMobject(func1,num_dashes=6,equal_lengths=True)\n        func_stretched = DashedVMobject(func1, num_dashes=6, equal_lengths=False)\n        bottom_row = VGroup(func_even,func_stretched)\n\n        top_row.arrange(buff=0.3)\n        middle_row.arrange()\n        bottom_row.arrange(buff=1)\n        everything = VGroup(top_row, middle_row, bottom_row).arrange(DOWN, buff=1)\n        self.add(everything)", "code_sha1": "a327d75203dc410f3999e2a16f9dd430598427ea"}
{"url": "https://docs.manim.community/en/stable/reference/manim.mobject.types.vectorized_mobject.VDict.html", "depth": 1, "instruction": "The scene displays a red square and a yellow circle, organized in a vertical dictionary format with keys shown. A green text appears below the square, which later changes to purple and scales up. A rectangle is added and subsequently removed, while the square and circle fade out. Finally, two additional vertical dictionaries are created and displayed.", "code": "from manim import *\n\nclass ShapesWithVDict(Scene):\n    def construct(self):\n        square = Square().set_color(RED)\n        circle = Circle().set_color(YELLOW).next_to(square, UP)\n\n        # create dict from list of tuples each having key-mobject pair\n        pairs = [(\"s\", square), (\"c\", circle)]\n        my_dict = VDict(pairs, show_keys=True)\n\n        # display it just like a VGroup\n        self.play(Create(my_dict))\n        self.wait()\n\n        text = Tex(\"Some text\").set_color(GREEN).next_to(square, DOWN)\n\n        # add a key-value pair by wrapping it in a single-element list of tuple\n        # after attrs branch is merged, it will be easier like `.add(t=text)`\n        my_dict.add([(\"t\", text)])\n        self.wait()\n\n        rect = Rectangle().next_to(text, DOWN)\n        # can also do key assignment like a python dict\n        my_dict[\"r\"] = rect\n\n        # access submobjects like a python dict\n        my_dict[\"t\"].set_color(PURPLE)\n        self.play(my_dict[\"t\"].animate.scale(3))\n        self.wait()\n\n        # also supports python dict styled reassignment\n        my_dict[\"t\"] = Tex(\"Some other text\").set_color(BLUE)\n        self.wait()\n\n        # remove submobject by key\n        my_dict.remove(\"t\")\n        self.wait()\n\n        self.play(Uncreate(my_dict[\"s\"]))\n        self.wait()\n\n        self.play(FadeOut(my_dict[\"c\"]))\n        self.wait()\n\n        self.play(FadeOut(my_dict[\"r\"], shift=DOWN))\n        self.wait()\n\n        # you can also make a VDict from an existing dict of mobjects\n        plain_dict = {\n            1: Integer(1).shift(DOWN),\n            2: Integer(2).shift(2 * DOWN),\n            3: Integer(3).shift(3 * DOWN),\n        }\n\n        vdict_from_plain_dict = VDict(plain_dict)\n        vdict_from_plain_dict.shift(1.5 * (UP + LEFT))\n        self.play(Create(vdict_from_plain_dict))\n\n        # you can even use zip\n        vdict_using_zip = VDict(zip([\"s\", \"c\", \"r\"], [Square(), Circle(), Rectangle()]))\n        vdict_using_zip.shift(1.5 * RIGHT)\n        self.play(Create(vdict_using_zip))\n        self.wait()", "code_sha1": "e43b053eec7c79905575b2e58655c9c1b5002207"}
{"url": "https://docs.manim.community/en/stable/reference/manim.mobject.types.vectorized_mobject.VDict.html", "depth": 1, "instruction": "The scene features a red square and a yellow circle, displayed within a vertical dictionary (VDict) that shows keys. A green text appears below the square, later changing to purple and scaling up. A rectangle is added below the text, which is subsequently replaced and removed. Finally, two additional VDicts are created and displayed, shifting positions.", "code": "class ShapesWithVDict(Scene):\n    def construct(self):\n        square = Square().set_color(RED)\n        circle = Circle().set_color(YELLOW).next_to(square, UP)\n\n        # create dict from list of tuples each having key-mobject pair\n        pairs = [(\"s\", square), (\"c\", circle)]\n        my_dict = VDict(pairs, show_keys=True)\n\n        # display it just like a VGroup\n        self.play(Create(my_dict))\n        self.wait()\n\n        text = Tex(\"Some text\").set_color(GREEN).next_to(square, DOWN)\n\n        # add a key-value pair by wrapping it in a single-element list of tuple\n        # after attrs branch is merged, it will be easier like `.add(t=text)`\n        my_dict.add([(\"t\", text)])\n        self.wait()\n\n        rect = Rectangle().next_to(text, DOWN)\n        # can also do key assignment like a python dict\n        my_dict[\"r\"] = rect\n\n        # access submobjects like a python dict\n        my_dict[\"t\"].set_color(PURPLE)\n        self.play(my_dict[\"t\"].animate.scale(3))\n        self.wait()\n\n        # also supports python dict styled reassignment\n        my_dict[\"t\"] = Tex(\"Some other text\").set_color(BLUE)\n        self.wait()\n\n        # remove submobject by key\n        my_dict.remove(\"t\")\n        self.wait()\n\n        self.play(Uncreate(my_dict[\"s\"]))\n        self.wait()\n\n        self.play(FadeOut(my_dict[\"c\"]))\n        self.wait()\n\n        self.play(FadeOut(my_dict[\"r\"], shift=DOWN))\n        self.wait()\n\n        # you can also make a VDict from an existing dict of mobjects\n        plain_dict = {\n            1: Integer(1).shift(DOWN),\n            2: Integer(2).shift(2 * DOWN),\n            3: Integer(3).shift(3 * DOWN),\n        }\n\n        vdict_from_plain_dict = VDict(plain_dict)\n        vdict_from_plain_dict.shift(1.5 * (UP + LEFT))\n        self.play(Create(vdict_from_plain_dict))\n\n        # you can even use zip\n        vdict_using_zip = VDict(zip([\"s\", \"c\", \"r\"], [Square(), Circle(), Rectangle()]))\n        vdict_using_zip.shift(1.5 * RIGHT)\n        self.play(Create(vdict_using_zip))\n        self.wait()", "code_sha1": "e57205dcfdcdf52ad897b5e8203fd1c67a9feed4"}
{"url": "https://docs.manim.community/en/stable/reference/manim.mobject.types.vectorized_mobject.VGroup.html", "depth": 1, "instruction": "A VGroup containing a Triangle and a Square is created, initially displaying both shapes. The Triangle is removed, leaving only the Square visible. The final state shows an empty VGroup, indicating all shapes have been removed. No animations or camera operations are specified.", "code": "from manim import Triangle, Square, VGroup\nvg = VGroup()\ntriangle, square = Triangle(), Square()\nvg.add(triangle)\nVGroup(Triangle)\nvg + square  # a new VGroup is constructed\nVGroup(Triangle, Square)\nvg  # not modified\nVGroup(Triangle)\nvg += square\nvg  # modifies vg\nVGroup(Triangle, Square)\nvg.remove(triangle)\nVGroup(Square)\nvg - square  # a new VGroup is constructed\nVGroup()\nvg  # not modified\nVGroup(Square)\nvg -= square\nvg  # modifies vg\nVGroup()", "code_sha1": "73e9d33b7bea797ebdbe206cd6ee14c903aed192"}
{"url": "https://docs.manim.community/en/stable/reference/manim.mobject.types.vectorized_mobject.VGroup.html", "depth": 1, "instruction": "The scene displays a group of concentric circles, each with varying radii and distinct colors (DARK_BROWN, BLUE_E, BLUE_D, BLUE_A, TEAL_B, GREEN_B, YELLOW_E), all with a stroke width of 10. The circles are arranged in a VGroup and added to the scene without any animations or camera operations.", "code": "from manim import *\n\nclass ArcShapeIris(Scene):\n    def construct(self):\n        colors = [DARK_BROWN, BLUE_E, BLUE_D, BLUE_A, TEAL_B, GREEN_B, YELLOW_E]\n        radius = [1 + rad * 0.1 for rad in range(len(colors))]\n\n        circles_group = VGroup()\n\n        # zip(radius, color) makes the iterator [(radius[i], color[i]) for i in range(radius)]\n        circles_group.add(*[Circle(radius=rad, stroke_width=10, color=col)\n                            for rad, col in zip(radius, colors)])\n        self.add(circles_group)", "code_sha1": "6304d2eced6437798187164f1c549a93d0c58fd6"}
{"url": "https://docs.manim.community/en/stable/reference/manim.mobject.types.vectorized_mobject.VGroup.html", "depth": 1, "instruction": "The scene features three colored circles (red, green, blue) arranged in a VGroup. The red circle shifts left, the blue circle shifts right, and the green circle remains centered. The entire group animates downward, then the red circle is removed, allowing the remaining circles to animate left and up separately, followed by a rightward shift of the combined group.", "code": "from manim import *\n\nclass AddToVGroup(Scene):\n    def construct(self):\n        circle_red = Circle(color=RED)\n        circle_green = Circle(color=GREEN)\n        circle_blue = Circle(color=BLUE)\n        circle_red.shift(LEFT)\n        circle_blue.shift(RIGHT)\n        gr = VGroup(circle_red, circle_green)\n        gr2 = VGroup(circle_blue) # Constructor uses add directly\n        self.add(gr,gr2)\n        self.wait()\n        gr += gr2 # Add group to another\n        self.play(\n            gr.animate.shift(DOWN),\n        )\n        gr -= gr2 # Remove group\n        self.play( # Animate groups separately\n            gr.animate.shift(LEFT),\n            gr2.animate.shift(UP),\n        )\n        self.play( #Animate groups without modification\n            (gr+gr2).animate.shift(RIGHT)\n        )\n        self.play( # Animate group without component\n            (gr-circle_red).animate.shift(RIGHT)\n        )", "code_sha1": "e32fc189752117f6df058199a52bc5514f167f24"}
{"url": "https://docs.manim.community/en/stable/reference/manim.mobject.types.vectorized_mobject.VGroup.html", "depth": 1, "instruction": "A scene displays a grouped arrangement of a square, two circles, a triangle, and three dots, all in default colors and sizes, positioned in a neat layout. The objects are added to the scene without animations, showcasing their collective structure.", "code": "from manim import *\n\nclass AddIterableToVGroupExample(Scene):\n    def construct(self):\n        v = VGroup(\n            Square(),               # Singular VMobject instance\n            [Circle(), Triangle()], # List of VMobject instances\n            Dot(),\n            (Dot() for _ in range(2)), # Iterable that generates VMobjects\n        )\n        v.arrange()\n        self.add(v)", "code_sha1": "3373e469007eca71cffbda909d7cdb880af02200"}
{"url": "https://docs.manim.community/en/stable/reference/manim.mobject.types.vectorized_mobject.VGroup.html", "depth": 1, "instruction": "The scene displays a group of concentric circles, each with varying radii and distinct colors (DARK_BROWN, BLUE_E, BLUE_D, BLUE_A, TEAL_B, GREEN_B, YELLOW_E), arranged from smallest to largest. The circles have a stroke width of 10 and are positioned at the center of the scene.", "code": "class ArcShapeIris(Scene):\n    def construct(self):\n        colors = [DARK_BROWN, BLUE_E, BLUE_D, BLUE_A, TEAL_B, GREEN_B, YELLOW_E]\n        radius = [1 + rad * 0.1 for rad in range(len(colors))]\n\n        circles_group = VGroup()\n\n        # zip(radius, color) makes the iterator [(radius[i], color[i]) for i in range(radius)]\n        circles_group.add(*[Circle(radius=rad, stroke_width=10, color=col)\n                            for rad, col in zip(radius, colors)])\n        self.add(circles_group)", "code_sha1": "ea208177f91a1639933720d30a7207a554a1b703"}
{"url": "https://docs.manim.community/en/stable/reference/manim.mobject.types.vectorized_mobject.VGroup.html", "depth": 1, "instruction": "Three circles (red, green, blue) are created, with red shifted left and blue shifted right. A green circle is added to a VGroup, which is animated to shift down. The red circle is removed, and the remaining groups animate separately: the first shifts left, the second shifts up, followed by a combined right shift, and finally, the blue circle shifts right.", "code": "class AddToVGroup(Scene):\n    def construct(self):\n        circle_red = Circle(color=RED)\n        circle_green = Circle(color=GREEN)\n        circle_blue = Circle(color=BLUE)\n        circle_red.shift(LEFT)\n        circle_blue.shift(RIGHT)\n        gr = VGroup(circle_red, circle_green)\n        gr2 = VGroup(circle_blue) # Constructor uses add directly\n        self.add(gr,gr2)\n        self.wait()\n        gr += gr2 # Add group to another\n        self.play(\n            gr.animate.shift(DOWN),\n        )\n        gr -= gr2 # Remove group\n        self.play( # Animate groups separately\n            gr.animate.shift(LEFT),\n            gr2.animate.shift(UP),\n        )\n        self.play( #Animate groups without modification\n            (gr+gr2).animate.shift(RIGHT)\n        )\n        self.play( # Animate group without component\n            (gr-circle_red).animate.shift(RIGHT)\n        )", "code_sha1": "2f7f84d3d3d931a1eafa9215f95dde8de99bfd9e"}
{"url": "https://docs.manim.community/en/stable/reference/manim.mobject.types.vectorized_mobject.VGroup.html", "depth": 1, "instruction": "A scene displays a grouped arrangement of a square, two circles, a triangle, and three dots, all in distinct colors. The objects are neatly organized in a row, showcasing their individual shapes and sizes, with the camera focused on the entire VGroup.", "code": "class AddIterableToVGroupExample(Scene):\n    def construct(self):\n        v = VGroup(\n            Square(),               # Singular VMobject instance\n            [Circle(), Triangle()], # List of VMobject instances\n            Dot(),\n            (Dot() for _ in range(2)), # Iterable that generates VMobjects\n        )\n        v.arrange()\n        self.add(v)", "code_sha1": "f23d6034c41199c9f40b6e0fa5dbb8133e53ccbd"}
{"url": "https://docs.manim.community/en/stable/reference/manim.mobject.types.vectorized_mobject.VMobject.html", "depth": 1, "instruction": "The code returns the string \"CCW\", indicating that a Circle is drawn in a counterclockwise direction.", "code": "from manim import Circle\nCircle().get_direction()\n'CCW'", "code_sha1": "9346736a62f1550c06be93ac18066b0ed997c62b"}
{"url": "https://docs.manim.community/en/stable/reference/manim.mobject.types.vectorized_mobject.VMobject.html", "depth": 1, "instruction": "A diagonal line is drawn from the bottom left to the top right of the screen, with three colored dots (red, blue, yellow) positioned at 1/4, 1/2, and 3/4 along the line, respectively. Each dot appears sequentially without any animations.", "code": "from manim import *\n\nclass PointFromProportion(Scene):\n    def construct(self):\n        line = Line(2*DL, 2*UR)\n        self.add(line)\n        colors = (RED, BLUE, YELLOW)\n        proportions = (1/4, 1/2, 3/4)\n        for color, proportion in zip(colors, proportions):\n            self.add(Dot(color=color).move_to(\n                    line.point_from_proportion(proportion)\n            ))", "code_sha1": "6298c56a407f010f3e13e629a363fd84f94f48bb"}
{"url": "https://docs.manim.community/en/stable/reference/manim.mobject.types.vectorized_mobject.VMobject.html", "depth": 1, "instruction": "Two regular pentagons are created: one in the center-left (blue) and one in the center-right (red, reversed direction). Both are drawn simultaneously over 4 seconds, appearing from the center of the screen.", "code": "from manim import *\n\nclass ChangeOfDirection(Scene):\n    def construct(self):\n        ccw = RegularPolygon(5)\n        ccw.shift(LEFT)\n        cw = RegularPolygon(5)\n        cw.shift(RIGHT).reverse_direction()\n\n        self.play(Create(ccw), Create(cw),\n        run_time=4)", "code_sha1": "c9c78d31c93aa9c542b947acdf16f497f0ede08d"}
{"url": "https://docs.manim.community/en/stable/reference/manim.mobject.types.vectorized_mobject.VMobject.html", "depth": 1, "instruction": "A yellow line with a stroke width of 20 units is displayed horizontally across the screen, featuring rounded caps at both ends.", "code": "from manim import *\n\nclass CapStyleExample(Scene):\n    def construct(self):\n        line = Line(LEFT, RIGHT, color=YELLOW, stroke_width=20)\n        line.set_cap_style(CapStyleType.ROUND)\n        self.add(line)", "code_sha1": "e2a47544ea7773df9ee366e12e45278f5cb94357"}
{"url": "https://docs.manim.community/en/stable/reference/manim.mobject.types.vectorized_mobject.VMobject.html", "depth": 1, "instruction": "A large white square is centered on the screen, accompanied by a horizontally arranged group of three circles: a green circle with 80% opacity, a yellow circle with full opacity, and a red circle with 20% opacity. All shapes are static with no animations.", "code": "from manim import *\n\nclass SetFill(Scene):\n    def construct(self):\n        square = Square().scale(2).set_fill(WHITE,1)\n        circle1 = Circle().set_fill(GREEN,0.8)\n        circle2 = Circle().set_fill(YELLOW) # No fill_opacity\n        circle3 = Circle().set_fill(color = '#FF2135', opacity = 0.2)\n        group = Group(circle1,circle2,circle3).arrange()\n        self.add(square)\n        self.add(group)", "code_sha1": "054cc1020036d2302f6ff9a2f3fe3199f86dfbef"}
{"url": "https://docs.manim.community/en/stable/reference/manim.mobject.types.vectorized_mobject.VMobject.html", "depth": 1, "instruction": "A red square with corners defined by the points UR, UL, DL, DR, scaled to twice its size, is displayed in the center of the scene.", "code": "from manim import *\n\nclass PointsAsCornersExample(Scene):\n    def construct(self):\n        corners = (\n            # create square\n            UR, UL,\n            DL, DR,\n            UR,\n            # create crosses\n            DL, UL,\n            DR\n        )\n        vmob = VMobject(stroke_color=RED)\n        vmob.set_points_as_corners(corners).scale(2)\n        self.add(vmob)", "code_sha1": "9e0cae9350ac351b10e91cf40595cae2a8b97871"}
{"url": "https://docs.manim.community/en/stable/reference/manim.mobject.types.vectorized_mobject.VMobject.html", "depth": 1, "instruction": "A filled circle with a sheen effect is displayed, oriented towards the down-right direction, creating a glossy appearance.", "code": "from manim import *\n\nclass SetSheen(Scene):\n    def construct(self):\n        circle = Circle(fill_opacity=1).set_sheen(-0.3, DR)\n        self.add(circle)", "code_sha1": "8d1b55dd5df014bc5f59581c56bb984a35c0b66e"}
{"url": "https://docs.manim.community/en/stable/reference/manim.mobject.types.vectorized_mobject.VMobject.html", "depth": 1, "instruction": "A diagonal line is drawn from the bottom left to the top right of the scene, with three colored dots (red, blue, yellow) positioned at 25%, 50%, and 75% along the line, respectively. Each dot is added sequentially without animations, creating a static visual representation of the points along the line.", "code": "class PointFromProportion(Scene):\n    def construct(self):\n        line = Line(2*DL, 2*UR)\n        self.add(line)\n        colors = (RED, BLUE, YELLOW)\n        proportions = (1/4, 1/2, 3/4)\n        for color, proportion in zip(colors, proportions):\n            self.add(Dot(color=color).move_to(\n                    line.point_from_proportion(proportion)\n            ))", "code_sha1": "f003419b21e65aae83d35c3fb52c02cc0a296aab"}
{"url": "https://docs.manim.community/en/stable/reference/manim.mobject.types.vectorized_mobject.VMobject.html", "depth": 1, "instruction": "Two regular pentagons are created: one shifted left (counterclockwise) and one shifted right (clockwise, reversed direction). Both pentagons are drawn simultaneously over 4 seconds.", "code": "class ChangeOfDirection(Scene):\n    def construct(self):\n        ccw = RegularPolygon(5)\n        ccw.shift(LEFT)\n        cw = RegularPolygon(5)\n        cw.shift(RIGHT).reverse_direction()\n\n        self.play(Create(ccw), Create(cw),\n        run_time=4)", "code_sha1": "1d731870eed5e99f5f883b87c09db4443d97cd2c"}
{"url": "https://docs.manim.community/en/stable/reference/manim.mobject.types.vectorized_mobject.VMobject.html", "depth": 1, "instruction": "A yellow line with a stroke width of 20 units is displayed horizontally across the screen, featuring rounded caps at both ends.", "code": "class CapStyleExample(Scene):\n    def construct(self):\n        line = Line(LEFT, RIGHT, color=YELLOW, stroke_width=20)\n        line.set_cap_style(CapStyleType.ROUND)\n        self.add(line)", "code_sha1": "2c98b162b4bee8d9f9accf9d2f03f6d0c8edd76b"}
{"url": "https://docs.manim.community/en/stable/reference/manim.mobject.types.vectorized_mobject.VMobject.html", "depth": 1, "instruction": "A large white square is centered on the screen, accompanied by three arranged circles: a green circle with 80% opacity, a yellow circle with full opacity, and a red circle with 20% opacity. The scene features no animations or camera operations.", "code": "class SetFill(Scene):\n    def construct(self):\n        square = Square().scale(2).set_fill(WHITE,1)\n        circle1 = Circle().set_fill(GREEN,0.8)\n        circle2 = Circle().set_fill(YELLOW) # No fill_opacity\n        circle3 = Circle().set_fill(color = '#FF2135', opacity = 0.2)\n        group = Group(circle1,circle2,circle3).arrange()\n        self.add(square)\n        self.add(group)", "code_sha1": "a4254695e6b9d2b1a60708370575249be0718174"}
{"url": "https://docs.manim.community/en/stable/reference/manim.mobject.types.vectorized_mobject.VMobject.html", "depth": 1, "instruction": "A red VMobject shaped like a square with corners defined by the specified points, scaled to twice its original size, is displayed in the center of the scene.", "code": "class PointsAsCornersExample(Scene):\n    def construct(self):\n        corners = (\n            # create square\n            UR, UL,\n            DL, DR,\n            UR,\n            # create crosses\n            DL, UL,\n            DR\n        )\n        vmob = VMobject(stroke_color=RED)\n        vmob.set_points_as_corners(corners).scale(2)\n        self.add(vmob)", "code_sha1": "0aee1ffbbe63037345db5afd05ac330b9aa3336d"}
{"url": "https://docs.manim.community/en/stable/reference/manim.mobject.types.vectorized_mobject.VMobject.html", "depth": 1, "instruction": "A filled circle with a sheen effect is displayed, oriented towards the down-right direction, creating a glossy appearance. The sheen enhances the visual depth of the circle, making it appear reflective.", "code": "class SetSheen(Scene):\n    def construct(self):\n        circle = Circle(fill_opacity=1).set_sheen(-0.3, DR)\n        self.add(circle)", "code_sha1": "70e991b3dbbafd24710ca3a3433d848c273759d1"}
{"url": "https://docs.manim.community/en/stable/reference/manim.mobject.value_tracker.ComplexValueTracker.html", "depth": 1, "instruction": "A dot moves along a complex plane, starting at (-2, 1) and transitioning through points (3, 2), (2, 3), (0, 1), and approximately (0.4, -0.2) in a smooth, animated path, while a grid background remains static.", "code": "from manim import *\n\nclass ComplexValueTrackerExample(Scene):\n    def construct(self):\n        tracker = ComplexValueTracker(-2+1j)\n        dot = Dot().add_updater(\n            lambda x: x.move_to(tracker.points)\n        )\n\n        self.add(NumberPlane(), dot)\n\n        self.play(tracker.animate.set_value(3+2j))\n        self.play(tracker.animate.set_value(tracker.get_value() * 1j))\n        self.play(tracker.animate.set_value(tracker.get_value() - 2j))\n        self.play(tracker.animate.set_value(tracker.get_value() / (-2 + 3j)))", "code_sha1": "6622891591c9eb05359879be346a966b0196c198"}
{"url": "https://docs.manim.community/en/stable/reference/manim.mobject.value_tracker.ComplexValueTracker.html", "depth": 1, "instruction": "A dot moves along a complex plane, starting at (-2, 1) and transitioning through points (3, 2), (2, 3), (0, 1), and approximately (0.4, -0.2) in a series of smooth animations, with the number plane as the background.", "code": "class ComplexValueTrackerExample(Scene):\n    def construct(self):\n        tracker = ComplexValueTracker(-2+1j)\n        dot = Dot().add_updater(\n            lambda x: x.move_to(tracker.points)\n        )\n\n        self.add(NumberPlane(), dot)\n\n        self.play(tracker.animate.set_value(3+2j))\n        self.play(tracker.animate.set_value(tracker.get_value() * 1j))\n        self.play(tracker.animate.set_value(tracker.get_value() - 2j))\n        self.play(tracker.animate.set_value(tracker.get_value() / (-2 + 3j)))", "code_sha1": "1dc3090682f9b3e78d0a360d3526e67e9dc182a0"}
{"url": "https://docs.manim.community/en/stable/reference/manim.mobject.value_tracker.ValueTracker.html", "depth": 1, "instruction": "A number line with a downward-pointing vector pointer and a label \"x\" animates as the pointer moves along the line. The pointer's position updates dynamically based on a ValueTracker, which changes values over time, including increments and decrements, with pauses between animations.", "code": "from manim import *\n\nclass ValueTrackerExample(Scene):\n    def construct(self):\n        number_line = NumberLine()\n        pointer = Vector(DOWN)\n        label = MathTex(\"x\").add_updater(lambda m: m.next_to(pointer, UP))\n\n        tracker = ValueTracker(0)\n        pointer.add_updater(\n            lambda m: m.next_to(\n                        number_line.n2p(tracker.get_value()),\n                        UP\n                    )\n        )\n        self.add(number_line, pointer,label)\n        tracker += 1.5\n        self.wait(1)\n        tracker -= 4\n        self.wait(0.5)\n        self.play(tracker.animate.set_value(5))\n        self.wait(0.5)\n        self.play(tracker.animate.set_value(3))\n        self.play(tracker.animate.increment_value(-2))\n        self.wait(0.5)", "code_sha1": "bc3b7c3be92d4f1ea6a2edb5852f46325d15f28b"}
{"url": "https://docs.manim.community/en/stable/reference/manim.mobject.value_tracker.ValueTracker.html", "depth": 1, "instruction": "A large dot moves continuously along the x-axis from the origin to the right over 2 seconds, driven by a ValueTracker that increments its value. The dot's radius is 3, and it updates its position in real-time as the ValueTracker changes.", "code": "from manim import *\n\nclass ValueTrackerExample(Scene):\n    def construct(self):\n        tracker = ValueTracker(0)\n        label = Dot(radius=3).add_updater(lambda x : x.set_x(tracker.get_value()))\n        self.add(label)\n        self.add(tracker)\n        tracker.add_updater(lambda mobject, dt: mobject.increment_value(dt))\n        self.wait(2)", "code_sha1": "544cae3837ede9b469a2b4a58dece1e91d0255b0"}
{"url": "https://docs.manim.community/en/stable/reference/manim.mobject.value_tracker.ValueTracker.html", "depth": 1, "instruction": "A number line with a downward-pointing vector pointer and a label \"x\" moves along the line as its value changes. The pointer updates its position dynamically based on the ValueTracker, which animates to values 1.5, -2.5, 5, 3, and 1, with pauses in between.", "code": "class ValueTrackerExample(Scene):\n    def construct(self):\n        number_line = NumberLine()\n        pointer = Vector(DOWN)\n        label = MathTex(\"x\").add_updater(lambda m: m.next_to(pointer, UP))\n\n        tracker = ValueTracker(0)\n        pointer.add_updater(\n            lambda m: m.next_to(\n                        number_line.n2p(tracker.get_value()),\n                        UP\n                    )\n        )\n        self.add(number_line, pointer,label)\n        tracker += 1.5\n        self.wait(1)\n        tracker -= 4\n        self.wait(0.5)\n        self.play(tracker.animate.set_value(5))\n        self.wait(0.5)\n        self.play(tracker.animate.set_value(3))\n        self.play(tracker.animate.increment_value(-2))\n        self.wait(0.5)", "code_sha1": "baeb0e62390e5529db07b3dc8fe31afdc31d72bf"}
{"url": "https://docs.manim.community/en/stable/reference/manim.mobject.value_tracker.ValueTracker.html", "depth": 1, "instruction": "A dot with a radius of 3 moves horizontally across the screen, continuously updating its position based on a ValueTracker that increments over 2 seconds. The dot starts at the left and smoothly transitions to the right, while the scene remains static.", "code": "class ValueTrackerExample(Scene):\n    def construct(self):\n        tracker = ValueTracker(0)\n        label = Dot(radius=3).add_updater(lambda x : x.set_x(tracker.get_value()))\n        self.add(label)\n        self.add(tracker)\n        tracker.add_updater(lambda mobject, dt: mobject.increment_value(dt))\n        self.wait(2)", "code_sha1": "695e14a5e34122936b38fb2542a3f4ab664098b6"}
{"url": "https://docs.manim.community/en/stable/reference/manim.mobject.vector_field.ArrowVectorField.html", "depth": 1, "instruction": "A vector field is displayed with arrows pointing in various directions, created by a custom function. The arrows are colored and sized uniformly, filling the scene. The camera remains static, showcasing the entire vector field without any animations or transitions.", "code": "from manim import *\n\nclass BasicUsage(Scene):\n    def construct(self):\n        func = lambda pos: ((pos[0] * UR + pos[1] * LEFT) - pos) / 3\n        self.add(ArrowVectorField(func))", "code_sha1": "5e912406af496f3d0d693611c05472db7838b796"}
{"url": "https://docs.manim.community/en/stable/reference/manim.mobject.vector_field.ArrowVectorField.html", "depth": 1, "instruction": "The scene displays a vector field represented by arrows, initially in a standard size, then morphs into a second vector field where arrow lengths are proportional to their x-coordinates. The transition is animated smoothly, with a brief pause before and after the transformation. The background remains static throughout.", "code": "from manim import *\n\nclass SizingAndSpacing(Scene):\n    def construct(self):\n        func = lambda pos: np.sin(pos[0] / 2) * UR + np.cos(pos[1] / 2) * LEFT\n        vf = ArrowVectorField(func, x_range=[-7, 7, 1])\n        self.add(vf)\n        self.wait()\n\n        length_func = lambda x: x / 3\n        vf2 = ArrowVectorField(func, x_range=[-7, 7, 1], length_func=length_func)\n        self.play(vf.animate.become(vf2))\n        self.wait()", "code_sha1": "bb16a6035ed534333e00646c255cf9d55e6730b3"}
{"url": "https://docs.manim.community/en/stable/reference/manim.mobject.vector_field.ArrowVectorField.html", "depth": 1, "instruction": "The scene displays a vector field represented by colorful arrows, with a minimum radius circle in red and a maximum radius circle in dark gray, both positioned to the left. The vector field is created using a function that shifts arrows based on their position, showcasing a gradient of colors from red to dark gray.", "code": "from manim import *\n\nclass Coloring(Scene):\n    def construct(self):\n        func = lambda pos: pos - LEFT * 5\n        colors = [RED, YELLOW, BLUE, DARK_GRAY]\n        min_radius = Circle(radius=2, color=colors[0]).shift(LEFT * 5)\n        max_radius = Circle(radius=10, color=colors[-1]).shift(LEFT * 5)\n        vf = ArrowVectorField(\n            func, min_color_scheme_value=2, max_color_scheme_value=10, colors=colors\n        )\n        self.add(vf, min_radius, max_radius)", "code_sha1": "557273ddf493a3ee19b8ad7803573a5f7d10d25d"}
{"url": "https://docs.manim.community/en/stable/reference/manim.mobject.vector_field.ArrowVectorField.html", "depth": 1, "instruction": "A vector field is displayed with arrows originating from a grid, each arrow pointing in a direction determined by the specified function. The arrows are uniformly sized and colored, creating a visually appealing flow effect across the scene.", "code": "class BasicUsage(Scene):\n    def construct(self):\n        func = lambda pos: ((pos[0] * UR + pos[1] * LEFT) - pos) / 3\n        self.add(ArrowVectorField(func))", "code_sha1": "48bbbec61f31ce8847ee23eb1fec5140f1b62379"}
{"url": "https://docs.manim.community/en/stable/reference/manim.mobject.vector_field.ArrowVectorField.html", "depth": 1, "instruction": "The scene displays a vector field represented by arrows, initially in one configuration, then morphing into a new configuration with arrows adjusted in length based on their x-position. The first vector field is static, followed by a smooth animation transitioning to the second field, with both fields displayed against a plain background.", "code": "class SizingAndSpacing(Scene):\n    def construct(self):\n        func = lambda pos: np.sin(pos[0] / 2) * UR + np.cos(pos[1] / 2) * LEFT\n        vf = ArrowVectorField(func, x_range=[-7, 7, 1])\n        self.add(vf)\n        self.wait()\n\n        length_func = lambda x: x / 3\n        vf2 = ArrowVectorField(func, x_range=[-7, 7, 1], length_func=length_func)\n        self.play(vf.animate.become(vf2))\n        self.wait()", "code_sha1": "b83350c9bc671b97ef5b4447db7b99cdfff4c350"}
{"url": "https://docs.manim.community/en/stable/reference/manim.mobject.vector_field.ArrowVectorField.html", "depth": 1, "instruction": "The scene displays a vector field represented by colorful arrows, with a minimum radius circle in red and a maximum radius circle in dark gray, both positioned on the left. The vector field is created using a function that shifts arrows based on their position, with colors transitioning from red to blue.", "code": "class Coloring(Scene):\n    def construct(self):\n        func = lambda pos: pos - LEFT * 5\n        colors = [RED, YELLOW, BLUE, DARK_GRAY]\n        min_radius = Circle(radius=2, color=colors[0]).shift(LEFT * 5)\n        max_radius = Circle(radius=10, color=colors[-1]).shift(LEFT * 5)\n        vf = ArrowVectorField(\n            func, min_color_scheme_value=2, max_color_scheme_value=10, colors=colors\n        )\n        self.add(vf, min_radius, max_radius)", "code_sha1": "960c6ab3cb12e0bc142e5d10d6c2c70fbebd8ab8"}
{"url": "https://docs.manim.community/en/stable/reference/manim.mobject.vector_field.StreamLines.html", "depth": 1, "instruction": "The scene displays a set of flowing streamlines generated by a vector field, colored with a gradient effect. The lines have a moderate stroke width and are semi-transparent, creating a dynamic visual effect as they animate smoothly across the screen.", "code": "from manim import *\n\nclass BasicUsage(Scene):\n    def construct(self):\n        func = lambda pos: ((pos[0] * UR + pos[1] * LEFT) - pos) / 3\n        self.add(StreamLines(func))", "code_sha1": "e314778dd84d37b33de5b9f5784e987b4dc95cbd"}
{"url": "https://docs.manim.community/en/stable/reference/manim.mobject.vector_field.StreamLines.html", "depth": 1, "instruction": "The scene displays a dynamic flow of streamlines generated by a sine and cosine function, overlaid on a blue spawning area rectangle and a larger green flowing area rectangle. Two labels, \"Spawning Area\" and \"Flowing Area,\" are positioned within the scene, each with a semi-transparent background.", "code": "from manim import *\n\nclass SpawningAndFlowingArea(Scene):\n    def construct(self):\n        func = lambda pos: np.sin(pos[0]) * UR + np.cos(pos[1]) * LEFT + pos / 5\n        stream_lines = StreamLines(\n            func, x_range=[-3, 3, 0.2], y_range=[-2, 2, 0.2], padding=1\n        )\n\n        spawning_area = Rectangle(width=6, height=4)\n        flowing_area = Rectangle(width=8, height=6)\n        labels = [Tex(\"Spawning Area\"), Tex(\"Flowing Area\").shift(DOWN * 2.5)]\n        for lbl in labels:\n            lbl.add_background_rectangle(opacity=0.6, buff=0.05)\n\n        self.add(stream_lines, spawning_area, flowing_area, *labels)", "code_sha1": "0854a7be0aa1c94926713924f4258eb2c60375c9"}
{"url": "https://docs.manim.community/en/stable/reference/manim.mobject.vector_field.StreamLines.html", "depth": 1, "instruction": "The scene features yellow streamlines created from a vector field, animated to flow smoothly across the screen. The lines are displayed with a stroke width of 3, filling the defined x and y ranges. The animation lasts for one virtual time unit, followed by a brief pause before the scene concludes.", "code": "from manim import *\n\nclass StreamLineCreation(Scene):\n    def construct(self):\n        func = lambda pos: (pos[0] * UR + pos[1] * LEFT) - pos\n        stream_lines = StreamLines(\n            func,\n            color=YELLOW,\n            x_range=[-7, 7, 1],\n            y_range=[-4, 4, 1],\n            stroke_width=3,\n            virtual_time=1,  # use shorter lines\n            max_anchors_per_line=5,  # better performance with fewer anchors\n        )\n        self.play(stream_lines.create())  # uses virtual_time as run_time\n        self.wait()", "code_sha1": "0ffc99c4819a121807ad8898a4daa392ba5dde3b"}
{"url": "https://docs.manim.community/en/stable/reference/manim.mobject.vector_field.StreamLines.html", "depth": 1, "instruction": "The scene displays flowing blue streamlines generated from a sine and cosine function, with a stroke width of 3. The streamlines animate smoothly for 1.5 seconds, then pause for 1 second before ending the animation, creating a dynamic visual effect of fluid motion.", "code": "from manim import *\n\nclass EndAnimation(Scene):\n    def construct(self):\n        func = lambda pos: np.sin(pos[0] / 2) * UR + np.cos(pos[1] / 2) * LEFT\n        stream_lines = StreamLines(\n            func, stroke_width=3, max_anchors_per_line=5, virtual_time=1, color=BLUE\n        )\n        self.add(stream_lines)\n        stream_lines.start_animation(warm_up=False, flow_speed=1.5, time_width=0.5)\n        self.wait(1)\n        self.play(stream_lines.end_animation())", "code_sha1": "a22d18e23345362aafc32faea2aaf30e14f36d9e"}
{"url": "https://docs.manim.community/en/stable/reference/manim.mobject.vector_field.StreamLines.html", "depth": 1, "instruction": "The scene displays animated streamlines flowing continuously in a sinusoidal pattern, with a stroke width of 3. The lines move smoothly, creating a dynamic visual effect, while the camera remains static. The animation runs for a duration determined by the flow speed of 1.5, enhancing the fluid motion of the streamlines.", "code": "from manim import *\n\nclass ContinuousMotion(Scene):\n    def construct(self):\n        func = lambda pos: np.sin(pos[0] / 2) * UR + np.cos(pos[1] / 2) * LEFT\n        stream_lines = StreamLines(func, stroke_width=3, max_anchors_per_line=30)\n        self.add(stream_lines)\n        stream_lines.start_animation(warm_up=False, flow_speed=1.5)\n        self.wait(stream_lines.virtual_time / stream_lines.flow_speed)", "code_sha1": "d1fd55a262964e25ee78cbba06d37333b82aaa08"}
{"url": "https://docs.manim.community/en/stable/reference/manim.mobject.vector_field.StreamLines.html", "depth": 1, "instruction": "A set of animated streamlines flows smoothly across the scene, originating from a defined function, with a medium stroke width and semi-transparent appearance, creating a dynamic visual effect.", "code": "class BasicUsage(Scene):\n    def construct(self):\n        func = lambda pos: ((pos[0] * UR + pos[1] * LEFT) - pos) / 3\n        self.add(StreamLines(func))", "code_sha1": "430cb0a6720894d93f40149394f221798949def0"}
{"url": "https://docs.manim.community/en/stable/reference/manim.mobject.vector_field.StreamLines.html", "depth": 1, "instruction": "The scene displays a dynamic flow of streamlines generated by a sine and cosine function, overlaid on two rectangles labeled \"Spawning Area\" and \"Flowing Area.\" The spawning area is 6x4 units, and the flowing area is 8x6 units. Labels have semi-transparent backgrounds, enhancing visibility against the animated streamlines.", "code": "class SpawningAndFlowingArea(Scene):\n    def construct(self):\n        func = lambda pos: np.sin(pos[0]) * UR + np.cos(pos[1]) * LEFT + pos / 5\n        stream_lines = StreamLines(\n            func, x_range=[-3, 3, 0.2], y_range=[-2, 2, 0.2], padding=1\n        )\n\n        spawning_area = Rectangle(width=6, height=4)\n        flowing_area = Rectangle(width=8, height=6)\n        labels = [Tex(\"Spawning Area\"), Tex(\"Flowing Area\").shift(DOWN * 2.5)]\n        for lbl in labels:\n            lbl.add_background_rectangle(opacity=0.6, buff=0.05)\n\n        self.add(stream_lines, spawning_area, flowing_area, *labels)", "code_sha1": "abe1239e0510eba8551fd3929c5166a3d04ad2d4"}
{"url": "https://docs.manim.community/en/stable/reference/manim.mobject.vector_field.StreamLines.html", "depth": 1, "instruction": "The scene features yellow stream lines created from a specified function, animated to flow smoothly across the screen. The lines have a stroke width of 3 and are displayed over a range of x and y coordinates. The animation lasts for one virtual time unit, followed by a brief pause before the scene ends.", "code": "class StreamLineCreation(Scene):\n    def construct(self):\n        func = lambda pos: (pos[0] * UR + pos[1] * LEFT) - pos\n        stream_lines = StreamLines(\n            func,\n            color=YELLOW,\n            x_range=[-7, 7, 1],\n            y_range=[-4, 4, 1],\n            stroke_width=3,\n            virtual_time=1,  # use shorter lines\n            max_anchors_per_line=5,  # better performance with fewer anchors\n        )\n        self.play(stream_lines.create())  # uses virtual_time as run_time\n        self.wait()", "code_sha1": "b76dba251e78dcd1aba9dc6637b62e83d37e02e4"}
{"url": "https://docs.manim.community/en/stable/reference/manim.mobject.vector_field.StreamLines.html", "depth": 1, "instruction": "The scene displays flowing blue streamlines generated by a sine and cosine function, with a stroke width of 3. The streamlines animate smoothly for 1.5 seconds, then pause for 1 second before ending the animation. The camera remains static throughout the scene.", "code": "class EndAnimation(Scene):\n    def construct(self):\n        func = lambda pos: np.sin(pos[0] / 2) * UR + np.cos(pos[1] / 2) * LEFT\n        stream_lines = StreamLines(\n            func, stroke_width=3, max_anchors_per_line=5, virtual_time=1, color=BLUE\n        )\n        self.add(stream_lines)\n        stream_lines.start_animation(warm_up=False, flow_speed=1.5, time_width=0.5)\n        self.wait(1)\n        self.play(stream_lines.end_animation())", "code_sha1": "88e09973a539fc60ec01b89f7589dfa896fa5aeb"}
{"url": "https://docs.manim.community/en/stable/reference/manim.mobject.vector_field.StreamLines.html", "depth": 1, "instruction": "The scene displays animated streamlines flowing in a sinusoidal pattern, colored with a gradient effect. The lines have a stroke width of 3 and are generated dynamically based on a mathematical function. The animation runs continuously at a flow speed of 1.5, creating a smooth visual effect.", "code": "class ContinuousMotion(Scene):\n    def construct(self):\n        func = lambda pos: np.sin(pos[0] / 2) * UR + np.cos(pos[1] / 2) * LEFT\n        stream_lines = StreamLines(func, stroke_width=3, max_anchors_per_line=30)\n        self.add(stream_lines)\n        stream_lines.start_animation(warm_up=False, flow_speed=1.5)\n        self.wait(stream_lines.virtual_time / stream_lines.flow_speed)", "code_sha1": "40d5c406f89d1a7585e22adaea9467a7d15510c8"}
{"url": "https://docs.manim.community/en/stable/reference/manim.mobject.vector_field.VectorField.html", "depth": 1, "instruction": "A gray circle and a dot are positioned at the left of the screen, both nudged along a dynamic vector field defined by sine and cosine functions. The circle and dot move smoothly over 60 frames, following the vector field's direction, while the scene lasts for 6 seconds.", "code": "from manim import *\n\nclass Nudging(Scene):\n    def construct(self):\n        func = lambda pos: np.sin(pos[1] / 2) * RIGHT + np.cos(pos[0] / 2) * UP\n        vector_field = ArrowVectorField(\n            func, x_range=[-7, 7, 1], y_range=[-4, 4, 1], length_func=lambda x: x / 2\n        )\n        self.add(vector_field)\n        circle = Circle(radius=2).shift(LEFT)\n        self.add(circle.copy().set_color(GRAY))\n        dot = Dot().move_to(circle)\n\n        vector_field.nudge(circle, -2, 60, True)\n        vector_field.nudge(dot, -2, 60)\n\n        circle.add_updater(vector_field.get_nudge_updater(pointwise=True))\n        dot.add_updater(vector_field.get_nudge_updater())\n        self.add(circle, dot)\n        self.wait(6)", "code_sha1": "51c4ffae5f11942bdf7bf380ffdeae11ddf47379"}
{"url": "https://docs.manim.community/en/stable/reference/manim.mobject.vector_field.VectorField.html", "depth": 1, "instruction": "The scene displays an animated vector field represented by arrows, initially in their original size and direction, then smoothly transitioning to a scaled-down version (50% size) while maintaining their orientation. The background remains static, and the animation lasts for a brief moment before the scene concludes with a pause.", "code": "from manim import *\n\nclass ScaleVectorFieldFunction(Scene):\n    def construct(self):\n        func = lambda pos: np.sin(pos[1]) * RIGHT + np.cos(pos[0]) * UP\n        vector_field = ArrowVectorField(func)\n        self.add(vector_field)\n        self.wait()\n\n        func = VectorField.scale_func(func, 0.5)\n        self.play(vector_field.animate.become(ArrowVectorField(func)))\n        self.wait()", "code_sha1": "e04105a87467f872bd7bef5824c5d151cd5605e2"}
{"url": "https://docs.manim.community/en/stable/reference/manim.mobject.vector_field.VectorField.html", "depth": 1, "instruction": "A vector field is displayed with arrows representing the field's direction and strength, alongside a gray circle and a dot. The circle and dot are nudged along the vector field, with the circle moving smoothly while the dot follows the field's vectors. The scene lasts for 6 seconds, showcasing the dynamic movement.", "code": "class Nudging(Scene):\n    def construct(self):\n        func = lambda pos: np.sin(pos[1] / 2) * RIGHT + np.cos(pos[0] / 2) * UP\n        vector_field = ArrowVectorField(\n            func, x_range=[-7, 7, 1], y_range=[-4, 4, 1], length_func=lambda x: x / 2\n        )\n        self.add(vector_field)\n        circle = Circle(radius=2).shift(LEFT)\n        self.add(circle.copy().set_color(GRAY))\n        dot = Dot().move_to(circle)\n\n        vector_field.nudge(circle, -2, 60, True)\n        vector_field.nudge(dot, -2, 60)\n\n        circle.add_updater(vector_field.get_nudge_updater(pointwise=True))\n        dot.add_updater(vector_field.get_nudge_updater())\n        self.add(circle, dot)\n        self.wait(6)", "code_sha1": "4e6b25761f02c2a164d2bbf02bd9f404f10ee092"}
{"url": "https://docs.manim.community/en/stable/reference/manim.mobject.vector_field.VectorField.html", "depth": 1, "instruction": "The scene displays a dynamic vector field represented by arrows, initially animated with a sine and cosine function. After a brief pause, the vector field scales down to half its original size, with the arrows smoothly transitioning to their new positions, maintaining their direction. The background remains static throughout the animation.", "code": "class ScaleVectorFieldFunction(Scene):\n    def construct(self):\n        func = lambda pos: np.sin(pos[1]) * RIGHT + np.cos(pos[0]) * UP\n        vector_field = ArrowVectorField(func)\n        self.add(vector_field)\n        self.wait()\n\n        func = VectorField.scale_func(func, 0.5)\n        self.play(vector_field.animate.become(ArrowVectorField(func)))\n        self.wait()", "code_sha1": "f0a4427705261c481031c37c4988575d2ae96479"}
{"url": "https://docs.manim.community/en/stable/reference/manim.scene.moving_camera_scene.html", "depth": 1, "instruction": "The scene features a blue \"Hello World\" text. The camera zooms in to focus on the text, expanding its width by 20%, followed by a brief pause of 0.3 seconds, then smoothly restores to its original position and zoom level.", "code": "from manim import *\n\nclass ChangingCameraWidthAndRestore(MovingCameraScene):\n    def construct(self):\n        text = Text(\"Hello World\").set_color(BLUE)\n        self.add(text)\n        self.camera.frame.save_state()\n        self.play(self.camera.frame.animate.set(width=text.width * 1.2))\n        self.wait(0.3)\n        self.play(Restore(self.camera.frame))", "code_sha1": "c0c4fb1be0922c70996c2f1520d3bfc64d213f52"}
{"url": "https://docs.manim.community/en/stable/reference/manim.scene.moving_camera_scene.html", "depth": 1, "instruction": "The scene features a red square and a green triangle, both with 50% opacity. The camera smoothly transitions to focus on the square, then shifts to the triangle, with brief pauses before and after each movement.", "code": "from manim import *\n\nclass MovingCameraCenter(MovingCameraScene):\n    def construct(self):\n        s = Square(color=RED, fill_opacity=0.5).move_to(2 * LEFT)\n        t = Triangle(color=GREEN, fill_opacity=0.5).move_to(2 * RIGHT)\n        self.wait(0.3)\n        self.add(s, t)\n        self.play(self.camera.frame.animate.move_to(s))\n        self.wait(0.3)\n        self.play(self.camera.frame.animate.move_to(t))", "code_sha1": "cc09a322b745af8bd4ee4c6e55c80b48c803e48c"}
{"url": "https://docs.manim.community/en/stable/reference/manim.scene.moving_camera_scene.html", "depth": 1, "instruction": "The scene features a blue square and a yellow triangle, both with 50% opacity. The camera first zooms in on the square, then transitions to the triangle, and finally zooms out to a wide view centered on the origin, with smooth animations and a total duration of approximately 1 second.", "code": "from manim import *\n\nclass MovingAndZoomingCamera(MovingCameraScene):\n    def construct(self):\n        s = Square(color=BLUE, fill_opacity=0.5).move_to(2 * LEFT)\n        t = Triangle(color=YELLOW, fill_opacity=0.5).move_to(2 * RIGHT)\n        self.add(s, t)\n        self.play(self.camera.frame.animate.move_to(s).set(width=s.width*2))\n        self.wait(0.3)\n        self.play(self.camera.frame.animate.move_to(t).set(width=t.width*2))\n\n        self.play(self.camera.frame.animate.move_to(ORIGIN).set(width=14))", "code_sha1": "43884bfe1dce26c00dcc27c532d61b07b49b08e6"}
{"url": "https://docs.manim.community/en/stable/reference/manim.scene.moving_camera_scene.html", "depth": 1, "instruction": "The scene features a graph of the sine function on a coordinate plane, with two white dots marking the start and end points. The camera smoothly zooms in on the first dot, then moves to the second dot, and finally restores to its original position, creating a dynamic visual exploration of the graph.", "code": "from manim import *\n\nclass MovingCameraOnGraph(MovingCameraScene):\n    def construct(self):\n        self.camera.frame.save_state()\n\n        ax = Axes(x_range=[-1, 10], y_range=[-1, 10])\n        graph = ax.plot(lambda x: np.sin(x), color=WHITE, x_range=[0, 3 * PI])\n\n        dot_1 = Dot(ax.i2gp(graph.t_min, graph))\n        dot_2 = Dot(ax.i2gp(graph.t_max, graph))\n        self.add(ax, graph, dot_1, dot_2)\n\n        self.play(self.camera.frame.animate.scale(0.5).move_to(dot_1))\n        self.play(self.camera.frame.animate.move_to(dot_2))\n        self.play(Restore(self.camera.frame))\n        self.wait()", "code_sha1": "214134f89d4d143eb9d15b041f872f2e98defb7d"}
{"url": "https://docs.manim.community/en/stable/reference/manim.scene.moving_camera_scene.html", "depth": 1, "instruction": "The animation features a grid of four scenes, each displaying a circle and text. The camera smoothly zooms into each scene sequentially, pausing briefly on each before zooming out to encompass the entire group with a margin. The scenes are arranged with a buffer, and the camera transitions are animated.", "code": "from manim import *\n\nclass SlidingMultipleScenes(MovingCameraScene):\n    def construct(self):\n        def create_scene(number):\n            frame = Rectangle(width=16,height=9)\n            circ = Circle().shift(LEFT)\n            text = Tex(f\"This is Scene {str(number)}\").next_to(circ, RIGHT)\n            frame.add(circ,text)\n            return frame\n\n        group = VGroup(*(create_scene(i) for i in range(4))).arrange_in_grid(buff=4)\n        self.add(group)\n        self.camera.auto_zoom(group[0], animate=False)\n        for scene in group:\n            self.play(self.camera.auto_zoom(scene))\n            self.wait()\n\n        self.play(self.camera.auto_zoom(group, margin=2))", "code_sha1": "281820204e9c9b81a133ad1423cbd32e3ef86ea2"}
{"url": "https://docs.manim.community/en/stable/reference/manim.scene.moving_camera_scene.html", "depth": 1, "instruction": "The scene displays a blue \"Hello World\" text, with the camera zooming in to frame the text at 1.2 times its width, followed by a brief pause, and then restoring the camera to its original position.", "code": "class ChangingCameraWidthAndRestore(MovingCameraScene):\n    def construct(self):\n        text = Text(\"Hello World\").set_color(BLUE)\n        self.add(text)\n        self.camera.frame.save_state()\n        self.play(self.camera.frame.animate.set(width=text.width * 1.2))\n        self.wait(0.3)\n        self.play(Restore(self.camera.frame))", "code_sha1": "fa913afb8e4efdbb8412a1844e80c4f8e897599d"}
{"url": "https://docs.manim.community/en/stable/reference/manim.scene.moving_camera_scene.html", "depth": 1, "instruction": "The scene features a red square and a green triangle, both with 50% opacity, positioned on the left and right, respectively. The camera smoothly transitions to focus on the square, then shifts to the triangle, with pauses of 0.3 seconds before and after each camera movement.", "code": "class MovingCameraCenter(MovingCameraScene):\n    def construct(self):\n        s = Square(color=RED, fill_opacity=0.5).move_to(2 * LEFT)\n        t = Triangle(color=GREEN, fill_opacity=0.5).move_to(2 * RIGHT)\n        self.wait(0.3)\n        self.add(s, t)\n        self.play(self.camera.frame.animate.move_to(s))\n        self.wait(0.3)\n        self.play(self.camera.frame.animate.move_to(t))", "code_sha1": "5d11f33ab31a964eb169e4e9f95b0a2efdc2f2f8"}
{"url": "https://docs.manim.community/en/stable/reference/manim.scene.moving_camera_scene.html", "depth": 1, "instruction": "The scene features a blue square and a yellow triangle, both with 50% opacity. The camera first zooms in on the square, then transitions to the triangle, and finally zooms out to encompass a wider view, all with smooth animations and a brief pause between movements.", "code": "class MovingAndZoomingCamera(MovingCameraScene):\n    def construct(self):\n        s = Square(color=BLUE, fill_opacity=0.5).move_to(2 * LEFT)\n        t = Triangle(color=YELLOW, fill_opacity=0.5).move_to(2 * RIGHT)\n        self.add(s, t)\n        self.play(self.camera.frame.animate.move_to(s).set(width=s.width*2))\n        self.wait(0.3)\n        self.play(self.camera.frame.animate.move_to(t).set(width=t.width*2))\n\n        self.play(self.camera.frame.animate.move_to(ORIGIN).set(width=14))", "code_sha1": "36b6ac13ec9925834a7cde0cecb280a8e89a3fe1"}
{"url": "https://docs.manim.community/en/stable/reference/manim.scene.moving_camera_scene.html", "depth": 1, "instruction": "The scene features a graph of the sine function on a coordinate plane, with two dots marking the start and end points. The camera smoothly zooms in on the first dot, moves to the second dot, and then restores to its original position, all while maintaining a clear view of the graph.", "code": "class MovingCameraOnGraph(MovingCameraScene):\n    def construct(self):\n        self.camera.frame.save_state()\n\n        ax = Axes(x_range=[-1, 10], y_range=[-1, 10])\n        graph = ax.plot(lambda x: np.sin(x), color=WHITE, x_range=[0, 3 * PI])\n\n        dot_1 = Dot(ax.i2gp(graph.t_min, graph))\n        dot_2 = Dot(ax.i2gp(graph.t_max, graph))\n        self.add(ax, graph, dot_1, dot_2)\n\n        self.play(self.camera.frame.animate.scale(0.5).move_to(dot_1))\n        self.play(self.camera.frame.animate.move_to(dot_2))\n        self.play(Restore(self.camera.frame))\n        self.wait()", "code_sha1": "6b4bfe376a803254d2deb6f34dc23e818083cc08"}
{"url": "https://docs.manim.community/en/stable/reference/manim.scene.moving_camera_scene.html", "depth": 1, "instruction": "The scene features four rectangular frames arranged in a grid, each containing a circle and a text label indicating the scene number. The camera smoothly zooms in on each frame sequentially, pausing briefly on each, before zooming out to encompass all frames with a margin.", "code": "class SlidingMultipleScenes(MovingCameraScene):\n    def construct(self):\n        def create_scene(number):\n            frame = Rectangle(width=16,height=9)\n            circ = Circle().shift(LEFT)\n            text = Tex(f\"This is Scene {str(number)}\").next_to(circ, RIGHT)\n            frame.add(circ,text)\n            return frame\n\n        group = VGroup(*(create_scene(i) for i in range(4))).arrange_in_grid(buff=4)\n        self.add(group)\n        self.camera.auto_zoom(group[0], animate=False)\n        for scene in group:\n            self.play(self.camera.auto_zoom(scene))\n            self.wait()\n\n        self.play(self.camera.auto_zoom(group, margin=2))", "code_sha1": "1f1b995a042cb9c63ba3dfb33e3be2da54b0a4c5"}
{"url": "https://docs.manim.community/en/stable/reference/manim.scene.scene.Scene.html", "depth": 1, "instruction": "The scene displays the text \"Hello World!\" in a standard font, animated with a writing effect, appearing from left to right on the screen. The text is centered and has a default color, with no additional objects or background elements present.", "code": "class MyScene(Scene):\n    def construct(self):\n        self.play(Write(Text(\"Hello World!\")))", "code_sha1": "875b913bb78e388da71f4cc5a545b01c94f91a7e"}
{"url": "https://docs.manim.community/en/stable/reference/manim.scene.scene.Scene.html", "depth": 1, "instruction": "A green dot appears, followed by a sound effect. After a pause, the dot changes to blue with another sound, then to red with a final sound, each accompanied by a wait. The scene features a simple background and no camera movements.", "code": "from manim import *\n\nclass SoundExample(Scene):\n    # Source of sound under Creative Commons 0 License. https://freesound.org/people/Druminfected/sounds/250551/\n    def construct(self):\n        dot = Dot().set_color(GREEN)\n        self.add_sound(\"click.wav\")\n        self.add(dot)\n        self.wait()\n        self.add_sound(\"click.wav\")\n        dot.set_color(BLUE)\n        self.wait()\n        self.add_sound(\"click.wav\")\n        dot.set_color(RED)\n        self.wait()", "code_sha1": "7aa29bfd40c6c69df3912c4983a02027aa586c93"}
{"url": "https://docs.manim.community/en/stable/reference/manim.scene.scene.Scene.html", "depth": 1, "instruction": "A square is created, followed by a subcaption \"Hello square!\" appearing for 1 second. Then, the square transforms into a circle with the subcaption \"The square transforms.\" displayed during the transformation. The animations are smooth, with the subcaptions appearing at the start of their respective actions.", "code": "class SubcaptionExample(Scene):\n    def construct(self):\n        square = Square()\n        circle = Circle()\n\n        # first option: via the add_subcaption method\n        self.add_subcaption(\"Hello square!\", duration=1)\n        self.play(Create(square))\n\n        # second option: within the call to Scene.play\n        self.play(\n            Transform(square, circle), subcaption=\"The square transforms.\"\n        )", "code_sha1": "964aa23378c96528a13802034bc408051203436c"}
{"url": "https://docs.manim.community/en/stable/reference/manim.scene.scene.Scene.html", "depth": 1, "instruction": "A green dot appears, followed by a sound effect. After a pause, the dot changes to blue with another sound, then to red with a final sound, each accompanied by a wait time. The scene features a simple background with no camera movements.", "code": "class SoundExample(Scene):\n    # Source of sound under Creative Commons 0 License. https://freesound.org/people/Druminfected/sounds/250551/\n    def construct(self):\n        dot = Dot().set_color(GREEN)\n        self.add_sound(\"click.wav\")\n        self.add(dot)\n        self.wait()\n        self.add_sound(\"click.wav\")\n        dot.set_color(BLUE)\n        self.wait()\n        self.add_sound(\"click.wav\")\n        dot.set_color(RED)\n        self.wait()", "code_sha1": "8bae1a459e7f3268b00594809282993863a5db23"}
{"url": "https://docs.manim.community/en/stable/reference/manim.scene.vector_space_scene.LinearTransformationScene.html", "depth": 1, "instruction": "The scene displays a grid with coordinate axes, where a vector transforms according to the matrix [[1, 1], [0, 1]]. The original vector leaves a ghost image, while the transformed vector is highlighted. The transformation occurs smoothly, followed by a brief pause.", "code": "from manim import *\n\nclass LinearTransformationSceneExample(LinearTransformationScene):\n    def __init__(self, **kwargs):\n        LinearTransformationScene.__init__(\n            self,\n            show_coordinates=True,\n            leave_ghost_vectors=True,\n            **kwargs\n        )\n\n    def construct(self):\n        matrix = [[1, 1], [0, 1]]\n        self.apply_matrix(matrix)\n        self.wait()", "code_sha1": "91c71151dd54a591c70d2cdbf842ae940f498583"}
{"url": "https://docs.manim.community/en/stable/reference/manim.scene.vector_space_scene.LinearTransformationScene.html", "depth": 1, "instruction": "The scene displays a grid with basis vectors transformed by the matrix [[1, 1], [0, 1]], leaving ghost images of the original vectors. The transformation occurs smoothly, followed by a brief pause to observe the result.", "code": "class LinearTransformationSceneExample(LinearTransformationScene):\n    def __init__(self, **kwargs):\n        LinearTransformationScene.__init__(\n            self,\n            show_coordinates=True,\n            leave_ghost_vectors=True,\n            **kwargs\n        )\n\n    def construct(self):\n        matrix = [[1, 1], [0, 1]]\n        self.apply_matrix(matrix)\n        self.wait()", "code_sha1": "37bbaef29f951e2ffb6d4e8c8d0dbdcede3c7319"}
{"url": "https://docs.manim.community/en/stable/reference/manim.scene.zoomed_scene.html", "depth": 1, "instruction": "A green dot appears at the center of the scene, waits for 1 second, then the scene activates zooming without animation, waits another second, and finally, the dot shifts left while the zoom remains active.", "code": "from manim import *\n\nclass UseZoomedScene(ZoomedScene):\n    def construct(self):\n        dot = Dot().set_color(GREEN)\n        self.add(dot)\n        self.wait(1)\n        self.activate_zooming(animate=False)\n        self.wait(1)\n        self.play(dot.animate.shift(LEFT))", "code_sha1": "2374982455f082afdac1b064179efe869066ee79"}
{"url": "https://docs.manim.community/en/stable/reference/manim.scene.zoomed_scene.html", "depth": 1, "instruction": "A green dot and a small filled circle are displayed, with the dot initially positioned on the left. After a brief pause, the scene zooms in, scaling the view and shifting downward, emphasizing the dot's movement to the left. The zoomed frame has a thick border, enhancing focus on the objects.", "code": "from manim import *\n\nclass ChangingZoomScale(ZoomedScene):\n    def __init__(self, **kwargs):\n        ZoomedScene.__init__(\n            self,\n            zoom_factor=0.3,\n            zoomed_display_height=1,\n            zoomed_display_width=3,\n            image_frame_stroke_width=20,\n            zoomed_camera_config={\n                \"default_frame_stroke_width\": 3,\n            },\n            **kwargs\n        )\n\n    def construct(self):\n        dot = Dot().set_color(GREEN)\n        sq = Circle(fill_opacity=1, radius=0.2).next_to(dot, RIGHT)\n        self.add(dot, sq)\n        self.wait(1)\n        self.activate_zooming(animate=False)\n        self.wait(1)\n        self.play(dot.animate.shift(LEFT * 0.3))\n\n        self.play(self.zoomed_camera.frame.animate.scale(4))\n        self.play(self.zoomed_camera.frame.animate.shift(0.5 * DOWN))", "code_sha1": "38bd50917f110a9dc0c50c287068bcbf696c1eda"}
{"url": "https://docs.manim.community/en/stable/reference/manim.scene.zoomed_scene.html", "depth": 1, "instruction": "A green dot appears at the center of the screen, waits for 1 second, then the scene activates zooming without animation. After another 1-second pause, the dot shifts left while remaining centered, emphasizing the zoomed-in effect.", "code": "class UseZoomedScene(ZoomedScene):\n    def construct(self):\n        dot = Dot().set_color(GREEN)\n        self.add(dot)\n        self.wait(1)\n        self.activate_zooming(animate=False)\n        self.wait(1)\n        self.play(dot.animate.shift(LEFT))", "code_sha1": "656d8940c67c1899d0dda933f5d48bf5ac8b2841"}
{"url": "https://docs.manim.community/en/stable/reference/manim.scene.zoomed_scene.html", "depth": 1, "instruction": "A green dot and a filled circle are displayed, with the dot initially positioned on the left. After a brief pause, the scene zooms in, scaling the camera frame by 4 and shifting it downwards, emphasizing the objects while maintaining their original colors and sizes.", "code": "class ChangingZoomScale(ZoomedScene):\n    def __init__(self, **kwargs):\n        ZoomedScene.__init__(\n            self,\n            zoom_factor=0.3,\n            zoomed_display_height=1,\n            zoomed_display_width=3,\n            image_frame_stroke_width=20,\n            zoomed_camera_config={\n                \"default_frame_stroke_width\": 3,\n            },\n            **kwargs\n        )\n\n    def construct(self):\n        dot = Dot().set_color(GREEN)\n        sq = Circle(fill_opacity=1, radius=0.2).next_to(dot, RIGHT)\n        self.add(dot, sq)\n        self.wait(1)\n        self.activate_zooming(animate=False)\n        self.wait(1)\n        self.play(dot.animate.shift(LEFT * 0.3))\n\n        self.play(self.zoomed_camera.frame.animate.scale(4))\n        self.play(self.zoomed_camera.frame.animate.shift(0.5 * DOWN))", "code_sha1": "7e7b1b9f6a1b2ff19c70d29fff9bc136ea0e6706"}
{"url": "https://docs.manim.community/en/stable/reference/manim.utils.bezier.html", "depth": 1, "instruction": "The code checks if a series of 3D points form a closed spline by comparing the first and last points for proximity, returning `True` or `False` based on their closeness.", "code": "import numpy as np\nfrom manim import is_closed\nis_closed(\n    np.array(\n        [\n            [0, 0, 0],\n            [1, 2, 3],\n            [3, 2, 1],\n            [0, 0, 0],\n        ]\n    )\n)\nTrue\nis_closed(\n    np.array(\n        [\n            [0, 0, 0],\n            [1, 2, 3],\n            [3, 2, 1],\n            [1e-10, 1e-10, 1e-10],\n        ]\n    )\n)\nTrue\nis_closed(\n    np.array(\n        [\n            [0, 0, 0],\n            [1, 2, 3],\n            [3, 2, 1],\n            [1e-2, 1e-2, 1e-2],\n        ]\n    )\n)\nFalse", "code_sha1": "05777ccf0753410c4029fcfdbc3404612d61a74e"}
{"url": "https://docs.manim.community/en/stable/reference/manim.utils.color.html", "depth": 1, "instruction": "The visual result displays a color swatch filled with the XKCD color \"AVOCADO\" (#90B134), presented as a rectangular shape centered on the screen, with no animations or camera operations applied.", "code": "from manim import XKCD\nXKCD.AVOCADO\nManimColor('#90B134')", "code_sha1": "b1ce09daa81414c40e792dc401317643f5eb713f"}
{"url": "https://docs.manim.community/en/stable/reference/manim.utils.color.core.html", "depth": 1, "instruction": "The code outputs the hexadecimal representation of the color RED, which is #FC6255, demonstrating how to access and utilize predefined color constants in Manim.", "code": "from manim import RED, GREEN, BLUE\nprint(RED)\n#FC6255", "code_sha1": "00a903617c75c99e2c1b5e01561f2e3a0c8890ab"}
{"url": "https://docs.manim.community/en/stable/reference/manim.utils.color.AS2700.html", "depth": 1, "instruction": "Display a bright blue rectangle (AS2700.B23) centered on the screen, with a width of 4 units and height of 2 units, animated to fade in over 2 seconds, while the background remains white.", "code": "from manim import AS2700\nAS2700.B23_BRIGHT_BLUE\nManimColor('#174F90')", "code_sha1": "6c2da2b50e5faf50e88aa502ef94f0b026062d09"}
{"url": "https://docs.manim.community/en/stable/reference/manim.utils.color.BS381.html", "depth": 1, "instruction": "Display a vibrant Oxford Blue rectangle with dimensions 3x2 units, centered on the screen, while fading in over 2 seconds. The background remains white, emphasizing the deep blue color.", "code": "from manim import BS381\nBS381.OXFORD_BLUE\nManimColor('#1F3057')", "code_sha1": "5b7a64640d1f689656a79c57fcb40175ce41ef9b"}
{"url": "https://docs.manim.community/en/stable/reference/manim.utils.color.DVIPSNAMES.html", "depth": 1, "instruction": "A dark orchid-colored rectangle (#A4538A) is displayed on the screen, centered and occupying a moderate size. The background is white, enhancing the rectangle's visibility. No animations or camera operations are applied, resulting in a static visual presentation.", "code": "from manim import DVIPSNAMES\nDVIPSNAMES.DARKORCHID\nManimColor('#A4538A')", "code_sha1": "2f8cd8be330415204530064fc208f298a1b01d67"}
{"url": "https://docs.manim.community/en/stable/reference/manim.utils.color.SVGNAMES.html", "depth": 1, "instruction": "Display a light coral rectangle with a size of 2x1 units, centered on the screen. The rectangle should have a fill color of #EF7F7F and no stroke. Animate it to fade in over 2 seconds, then hold for 1 second before fading out over 2 seconds.", "code": "from manim import SVGNAMES\nSVGNAMES.LIGHTCORAL\nManimColor('#EF7F7F')", "code_sha1": "57ecf428c44cd1d63103cd5e4c8565c97587033d"}
{"url": "https://docs.manim.community/en/stable/reference/manim.utils.color.XKCD.html", "depth": 1, "instruction": "The visual result displays a vibrant orange rectangle filled with the XKCD color \"MANGO\" (#FFA62B), positioned centrally on the screen, with a smooth fade-in animation lasting 2 seconds. The background is a soft white, enhancing the rectangle's brightness.", "code": "from manim import XKCD\nXKCD.MANGO\nManimColor('#FFA62B')", "code_sha1": "c9feee50464d3d91347f7516dbd9172b3eab3440"}
{"url": "https://docs.manim.community/en/stable/reference/manim.utils.color.X11.html", "depth": 1, "instruction": "The visual result displays a rectangular shape filled with the color Beige (#F5F5DC) from the X11 color palette, positioned centrally on the screen, with a smooth fade-in animation over 2 seconds.", "code": "from manim import X11\nX11.BEIGE\nManimColor('#F5F5DC')", "code_sha1": "a979e08c308a86d6bcd6b0a10d8a712331d8547b"}
{"url": "https://docs.manim.community/en/stable/reference/manim.constants.CapStyleType.html", "depth": 1, "instruction": "Display four green arcs with varying cap styles (AUTO, ROUND, BUTT, SQUARE) arranged horizontally, each with a stroke width of 20. Below each arc, a corresponding label in font size 24 indicates the cap style name.", "code": "from manim import *\n\nclass CapStyleVariants(Scene):\n    def construct(self):\n        arcs = VGroup(*[\n            Arc(\n                radius=1,\n                start_angle=0,\n                angle=TAU / 4,\n                stroke_width=20,\n                color=GREEN,\n                cap_style=cap_style,\n            )\n            for cap_style in CapStyleType\n        ])\n        arcs.arrange(RIGHT, buff=1)\n        self.add(arcs)\n        for arc in arcs:\n            label = Text(arc.cap_style.name, font_size=24).next_to(arc, DOWN)\n            self.add(label)", "code_sha1": "5932ac3d783a5805281ebf9c71af35b971bbc64f"}
{"url": "https://docs.manim.community/en/stable/reference/manim.constants.CapStyleType.html", "depth": 1, "instruction": "Four green arcs with varying cap styles (AUTO, ROUND, BUTT, SQUARE) are arranged horizontally with a buffer of 1 unit between them. Each arc has a stroke width of 20 and a radius of 1. Below each arc, a label displays the corresponding cap style name in font size 24.", "code": "class CapStyleVariants(Scene):\n    def construct(self):\n        arcs = VGroup(*[\n            Arc(\n                radius=1,\n                start_angle=0,\n                angle=TAU / 4,\n                stroke_width=20,\n                color=GREEN,\n                cap_style=cap_style,\n            )\n            for cap_style in CapStyleType\n        ])\n        arcs.arrange(RIGHT, buff=1)\n        self.add(arcs)\n        for arc in arcs:\n            label = Text(arc.cap_style.name, font_size=24).next_to(arc, DOWN)\n            self.add(label)", "code_sha1": "55bac4e786a5f92c680f1800fad4c07ce8a2e802"}
{"url": "https://docs.manim.community/en/stable/reference/manim.constants.LineJointType.html", "depth": 1, "instruction": "The scene displays a series of green VMobjects with a stroke width of 20, arranged horizontally with equal spacing. Each line represents a different joint type (AUTO, ROUND, BEVEL), labeled below with corresponding text. The lines are positioned in a row, showcasing their distinct joint styles.", "code": "from manim import *\n\nclass LineJointVariants(Scene):\n    def construct(self):\n        mob = VMobject(stroke_width=20, color=GREEN).set_points_as_corners([\n            np.array([-2, 0, 0]),\n            np.array([0, 0, 0]),\n            np.array([-2, 1, 0]),\n        ])\n        lines = VGroup(*[mob.copy() for _ in range(len(LineJointType))])\n        for line, joint_type in zip(lines, LineJointType):\n            line.joint_type = joint_type\n\n        lines.arrange(RIGHT, buff=1)\n        self.add(lines)\n        for line in lines:\n            label = Text(line.joint_type.name).next_to(line, DOWN)\n            self.add(label)", "code_sha1": "983550b01b5cc1c4cad0803aa551db39c4949ec5"}
{"url": "https://docs.manim.community/en/stable/reference/manim.constants.LineJointType.html", "depth": 1, "instruction": "The scene displays a series of green lines with varying joint types (AUTO, ROUND, BEVEL), arranged horizontally with equal spacing. Each line has a stroke width of 20. Below each line, a label indicates its joint type. The overall composition is visually clear and organized, showcasing the differences in line joints effectively.", "code": "class LineJointVariants(Scene):\n    def construct(self):\n        mob = VMobject(stroke_width=20, color=GREEN).set_points_as_corners([\n            np.array([-2, 0, 0]),\n            np.array([0, 0, 0]),\n            np.array([-2, 1, 0]),\n        ])\n        lines = VGroup(*[mob.copy() for _ in range(len(LineJointType))])\n        for line, joint_type in zip(lines, LineJointType):\n            line.joint_type = joint_type\n\n        lines.arrange(RIGHT, buff=1)\n        self.add(lines)\n        for line in lines:\n            label = Text(line.joint_type.name).next_to(line, DOWN)\n            self.add(label)", "code_sha1": "487a8cda62c3686a3a4401f647f768528f844f67"}
{"url": "https://docs.manim.community/en/stable/reference/manim.utils.debug.html", "depth": 1, "instruction": "The scene displays a mathematical equation with the first term indexed, featuring a purple color for a specific character and dark blue for a substring. The equation is centered on the screen, with the indexed labels positioned appropriately beneath the first term, creating a clear visual distinction between the components.", "code": "from manim import *\n\nclass IndexLabelsExample(Scene):\n    def construct(self):\n        text = MathTex(\n            \"\\\\frac{d}{dx}f(x)g(x)=\",\n            \"f(x)\\\\frac{d}{dx}g(x)\",\n            \"+\",\n            \"g(x)\\\\frac{d}{dx}f(x)\",\n        )\n\n        #index the fist term in the MathTex mob\n        indices = index_labels(text[0])\n\n        text[0][1].set_color(PURPLE_B)\n        text[0][8:12].set_color(DARK_BLUE)\n\n        self.add(text, indices)", "code_sha1": "fe188730fd0ad3b53caa05a87c60ca24198f42eb"}
{"url": "https://docs.manim.community/en/stable/reference/manim.utils.debug.html", "depth": 1, "instruction": "The scene displays a mathematical equation with the first term highlighted: the variable 'f(x)' in purple and the derivative 'd/dx' in dark blue. The equation is accompanied by indexed labels, visually emphasizing the first term's components. The overall layout is clean, with the text centered on the screen.", "code": "class IndexLabelsExample(Scene):\n    def construct(self):\n        text = MathTex(\n            \"\\\\frac{d}{dx}f(x)g(x)=\",\n            \"f(x)\\\\frac{d}{dx}g(x)\",\n            \"+\",\n            \"g(x)\\\\frac{d}{dx}f(x)\",\n        )\n\n        #index the fist term in the MathTex mob\n        indices = index_labels(text[0])\n\n        text[0][1].set_color(PURPLE_B)\n        text[0][8:12].set_color(DARK_BLUE)\n\n        self.add(text, indices)", "code_sha1": "f79db49008e0d41d2bdbeb5c003deda9c694d76c"}
{"url": "https://docs.manim.community/en/stable/reference/manim.utils.docbuild.manim_directive.html", "depth": 1, "instruction": "The code defines a Manim scene named \"MyScene,\" which will be rendered as a video within Sphinx documentation, showcasing the scene's visual elements and animations as specified in the class definition.", "code": ".. manim:: MyScene\n\n    class MyScene(Scene):\n        def construct(self):", "code_sha1": "09df4b598cfa88a1f1fcce5c95b49e5b37628938"}
{"url": "https://docs.manim.community/en/stable/reference/manim.utils.docbuild.manim_directive.html", "depth": 1, "instruction": "A red dot is created and animated onto the scene with a smooth entrance effect, showcasing its vibrant color against a neutral background. The animation is timed to flow seamlessly, emphasizing the dot's appearance.", "code": ".. manim:: DirectiveDoctestExample\n    :ref_classes: Dot\nfrom manim import Create, Dot, RED, Scene\ndot = Dot(color=RED)\ndot.color\n    ManimColor('#FC6255')\nclass DirectiveDoctestExample(Scene):\n    def construct(self):\n        self.play(Create(dot))", "code_sha1": "35726c5da763f4450002af7e1772ee83621fcca0"}
{"url": "https://docs.manim.community/en/stable/reference/manim.utils.ipython_magic.ManimMagic.html", "depth": 1, "instruction": "The code sets up a Manim scene named \"MyAwesomeScene,\" ready for animation, but does not specify any visual elements or animations within the `construct` method. The scene will be rendered in a JupyterLab environment, allowing for dynamic video updates.", "code": "%%manim [CLI options] MyAwesomeScene\n\nclass MyAweseomeScene(Scene):\n    def construct(self):", "code_sha1": "5f33d73157dac393fd05f86fb60242aebd0fcddc"}
{"url": "https://docs.manim.community/en/stable/reference/manim.utils.ipython_magic.ManimMagic.html", "depth": 1, "instruction": "A light background scene featuring a scaled-down Manim banner animates into view, first appearing with a creation effect, followed by an expansion animation, all set against a soft beige backdrop. The banner is visually prominent, occupying a central position on the screen.", "code": "%%manim -v WARNING --disable_caching -qm BannerExample\n\nconfig.media_width = \"75%\"\nconfig.media_embed = True\n\nclass BannerExample(Scene):\n    def construct(self):\n        self.camera.background_color = \"#ece6e2\"\n        banner_large = ManimBanner(dark_theme=False).scale(0.7)\n        self.play(banner_large.create())\n        self.play(banner_large.expand())", "code_sha1": "80965d411ac0924dd25b80aa91f8704caf52f697"}
{"url": "https://docs.manim.community/en/stable/reference/manim.utils.paths.html", "depth": 1, "instruction": "Three colored dots (red, green, blue) start at positions left of the screen (up, down, left) and transform to positions right of the screen (center, up, down) along a clockwise half-circle path over 2 seconds, leaving traced paths behind. The scene pauses before and after the transformation.", "code": "from manim import *\n\nclass ClockwisePathExample(Scene):\n    def construct(self):\n        colors = [RED, GREEN, BLUE]\n\n        starting_points = VGroup(\n            *[\n                Dot(LEFT + pos, color=color)\n                for pos, color in zip([UP, DOWN, LEFT], colors)\n            ]\n        )\n\n        finish_points = VGroup(\n            *[\n                Dot(RIGHT + pos, color=color)\n                for pos, color in zip([ORIGIN, UP, DOWN], colors)\n            ]\n        )\n\n        self.add(starting_points)\n        self.add(finish_points)\n        for dot in starting_points:\n            self.add(TracedPath(dot.get_center, stroke_color=dot.get_color()))\n\n        self.wait()\n        self.play(\n            Transform(\n                starting_points,\n                finish_points,\n                path_func=utils.paths.clockwise_path(),\n                run_time=2,\n            )\n        )\n        self.wait()", "code_sha1": "ac3d489c388f24070b05a0cec9dc878dcb65cf14"}
{"url": "https://docs.manim.community/en/stable/reference/manim.utils.paths.html", "depth": 1, "instruction": "Three colored dots (red, green, blue) start from the left (UP, DOWN, LEFT) and transform to the right (ORIGIN, UP, DOWN) along a counterclockwise path over 2 seconds, leaving a trace of their movement. The scene pauses before and after the transformation.", "code": "from manim import *\n\nclass CounterclockwisePathExample(Scene):\n    def construct(self):\n        colors = [RED, GREEN, BLUE]\n\n        starting_points = VGroup(\n            *[\n                Dot(LEFT + pos, color=color)\n                for pos, color in zip([UP, DOWN, LEFT], colors)\n            ]\n        )\n\n        finish_points = VGroup(\n            *[\n                Dot(RIGHT + pos, color=color)\n                for pos, color in zip([ORIGIN, UP, DOWN], colors)\n            ]\n        )\n\n        self.add(starting_points)\n        self.add(finish_points)\n        for dot in starting_points:\n            self.add(TracedPath(dot.get_center, stroke_color=dot.get_color()))\n\n        self.wait()\n        self.play(\n            Transform(\n                starting_points,\n                finish_points,\n                path_func=utils.paths.counterclockwise_path(),\n                run_time=2,\n            )\n        )\n        self.wait()", "code_sha1": "8e4fc3747bf6cbde6ce491ced5878c9e45e41832"}
{"url": "https://docs.manim.community/en/stable/reference/manim.utils.paths.html", "depth": 1, "instruction": "Three colored dots (red, green, blue) start at positions LEFT + UP, LEFT + DOWN, and LEFT, then smoothly transform to RIGHT, UP, and DOWN, respectively, along a circular arc over 3 seconds, leaving a trace of their paths. The scene includes a brief pause before and after the animation.", "code": "from manim import *\n\nclass PathAlongArcExample(Scene):\n    def construct(self):\n        colors = [RED, GREEN, BLUE]\n\n        starting_points = VGroup(\n            *[\n                Dot(LEFT + pos, color=color)\n                for pos, color in zip([UP, DOWN, LEFT], colors)\n            ]\n        )\n\n        finish_points = VGroup(\n            *[\n                Dot(RIGHT + pos, color=color)\n                for pos, color in zip([ORIGIN, UP, DOWN], colors)\n            ]\n        )\n\n        self.add(starting_points)\n        self.add(finish_points)\n        for dot in starting_points:\n            self.add(TracedPath(dot.get_center, stroke_color=dot.get_color()))\n\n        self.wait()\n        self.play(\n            Transform(\n                starting_points,\n                finish_points,\n                path_func=utils.paths.path_along_arc(TAU * 2 / 3),\n                run_time=3,\n            )\n        )\n        self.wait()", "code_sha1": "829387c760509255f7506257fe6af29f227c9269"}
{"url": "https://docs.manim.community/en/stable/reference/manim.utils.paths.html", "depth": 1, "instruction": "Three colored dots (red, green, blue) start at specified positions on the left and transform to new positions on the right along a circular path over 3 seconds, while leaving a trace of their movement. A stationary dot is centered at 3 units left. The scene pauses before and after the animation.", "code": "from manim import *\n\nclass PathAlongCirclesExample(Scene):\n    def construct(self):\n        colors = [RED, GREEN, BLUE]\n\n        starting_points = VGroup(\n            *[\n                Dot(LEFT + pos, color=color)\n                for pos, color in zip([UP, DOWN, LEFT], colors)\n            ]\n        )\n\n        finish_points = VGroup(\n            *[\n                Dot(RIGHT + pos, color=color)\n                for pos, color in zip([ORIGIN, UP, DOWN], colors)\n            ]\n        )\n\n        self.add(starting_points)\n        self.add(finish_points)\n        for dot in starting_points:\n            self.add(TracedPath(dot.get_center, stroke_color=dot.get_color()))\n\n        circle_center = Dot(3 * LEFT)\n        self.add(circle_center)\n\n        self.wait()\n        self.play(\n            Transform(\n                starting_points,\n                finish_points,\n                path_func=utils.paths.path_along_circles(\n                    2 * PI, circle_center.get_center()\n                ),\n                run_time=3,\n            )\n        )\n        self.wait()", "code_sha1": "6392dbfc43a5d66fedbb1b0cd9123dc80c652df9"}
{"url": "https://docs.manim.community/en/stable/reference/manim.utils.paths.html", "depth": 1, "instruction": "Three colored dots (red, green, blue) start at positions LEFT + UP, LEFT + DOWN, and LEFT, then transform to RIGHT, UP, and DOWN, following a spiral path over 5 seconds, while their trails are traced. The scene pauses before and after the transformation.", "code": "from manim import *\n\nclass SpiralPathExample(Scene):\n    def construct(self):\n        colors = [RED, GREEN, BLUE]\n\n        starting_points = VGroup(\n            *[\n                Dot(LEFT + pos, color=color)\n                for pos, color in zip([UP, DOWN, LEFT], colors)\n            ]\n        )\n\n        finish_points = VGroup(\n            *[\n                Dot(RIGHT + pos, color=color)\n                for pos, color in zip([ORIGIN, UP, DOWN], colors)\n            ]\n        )\n\n        self.add(starting_points)\n        self.add(finish_points)\n        for dot in starting_points:\n            self.add(TracedPath(dot.get_center, stroke_color=dot.get_color()))\n\n        self.wait()\n        self.play(\n            Transform(\n                starting_points,\n                finish_points,\n                path_func=utils.paths.spiral_path(2 * TAU),\n                run_time=5,\n            )\n        )\n        self.wait()", "code_sha1": "4109c65c5064e9db090e192eb9bf1f1b8b101c28"}
{"url": "https://docs.manim.community/en/stable/reference/manim.utils.paths.html", "depth": 1, "instruction": "Three colored dots (red, green, blue) start at the left (UP, DOWN, LEFT) and transform to the right (ORIGIN, UP, DOWN) along straight paths, leaving behind traced paths. The transformation occurs over 2 seconds, with a brief pause before and after the animation.", "code": "from manim import *\n\nclass StraightPathExample(Scene):\n    def construct(self):\n        colors = [RED, GREEN, BLUE]\n\n        starting_points = VGroup(\n            *[\n                Dot(LEFT + pos, color=color)\n                for pos, color in zip([UP, DOWN, LEFT], colors)\n            ]\n        )\n\n        finish_points = VGroup(\n            *[\n                Dot(RIGHT + pos, color=color)\n                for pos, color in zip([ORIGIN, UP, DOWN], colors)\n            ]\n        )\n\n        self.add(starting_points)\n        self.add(finish_points)\n        for dot in starting_points:\n            self.add(TracedPath(dot.get_center, stroke_color=dot.get_color()))\n\n        self.wait()\n        self.play(\n            Transform(\n                starting_points,\n                finish_points,\n                path_func=utils.paths.straight_path(),\n                run_time=2,\n            )\n        )\n        self.wait()", "code_sha1": "6801701f1d401d835a95537d2acbc36fed64ef66"}
{"url": "https://docs.manim.community/en/stable/reference/manim.utils.paths.html", "depth": 1, "instruction": "Three colored dots (red, green, blue) start at positions left of the screen (up, down, left) and transform to positions right of the screen (center, up, down) along a clockwise path over 2 seconds, leaving traced paths behind them. The scene includes a brief pause before and after the transformation.", "code": "class ClockwisePathExample(Scene):\n    def construct(self):\n        colors = [RED, GREEN, BLUE]\n\n        starting_points = VGroup(\n            *[\n                Dot(LEFT + pos, color=color)\n                for pos, color in zip([UP, DOWN, LEFT], colors)\n            ]\n        )\n\n        finish_points = VGroup(\n            *[\n                Dot(RIGHT + pos, color=color)\n                for pos, color in zip([ORIGIN, UP, DOWN], colors)\n            ]\n        )\n\n        self.add(starting_points)\n        self.add(finish_points)\n        for dot in starting_points:\n            self.add(TracedPath(dot.get_center, stroke_color=dot.get_color()))\n\n        self.wait()\n        self.play(\n            Transform(\n                starting_points,\n                finish_points,\n                path_func=utils.paths.clockwise_path(),\n                run_time=2,\n            )\n        )\n        self.wait()", "code_sha1": "1dfd4af889455ac97e45af4eb78ebd7bdae1b682"}
{"url": "https://docs.manim.community/en/stable/reference/manim.utils.paths.html", "depth": 1, "instruction": "Three colored dots (red, green, blue) start at the left (UP, DOWN, LEFT) and transform to the right (ORIGIN, UP, DOWN) along a counterclockwise path over 2 seconds, leaving traced paths behind. The scene pauses before and after the transformation.", "code": "class CounterclockwisePathExample(Scene):\n    def construct(self):\n        colors = [RED, GREEN, BLUE]\n\n        starting_points = VGroup(\n            *[\n                Dot(LEFT + pos, color=color)\n                for pos, color in zip([UP, DOWN, LEFT], colors)\n            ]\n        )\n\n        finish_points = VGroup(\n            *[\n                Dot(RIGHT + pos, color=color)\n                for pos, color in zip([ORIGIN, UP, DOWN], colors)\n            ]\n        )\n\n        self.add(starting_points)\n        self.add(finish_points)\n        for dot in starting_points:\n            self.add(TracedPath(dot.get_center, stroke_color=dot.get_color()))\n\n        self.wait()\n        self.play(\n            Transform(\n                starting_points,\n                finish_points,\n                path_func=utils.paths.counterclockwise_path(),\n                run_time=2,\n            )\n        )\n        self.wait()", "code_sha1": "efb8f409ff81f8561796c310316c777f20da6ff4"}
{"url": "https://docs.manim.community/en/stable/reference/manim.utils.paths.html", "depth": 1, "instruction": "Three colored dots (red, green, blue) start at positions LEFT + UP, LEFT + DOWN, and LEFT, then smoothly transform to RIGHT + ORIGIN, RIGHT + UP, and RIGHT + DOWN over 3 seconds, tracing arcs. The scene includes a wait before and after the transformation, with paths traced behind the moving dots.", "code": "class PathAlongArcExample(Scene):\n    def construct(self):\n        colors = [RED, GREEN, BLUE]\n\n        starting_points = VGroup(\n            *[\n                Dot(LEFT + pos, color=color)\n                for pos, color in zip([UP, DOWN, LEFT], colors)\n            ]\n        )\n\n        finish_points = VGroup(\n            *[\n                Dot(RIGHT + pos, color=color)\n                for pos, color in zip([ORIGIN, UP, DOWN], colors)\n            ]\n        )\n\n        self.add(starting_points)\n        self.add(finish_points)\n        for dot in starting_points:\n            self.add(TracedPath(dot.get_center, stroke_color=dot.get_color()))\n\n        self.wait()\n        self.play(\n            Transform(\n                starting_points,\n                finish_points,\n                path_func=utils.paths.path_along_arc(TAU * 2 / 3),\n                run_time=3,\n            )\n        )\n        self.wait()", "code_sha1": "8e9c4e7992e16c84ba28b2643925bbc2968d947f"}
{"url": "https://docs.manim.community/en/stable/reference/manim.utils.paths.html", "depth": 1, "instruction": "Three colored dots (red, green, blue) start at positions LEFT + UP, LEFT + DOWN, and LEFT + LEFT, then transform to RIGHT + ORIGIN, RIGHT + UP, and RIGHT + DOWN over 3 seconds, following a circular path around a central dot at 3 * LEFT. Traced paths appear for each dot during the transformation.", "code": "class PathAlongCirclesExample(Scene):\n    def construct(self):\n        colors = [RED, GREEN, BLUE]\n\n        starting_points = VGroup(\n            *[\n                Dot(LEFT + pos, color=color)\n                for pos, color in zip([UP, DOWN, LEFT], colors)\n            ]\n        )\n\n        finish_points = VGroup(\n            *[\n                Dot(RIGHT + pos, color=color)\n                for pos, color in zip([ORIGIN, UP, DOWN], colors)\n            ]\n        )\n\n        self.add(starting_points)\n        self.add(finish_points)\n        for dot in starting_points:\n            self.add(TracedPath(dot.get_center, stroke_color=dot.get_color()))\n\n        circle_center = Dot(3 * LEFT)\n        self.add(circle_center)\n\n        self.wait()\n        self.play(\n            Transform(\n                starting_points,\n                finish_points,\n                path_func=utils.paths.path_along_circles(\n                    2 * PI, circle_center.get_center()\n                ),\n                run_time=3,\n            )\n        )\n        self.wait()", "code_sha1": "8235da6dcefa3703cbe16fb2c8a87aa775c20999"}
{"url": "https://docs.manim.community/en/stable/reference/manim.utils.paths.html", "depth": 1, "instruction": "Three colored dots (red, green, blue) start from positions LEFT + UP, LEFT + DOWN, and LEFT, respectively. They trace spiraling paths to RIGHT, ORIGIN + UP, and ORIGIN + DOWN over 5 seconds, while leaving a colored trace. The scene pauses before and after the transformation.", "code": "class SpiralPathExample(Scene):\n    def construct(self):\n        colors = [RED, GREEN, BLUE]\n\n        starting_points = VGroup(\n            *[\n                Dot(LEFT + pos, color=color)\n                for pos, color in zip([UP, DOWN, LEFT], colors)\n            ]\n        )\n\n        finish_points = VGroup(\n            *[\n                Dot(RIGHT + pos, color=color)\n                for pos, color in zip([ORIGIN, UP, DOWN], colors)\n            ]\n        )\n\n        self.add(starting_points)\n        self.add(finish_points)\n        for dot in starting_points:\n            self.add(TracedPath(dot.get_center, stroke_color=dot.get_color()))\n\n        self.wait()\n        self.play(\n            Transform(\n                starting_points,\n                finish_points,\n                path_func=utils.paths.spiral_path(2 * TAU),\n                run_time=5,\n            )\n        )\n        self.wait()", "code_sha1": "a46085b1d5d6a5ad987715b21fcbae5f8dfa8709"}
{"url": "https://docs.manim.community/en/stable/reference/manim.utils.paths.html", "depth": 1, "instruction": "Three colored dots (red, green, blue) start at the left (UP, DOWN, LEFT) and transform to the right (ORIGIN, UP, DOWN) over 2 seconds, leaving a traced path behind each. The scene includes a brief pause before and after the transformation.", "code": "class StraightPathExample(Scene):\n    def construct(self):\n        colors = [RED, GREEN, BLUE]\n\n        starting_points = VGroup(\n            *[\n                Dot(LEFT + pos, color=color)\n                for pos, color in zip([UP, DOWN, LEFT], colors)\n            ]\n        )\n\n        finish_points = VGroup(\n            *[\n                Dot(RIGHT + pos, color=color)\n                for pos, color in zip([ORIGIN, UP, DOWN], colors)\n            ]\n        )\n\n        self.add(starting_points)\n        self.add(finish_points)\n        for dot in starting_points:\n            self.add(TracedPath(dot.get_center, stroke_color=dot.get_color()))\n\n        self.wait()\n        self.play(\n            Transform(\n                starting_points,\n                finish_points,\n                path_func=utils.paths.straight_path(),\n                run_time=2,\n            )\n        )\n        self.wait()", "code_sha1": "35f517754f569997bc3d747d24038cf33a44ff51"}
{"url": "https://docs.manim.community/en/stable/reference/manim.utils.rate_functions.html", "depth": 1, "instruction": "The scene displays a grid of 8 parametric function plots, each representing different easing functions in yellow, surrounded by white rectangles. Each plot is labeled with its function name in bold, scaled text above. The entire grid is centered and scaled to fit within the frame, creating a visually organized layout of easing functions.", "code": "from manim import *\n\nclass RateFuncExample(Scene):\n    def construct(self):\n        x = VGroup()\n        for k, v in rate_functions.__dict__.items():\n            if \"function\" in str(v):\n                if (\n                    not k.startswith(\"__\")\n                    and not k.startswith(\"sqrt\")\n                    and not k.startswith(\"bezier\")\n                ):\n                    try:\n                        rate_func = v\n                        plot = (\n                            ParametricFunction(\n                                lambda x: [x, rate_func(x), 0],\n                                t_range=[0, 1, .01],\n                                use_smoothing=False,\n                                color=YELLOW,\n                            )\n                            .stretch_to_fit_width(1.5)\n                            .stretch_to_fit_height(1)\n                        )\n                        plot_bg = SurroundingRectangle(plot).set_color(WHITE)\n                        plot_title = (\n                            Text(rate_func.__name__, weight=BOLD)\n                            .scale(0.5)\n                            .next_to(plot_bg, UP, buff=0.1)\n                        )\n                        x.add(VGroup(plot_bg, plot, plot_title))\n                    except: # because functions `not_quite_there`, `function squish_rate_func` are not working.\n                        pass\n        x.arrange_in_grid(cols=8)\n        x.height = config.frame_height\n        x.width = config.frame_width\n        x.move_to(ORIGIN).scale(0.95)\n        self.add(x)", "code_sha1": "7c7466c5a836f6bd638db191b030d3cf6302cb59"}
{"url": "https://docs.manim.community/en/stable/reference/manim.utils.rate_functions.html", "depth": 1, "instruction": "Three horizontal lines (red, green, blue) appear with corresponding dots and labels (\"Ease In,\" \"Ease Out,\" \"Ease In Out\"). Dots move along their respective lines over 7 seconds, with smooth animations: the first dot eases in, the second eases out, and the third eases in and out. The scene concludes with a brief pause.", "code": "from manim import *\n\nclass RateFunctions1Example(Scene):\n    def construct(self):\n        line1 = Line(3*LEFT, 3*RIGHT).shift(UP).set_color(RED)\n        line2 = Line(3*LEFT, 3*RIGHT).set_color(GREEN)\n        line3 = Line(3*LEFT, 3*RIGHT).shift(DOWN).set_color(BLUE)\n\n        dot1 = Dot().move_to(line1.get_left())\n        dot2 = Dot().move_to(line2.get_left())\n        dot3 = Dot().move_to(line3.get_left())\n\n        label1 = Tex(\"Ease In\").next_to(line1, RIGHT)\n        label2 = Tex(\"Ease out\").next_to(line2, RIGHT)\n        label3 = Tex(\"Ease In Out\").next_to(line3, RIGHT)\n\n        self.play(\n            FadeIn(VGroup(line1, line2, line3)),\n            FadeIn(VGroup(dot1, dot2, dot3)),\n            Write(VGroup(label1, label2, label3)),\n        )\n        self.play(\n            MoveAlongPath(dot1, line1, rate_func=rate_functions.ease_in_sine),\n            MoveAlongPath(dot2, line2, rate_func=rate_functions.ease_out_sine),\n            MoveAlongPath(dot3, line3, rate_func=rate_functions.ease_in_out_sine),\n            run_time=7\n        )\n        self.wait()", "code_sha1": "e20ab4a5ac4ebc286aabc617c835dff09813d1db"}
{"url": "https://docs.manim.community/en/stable/reference/manim.utils.rate_functions.html", "depth": 1, "instruction": "A grid of 8 columns displays various easing function plots, each with a yellow curve, surrounded by a white rectangle. Above each plot, a bold, scaled-down title indicates the function name. The entire arrangement is centered and slightly scaled down to fit within the scene's frame.", "code": "class RateFuncExample(Scene):\n    def construct(self):\n        x = VGroup()\n        for k, v in rate_functions.__dict__.items():\n            if \"function\" in str(v):\n                if (\n                    not k.startswith(\"__\")\n                    and not k.startswith(\"sqrt\")\n                    and not k.startswith(\"bezier\")\n                ):\n                    try:\n                        rate_func = v\n                        plot = (\n                            ParametricFunction(\n                                lambda x: [x, rate_func(x), 0],\n                                t_range=[0, 1, .01],\n                                use_smoothing=False,\n                                color=YELLOW,\n                            )\n                            .stretch_to_fit_width(1.5)\n                            .stretch_to_fit_height(1)\n                        )\n                        plot_bg = SurroundingRectangle(plot).set_color(WHITE)\n                        plot_title = (\n                            Text(rate_func.__name__, weight=BOLD)\n                            .scale(0.5)\n                            .next_to(plot_bg, UP, buff=0.1)\n                        )\n                        x.add(VGroup(plot_bg, plot, plot_title))\n                    except: # because functions `not_quite_there`, `function squish_rate_func` are not working.\n                        pass\n        x.arrange_in_grid(cols=8)\n        x.height = config.frame_height\n        x.width = config.frame_width\n        x.move_to(ORIGIN).scale(0.95)\n        self.add(x)", "code_sha1": "745f1d09b026c0ad0eaf7f3c759e3be4c2b27ac2"}
{"url": "https://docs.manim.community/en/stable/reference/manim.utils.rate_functions.html", "depth": 1, "instruction": "Three horizontal lines in red, green, and blue are displayed with corresponding dots at their left ends. Labels \"Ease In,\" \"Ease Out,\" and \"Ease In Out\" appear next to each line. Dots move along their respective lines over 7 seconds, with smooth animations: dot1 eases in, dot2 eases out, and dot3 eases in and out.", "code": "class RateFunctions1Example(Scene):\n    def construct(self):\n        line1 = Line(3*LEFT, 3*RIGHT).shift(UP).set_color(RED)\n        line2 = Line(3*LEFT, 3*RIGHT).set_color(GREEN)\n        line3 = Line(3*LEFT, 3*RIGHT).shift(DOWN).set_color(BLUE)\n\n        dot1 = Dot().move_to(line1.get_left())\n        dot2 = Dot().move_to(line2.get_left())\n        dot3 = Dot().move_to(line3.get_left())\n\n        label1 = Tex(\"Ease In\").next_to(line1, RIGHT)\n        label2 = Tex(\"Ease out\").next_to(line2, RIGHT)\n        label3 = Tex(\"Ease In Out\").next_to(line3, RIGHT)\n\n        self.play(\n            FadeIn(VGroup(line1, line2, line3)),\n            FadeIn(VGroup(dot1, dot2, dot3)),\n            Write(VGroup(label1, label2, label3)),\n        )\n        self.play(\n            MoveAlongPath(dot1, line1, rate_func=rate_functions.ease_in_sine),\n            MoveAlongPath(dot2, line2, rate_func=rate_functions.ease_out_sine),\n            MoveAlongPath(dot3, line3, rate_func=rate_functions.ease_in_out_sine),\n            run_time=7\n        )\n        self.wait()", "code_sha1": "ff6fbbfba4eb67968b68508bbb9ad8ae1bb963ad"}
{"url": "https://docs.manim.community/en/stable/reference/manim.utils.space_ops.html", "depth": 1, "instruction": "A square is displayed, initially at the origin, then shifted 2 units up. The winding number is calculated twice: first returning 1.0, then 0.0 after the shift, indicating the square's position relative to the origin.", "code": "from manim import Square, get_winding_number\npolygon = Square()\nget_winding_number(polygon.get_vertices())\nnp.float64(1.0)\npolygon.shift(2 * UP)\nSquare\nget_winding_number(polygon.get_vertices())\nnp.float64(0.0)", "code_sha1": "c9e052373f167cffbac06b2e82945c48da86eee9"}
{"url": "https://docs.manim.community/en/stable/contributing/docs/examples.html", "depth": 1, "instruction": "A MathTex formula displaying the integral equation \\(\\int_a^b f'(x) dx = f(b) - f(a)\\) appears centered on the screen, with a duration of 1 second before the scene ends.", "code": "Formulas\n========\n\n.. manim:: Formula1\n    :save_last_frame:\n\n    class Formula1(Scene):\n        def construct(self):\n            t = MathTex(r\"\\int_a^b f'(x) dx = f(b) - f(a)\")\n            self.add(t)\n            self.wait(1)", "code_sha1": "b575db51b2bd6b85da509f91a21bace5b0bf3318"}
{"url": "https://docs.manim.community/en/stable/contributing/testing.html", "depth": 1, "instruction": "A circle is animated with a smooth entrance into the scene, appearing in the center with a default size and color. The animation is captured for comparison, ensuring the visual output matches expected frames.", "code": "from manim import *\nfrom manim.utils.testing.frames_comparison import frames_comparison\n\n__module_test__ = \"geometry\"\n\n\n@frames_comparison\ndef test_circle(scene):\n    circle = Circle()\n    scene.play(Animation(circle))", "code_sha1": "a8f2365c65ca6cf15f02c06709d96f0ae3b23690"}
{"url": "https://docs.manim.community/en/stable/contributing/testing.html", "depth": 1, "instruction": "A circle is animated into view, with its default properties, as the scene captures multiple frames for comparison, ensuring the animation's smoothness and correctness across frames.", "code": "@frames_comparison(last_frame=False)\ndef test_circle(scene):\n    circle = Circle()\n    scene.play(Animation(circle))", "code_sha1": "dd67e6bc90e86b5d242e88b9f4a42b5c7bf84ab6"}
{"url": "https://docs.manim.community/en/stable/contributing/testing.html", "depth": 1, "instruction": "A circle is animated into view within a 3D scene, showcasing its smooth appearance. The animation occurs over a brief duration, with the circle's default color and size, centered in the frame. The test captures multiple frames for comparison, ensuring visual consistency across animations.", "code": "@frames_comparison(last_frame=False, base_scene=ThreeDScene)\ndef test_circle(scene):\n    circle = Circle()\n    scene.play(Animation(circle))", "code_sha1": "a988344f7d9b6e71de40c1a19c7e4eda0335f7bc"}
{"url": "https://docs.manim.community/en/stable/contributing/performance.html", "depth": 1, "instruction": "A square transforms into a circle on a plain background, with the square initially displayed in blue and the circle in green. The transformation is smooth and takes place over a medium duration, showcasing the animation's fluidity. The camera remains static throughout the scene.", "code": "from manim import *\n\n\nclass SquareToCircle(Scene):\n    def construct(self):\n        s = Square()\n        c = Circle()\n        self.add(s)\n        self.play(Transform(s, c))\n\n\nwith tempconfig({\"quality\": \"medium_quality\", \"disable_caching\": True}):\n    scene = SquareToCircle()\n    scene.render()", "code_sha1": "32818ecb02d44829e7647d37d40352d674aa4389"}
{"url": "https://docs.manim.community/en/stable/_modules/manim/animation/animation.html", "depth": 2, "instruction": "The code defines an `Animation` class in Manim, allowing for the creation and management of animations for mobjects. It includes properties like `run_time`, `lag_ratio`, and `rate_func`, enabling customizable animations. The `Add` subclass facilitates adding mobjects to scenes with optional timing, while `Wait` provides a pause in animations.", "code": "\"\"\"Animate mobjects.\"\"\"\n\nfrom __future__ import annotations\n\nfrom manim.mobject.opengl.opengl_mobject import OpenGLMobject\n\nfrom .. import config, logger\nfrom ..constants import RendererType\nfrom ..mobject import mobject\nfrom ..mobject.mobject import Group, Mobject\nfrom ..mobject.opengl import opengl_mobject\nfrom ..utils.rate_functions import linear, smooth\n\n__all__ = [\"Animation\", \"Wait\", \"Add\", \"override_animation\"]\n\n\nfrom collections.abc import Iterable, Sequence\nfrom copy import deepcopy\nfrom functools import partialmethod\nfrom typing import TYPE_CHECKING, Any, Callable\n\nfrom typing_extensions import Self\n\nif TYPE_CHECKING:\n    from manim.scene.scene import Scene\n\n\nDEFAULT_ANIMATION_RUN_TIME: float = 1.0\nDEFAULT_ANIMATION_LAG_RATIO: float = 0.0\n\n\n\n[docs]\nclass Animation:\n    \"\"\"An animation.\n\n    Animations have a fixed time span.\n\n    Parameters\n    ----------\n    mobject\n        The mobject to be animated. This is not required for all types of animations.\n    lag_ratio\n        Defines the delay after which the animation is applied to submobjects. This lag\n        is relative to the duration of the animation.\n\n        This does not influence the total\n        runtime of the animation. Instead the runtime of individual animations is\n        adjusted so that the complete animation has the defined run time.\n\n    run_time\n        The duration of the animation in seconds.\n    rate_func\n        The function defining the animation progress based on the relative runtime (see  :mod:`~.rate_functions`) .\n\n        For example ``rate_func(0.5)`` is the proportion of the animation that is done\n        after half of the animations run time.\n\n\n    reverse_rate_function\n        Reverses the rate function of the animation. Setting ``reverse_rate_function``\n        does not have any effect on ``remover`` or ``introducer``. These need to be\n        set explicitly if an introducer-animation should be turned into a remover one\n        and vice versa.\n    name\n        The name of the animation. This gets displayed while rendering the animation.\n        Defaults to <class-name>(<Mobject-name>).\n    remover\n        Whether the given mobject should be removed from the scene after this animation.\n    suspend_mobject_updating\n        Whether updaters of the mobject should be suspended during the animation.\n\n\n    .. NOTE::\n\n        In the current implementation of this class, the specified rate function is applied\n        within :meth:`.Animation.interpolate_mobject` call as part of the call to\n        :meth:`.Animation.interpolate_submobject`. For subclasses of :class:`.Animation`\n        that are implemented by overriding :meth:`interpolate_mobject`, the rate function\n        has to be applied manually (e.g., by passing ``self.rate_func(alpha)`` instead\n        of just ``alpha``).\n\n\n    Examples\n    --------\n\n    .. manim:: LagRatios\n\n        class LagRatios(Scene):\n            def construct(self):\n                ratios = [0, 0.1, 0.5, 1, 2]  # demonstrated lag_ratios\n\n                # Create dot groups\n                group = VGroup(*[Dot() for _ in range(4)]).arrange_submobjects()\n                groups = VGroup(*[group.copy() for _ in ratios]).arrange_submobjects(buff=1)\n                self.add(groups)\n\n                # Label groups\n                self.add(Text(\"lag_ratio = \", font_size=36).next_to(groups, UP, buff=1.5))\n                for group, ratio in zip(groups, ratios):\n                    self.add(Text(str(ratio), font_size=36).next_to(group, UP))\n\n                #Animate groups with different lag_ratios\n                self.play(AnimationGroup(*[\n                    group.animate(lag_ratio=ratio, run_time=1.5).shift(DOWN * 2)\n                    for group, ratio in zip(groups, ratios)\n                ]))\n\n                # lag_ratio also works recursively on nested submobjects:\n                self.play(groups.animate(run_time=1, lag_ratio=0.1).shift(UP * 2))\n\n    \"\"\"\n\n    def __new__(\n        cls,\n        mobject=None,\n        *args,\n        use_override=True,\n        **kwargs,\n    ) -> Self:\n        if isinstance(mobject, Mobject) and use_override:\n            func = mobject.animation_override_for(cls)\n            if func is not None:\n                anim = func(mobject, *args, **kwargs)\n                logger.debug(\n                    f\"The {cls.__name__} animation has been is overridden for \"\n                    f\"{type(mobject).__name__} mobjects. use_override = False can \"\n                    f\" be used as keyword argument to prevent animation overriding.\",\n                )\n                return anim\n        return super().__new__(cls)\n\n    def __init__(\n        self,\n        mobject: Mobject | None,\n        lag_ratio: float = DEFAULT_ANIMATION_LAG_RATIO,\n        run_time: float = DEFAULT_ANIMATION_RUN_TIME,\n        rate_func: Callable[[float], float] = smooth,\n        reverse_rate_function: bool = False,\n        name: str = None,\n        remover: bool = False,  # remove a mobject from the screen?\n        suspend_mobject_updating: bool = True,\n        introducer: bool = False,\n        *,\n        _on_finish: Callable[[], None] = lambda _: None,\n        **kwargs,\n    ) -> None:\n        self._typecheck_input(mobject)\n        self.run_time: float = run_time\n        self.rate_func: Callable[[float], float] = rate_func\n        self.reverse_rate_function: bool = reverse_rate_function\n        self.name: str | None = name\n        self.remover: bool = remover\n        self.introducer: bool = introducer\n        self.suspend_mobject_updating: bool = suspend_mobject_updating\n        self.lag_ratio: float = lag_ratio\n        self._on_finish: Callable[[Scene], None] = _on_finish\n        if config[\"renderer\"] == RendererType.OPENGL:\n            self.starting_mobject: OpenGLMobject = OpenGLMobject()\n            self.mobject: OpenGLMobject = (\n                mobject if mobject is not None else OpenGLMobject()\n            )\n        else:\n            self.starting_mobject: Mobject = Mobject()\n            self.mobject: Mobject = mobject if mobject is not None else Mobject()\n        if kwargs:\n            logger.debug(\"Animation received extra kwargs: %s\", kwargs)\n\n        if hasattr(self, \"CONFIG\"):\n            logger.error(\n                (\n                    \"CONFIG has been removed from ManimCommunity.\",\n                    \"Please use keyword arguments instead.\",\n                ),\n            )\n\n    @property\n    def run_time(self) -> float:\n        return self._run_time\n\n    @run_time.setter\n    def run_time(self, value: float) -> None:\n        if value < 0:\n            raise ValueError(\n                f\"The run_time of {self.__class__.__name__} cannot be \"\n                f\"negative. The given value was {value}.\"\n            )\n        self._run_time = value\n\n    def _typecheck_input(self, mobject: Mobject | None) -> None:\n        if mobject is None:\n            logger.debug(\"Animation with empty mobject\")\n        elif not isinstance(mobject, (Mobject, OpenGLMobject)):\n            raise TypeError(\"Animation only works on Mobjects\")\n\n    def __str__(self) -> str:\n        if self.name:\n            return self.name\n        return f\"{self.__class__.__name__}({str(self.mobject)})\"\n\n    def __repr__(self) -> str:\n        return str(self)\n\n\n[docs]\n    def begin(self) -> None:\n        \"\"\"Begin the animation.\n\n        This method is called right as an animation is being played. As much\n        initialization as possible, especially any mobject copying, should live in this\n        method.\n\n        \"\"\"\n        self.starting_mobject = self.create_starting_mobject()\n        if self.suspend_mobject_updating:\n            # All calls to self.mobject's internal updaters\n            # during the animation, either from this Animation\n            # or from the surrounding scene, should do nothing.\n            # It is, however, okay and desirable to call\n            # the internal updaters of self.starting_mobject,\n            # or any others among self.get_all_mobjects()\n            self.mobject.suspend_updating()\n        self.interpolate(0)\n\n\n\n[docs]\n    def finish(self) -> None:\n        # TODO: begin and finish should require a scene as parameter.\n        # That way Animation.clean_up_from_screen and Scene.add_mobjects_from_animations\n        # could be removed as they fulfill basically the same purpose.\n        \"\"\"Finish the animation.\n\n        This method gets called when the animation is over.\n\n        \"\"\"\n        self.interpolate(1)\n        if self.suspend_mobject_updating and self.mobject is not None:\n            self.mobject.resume_updating()\n\n\n\n[docs]\n    def clean_up_from_scene(self, scene: Scene) -> None:\n        \"\"\"Clean up the :class:`~.Scene` after finishing the animation.\n\n        This includes to :meth:`~.Scene.remove` the Animation's\n        :class:`~.Mobject` if the animation is a remover.\n\n        Parameters\n        ----------\n        scene\n            The scene the animation should be cleaned up from.\n        \"\"\"\n        self._on_finish(scene)\n        if self.is_remover():\n            scene.remove(self.mobject)\n\n\n\n[docs]\n    def _setup_scene(self, scene: Scene) -> None:\n        \"\"\"Setup up the :class:`~.Scene` before starting the animation.\n\n        This includes to :meth:`~.Scene.add` the Animation's\n        :class:`~.Mobject` if the animation is an introducer.\n\n        Parameters\n        ----------\n        scene\n            The scene the animation should be cleaned up from.\n        \"\"\"\n        if scene is None:\n            return\n        if (\n            self.is_introducer()\n            and self.mobject not in scene.get_mobject_family_members()\n        ):\n            scene.add(self.mobject)\n\n\n    def create_starting_mobject(self) -> Mobject:\n        # Keep track of where the mobject starts\n        return self.mobject.copy()\n\n\n[docs]\n    def get_all_mobjects(self) -> Sequence[Mobject]:\n        \"\"\"Get all mobjects involved in the animation.\n\n        Ordering must match the ordering of arguments to interpolate_submobject\n\n        Returns\n        -------\n        Sequence[Mobject]\n            The sequence of mobjects.\n        \"\"\"\n        return self.mobject, self.starting_mobject\n\n\n    def get_all_families_zipped(self) -> Iterable[tuple]:\n        if config[\"renderer\"] == RendererType.OPENGL:\n            return zip(*(mob.get_family() for mob in self.get_all_mobjects()))\n        return zip(\n            *(mob.family_members_with_points() for mob in self.get_all_mobjects())\n        )\n\n\n[docs]\n    def update_mobjects(self, dt: float) -> None:\n        \"\"\"\n        Updates things like starting_mobject, and (for\n        Transforms) target_mobject.  Note, since typically\n        (always?) self.mobject will have its updating\n        suspended during the animation, this will do\n        nothing to self.mobject.\n        \"\"\"\n        for mob in self.get_all_mobjects_to_update():\n            mob.update(dt)\n\n\n\n[docs]\n    def get_all_mobjects_to_update(self) -> list[Mobject]:\n        \"\"\"Get all mobjects to be updated during the animation.\n\n        Returns\n        -------\n        List[Mobject]\n            The list of mobjects to be updated during the animation.\n        \"\"\"\n        # The surrounding scene typically handles\n        # updating of self.mobject.  Besides, in\n        # most cases its updating is suspended anyway\n        return list(filter(lambda m: m is not self.mobject, self.get_all_mobjects()))\n\n\n\n[docs]\n    def copy(self) -> Animation:\n        \"\"\"Create a copy of the animation.\n\n        Returns\n        -------\n        Animation\n            A copy of ``self``\n        \"\"\"\n        return deepcopy(self)\n\n\n    # Methods for interpolation, the mean of an Animation\n\n    # TODO: stop using alpha as parameter name in different meanings.\n\n[docs]\n    def interpolate(self, alpha: float) -> None:\n        \"\"\"Set the animation progress.\n\n        This method gets called for every frame during an animation.\n\n        Parameters\n        ----------\n        alpha\n            The relative time to set the animation to, 0 meaning the start, 1 meaning\n            the end.\n        \"\"\"\n        self.interpolate_mobject(alpha)\n\n\n\n[docs]\n    def interpolate_mobject(self, alpha: float) -> None:\n        \"\"\"Interpolates the mobject of the :class:`Animation` based on alpha value.\n\n        Parameters\n        ----------\n        alpha\n            A float between 0 and 1 expressing the ratio to which the animation\n            is completed. For example, alpha-values of 0, 0.5, and 1 correspond\n            to the animation being completed 0%, 50%, and 100%, respectively.\n        \"\"\"\n        families = list(self.get_all_families_zipped())\n        for i, mobs in enumerate(families):\n            sub_alpha = self.get_sub_alpha(alpha, i, len(families))\n            self.interpolate_submobject(*mobs, sub_alpha)\n\n\n    def interpolate_submobject(\n        self,\n        submobject: Mobject,\n        starting_submobject: Mobject,\n        # target_copy: Mobject, #Todo: fix - signature of interpolate_submobject differs in Transform().\n        alpha: float,\n    ) -> Animation:\n        # Typically implemented by subclass\n        pass\n\n\n[docs]\n    def get_sub_alpha(self, alpha: float, index: int, num_submobjects: int) -> float:\n        \"\"\"Get the animation progress of any submobjects subanimation.\n\n        Parameters\n        ----------\n        alpha\n            The overall animation progress\n        index\n            The index of the subanimation.\n        num_submobjects\n            The total count of subanimations.\n\n        Returns\n        -------\n        float\n            The progress of the subanimation.\n        \"\"\"\n        # TODO, make this more understandable, and/or combine\n        # its functionality with AnimationGroup's method\n        # build_animations_with_timings\n        lag_ratio = self.lag_ratio\n        full_length = (num_submobjects - 1) * lag_ratio + 1\n        value = alpha * full_length\n        lower = index * lag_ratio\n        if self.reverse_rate_function:\n            return self.rate_func(1 - (value - lower))\n        else:\n            return self.rate_func(value - lower)\n\n\n    # Getters and setters\n\n[docs]\n    def set_run_time(self, run_time: float) -> Animation:\n        \"\"\"Set the run time of the animation.\n\n        Parameters\n        ----------\n        run_time\n            The new time the animation should take in seconds.\n\n        .. note::\n\n            The run_time of an animation should not be changed while it is already\n            running.\n\n        Returns\n        -------\n        Animation\n            ``self``\n        \"\"\"\n        self.run_time = run_time\n        return self\n\n\n    # TODO: is this getter even necessary?\n\n[docs]\n    def get_run_time(self) -> float:\n        \"\"\"Get the run time of the animation.\n\n        Returns\n        -------\n        float\n            The time the animation takes in seconds.\n        \"\"\"\n        return self.run_time\n\n\n\n[docs]\n    def set_rate_func(\n        self,\n        rate_func: Callable[[float], float],\n    ) -> Animation:\n        \"\"\"Set the rate function of the animation.\n\n        Parameters\n        ----------\n        rate_func\n            The new function defining the animation progress based on the\n            relative runtime (see :mod:`~.rate_functions`).\n\n        Returns\n        -------\n        Animation\n            ``self``\n        \"\"\"\n        self.rate_func = rate_func\n        return self\n\n\n\n[docs]\n    def get_rate_func(\n        self,\n    ) -> Callable[[float], float]:\n        \"\"\"Get the rate function of the animation.\n\n        Returns\n        -------\n        Callable[[float], float]\n            The rate function of the animation.\n        \"\"\"\n        return self.rate_func\n\n\n\n[docs]\n    def set_name(self, name: str) -> Animation:\n        \"\"\"Set the name of the animation.\n\n        Parameters\n        ----------\n        name\n            The new name of the animation.\n\n        Returns\n        -------\n        Animation\n            ``self``\n        \"\"\"\n        self.name = name\n        return self\n\n\n\n[docs]\n    def is_remover(self) -> bool:\n        \"\"\"Test if the animation is a remover.\n\n        Returns\n        -------\n        bool\n            ``True`` if the animation is a remover, ``False`` otherwise.\n        \"\"\"\n        return self.remover\n\n\n\n[docs]\n    def is_introducer(self) -> bool:\n        \"\"\"Test if the animation is an introducer.\n\n        Returns\n        -------\n        bool\n            ``True`` if the animation is an introducer, ``False`` otherwise.\n        \"\"\"\n        return self.introducer\n\n\n    @classmethod\n    def __init_subclass__(cls, **kwargs) -> None:\n        super().__init_subclass__(**kwargs)\n\n        cls._original__init__ = cls.__init__\n\n\n[docs]\n    @classmethod\n    def set_default(cls, **kwargs) -> None:\n        \"\"\"Sets the default values of keyword arguments.\n\n        If this method is called without any additional keyword\n        arguments, the original default values of the initialization\n        method of this class are restored.\n\n        Parameters\n        ----------\n\n        kwargs\n            Passing any keyword argument will update the default\n            values of the keyword arguments of the initialization\n            function of this class.\n\n        Examples\n        --------\n\n        .. manim:: ChangeDefaultAnimation\n\n            class ChangeDefaultAnimation(Scene):\n                def construct(self):\n                    Rotate.set_default(run_time=2, rate_func=rate_functions.linear)\n                    Indicate.set_default(color=None)\n\n                    S = Square(color=BLUE, fill_color=BLUE, fill_opacity=0.25)\n                    self.add(S)\n                    self.play(Rotate(S, PI))\n                    self.play(Indicate(S))\n\n                    Rotate.set_default()\n                    Indicate.set_default()\n\n        \"\"\"\n        if kwargs:\n            cls.__init__ = partialmethod(cls.__init__, **kwargs)\n        else:\n            cls.__init__ = cls._original__init__\n\n\n\n\n\n[docs]\ndef prepare_animation(\n    anim: Animation | mobject._AnimationBuilder,\n) -> Animation:\n    r\"\"\"Returns either an unchanged animation, or the animation built\n    from a passed animation factory.\n\n    Examples\n    --------\n\n    ::\nfrom manim import Square, FadeIn\ns = Square()\nprepare_animation(FadeIn(s))\n        FadeIn(Square)\n\n    ::\nprepare_animation(s.animate.scale(2).rotate(42))\n        _MethodAnimation(Square)\n\n    ::\nprepare_animation(42)\n        Traceback (most recent call last):\n\n        TypeError: Object 42 cannot be converted to an animation\n\n    \"\"\"\n    if isinstance(anim, mobject._AnimationBuilder):\n        return anim.build()\n\n    if isinstance(anim, opengl_mobject._AnimationBuilder):\n        return anim.build()\n\n    if isinstance(anim, Animation):\n        return anim\n\n    raise TypeError(f\"Object {anim} cannot be converted to an animation\")\n\n\n\n\n[docs]\nclass Wait(Animation):\n    \"\"\"A \"no operation\" animation.\n\n    Parameters\n    ----------\n    run_time\n        The amount of time that should pass.\n    stop_condition\n        A function without positional arguments that evaluates to a boolean.\n        The function is evaluated after every new frame has been rendered.\n        Playing the animation stops after the return value is truthy, or\n        after the specified ``run_time`` has passed.\n    frozen_frame\n        Controls whether or not the wait animation is static, i.e., corresponds\n        to a frozen frame. If ``False`` is passed, the render loop still\n        progresses through the animation as usual and (among other things)\n        continues to call updater functions. If ``None`` (the default value),\n        the :meth:`.Scene.play` call tries to determine whether the Wait call\n        can be static or not itself via :meth:`.Scene.should_mobjects_update`.\n    kwargs\n        Keyword arguments to be passed to the parent class, :class:`.Animation`.\n    \"\"\"\n\n    def __init__(\n        self,\n        run_time: float = 1,\n        stop_condition: Callable[[], bool] | None = None,\n        frozen_frame: bool | None = None,\n        rate_func: Callable[[float], float] = linear,\n        **kwargs,\n    ):\n        if stop_condition and frozen_frame:\n            raise ValueError(\"A static Wait animation cannot have a stop condition.\")\n\n        self.duration: float = run_time\n        self.stop_condition = stop_condition\n        self.is_static_wait: bool = frozen_frame\n        super().__init__(None, run_time=run_time, rate_func=rate_func, **kwargs)\n        # quick fix to work in opengl setting:\n        self.mobject.shader_wrapper_list = []\n\n\n[docs]\n    def begin(self) -> None:\n        pass\n\n\n\n[docs]\n    def finish(self) -> None:\n        pass\n\n\n\n[docs]\n    def clean_up_from_scene(self, scene: Scene) -> None:\n        pass\n\n\n\n[docs]\n    def update_mobjects(self, dt: float) -> None:\n        pass\n\n\n\n[docs]\n    def interpolate(self, alpha: float) -> None:\n        pass\n\n\n\n\n\n[docs]\nclass Add(Animation):\n    \"\"\"Add Mobjects to a scene, without animating them in any other way. This\n    is similar to the :meth:`.Scene.add` method, but :class:`Add` is an\n    animation which can be grouped into other animations.\n\n    Parameters\n    ----------\n    mobjects\n        One :class:`~.Mobject` or more to add to a scene.\n    run_time\n        The duration of the animation after adding the ``mobjects``. Defaults\n        to 0, which means this is an instant animation without extra wait time\n        after adding them.\n    **kwargs\n        Additional arguments to pass to the parent :class:`Animation` class.\n\n    Examples\n    --------\n\n    .. manim:: DefaultAddScene\n\n        class DefaultAddScene(Scene):\n            def construct(self):\n                text_1 = Text(\"I was added with Add!\")\n                text_2 = Text(\"Me too!\")\n                text_3 = Text(\"And me!\")\n                texts = VGroup(text_1, text_2, text_3).arrange(DOWN)\n                rect = SurroundingRectangle(texts, buff=0.5)\n\n                self.play(\n                    Create(rect, run_time=3.0),\n                    Succession(\n                        Wait(1.0),\n                        # You can Add a Mobject in the middle of an animation...\n                        Add(text_1),\n                        Wait(1.0),\n                        # ...or multiple Mobjects at once!\n                        Add(text_2, text_3),\n                    ),\n                )\n                self.wait()\n\n    .. manim:: AddWithRunTimeScene\n\n        class AddWithRunTimeScene(Scene):\n            def construct(self):\n                # A 5x5 grid of circles\n                circles = VGroup(\n                    *[Circle(radius=0.5) for _ in range(25)]\n                ).arrange_in_grid(5, 5)\n\n                self.play(\n                    Succession(\n                        # Add a run_time of 0.2 to wait for 0.2 seconds after\n                        # adding the circle, instead of using Wait(0.2) after Add!\n                        *[Add(circle, run_time=0.2) for circle in circles],\n                        rate_func=smooth,\n                    )\n                )\n                self.wait()\n    \"\"\"\n\n    def __init__(\n        self, *mobjects: Mobject, run_time: float = 0.0, **kwargs: Any\n    ) -> None:\n        mobject = mobjects[0] if len(mobjects) == 1 else Group(*mobjects)\n        super().__init__(mobject, run_time=run_time, introducer=True, **kwargs)\n\n\n[docs]\n    def begin(self) -> None:\n        pass\n\n\n\n[docs]\n    def finish(self) -> None:\n        pass\n\n\n\n[docs]\n    def clean_up_from_scene(self, scene: Scene) -> None:\n        pass\n\n\n\n[docs]\n    def update_mobjects(self, dt: float) -> None:\n        pass\n\n\n\n[docs]\n    def interpolate(self, alpha: float) -> None:\n        pass\n\n\n\n\n\n[docs]\ndef override_animation(\n    animation_class: type[Animation],\n) -> Callable[[Callable], Callable]:\n    \"\"\"Decorator used to mark methods as overrides for specific :class:`~.Animation` types.\n\n    Should only be used to decorate methods of classes derived from :class:`~.Mobject`.\n    ``Animation`` overrides get inherited to subclasses of the ``Mobject`` who defined\n    them. They don't override subclasses of the ``Animation`` they override.\n\n    See Also\n    --------\n    :meth:`~.Mobject.add_animation_override`\n\n    Parameters\n    ----------\n    animation_class\n        The animation to be overridden.\n\n    Returns\n    -------\n    Callable[[Callable], Callable]\n        The actual decorator. This marks the method as overriding an animation.\n\n    Examples\n    --------\n\n    .. manim:: OverrideAnimationExample\n\n        class MySquare(Square):\n            @override_animation(FadeIn)\n            def _fade_in_override(self, **kwargs):\n                return Create(self, **kwargs)\n\n        class OverrideAnimationExample(Scene):\n            def construct(self):\n                self.play(FadeIn(MySquare()))\n\n    \"\"\"\n\n    def decorator(func):\n        func._override_animation = animation_class\n        return func\n\n    return decorator", "code_sha1": "7c0b864bf8f1930665d7678b58d3c5e542a01b70"}
{"url": "https://docs.manim.community/en/stable/_modules/manim/animation/changing.html", "depth": 2, "instruction": "The code creates an animated boundary around a text object that cycles through colors (RED, GREEN, BLUE) while changing stroke width, and a traced path following a moving dot. The boundary animates with a smooth transition, while the traced path appears and dissipates over time, with a linear movement of the dot across the screen.", "code": "\"\"\"Animation of a mobject boundary and tracing of points.\"\"\"\n\nfrom __future__ import annotations\n\n__all__ = [\"AnimatedBoundary\", \"TracedPath\"]\n\nfrom typing import Callable\n\nfrom manim.mobject.opengl.opengl_compatibility import ConvertToOpenGL\nfrom manim.mobject.types.vectorized_mobject import VGroup, VMobject\nfrom manim.utils.color import (\n    BLUE_B,\n    BLUE_D,\n    BLUE_E,\n    GREY_BROWN,\n    WHITE,\n    ParsableManimColor,\n)\nfrom manim.utils.rate_functions import smooth\n\n\n\n[docs]\nclass AnimatedBoundary(VGroup):\n    \"\"\"Boundary of a :class:`.VMobject` with animated color change.\n\n    Examples\n    --------\n    .. manim:: AnimatedBoundaryExample\n\n        class AnimatedBoundaryExample(Scene):\n            def construct(self):\n                text = Text(\"So shiny!\")\n                boundary = AnimatedBoundary(text, colors=[RED, GREEN, BLUE],\n                                            cycle_rate=3)\n                self.add(text, boundary)\n                self.wait(2)\n\n    \"\"\"\n\n    def __init__(\n        self,\n        vmobject,\n        colors=[BLUE_D, BLUE_B, BLUE_E, GREY_BROWN],\n        max_stroke_width=3,\n        cycle_rate=0.5,\n        back_and_forth=True,\n        draw_rate_func=smooth,\n        fade_rate_func=smooth,\n        **kwargs,\n    ):\n        super().__init__(**kwargs)\n        self.colors = colors\n        self.max_stroke_width = max_stroke_width\n        self.cycle_rate = cycle_rate\n        self.back_and_forth = back_and_forth\n        self.draw_rate_func = draw_rate_func\n        self.fade_rate_func = fade_rate_func\n        self.vmobject = vmobject\n        self.boundary_copies = [\n            vmobject.copy().set_style(stroke_width=0, fill_opacity=0) for x in range(2)\n        ]\n        self.add(*self.boundary_copies)\n        self.total_time = 0\n        self.add_updater(lambda m, dt: self.update_boundary_copies(dt))\n\n    def update_boundary_copies(self, dt):\n        # Not actual time, but something which passes at\n        # an altered rate to make the implementation below\n        # cleaner\n        time = self.total_time * self.cycle_rate\n        growing, fading = self.boundary_copies\n        colors = self.colors\n        msw = self.max_stroke_width\n        vmobject = self.vmobject\n\n        index = int(time % len(colors))\n        alpha = time % 1\n        draw_alpha = self.draw_rate_func(alpha)\n        fade_alpha = self.fade_rate_func(alpha)\n\n        if self.back_and_forth and int(time) % 2 == 1:\n            bounds = (1 - draw_alpha, 1)\n        else:\n            bounds = (0, draw_alpha)\n        self.full_family_become_partial(growing, vmobject, *bounds)\n        growing.set_stroke(colors[index], width=msw)\n\n        if time >= 1:\n            self.full_family_become_partial(fading, vmobject, 0, 1)\n            fading.set_stroke(color=colors[index - 1], width=(1 - fade_alpha) * msw)\n\n        self.total_time += dt\n\n    def full_family_become_partial(self, mob1, mob2, a, b):\n        family1 = mob1.family_members_with_points()\n        family2 = mob2.family_members_with_points()\n        for sm1, sm2 in zip(family1, family2):\n            sm1.pointwise_become_partial(sm2, a, b)\n        return self\n\n\n\n\n[docs]\nclass TracedPath(VMobject, metaclass=ConvertToOpenGL):\n    \"\"\"Traces the path of a point returned by a function call.\n\n    Parameters\n    ----------\n    traced_point_func\n        The function to be traced.\n    stroke_width\n        The width of the trace.\n    stroke_color\n        The color of the trace.\n    dissipating_time\n        The time taken for the path to dissipate. Default set to ``None``\n        which disables dissipation.\n\n    Examples\n    --------\n    .. manim:: TracedPathExample\n\n        class TracedPathExample(Scene):\n            def construct(self):\n                circ = Circle(color=RED).shift(4*LEFT)\n                dot = Dot(color=RED).move_to(circ.get_start())\n                rolling_circle = VGroup(circ, dot)\n                trace = TracedPath(circ.get_start)\n                rolling_circle.add_updater(lambda m: m.rotate(-0.3))\n                self.add(trace, rolling_circle)\n                self.play(rolling_circle.animate.shift(8*RIGHT), run_time=4, rate_func=linear)\n\n    .. manim:: DissipatingPathExample\n\n        class DissipatingPathExample(Scene):\n            def construct(self):\n                a = Dot(RIGHT * 2)\n                b = TracedPath(a.get_center, dissipating_time=0.5, stroke_opacity=[0, 1])\n                self.add(a, b)\n                self.play(a.animate(path_arc=PI / 4).shift(LEFT * 2))\n                self.play(a.animate(path_arc=-PI / 4).shift(LEFT * 2))\n                self.wait()\n\n    \"\"\"\n\n    def __init__(\n        self,\n        traced_point_func: Callable,\n        stroke_width: float = 2,\n        stroke_color: ParsableManimColor | None = WHITE,\n        dissipating_time: float | None = None,\n        **kwargs,\n    ):\n        super().__init__(stroke_color=stroke_color, stroke_width=stroke_width, **kwargs)\n        self.traced_point_func = traced_point_func\n        self.dissipating_time = dissipating_time\n        self.time = 1 if self.dissipating_time else None\n        self.add_updater(self.update_path)\n\n    def update_path(self, mob, dt):\n        new_point = self.traced_point_func()\n        if not self.has_points():\n            self.start_new_path(new_point)\n        self.add_line_to(new_point)\n        if self.dissipating_time:\n            self.time += dt\n            if self.time - 1 > self.dissipating_time:\n                nppcc = self.n_points_per_curve\n                self.set_points(self.points[nppcc:])", "code_sha1": "a12ca3f7590b1d912298951ff76abd2dbc30e1c4"}
{"url": "https://docs.manim.community/en/stable/_modules/manim/animation/composition.html", "depth": 2, "instruction": "The code defines classes for managing and playing multiple animations in sequence or with delays, including `AnimationGroup`, `Succession`, `LaggedStart`, and `LaggedStartMap`. Each class allows for customizable timing and execution of animations on groups of objects, facilitating complex visual sequences in Manim.", "code": "\"\"\"Tools for displaying multiple animations at once.\"\"\"\n\nfrom __future__ import annotations\n\nimport types\nfrom collections.abc import Iterable, Sequence\nfrom typing import TYPE_CHECKING, Callable\n\nimport numpy as np\n\nfrom manim._config import config\nfrom manim.animation.animation import Animation, prepare_animation\nfrom manim.constants import RendererType\nfrom manim.mobject.mobject import Group, Mobject\nfrom manim.mobject.opengl.opengl_mobject import OpenGLGroup\nfrom manim.scene.scene import Scene\nfrom manim.utils.iterables import remove_list_redundancies\nfrom manim.utils.parameter_parsing import flatten_iterable_parameters\nfrom manim.utils.rate_functions import linear\n\nif TYPE_CHECKING:\n    from manim.mobject.opengl.opengl_vectorized_mobject import OpenGLVGroup\n    from manim.mobject.types.vectorized_mobject import VGroup\n\n__all__ = [\"AnimationGroup\", \"Succession\", \"LaggedStart\", \"LaggedStartMap\"]\n\n\nDEFAULT_LAGGED_START_LAG_RATIO: float = 0.05\n\n\n\n[docs]\nclass AnimationGroup(Animation):\n    \"\"\"Plays a group or series of :class:`~.Animation`.\n\n    Parameters\n    ----------\n    animations\n        Sequence of :class:`~.Animation` objects to be played.\n    group\n        A group of multiple :class:`~.Mobject`.\n    run_time\n        The duration of the animation in seconds.\n    rate_func\n        The function defining the animation progress based on the relative\n        runtime (see :mod:`~.rate_functions`) .\n    lag_ratio\n        Defines the delay after which the animation is applied to submobjects. A lag_ratio of\n        ``n.nn`` means the next animation will play when ``nnn%`` of the current animation has played.\n        Defaults to 0.0, meaning that all animations will be played together.\n\n        This does not influence the total runtime of the animation. Instead the runtime\n        of individual animations is adjusted so that the complete animation has the defined\n        run time.\n    \"\"\"\n\n    def __init__(\n        self,\n        *animations: Animation | Iterable[Animation] | types.GeneratorType[Animation],\n        group: Group | VGroup | OpenGLGroup | OpenGLVGroup = None,\n        run_time: float | None = None,\n        rate_func: Callable[[float], float] = linear,\n        lag_ratio: float = 0,\n        **kwargs,\n    ) -> None:\n        arg_anim = flatten_iterable_parameters(animations)\n        self.animations = [prepare_animation(anim) for anim in arg_anim]\n        self.rate_func = rate_func\n        self.group = group\n        if self.group is None:\n            mobjects = remove_list_redundancies(\n                [anim.mobject for anim in self.animations if not anim.is_introducer()],\n            )\n            if config[\"renderer\"] == RendererType.OPENGL:\n                self.group = OpenGLGroup(*mobjects)\n            else:\n                self.group = Group(*mobjects)\n        super().__init__(\n            self.group, rate_func=self.rate_func, lag_ratio=lag_ratio, **kwargs\n        )\n        self.run_time: float = self.init_run_time(run_time)\n\n\n[docs]\n    def get_all_mobjects(self) -> Sequence[Mobject]:\n        return list(self.group)\n\n\n\n[docs]\n    def begin(self) -> None:\n        if not self.animations:\n            raise ValueError(\n                f\"Trying to play {self} without animations, this is not supported. \"\n                \"Please add at least one subanimation.\"\n            )\n        self.anim_group_time = 0.0\n        if self.suspend_mobject_updating:\n            self.group.suspend_updating()\n        for anim in self.animations:\n            anim.begin()\n\n\n\n[docs]\n    def _setup_scene(self, scene) -> None:\n        for anim in self.animations:\n            anim._setup_scene(scene)\n\n\n\n[docs]\n    def finish(self) -> None:\n        for anim in self.animations:\n            anim.finish()\n        self.anims_begun[:] = True\n        self.anims_finished[:] = True\n        if self.suspend_mobject_updating:\n            self.group.resume_updating()\n\n\n\n[docs]\n    def clean_up_from_scene(self, scene: Scene) -> None:\n        self._on_finish(scene)\n        for anim in self.animations:\n            if self.remover:\n                anim.remover = self.remover\n            anim.clean_up_from_scene(scene)\n\n\n\n[docs]\n    def update_mobjects(self, dt: float) -> None:\n        for anim in self.anims_with_timings[\"anim\"][\n            self.anims_begun & ~self.anims_finished\n        ]:\n            anim.update_mobjects(dt)\n\n\n\n[docs]\n    def init_run_time(self, run_time) -> float:\n        \"\"\"Calculates the run time of the animation, if different from ``run_time``.\n\n        Parameters\n        ----------\n        run_time\n            The duration of the animation in seconds.\n\n        Returns\n        -------\n        run_time\n            The duration of the animation in seconds.\n        \"\"\"\n        self.build_animations_with_timings()\n        # Note: if lag_ratio < 1, then not necessarily the final animation's\n        # end time will be the max end time! Therefore we must calculate the\n        # maximum over all the end times, and not just take the last one.\n        # Example: if you want to play 2 animations of 10s and 1s with a\n        # lag_ratio of 0.1, the 1st one will end at t=10 and the 2nd one will\n        # end at t=2, so the AnimationGroup will end at t=10.\n        self.max_end_time = max(self.anims_with_timings[\"end\"], default=0)\n        return self.max_end_time if run_time is None else run_time\n\n\n\n[docs]\n    def build_animations_with_timings(self) -> None:\n        \"\"\"Creates a list of triplets of the form (anim, start_time, end_time).\"\"\"\n        run_times = np.array([anim.run_time for anim in self.animations])\n        num_animations = run_times.shape[0]\n        dtype = [(\"anim\", \"O\"), (\"start\", \"f8\"), (\"end\", \"f8\")]\n        self.anims_with_timings = np.zeros(num_animations, dtype=dtype)\n        self.anims_begun = np.zeros(num_animations, dtype=bool)\n        self.anims_finished = np.zeros(num_animations, dtype=bool)\n        if num_animations == 0:\n            return\n\n        lags = run_times[:-1] * self.lag_ratio\n        self.anims_with_timings[\"anim\"] = self.animations\n        self.anims_with_timings[\"start\"][1:] = np.add.accumulate(lags)\n        self.anims_with_timings[\"end\"] = self.anims_with_timings[\"start\"] + run_times\n\n\n\n[docs]\n    def interpolate(self, alpha: float) -> None:\n        # Note, if the run_time of AnimationGroup has been\n        # set to something other than its default, these\n        # times might not correspond to actual times,\n        # e.g. of the surrounding scene.  Instead they'd\n        # be a rescaled version.  But that's okay!\n        anim_group_time = self.rate_func(alpha) * self.max_end_time\n        time_goes_back = anim_group_time < self.anim_group_time\n\n        # Only update ongoing animations\n        awt = self.anims_with_timings\n        new_begun = anim_group_time >= awt[\"start\"]\n        new_finished = anim_group_time > awt[\"end\"]\n        to_update = awt[\n            (self.anims_begun | new_begun) & (~self.anims_finished | ~new_finished)\n        ]\n\n        run_times = to_update[\"end\"] - to_update[\"start\"]\n        with_zero_run_time = run_times == 0\n        run_times[with_zero_run_time] = 1\n        sub_alphas = (anim_group_time - to_update[\"start\"]) / run_times\n        if time_goes_back:\n            sub_alphas[(sub_alphas < 0) | with_zero_run_time] = 0\n        else:\n            sub_alphas[(sub_alphas > 1) | with_zero_run_time] = 1\n\n        for anim_to_update, sub_alpha in zip(to_update[\"anim\"], sub_alphas):\n            anim_to_update.interpolate(sub_alpha)\n\n        self.anim_group_time = anim_group_time\n        self.anims_begun = new_begun\n        self.anims_finished = new_finished\n\n\n\n\n\n[docs]\nclass Succession(AnimationGroup):\n    \"\"\"Plays a series of animations in succession.\n\n    Parameters\n    ----------\n    animations\n        Sequence of :class:`~.Animation` objects to be played.\n    lag_ratio\n        Defines the delay after which the animation is applied to submobjects. A lag_ratio of\n        ``n.nn`` means the next animation will play when ``nnn%`` of the current animation has played.\n        Defaults to 1.0, meaning that the next animation will begin when 100% of the current\n        animation has played.\n\n        This does not influence the total runtime of the animation. Instead the runtime\n        of individual animations is adjusted so that the complete animation has the defined\n        run time.\n\n    Examples\n    --------\n    .. manim:: SuccessionExample\n\n        class SuccessionExample(Scene):\n            def construct(self):\n                dot1 = Dot(point=LEFT * 2 + UP * 2, radius=0.16, color=BLUE)\n                dot2 = Dot(point=LEFT * 2 + DOWN * 2, radius=0.16, color=MAROON)\n                dot3 = Dot(point=RIGHT * 2 + DOWN * 2, radius=0.16, color=GREEN)\n                dot4 = Dot(point=RIGHT * 2 + UP * 2, radius=0.16, color=YELLOW)\n                self.add(dot1, dot2, dot3, dot4)\n\n                self.play(Succession(\n                    dot1.animate.move_to(dot2),\n                    dot2.animate.move_to(dot3),\n                    dot3.animate.move_to(dot4),\n                    dot4.animate.move_to(dot1)\n                ))\n    \"\"\"\n\n    def __init__(self, *animations: Animation, lag_ratio: float = 1, **kwargs) -> None:\n        super().__init__(*animations, lag_ratio=lag_ratio, **kwargs)\n\n\n[docs]\n    def begin(self) -> None:\n        if not self.animations:\n            raise ValueError(\n                f\"Trying to play {self} without animations, this is not supported. \"\n                \"Please add at least one subanimation.\"\n            )\n        self.update_active_animation(0)\n\n\n\n[docs]\n    def finish(self) -> None:\n        while self.active_animation is not None:\n            self.next_animation()\n\n\n\n[docs]\n    def update_mobjects(self, dt: float) -> None:\n        if self.active_animation:\n            self.active_animation.update_mobjects(dt)\n\n\n\n[docs]\n    def _setup_scene(self, scene) -> None:\n        if scene is None:\n            return\n        if self.is_introducer():\n            for anim in self.animations:\n                if not anim.is_introducer() and anim.mobject is not None:\n                    scene.add(anim.mobject)\n\n        self.scene = scene\n\n\n    def update_active_animation(self, index: int) -> None:\n        self.active_index = index\n        if index >= len(self.animations):\n            self.active_animation: Animation | None = None\n            self.active_start_time: float | None = None\n            self.active_end_time: float | None = None\n        else:\n            self.active_animation = self.animations[index]\n            self.active_animation._setup_scene(self.scene)\n            self.active_animation.begin()\n            self.active_start_time = self.anims_with_timings[index][\"start\"]\n            self.active_end_time = self.anims_with_timings[index][\"end\"]\n\n\n[docs]\n    def next_animation(self) -> None:\n        \"\"\"Proceeds to the next animation.\n\n        This method is called right when the active animation finishes.\n        \"\"\"\n        if self.active_animation is not None:\n            self.active_animation.finish()\n        self.update_active_animation(self.active_index + 1)\n\n\n\n[docs]\n    def interpolate(self, alpha: float) -> None:\n        current_time = self.rate_func(alpha) * self.max_end_time\n        while self.active_end_time is not None and current_time >= self.active_end_time:\n            self.next_animation()\n        if self.active_animation is not None and self.active_start_time is not None:\n            elapsed = current_time - self.active_start_time\n            active_run_time = self.active_animation.run_time\n            subalpha = elapsed / active_run_time if active_run_time != 0.0 else 1.0\n            self.active_animation.interpolate(subalpha)\n\n\n\n\n\n[docs]\nclass LaggedStart(AnimationGroup):\n    \"\"\"Adjusts the timing of a series of :class:`~.Animation` according to ``lag_ratio``.\n\n    Parameters\n    ----------\n    animations\n        Sequence of :class:`~.Animation` objects to be played.\n    lag_ratio\n        Defines the delay after which the animation is applied to submobjects. A lag_ratio of\n        ``n.nn`` means the next animation will play when ``nnn%`` of the current animation has played.\n        Defaults to 0.05, meaning that the next animation will begin when 5% of the current\n        animation has played.\n\n        This does not influence the total runtime of the animation. Instead the runtime\n        of individual animations is adjusted so that the complete animation has the defined\n        run time.\n\n    Examples\n    --------\n    .. manim:: LaggedStartExample\n\n        class LaggedStartExample(Scene):\n            def construct(self):\n                title = Text(\"lag_ratio = 0.25\").to_edge(UP)\n\n                dot1 = Dot(point=LEFT * 2 + UP, radius=0.16)\n                dot2 = Dot(point=LEFT * 2, radius=0.16)\n                dot3 = Dot(point=LEFT * 2 + DOWN, radius=0.16)\n                line_25 = DashedLine(\n                    start=LEFT + UP * 2,\n                    end=LEFT + DOWN * 2,\n                    color=RED\n                )\n                label = Text(\"25%\", font_size=24).next_to(line_25, UP)\n                self.add(title, dot1, dot2, dot3, line_25, label)\n\n                self.play(LaggedStart(\n                    dot1.animate.shift(RIGHT * 4),\n                    dot2.animate.shift(RIGHT * 4),\n                    dot3.animate.shift(RIGHT * 4),\n                    lag_ratio=0.25,\n                    run_time=4\n                ))\n    \"\"\"\n\n    def __init__(\n        self,\n        *animations: Animation,\n        lag_ratio: float = DEFAULT_LAGGED_START_LAG_RATIO,\n        **kwargs,\n    ):\n        super().__init__(*animations, lag_ratio=lag_ratio, **kwargs)\n\n\n\n\n[docs]\nclass LaggedStartMap(LaggedStart):\n    \"\"\"Plays a series of :class:`~.Animation` while mapping a function to submobjects.\n\n    Parameters\n    ----------\n    AnimationClass\n        :class:`~.Animation` to apply to mobject.\n    mobject\n        :class:`~.Mobject` whose submobjects the animation, and optionally the function,\n        are to be applied.\n    arg_creator\n        Function which will be applied to :class:`~.Mobject`.\n    run_time\n        The duration of the animation in seconds.\n\n    Examples\n    --------\n    .. manim:: LaggedStartMapExample\n\n        class LaggedStartMapExample(Scene):\n            def construct(self):\n                title = Tex(\"LaggedStartMap\").to_edge(UP, buff=LARGE_BUFF)\n                dots = VGroup(\n                    *[Dot(radius=0.16) for _ in range(35)]\n                    ).arrange_in_grid(rows=5, cols=7, buff=MED_LARGE_BUFF)\n                self.add(dots, title)\n\n                # Animate yellow ripple effect\n                for mob in dots, title:\n                    self.play(LaggedStartMap(\n                        ApplyMethod, mob,\n                        lambda m : (m.set_color, YELLOW),\n                        lag_ratio = 0.1,\n                        rate_func = there_and_back,\n                        run_time = 2\n                    ))\n    \"\"\"\n\n    def __init__(\n        self,\n        AnimationClass: Callable[..., Animation],\n        mobject: Mobject,\n        arg_creator: Callable[[Mobject], str] = None,\n        run_time: float = 2,\n        **kwargs,\n    ) -> None:\n        args_list = []\n        for submob in mobject:\n            if arg_creator:\n                args_list.append(arg_creator(submob))\n            else:\n                args_list.append((submob,))\n        anim_kwargs = dict(kwargs)\n        if \"lag_ratio\" in anim_kwargs:\n            anim_kwargs.pop(\"lag_ratio\")\n        animations = [AnimationClass(*args, **anim_kwargs) for args in args_list]\n        super().__init__(*animations, run_time=run_time, **kwargs)", "code_sha1": "bcc4f0a592862e6e2fb74255a5087ff6364c5ab8"}
{"url": "https://docs.manim.community/en/stable/_modules/manim/animation/creation.html", "depth": 2, "instruction": "The scene displays two rows of squares, each labeled with text above them. The first row features the words \"Write,\" \"AddTextLetterByLetter,\" \"Create,\" and \"Uncreate,\" while the second row includes \"DrawBorderThenFill,\" \"ShowIncreasingSubsets,\" and \"ShowSubmobjectsOneByOne.\" The animation sequentially reveals the text and squares with various effects over 3 seconds, concluding with a pause.", "code": "r\"\"\"Animate the display or removal of a mobject from a scene.\n\n.. manim:: CreationModule\n    :hide_source:\n\n    from manim import ManimBanner\n    class CreationModule(Scene):\n        def construct(self):\n            s1 = Square()\n            s2 = Square()\n            s3 = Square()\n            s4 = Square()\n            VGroup(s1, s2, s3, s4).set_x(0).arrange(buff=1.9).shift(UP)\n            s5 = Square()\n            s6 = Square()\n            s7 = Square()\n            VGroup(s5, s6, s7).set_x(0).arrange(buff=2.6).shift(2 * DOWN)\n            t1 = Text(\"Write\", font_size=24).next_to(s1, UP)\n            t2 = Text(\"AddTextLetterByLetter\", font_size=24).next_to(s2, UP)\n            t3 = Text(\"Create\", font_size=24).next_to(s3, UP)\n            t4 = Text(\"Uncreate\", font_size=24).next_to(s4, UP)\n            t5 = Text(\"DrawBorderThenFill\", font_size=24).next_to(s5, UP)\n            t6 = Text(\"ShowIncreasingSubsets\", font_size=22).next_to(s6, UP)\n            t7 = Text(\"ShowSubmobjectsOneByOne\", font_size=22).next_to(s7, UP)\n\n            self.add(s1, s2, s3, s4, s5, s6, s7, t1, t2, t3, t4, t5, t6, t7)\n\n            texts = [Text(\"manim\", font_size=29), Text(\"manim\", font_size=29)]\n            texts[0].move_to(s1.get_center())\n            texts[1].move_to(s2.get_center())\n            self.add(*texts)\n\n            objs = [ManimBanner().scale(0.25) for _ in range(5)]\n            objs[0].move_to(s3.get_center())\n            objs[1].move_to(s4.get_center())\n            objs[2].move_to(s5.get_center())\n            objs[3].move_to(s6.get_center())\n            objs[4].move_to(s7.get_center())\n            self.add(*objs)\n\n            self.play(\n                # text creation\n                Write(texts[0]),\n                AddTextLetterByLetter(texts[1]),\n                # mobject creation\n                Create(objs[0]),\n                Uncreate(objs[1]),\n                DrawBorderThenFill(objs[2]),\n                ShowIncreasingSubsets(objs[3]),\n                ShowSubmobjectsOneByOne(objs[4]),\n                run_time=3,\n            )\n\n            self.wait()\n\n\"\"\"\n\nfrom __future__ import annotations\n\n__all__ = [\n    \"Create\",\n    \"Uncreate\",\n    \"DrawBorderThenFill\",\n    \"Write\",\n    \"Unwrite\",\n    \"ShowPartial\",\n    \"ShowIncreasingSubsets\",\n    \"SpiralIn\",\n    \"AddTextLetterByLetter\",\n    \"RemoveTextLetterByLetter\",\n    \"ShowSubmobjectsOneByOne\",\n    \"AddTextWordByWord\",\n    \"TypeWithCursor\",\n    \"UntypeWithCursor\",\n]\n\n\nimport itertools as it\nfrom collections.abc import Iterable, Sequence\nfrom typing import TYPE_CHECKING, Callable\n\nimport numpy as np\n\nif TYPE_CHECKING:\n    from manim.mobject.text.text_mobject import Text\n    from manim.scene.scene import Scene\n\nfrom manim.constants import RIGHT, TAU\nfrom manim.mobject.opengl.opengl_surface import OpenGLSurface\nfrom manim.mobject.opengl.opengl_vectorized_mobject import OpenGLVMobject\nfrom manim.utils.color import ManimColor\n\nfrom .. import config\nfrom ..animation.animation import Animation\nfrom ..animation.composition import Succession\nfrom ..mobject.mobject import Group, Mobject\nfrom ..mobject.types.vectorized_mobject import VMobject\nfrom ..utils.bezier import integer_interpolate\nfrom ..utils.rate_functions import double_smooth, linear\n\n\n\n[docs]\nclass ShowPartial(Animation):\n    \"\"\"Abstract class for Animations that show the VMobject partially.\n\n    Raises\n    ------\n    :class:`TypeError`\n        If ``mobject`` is not an instance of :class:`~.VMobject`.\n\n    See Also\n    --------\n    :class:`Create`, :class:`~.ShowPassingFlash`\n\n    \"\"\"\n\n    def __init__(\n        self,\n        mobject: VMobject | OpenGLVMobject | OpenGLSurface | None,\n        **kwargs,\n    ):\n        pointwise = getattr(mobject, \"pointwise_become_partial\", None)\n        if not callable(pointwise):\n            raise NotImplementedError(\"This animation is not defined for this Mobject.\")\n        super().__init__(mobject, **kwargs)\n\n    def interpolate_submobject(\n        self,\n        submobject: Mobject,\n        starting_submobject: Mobject,\n        alpha: float,\n    ) -> None:\n        submobject.pointwise_become_partial(\n            starting_submobject, *self._get_bounds(alpha)\n        )\n\n    def _get_bounds(self, alpha: float) -> None:\n        raise NotImplementedError(\"Please use Create or ShowPassingFlash\")\n\n\n\n\n[docs]\nclass Create(ShowPartial):\n    \"\"\"Incrementally show a VMobject.\n\n    Parameters\n    ----------\n    mobject\n        The VMobject to animate.\n\n    Raises\n    ------\n    :class:`TypeError`\n        If ``mobject`` is not an instance of :class:`~.VMobject`.\n\n    Examples\n    --------\n    .. manim:: CreateScene\n\n        class CreateScene(Scene):\n            def construct(self):\n                self.play(Create(Square()))\n\n    See Also\n    --------\n    :class:`~.ShowPassingFlash`\n\n    \"\"\"\n\n    def __init__(\n        self,\n        mobject: VMobject | OpenGLVMobject | OpenGLSurface,\n        lag_ratio: float = 1.0,\n        introducer: bool = True,\n        **kwargs,\n    ) -> None:\n        super().__init__(mobject, lag_ratio=lag_ratio, introducer=introducer, **kwargs)\n\n    def _get_bounds(self, alpha: float) -> tuple[int, float]:\n        return (0, alpha)\n\n\n\n\n[docs]\nclass Uncreate(Create):\n    \"\"\"Like :class:`Create` but in reverse.\n\n    Examples\n    --------\n    .. manim:: ShowUncreate\n\n        class ShowUncreate(Scene):\n            def construct(self):\n                self.play(Uncreate(Square()))\n\n    See Also\n    --------\n    :class:`Create`\n\n    \"\"\"\n\n    def __init__(\n        self,\n        mobject: VMobject | OpenGLVMobject,\n        reverse_rate_function: bool = True,\n        remover: bool = True,\n        **kwargs,\n    ) -> None:\n        super().__init__(\n            mobject,\n            reverse_rate_function=reverse_rate_function,\n            introducer=False,\n            remover=remover,\n            **kwargs,\n        )\n\n\n\n\n[docs]\nclass DrawBorderThenFill(Animation):\n    \"\"\"Draw the border first and then show the fill.\n\n    Examples\n    --------\n    .. manim:: ShowDrawBorderThenFill\n\n        class ShowDrawBorderThenFill(Scene):\n            def construct(self):\n                self.play(DrawBorderThenFill(Square(fill_opacity=1, fill_color=ORANGE)))\n    \"\"\"\n\n    def __init__(\n        self,\n        vmobject: VMobject | OpenGLVMobject,\n        run_time: float = 2,\n        rate_func: Callable[[float], float] = double_smooth,\n        stroke_width: float = 2,\n        stroke_color: str = None,\n        draw_border_animation_config: dict = {},  # what does this dict accept?\n        fill_animation_config: dict = {},\n        introducer: bool = True,\n        **kwargs,\n    ) -> None:\n        self._typecheck_input(vmobject)\n        super().__init__(\n            vmobject,\n            run_time=run_time,\n            introducer=introducer,\n            rate_func=rate_func,\n            **kwargs,\n        )\n        self.stroke_width = stroke_width\n        self.stroke_color = stroke_color\n        self.draw_border_animation_config = draw_border_animation_config\n        self.fill_animation_config = fill_animation_config\n        self.outline = self.get_outline()\n\n    def _typecheck_input(self, vmobject: VMobject | OpenGLVMobject) -> None:\n        if not isinstance(vmobject, (VMobject, OpenGLVMobject)):\n            raise TypeError(\n                f\"{self.__class__.__name__} only works for vectorized Mobjects\"\n            )\n\n\n[docs]\n    def begin(self) -> None:\n        self.outline = self.get_outline()\n        super().begin()\n\n\n    def get_outline(self) -> Mobject:\n        outline = self.mobject.copy()\n        outline.set_fill(opacity=0)\n        for sm in outline.family_members_with_points():\n            sm.set_stroke(color=self.get_stroke_color(sm), width=self.stroke_width)\n        return outline\n\n    def get_stroke_color(self, vmobject: VMobject | OpenGLVMobject) -> ManimColor:\n        if self.stroke_color:\n            return self.stroke_color\n        elif vmobject.get_stroke_width() > 0:\n            return vmobject.get_stroke_color()\n        return vmobject.get_color()\n\n\n[docs]\n    def get_all_mobjects(self) -> Sequence[Mobject]:\n        return [*super().get_all_mobjects(), self.outline]\n\n\n    def interpolate_submobject(\n        self,\n        submobject: Mobject,\n        starting_submobject: Mobject,\n        outline,\n        alpha: float,\n    ) -> None:  # Fixme: not matching the parent class? What is outline doing here?\n        index: int\n        subalpha: float\n        index, subalpha = integer_interpolate(0, 2, alpha)\n        if index == 0:\n            submobject.pointwise_become_partial(outline, 0, subalpha)\n            submobject.match_style(outline)\n        else:\n            submobject.interpolate(outline, starting_submobject, subalpha)\n\n\n\n\n[docs]\nclass Write(DrawBorderThenFill):\n    \"\"\"Simulate hand-writing a :class:`~.Text` or hand-drawing a :class:`~.VMobject`.\n\n    Examples\n    --------\n    .. manim:: ShowWrite\n\n        class ShowWrite(Scene):\n            def construct(self):\n                self.play(Write(Text(\"Hello\", font_size=144)))\n\n    .. manim:: ShowWriteReversed\n\n        class ShowWriteReversed(Scene):\n            def construct(self):\n                self.play(Write(Text(\"Hello\", font_size=144), reverse=True, remover=False))\n\n    Tests\n    -----\n\n    Check that creating empty :class:`.Write` animations works::\nfrom manim import Write, Text\nWrite(Text(''))\n        Write(Text(''))\n    \"\"\"\n\n    def __init__(\n        self,\n        vmobject: VMobject | OpenGLVMobject,\n        rate_func: Callable[[float], float] = linear,\n        reverse: bool = False,\n        **kwargs,\n    ) -> None:\n        run_time: float | None = kwargs.pop(\"run_time\", None)\n        lag_ratio: float | None = kwargs.pop(\"lag_ratio\", None)\n        run_time, lag_ratio = self._set_default_config_from_length(\n            vmobject,\n            run_time,\n            lag_ratio,\n        )\n        self.reverse = reverse\n        if \"remover\" not in kwargs:\n            kwargs[\"remover\"] = reverse\n        super().__init__(\n            vmobject,\n            rate_func=rate_func,\n            run_time=run_time,\n            lag_ratio=lag_ratio,\n            introducer=not reverse,\n            **kwargs,\n        )\n\n    def _set_default_config_from_length(\n        self,\n        vmobject: VMobject | OpenGLVMobject,\n        run_time: float | None,\n        lag_ratio: float | None,\n    ) -> tuple[float, float]:\n        length = len(vmobject.family_members_with_points())\n        if run_time is None:\n            run_time = 1 if length < 15 else 2\n        if lag_ratio is None:\n            lag_ratio = min(4.0 / max(1.0, length), 0.2)\n        return run_time, lag_ratio\n\n    def reverse_submobjects(self) -> None:\n        self.mobject.invert(recursive=True)\n\n\n[docs]\n    def begin(self) -> None:\n        if self.reverse:\n            self.reverse_submobjects()\n        super().begin()\n\n\n\n[docs]\n    def finish(self) -> None:\n        super().finish()\n        if self.reverse:\n            self.reverse_submobjects()\n\n\n\n\n\n[docs]\nclass Unwrite(Write):\n    \"\"\"Simulate erasing by hand a :class:`~.Text` or a :class:`~.VMobject`.\n\n    Parameters\n    ----------\n    reverse\n        Set True to have the animation start erasing from the last submobject first.\n\n    Examples\n    --------\n\n    .. manim :: UnwriteReverseTrue\n\n        class UnwriteReverseTrue(Scene):\n            def construct(self):\n                text = Tex(\"Alice and Bob\").scale(3)\n                self.add(text)\n                self.play(Unwrite(text))\n\n    .. manim:: UnwriteReverseFalse\n\n        class UnwriteReverseFalse(Scene):\n            def construct(self):\n                text = Tex(\"Alice and Bob\").scale(3)\n                self.add(text)\n                self.play(Unwrite(text, reverse=False))\n    \"\"\"\n\n    def __init__(\n        self,\n        vmobject: VMobject,\n        rate_func: Callable[[float], float] = linear,\n        reverse: bool = True,\n        **kwargs,\n    ) -> None:\n        run_time: float | None = kwargs.pop(\"run_time\", None)\n        lag_ratio: float | None = kwargs.pop(\"lag_ratio\", None)\n        run_time, lag_ratio = self._set_default_config_from_length(\n            vmobject,\n            run_time,\n            lag_ratio,\n        )\n        super().__init__(\n            vmobject,\n            run_time=run_time,\n            lag_ratio=lag_ratio,\n            reverse_rate_function=True,\n            reverse=reverse,\n            **kwargs,\n        )\n\n\n\n\n[docs]\nclass SpiralIn(Animation):\n    r\"\"\"Create the Mobject with sub-Mobjects flying in on spiral trajectories.\n\n    Parameters\n    ----------\n    shapes\n        The Mobject on which to be operated.\n\n    scale_factor\n        The factor used for scaling the effect.\n\n    fade_in_fraction\n        Fractional duration of initial fade-in of sub-Mobjects as they fly inward.\n\n    Examples\n    --------\n    .. manim :: SpiralInExample\n\n        class SpiralInExample(Scene):\n            def construct(self):\n                pi = MathTex(r\"\\pi\").scale(7)\n                pi.shift(2.25 * LEFT + 1.5 * UP)\n                circle = Circle(color=GREEN_C, fill_opacity=1).shift(LEFT)\n                square = Square(color=BLUE_D, fill_opacity=1).shift(UP)\n                shapes = VGroup(pi, circle, square)\n                self.play(SpiralIn(shapes))\n    \"\"\"\n\n    def __init__(\n        self,\n        shapes: Mobject,\n        scale_factor: float = 8,\n        fade_in_fraction=0.3,\n        **kwargs,\n    ) -> None:\n        self.shapes = shapes.copy()\n        self.scale_factor = scale_factor\n        self.shape_center = shapes.get_center()\n        self.fade_in_fraction = fade_in_fraction\n        for shape in shapes:\n            shape.final_position = shape.get_center()\n            shape.initial_position = (\n                shape.final_position\n                + (shape.final_position - self.shape_center) * self.scale_factor\n            )\n            shape.move_to(shape.initial_position)\n            shape.save_state()\n\n        super().__init__(shapes, introducer=True, **kwargs)\n\n\n[docs]\n    def interpolate_mobject(self, alpha: float) -> None:\n        alpha = self.rate_func(alpha)\n        for original_shape, shape in zip(self.shapes, self.mobject):\n            shape.restore()\n            fill_opacity = original_shape.get_fill_opacity()\n            stroke_opacity = original_shape.get_stroke_opacity()\n            new_fill_opacity = min(\n                fill_opacity, alpha * fill_opacity / self.fade_in_fraction\n            )\n            new_stroke_opacity = min(\n                stroke_opacity, alpha * stroke_opacity / self.fade_in_fraction\n            )\n            shape.shift((shape.final_position - shape.initial_position) * alpha)\n            shape.rotate(TAU * alpha, about_point=self.shape_center)\n            shape.rotate(-TAU * alpha, about_point=shape.get_center_of_mass())\n            shape.set_fill(opacity=new_fill_opacity)\n            shape.set_stroke(opacity=new_stroke_opacity)\n\n\n\n\n\n[docs]\nclass ShowIncreasingSubsets(Animation):\n    \"\"\"Show one submobject at a time, leaving all previous ones displayed on screen.\n\n    Examples\n    --------\n\n    .. manim:: ShowIncreasingSubsetsScene\n\n        class ShowIncreasingSubsetsScene(Scene):\n            def construct(self):\n                p = VGroup(Dot(), Square(), Triangle())\n                self.add(p)\n                self.play(ShowIncreasingSubsets(p))\n                self.wait()\n    \"\"\"\n\n    def __init__(\n        self,\n        group: Mobject,\n        suspend_mobject_updating: bool = False,\n        int_func: Callable[[np.ndarray], np.ndarray] = np.floor,\n        reverse_rate_function=False,\n        **kwargs,\n    ) -> None:\n        self.all_submobs = list(group.submobjects)\n        self.int_func = int_func\n        for mobj in self.all_submobs:\n            mobj.set_opacity(0)\n        super().__init__(\n            group,\n            suspend_mobject_updating=suspend_mobject_updating,\n            reverse_rate_function=reverse_rate_function,\n            **kwargs,\n        )\n\n\n[docs]\n    def interpolate_mobject(self, alpha: float) -> None:\n        n_submobs = len(self.all_submobs)\n        value = (\n            1 - self.rate_func(alpha)\n            if self.reverse_rate_function\n            else self.rate_func(alpha)\n        )\n        index = int(self.int_func(value * n_submobs))\n        self.update_submobject_list(index)\n\n\n    def update_submobject_list(self, index: int) -> None:\n        for mobj in self.all_submobs[:index]:\n            mobj.set_opacity(1)\n        for mobj in self.all_submobs[index:]:\n            mobj.set_opacity(0)\n\n\n\n\n[docs]\nclass AddTextLetterByLetter(ShowIncreasingSubsets):\n    \"\"\"Show a :class:`~.Text` letter by letter on the scene.\n\n    Parameters\n    ----------\n    time_per_char\n        Frequency of appearance of the letters.\n\n    .. tip::\n\n        This is currently only possible for class:`~.Text` and not for class:`~.MathTex`\n\n    \"\"\"\n\n    def __init__(\n        self,\n        text: Text,\n        suspend_mobject_updating: bool = False,\n        int_func: Callable[[np.ndarray], np.ndarray] = np.ceil,\n        rate_func: Callable[[float], float] = linear,\n        time_per_char: float = 0.1,\n        run_time: float | None = None,\n        reverse_rate_function=False,\n        introducer=True,\n        **kwargs,\n    ) -> None:\n        self.time_per_char = time_per_char\n        # Check for empty text using family_members_with_points()\n        if not text.family_members_with_points():\n            raise ValueError(\n                f\"The text mobject {text} does not seem to contain any characters.\"\n            )\n        if run_time is None:\n            # minimum time per character is 1/frame_rate, otherwise\n            # the animation does not finish.\n            run_time = np.max((1 / config.frame_rate, self.time_per_char)) * len(text)\n        super().__init__(\n            text,\n            suspend_mobject_updating=suspend_mobject_updating,\n            int_func=int_func,\n            rate_func=rate_func,\n            run_time=run_time,\n            reverse_rate_function=reverse_rate_function,\n            introducer=introducer,\n            **kwargs,\n        )\n\n\n\n\n[docs]\nclass RemoveTextLetterByLetter(AddTextLetterByLetter):\n    \"\"\"Remove a :class:`~.Text` letter by letter from the scene.\n\n    Parameters\n    ----------\n    time_per_char\n        Frequency of appearance of the letters.\n\n    .. tip::\n\n        This is currently only possible for class:`~.Text` and not for class:`~.MathTex`\n\n    \"\"\"\n\n    def __init__(\n        self,\n        text: Text,\n        suspend_mobject_updating: bool = False,\n        int_func: Callable[[np.ndarray], np.ndarray] = np.ceil,\n        rate_func: Callable[[float], float] = linear,\n        time_per_char: float = 0.1,\n        run_time: float | None = None,\n        reverse_rate_function=True,\n        introducer=False,\n        remover=True,\n        **kwargs,\n    ) -> None:\n        super().__init__(\n            text,\n            suspend_mobject_updating=suspend_mobject_updating,\n            int_func=int_func,\n            rate_func=rate_func,\n            time_per_char=time_per_char,\n            run_time=run_time,\n            reverse_rate_function=reverse_rate_function,\n            introducer=introducer,\n            remover=remover,\n            **kwargs,\n        )\n\n\n\n\n[docs]\nclass ShowSubmobjectsOneByOne(ShowIncreasingSubsets):\n    \"\"\"Show one submobject at a time, removing all previously displayed ones from screen.\"\"\"\n\n    def __init__(\n        self,\n        group: Iterable[Mobject],\n        int_func: Callable[[np.ndarray], np.ndarray] = np.ceil,\n        **kwargs,\n    ) -> None:\n        new_group = Group(*group)\n        super().__init__(new_group, int_func=int_func, **kwargs)\n\n    def update_submobject_list(self, index: int) -> None:\n        current_submobjects = self.all_submobs[:index]\n        for mobj in current_submobjects[:-1]:\n            mobj.set_opacity(0)\n        if len(current_submobjects) > 0:\n            current_submobjects[-1].set_opacity(1)\n\n\n\n# TODO, this is broken...\n\n[docs]\nclass AddTextWordByWord(Succession):\n    \"\"\"Show a :class:`~.Text` word by word on the scene. Note: currently broken.\"\"\"\n\n    def __init__(\n        self,\n        text_mobject: Text,\n        run_time: float = None,\n        time_per_char: float = 0.06,\n        **kwargs,\n    ) -> None:\n        self.time_per_char = time_per_char\n        tpc = self.time_per_char\n        anims = it.chain(\n            *(\n                [\n                    ShowIncreasingSubsets(word, run_time=tpc * len(word)),\n                    Animation(word, run_time=0.005 * len(word) ** 1.5),\n                ]\n                for word in text_mobject\n            )\n        )\n        super().__init__(*anims, **kwargs)\n\n\n\n\n[docs]\nclass TypeWithCursor(AddTextLetterByLetter):\n    \"\"\"Similar to :class:`~.AddTextLetterByLetter` , but with an additional cursor mobject at the end.\n\n    Parameters\n    ----------\n    time_per_char\n        Frequency of appearance of the letters.\n    cursor\n        :class:`~.Mobject` shown after the last added letter.\n    buff\n        Controls how far away the cursor is to the right of the last added letter.\n    keep_cursor_y\n        If ``True``, the cursor's y-coordinate is set to the center of the ``Text`` and remains the same throughout the animation. Otherwise, it is set to the center of the last added letter.\n    leave_cursor_on\n        Whether to show the cursor after the animation.\n\n    .. tip::\n        This is currently only possible for class:`~.Text` and not for class:`~.MathTex`.\n\n\n    Examples\n    --------\n\n    .. manim:: InsertingTextExample\n        :ref_classes: Blink\n\n        class InsertingTextExample(Scene):\n            def construct(self):\n                text = Text(\"Inserting\", color=PURPLE).scale(1.5).to_edge(LEFT)\n                cursor = Rectangle(\n                    color = GREY_A,\n                    fill_color = GREY_A,\n                    fill_opacity = 1.0,\n                    height = 1.1,\n                    width = 0.5,\n                ).move_to(text[0]) # Position the cursor\n\n                self.play(TypeWithCursor(text, cursor))\n                self.play(Blink(cursor, blinks=2))\n\n    \"\"\"\n\n    def __init__(\n        self,\n        text: Text,\n        cursor: Mobject,\n        buff: float = 0.1,\n        keep_cursor_y: bool = True,\n        leave_cursor_on: bool = True,\n        time_per_char: float = 0.1,\n        reverse_rate_function=False,\n        introducer=True,\n        **kwargs,\n    ) -> None:\n        self.cursor = cursor\n        self.buff = buff\n        self.keep_cursor_y = keep_cursor_y\n        self.leave_cursor_on = leave_cursor_on\n        super().__init__(\n            text,\n            time_per_char=time_per_char,\n            reverse_rate_function=reverse_rate_function,\n            introducer=introducer,\n            **kwargs,\n        )\n\n\n[docs]\n    def begin(self) -> None:\n        self.y_cursor = self.cursor.get_y()\n        self.cursor.initial_position = self.mobject.get_center()\n        if self.keep_cursor_y:\n            self.cursor.set_y(self.y_cursor)\n\n        self.cursor.set_opacity(0)\n        self.mobject.add(self.cursor)\n        super().begin()\n\n\n\n[docs]\n    def finish(self) -> None:\n        if self.leave_cursor_on:\n            self.cursor.set_opacity(1)\n        else:\n            self.cursor.set_opacity(0)\n            self.mobject.remove(self.cursor)\n        super().finish()\n\n\n\n[docs]\n    def clean_up_from_scene(self, scene: Scene) -> None:\n        if not self.leave_cursor_on:\n            scene.remove(self.cursor)\n        super().clean_up_from_scene(scene)\n\n\n    def update_submobject_list(self, index: int) -> None:\n        for mobj in self.all_submobs[:index]:\n            mobj.set_opacity(1)\n\n        for mobj in self.all_submobs[index:]:\n            mobj.set_opacity(0)\n\n        if index != 0:\n            self.cursor.next_to(\n                self.all_submobs[index - 1], RIGHT, buff=self.buff\n            ).set_y(self.cursor.initial_position[1])\n        else:\n            self.cursor.move_to(self.all_submobs[0]).set_y(\n                self.cursor.initial_position[1]\n            )\n\n        if self.keep_cursor_y:\n            self.cursor.set_y(self.y_cursor)\n        self.cursor.set_opacity(1)\n\n\n\n\n[docs]\nclass UntypeWithCursor(TypeWithCursor):\n    \"\"\"Similar to :class:`~.RemoveTextLetterByLetter` , but with an additional cursor mobject at the end.\n\n    Parameters\n    ----------\n    time_per_char\n        Frequency of appearance of the letters.\n    cursor\n        :class:`~.Mobject` shown after the last added letter.\n    buff\n        Controls how far away the cursor is to the right of the last added letter.\n    keep_cursor_y\n        If ``True``, the cursor's y-coordinate is set to the center of the ``Text`` and remains the same throughout the animation. Otherwise, it is set to the center of the last added letter.\n    leave_cursor_on\n        Whether to show the cursor after the animation.\n\n    .. tip::\n        This is currently only possible for class:`~.Text` and not for class:`~.MathTex`.\n\n\n    Examples\n    --------\n\n    .. manim:: DeletingTextExample\n        :ref_classes: Blink\n\n        class DeletingTextExample(Scene):\n            def construct(self):\n                text = Text(\"Deleting\", color=PURPLE).scale(1.5).to_edge(LEFT)\n                cursor = Rectangle(\n                    color = GREY_A,\n                    fill_color = GREY_A,\n                    fill_opacity = 1.0,\n                    height = 1.1,\n                    width = 0.5,\n                ).move_to(text[0]) # Position the cursor\n\n                self.play(UntypeWithCursor(text, cursor))\n                self.play(Blink(cursor, blinks=2))\n\n    \"\"\"\n\n    def __init__(\n        self,\n        text: Text,\n        cursor: VMobject | None = None,\n        time_per_char: float = 0.1,\n        reverse_rate_function=True,\n        introducer=False,\n        remover=True,\n        **kwargs,\n    ) -> None:\n        super().__init__(\n            text,\n            cursor=cursor,\n            time_per_char=time_per_char,\n            reverse_rate_function=reverse_rate_function,\n            introducer=introducer,\n            remover=remover,\n            **kwargs,\n        )", "code_sha1": "d793727b2957fdd5b1f75ef55901fb8dd8960657"}
{"url": "https://docs.manim.community/en/stable/_modules/manim/animation/fading.html", "depth": 2, "instruction": "The scene displays the text \"Fade In\" scaling down to 66% while fading in from below, followed by a smooth transition to \"Fade Out.\" Finally, \"Fade Out\" scales up to 150% and fades out, moving downwards. The animations occur sequentially, creating a dynamic visual effect.", "code": "\"\"\"Fading in and out of view.\n\n.. manim:: Fading\n\n    class Fading(Scene):\n        def construct(self):\n            tex_in = Tex(\"Fade\", \"In\").scale(3)\n            tex_out = Tex(\"Fade\", \"Out\").scale(3)\n            self.play(FadeIn(tex_in, shift=DOWN, scale=0.66))\n            self.play(ReplacementTransform(tex_in, tex_out))\n            self.play(FadeOut(tex_out, shift=DOWN * 2, scale=1.5))\n\n\"\"\"\n\nfrom __future__ import annotations\n\n__all__ = [\n    \"FadeOut\",\n    \"FadeIn\",\n]\n\nimport numpy as np\n\nfrom manim.mobject.opengl.opengl_mobject import OpenGLMobject\n\nfrom ..animation.transform import Transform\nfrom ..constants import ORIGIN\nfrom ..mobject.mobject import Group, Mobject\nfrom ..scene.scene import Scene\n\n\nclass _Fade(Transform):\n    \"\"\"Fade :class:`~.Mobject` s in or out.\n\n    Parameters\n    ----------\n    mobjects\n        The mobjects to be faded.\n    shift\n        The vector by which the mobject shifts while being faded.\n    target_position\n        The position to/from which the mobject moves while being faded in. In case\n        another mobject is given as target position, its center is used.\n    scale\n        The factor by which the mobject is scaled initially before being rescaling to\n        its original size while being faded in.\n\n    \"\"\"\n\n    def __init__(\n        self,\n        *mobjects: Mobject,\n        shift: np.ndarray | None = None,\n        target_position: np.ndarray | Mobject | None = None,\n        scale: float = 1,\n        **kwargs,\n    ) -> None:\n        if not mobjects:\n            raise ValueError(\"At least one mobject must be passed.\")\n        mobject = mobjects[0] if len(mobjects) == 1 else Group(*mobjects)\n\n        self.point_target = False\n        if shift is None:\n            if target_position is not None:\n                if isinstance(target_position, (Mobject, OpenGLMobject)):\n                    target_position = target_position.get_center()\n                shift = target_position - mobject.get_center()\n                self.point_target = True\n            else:\n                shift = ORIGIN\n        self.shift_vector = shift\n        self.scale_factor = scale\n        super().__init__(mobject, **kwargs)\n\n    def _create_faded_mobject(self, fadeIn: bool) -> Mobject:\n        \"\"\"Create a faded, shifted and scaled copy of the mobject.\n\n        Parameters\n        ----------\n        fadeIn\n            Whether the faded mobject is used to fade in.\n\n        Returns\n        -------\n        Mobject\n            The faded, shifted and scaled copy of the mobject.\n        \"\"\"\n        faded_mobject = self.mobject.copy()\n        faded_mobject.fade(1)\n        direction_modifier = -1 if fadeIn and not self.point_target else 1\n        faded_mobject.shift(self.shift_vector * direction_modifier)\n        faded_mobject.scale(self.scale_factor)\n        return faded_mobject\n\n\n\n[docs]\nclass FadeIn(_Fade):\n    r\"\"\"Fade in :class:`~.Mobject` s.\n\n    Parameters\n    ----------\n    mobjects\n        The mobjects to be faded in.\n    shift\n        The vector by which the mobject shifts while being faded in.\n    target_position\n        The position from which the mobject starts while being faded in. In case\n        another mobject is given as target position, its center is used.\n    scale\n        The factor by which the mobject is scaled initially before being rescaling to\n        its original size while being faded in.\n\n    Examples\n    --------\n\n    .. manim :: FadeInExample\n\n        class FadeInExample(Scene):\n            def construct(self):\n                dot = Dot(UP * 2 + LEFT)\n                self.add(dot)\n                tex = Tex(\n                    \"FadeIn with \", \"shift \", r\" or target\\_position\", \" and scale\"\n                ).scale(1)\n                animations = [\n                    FadeIn(tex[0]),\n                    FadeIn(tex[1], shift=DOWN),\n                    FadeIn(tex[2], target_position=dot),\n                    FadeIn(tex[3], scale=1.5),\n                ]\n                self.play(AnimationGroup(*animations, lag_ratio=0.5))\n\n    \"\"\"\n\n    def __init__(self, *mobjects: Mobject, **kwargs) -> None:\n        super().__init__(*mobjects, introducer=True, **kwargs)\n\n    def create_target(self):\n        return self.mobject\n\n    def create_starting_mobject(self):\n        return self._create_faded_mobject(fadeIn=True)\n\n\n\n\n[docs]\nclass FadeOut(_Fade):\n    r\"\"\"Fade out :class:`~.Mobject` s.\n\n    Parameters\n    ----------\n    mobjects\n        The mobjects to be faded out.\n    shift\n        The vector by which the mobject shifts while being faded out.\n    target_position\n        The position to which the mobject moves while being faded out. In case another\n        mobject is given as target position, its center is used.\n    scale\n        The factor by which the mobject is scaled while being faded out.\n\n    Examples\n    --------\n\n    .. manim :: FadeInExample\n\n        class FadeInExample(Scene):\n            def construct(self):\n                dot = Dot(UP * 2 + LEFT)\n                self.add(dot)\n                tex = Tex(\n                    \"FadeOut with \", \"shift \", r\" or target\\_position\", \" and scale\"\n                ).scale(1)\n                animations = [\n                    FadeOut(tex[0]),\n                    FadeOut(tex[1], shift=DOWN),\n                    FadeOut(tex[2], target_position=dot),\n                    FadeOut(tex[3], scale=0.5),\n                ]\n                self.play(AnimationGroup(*animations, lag_ratio=0.5))\n\n\n    \"\"\"\n\n    def __init__(self, *mobjects: Mobject, **kwargs) -> None:\n        super().__init__(*mobjects, remover=True, **kwargs)\n\n    def create_target(self):\n        return self._create_faded_mobject(fadeIn=False)\n\n\n[docs]\n    def clean_up_from_scene(self, scene: Scene = None) -> None:\n        super().clean_up_from_scene(scene)\n        self.interpolate(0)", "code_sha1": "d8ff61fcf899b21d3ab8bfe1a0b7bae45066100d"}
{"url": "https://docs.manim.community/en/stable/_modules/manim/animation/growing.html", "depth": 2, "instruction": "The scene displays a square, circle, triangle, arrow, and star, arranged in two horizontal groups. The square grows from its origin, the circle from its center, the triangle from its bottom edge, the arrow grows from its start, and the star spins in from nothing, all with distinct animations and timing.", "code": "\"\"\"Animations that introduce mobjects to scene by growing them from points.\n\n.. manim:: Growing\n\n    class Growing(Scene):\n        def construct(self):\n            square = Square()\n            circle = Circle()\n            triangle = Triangle()\n            arrow = Arrow(LEFT, RIGHT)\n            star = Star()\n\n            VGroup(square, circle, triangle).set_x(0).arrange(buff=1.5).set_y(2)\n            VGroup(arrow, star).move_to(DOWN).set_x(0).arrange(buff=1.5).set_y(-2)\n\n            self.play(GrowFromPoint(square, ORIGIN))\n            self.play(GrowFromCenter(circle))\n            self.play(GrowFromEdge(triangle, DOWN))\n            self.play(GrowArrow(arrow))\n            self.play(SpinInFromNothing(star))\n\n\"\"\"\n\nfrom __future__ import annotations\n\n__all__ = [\n    \"GrowFromPoint\",\n    \"GrowFromCenter\",\n    \"GrowFromEdge\",\n    \"GrowArrow\",\n    \"SpinInFromNothing\",\n]\n\nimport typing\n\nimport numpy as np\n\nfrom ..animation.transform import Transform\nfrom ..constants import PI\nfrom ..utils.paths import spiral_path\n\nif typing.TYPE_CHECKING:\n    from manim.mobject.geometry.line import Arrow\n\n    from ..mobject.mobject import Mobject\n\n\n\n[docs]\nclass GrowFromPoint(Transform):\n    \"\"\"Introduce an :class:`~.Mobject` by growing it from a point.\n\n    Parameters\n    ----------\n    mobject\n        The mobjects to be introduced.\n    point\n        The point from which the mobject grows.\n    point_color\n        Initial color of the mobject before growing to its full size. Leave empty to match mobject's color.\n\n    Examples\n    --------\n\n    .. manim :: GrowFromPointExample\n\n        class GrowFromPointExample(Scene):\n            def construct(self):\n                dot = Dot(3 * UR, color=GREEN)\n                squares = [Square() for _ in range(4)]\n                VGroup(*squares).set_x(0).arrange(buff=1)\n                self.add(dot)\n                self.play(GrowFromPoint(squares[0], ORIGIN))\n                self.play(GrowFromPoint(squares[1], [-2, 2, 0]))\n                self.play(GrowFromPoint(squares[2], [3, -2, 0], RED))\n                self.play(GrowFromPoint(squares[3], dot, dot.get_color()))\n\n    \"\"\"\n\n    def __init__(\n        self, mobject: Mobject, point: np.ndarray, point_color: str = None, **kwargs\n    ) -> None:\n        self.point = point\n        self.point_color = point_color\n        super().__init__(mobject, introducer=True, **kwargs)\n\n    def create_target(self) -> Mobject:\n        return self.mobject\n\n    def create_starting_mobject(self) -> Mobject:\n        start = super().create_starting_mobject()\n        start.scale(0)\n        start.move_to(self.point)\n        if self.point_color:\n            start.set_color(self.point_color)\n        return start\n\n\n\n\n[docs]\nclass GrowFromCenter(GrowFromPoint):\n    \"\"\"Introduce an :class:`~.Mobject` by growing it from its center.\n\n    Parameters\n    ----------\n    mobject\n        The mobjects to be introduced.\n    point_color\n        Initial color of the mobject before growing to its full size. Leave empty to match mobject's color.\n\n    Examples\n    --------\n\n    .. manim :: GrowFromCenterExample\n\n        class GrowFromCenterExample(Scene):\n            def construct(self):\n                squares = [Square() for _ in range(2)]\n                VGroup(*squares).set_x(0).arrange(buff=2)\n                self.play(GrowFromCenter(squares[0]))\n                self.play(GrowFromCenter(squares[1], point_color=RED))\n\n    \"\"\"\n\n    def __init__(self, mobject: Mobject, point_color: str = None, **kwargs) -> None:\n        point = mobject.get_center()\n        super().__init__(mobject, point, point_color=point_color, **kwargs)\n\n\n\n\n[docs]\nclass GrowFromEdge(GrowFromPoint):\n    \"\"\"Introduce an :class:`~.Mobject` by growing it from one of its bounding box edges.\n\n    Parameters\n    ----------\n    mobject\n        The mobjects to be introduced.\n    edge\n        The direction to seek bounding box edge of mobject.\n    point_color\n        Initial color of the mobject before growing to its full size. Leave empty to match mobject's color.\n\n    Examples\n    --------\n\n    .. manim :: GrowFromEdgeExample\n\n        class GrowFromEdgeExample(Scene):\n            def construct(self):\n                squares = [Square() for _ in range(4)]\n                VGroup(*squares).set_x(0).arrange(buff=1)\n                self.play(GrowFromEdge(squares[0], DOWN))\n                self.play(GrowFromEdge(squares[1], RIGHT))\n                self.play(GrowFromEdge(squares[2], UR))\n                self.play(GrowFromEdge(squares[3], UP, point_color=RED))\n\n\n    \"\"\"\n\n    def __init__(\n        self, mobject: Mobject, edge: np.ndarray, point_color: str = None, **kwargs\n    ) -> None:\n        point = mobject.get_critical_point(edge)\n        super().__init__(mobject, point, point_color=point_color, **kwargs)\n\n\n\n\n[docs]\nclass GrowArrow(GrowFromPoint):\n    \"\"\"Introduce an :class:`~.Arrow` by growing it from its start toward its tip.\n\n    Parameters\n    ----------\n    arrow\n        The arrow to be introduced.\n    point_color\n        Initial color of the arrow before growing to its full size. Leave empty to match arrow's color.\n\n    Examples\n    --------\n\n    .. manim :: GrowArrowExample\n\n        class GrowArrowExample(Scene):\n            def construct(self):\n                arrows = [Arrow(2 * LEFT, 2 * RIGHT), Arrow(2 * DR, 2 * UL)]\n                VGroup(*arrows).set_x(0).arrange(buff=2)\n                self.play(GrowArrow(arrows[0]))\n                self.play(GrowArrow(arrows[1], point_color=RED))\n\n    \"\"\"\n\n    def __init__(self, arrow: Arrow, point_color: str = None, **kwargs) -> None:\n        point = arrow.get_start()\n        super().__init__(arrow, point, point_color=point_color, **kwargs)\n\n    def create_starting_mobject(self) -> Mobject:\n        start_arrow = self.mobject.copy()\n        start_arrow.scale(0, scale_tips=True, about_point=self.point)\n        if self.point_color:\n            start_arrow.set_color(self.point_color)\n        return start_arrow\n\n\n\n\n[docs]\nclass SpinInFromNothing(GrowFromCenter):\n    \"\"\"Introduce an :class:`~.Mobject` spinning and growing it from its center.\n\n    Parameters\n    ----------\n    mobject\n        The mobjects to be introduced.\n    angle\n        The amount of spinning before mobject reaches its full size. E.g. 2*PI means\n        that the object will do one full spin before being fully introduced.\n    point_color\n        Initial color of the mobject before growing to its full size. Leave empty to match mobject's color.\n\n    Examples\n    --------\n\n    .. manim :: SpinInFromNothingExample\n\n        class SpinInFromNothingExample(Scene):\n            def construct(self):\n                squares = [Square() for _ in range(3)]\n                VGroup(*squares).set_x(0).arrange(buff=2)\n                self.play(SpinInFromNothing(squares[0]))\n                self.play(SpinInFromNothing(squares[1], angle=2 * PI))\n                self.play(SpinInFromNothing(squares[2], point_color=RED))\n\n    \"\"\"\n\n    def __init__(\n        self, mobject: Mobject, angle: float = PI / 2, point_color: str = None, **kwargs\n    ) -> None:\n        self.angle = angle\n        super().__init__(\n            mobject, path_func=spiral_path(angle), point_color=point_color, **kwargs\n        )", "code_sha1": "1a34c49fff2b3e3ebf3f14b5ec25d25522bcaab6"}
{"url": "https://docs.manim.community/en/stable/_modules/manim/animation/indication.html", "depth": 2, "instruction": "The scene displays a series of text labels, each undergoing different attention-drawing animations (Flash, ShowPassingFlash, ApplyWave, etc.) in sequence. Each label fades out while the next one fades in, with specific animations highlighting each label, such as scaling, color changes, or wiggling, creating a dynamic visual effect.", "code": "\"\"\"Animations drawing attention to particular mobjects.\n\nExamples\n--------\n\n.. manim:: Indications\n\n    class Indications(Scene):\n        def construct(self):\n            indications = [ApplyWave,Circumscribe,Flash,FocusOn,Indicate,ShowPassingFlash,Wiggle]\n            names = [Tex(i.__name__).scale(3) for i in indications]\n\n            self.add(names[0])\n            for i in range(len(names)):\n                if indications[i] is Flash:\n                    self.play(Flash(UP))\n                elif indications[i] is ShowPassingFlash:\n                    self.play(ShowPassingFlash(Underline(names[i])))\n                else:\n                    self.play(indications[i](names[i]))\n                self.play(AnimationGroup(\n                    FadeOut(names[i], shift=UP*1.5),\n                    FadeIn(names[(i+1)%len(names)], shift=UP*1.5),\n                ))\n\n\"\"\"\n\nfrom __future__ import annotations\n\n__all__ = [\n    \"FocusOn\",\n    \"Indicate\",\n    \"Flash\",\n    \"ShowPassingFlash\",\n    \"ShowPassingFlashWithThinningStrokeWidth\",\n    \"ApplyWave\",\n    \"Circumscribe\",\n    \"Wiggle\",\n    \"Blink\",\n]\n\nfrom collections.abc import Iterable\nfrom typing import Callable\n\nimport numpy as np\n\nfrom manim.mobject.geometry.arc import Circle, Dot\nfrom manim.mobject.geometry.line import Line\nfrom manim.mobject.geometry.polygram import Rectangle\nfrom manim.mobject.geometry.shape_matchers import SurroundingRectangle\nfrom manim.scene.scene import Scene\n\nfrom .. import config\nfrom ..animation.animation import Animation\nfrom ..animation.composition import AnimationGroup, Succession\nfrom ..animation.creation import Create, ShowPartial, Uncreate\nfrom ..animation.fading import FadeIn, FadeOut\nfrom ..animation.movement import Homotopy\nfrom ..animation.transform import Transform\nfrom ..animation.updaters.update import UpdateFromFunc\nfrom ..constants import *\nfrom ..mobject.mobject import Mobject\nfrom ..mobject.types.vectorized_mobject import VGroup, VMobject\nfrom ..utils.bezier import interpolate, inverse_interpolate\nfrom ..utils.color import GREY, YELLOW, ParsableManimColor\nfrom ..utils.rate_functions import smooth, there_and_back, wiggle\nfrom ..utils.space_ops import normalize\n\n\n\n[docs]\nclass FocusOn(Transform):\n    \"\"\"Shrink a spotlight to a position.\n\n    Parameters\n    ----------\n    focus_point\n        The point at which to shrink the spotlight. If it is a :class:`.~Mobject` its center will be used.\n    opacity\n        The opacity of the spotlight.\n    color\n        The color of the spotlight.\n    run_time\n        The duration of the animation.\n\n    Examples\n    --------\n    .. manim:: UsingFocusOn\n\n        class UsingFocusOn(Scene):\n            def construct(self):\n                dot = Dot(color=YELLOW).shift(DOWN)\n                self.add(Tex(\"Focusing on the dot below:\"), dot)\n                self.play(FocusOn(dot))\n                self.wait()\n    \"\"\"\n\n    def __init__(\n        self,\n        focus_point: np.ndarray | Mobject,\n        opacity: float = 0.2,\n        color: str = GREY,\n        run_time: float = 2,\n        **kwargs,\n    ) -> None:\n        self.focus_point = focus_point\n        self.color = color\n        self.opacity = opacity\n        remover = True\n        starting_dot = Dot(\n            radius=config[\"frame_x_radius\"] + config[\"frame_y_radius\"],\n            stroke_width=0,\n            fill_color=self.color,\n            fill_opacity=0,\n        )\n        super().__init__(starting_dot, run_time=run_time, remover=remover, **kwargs)\n\n    def create_target(self) -> Dot:\n        little_dot = Dot(radius=0)\n        little_dot.set_fill(self.color, opacity=self.opacity)\n        little_dot.add_updater(lambda d: d.move_to(self.focus_point))\n        return little_dot\n\n\n\n\n[docs]\nclass Indicate(Transform):\n    \"\"\"Indicate a Mobject by temporarily resizing and recoloring it.\n\n    Parameters\n    ----------\n    mobject\n        The mobject to indicate.\n    scale_factor\n        The factor by which the mobject will be temporally scaled\n    color\n        The color the mobject temporally takes.\n    rate_func\n        The function defining the animation progress at every point in time.\n    kwargs\n        Additional arguments to be passed to the :class:`~.Succession` constructor\n\n    Examples\n    --------\n    .. manim:: UsingIndicate\n\n        class UsingIndicate(Scene):\n            def construct(self):\n                tex = Tex(\"Indicate\").scale(3)\n                self.play(Indicate(tex))\n                self.wait()\n    \"\"\"\n\n    def __init__(\n        self,\n        mobject: Mobject,\n        scale_factor: float = 1.2,\n        color: str = YELLOW,\n        rate_func: Callable[[float, float | None], np.ndarray] = there_and_back,\n        **kwargs,\n    ) -> None:\n        self.color = color\n        self.scale_factor = scale_factor\n        super().__init__(mobject, rate_func=rate_func, **kwargs)\n\n    def create_target(self) -> Mobject:\n        target = self.mobject.copy()\n        target.scale(self.scale_factor)\n        target.set_color(self.color)\n        return target\n\n\n\n\n[docs]\nclass Flash(AnimationGroup):\n    \"\"\"Send out lines in all directions.\n\n    Parameters\n    ----------\n    point\n        The center of the flash lines. If it is a :class:`.~Mobject` its center will be used.\n    line_length\n        The length of the flash lines.\n    num_lines\n        The number of flash lines.\n    flash_radius\n        The distance from `point` at which the flash lines start.\n    line_stroke_width\n        The stroke width of the flash lines.\n    color\n        The color of the flash lines.\n    time_width\n        The time width used for the flash lines. See :class:`.~ShowPassingFlash` for more details.\n    run_time\n        The duration of the animation.\n    kwargs\n        Additional arguments to be passed to the :class:`~.Succession` constructor\n\n    Examples\n    --------\n    .. manim:: UsingFlash\n\n        class UsingFlash(Scene):\n            def construct(self):\n                dot = Dot(color=YELLOW).shift(DOWN)\n                self.add(Tex(\"Flash the dot below:\"), dot)\n                self.play(Flash(dot))\n                self.wait()\n\n    .. manim:: FlashOnCircle\n\n        class FlashOnCircle(Scene):\n            def construct(self):\n                radius = 2\n                circle = Circle(radius)\n                self.add(circle)\n                self.play(Flash(\n                    circle, line_length=1,\n                    num_lines=30, color=RED,\n                    flash_radius=radius+SMALL_BUFF,\n                    time_width=0.3, run_time=2,\n                    rate_func = rush_from\n                ))\n    \"\"\"\n\n    def __init__(\n        self,\n        point: np.ndarray | Mobject,\n        line_length: float = 0.2,\n        num_lines: int = 12,\n        flash_radius: float = 0.1,\n        line_stroke_width: int = 3,\n        color: str = YELLOW,\n        time_width: float = 1,\n        run_time: float = 1.0,\n        **kwargs,\n    ) -> None:\n        if isinstance(point, Mobject):\n            self.point = point.get_center()\n        else:\n            self.point = point\n        self.color = color\n        self.line_length = line_length\n        self.num_lines = num_lines\n        self.flash_radius = flash_radius\n        self.line_stroke_width = line_stroke_width\n        self.run_time = run_time\n        self.time_width = time_width\n        self.animation_config = kwargs\n\n        self.lines = self.create_lines()\n        animations = self.create_line_anims()\n        super().__init__(*animations, group=self.lines)\n\n    def create_lines(self) -> VGroup:\n        lines = VGroup()\n        for angle in np.arange(0, TAU, TAU / self.num_lines):\n            line = Line(self.point, self.point + self.line_length * RIGHT)\n            line.shift((self.flash_radius) * RIGHT)\n            line.rotate(angle, about_point=self.point)\n            lines.add(line)\n        lines.set_color(self.color)\n        lines.set_stroke(width=self.line_stroke_width)\n        return lines\n\n    def create_line_anims(self) -> Iterable[ShowPassingFlash]:\n        return [\n            ShowPassingFlash(\n                line,\n                time_width=self.time_width,\n                run_time=self.run_time,\n                **self.animation_config,\n            )\n            for line in self.lines\n        ]\n\n\n\n\n[docs]\nclass ShowPassingFlash(ShowPartial):\n    r\"\"\"Show only a sliver of the VMobject each frame.\n\n    Parameters\n    ----------\n    mobject\n        The mobject whose stroke is animated.\n    time_width\n        The length of the sliver relative to the length of the stroke.\n\n    Examples\n    --------\n    .. manim:: TimeWidthValues\n\n        class TimeWidthValues(Scene):\n            def construct(self):\n                p = RegularPolygon(5, color=DARK_GRAY, stroke_width=6).scale(3)\n                lbl = VMobject()\n                self.add(p, lbl)\n                p = p.copy().set_color(BLUE)\n                for time_width in [0.2, 0.5, 1, 2]:\n                    lbl.become(Tex(r\"\\texttt{time\\_width={{%.1f}}}\"%time_width))\n                    self.play(ShowPassingFlash(\n                        p.copy().set_color(BLUE),\n                        run_time=2,\n                        time_width=time_width\n                    ))\n\n    See Also\n    --------\n    :class:`~.Create`\n\n    \"\"\"\n\n    def __init__(self, mobject: VMobject, time_width: float = 0.1, **kwargs) -> None:\n        self.time_width = time_width\n        super().__init__(mobject, remover=True, introducer=True, **kwargs)\n\n    def _get_bounds(self, alpha: float) -> tuple[float]:\n        tw = self.time_width\n        upper = interpolate(0, 1 + tw, alpha)\n        lower = upper - tw\n        upper = min(upper, 1)\n        lower = max(lower, 0)\n        return (lower, upper)\n\n\n[docs]\n    def clean_up_from_scene(self, scene: Scene) -> None:\n        super().clean_up_from_scene(scene)\n        for submob, start in self.get_all_families_zipped():\n            submob.pointwise_become_partial(start, 0, 1)\n\n\n\n\n\n[docs]\nclass ShowPassingFlashWithThinningStrokeWidth(AnimationGroup):\n    def __init__(self, vmobject, n_segments=10, time_width=0.1, remover=True, **kwargs):\n        self.n_segments = n_segments\n        self.time_width = time_width\n        self.remover = remover\n        max_stroke_width = vmobject.get_stroke_width()\n        max_time_width = kwargs.pop(\"time_width\", self.time_width)\n        super().__init__(\n            *(\n                ShowPassingFlash(\n                    vmobject.copy().set_stroke(width=stroke_width),\n                    time_width=time_width,\n                    **kwargs,\n                )\n                for stroke_width, time_width in zip(\n                    np.linspace(0, max_stroke_width, self.n_segments),\n                    np.linspace(max_time_width, 0, self.n_segments),\n                )\n            ),\n        )\n\n\n\n\n[docs]\nclass ApplyWave(Homotopy):\n    \"\"\"Send a wave through the Mobject distorting it temporarily.\n\n    Parameters\n    ----------\n    mobject\n        The mobject to be distorted.\n    direction\n        The direction in which the wave nudges points of the shape\n    amplitude\n        The distance points of the shape get shifted\n    wave_func\n        The function defining the shape of one wave flank.\n    time_width\n        The length of the wave relative to the width of the mobject.\n    ripples\n        The number of ripples of the wave\n    run_time\n        The duration of the animation.\n\n    Examples\n    --------\n\n    .. manim:: ApplyingWaves\n\n        class ApplyingWaves(Scene):\n            def construct(self):\n                tex = Tex(\"WaveWaveWaveWaveWave\").scale(2)\n                self.play(ApplyWave(tex))\n                self.play(ApplyWave(\n                    tex,\n                    direction=RIGHT,\n                    time_width=0.5,\n                    amplitude=0.3\n                ))\n                self.play(ApplyWave(\n                    tex,\n                    rate_func=linear,\n                    ripples=4\n                ))\n\n    \"\"\"\n\n    def __init__(\n        self,\n        mobject: Mobject,\n        direction: np.ndarray = UP,\n        amplitude: float = 0.2,\n        wave_func: Callable[[float], float] = smooth,\n        time_width: float = 1,\n        ripples: int = 1,\n        run_time: float = 2,\n        **kwargs,\n    ) -> None:\n        x_min = mobject.get_left()[0]\n        x_max = mobject.get_right()[0]\n        vect = amplitude * normalize(direction)\n\n        def wave(t):\n            # Creates a wave with n ripples from a simple rate_func\n            # This wave is build up as follows:\n            # The time is split into 2*ripples phases. In every phase the amplitude\n            # either rises to one or goes down to zero. Consecutive ripples will have\n            # their amplitudes in opposing directions (first ripple from 0 to 1 to 0,\n            # second from 0 to -1 to 0 and so on). This is how two ripples would be\n            # divided into phases:\n\n            #         ####|####        |            |\n            #       ##    |    ##      |            |\n            #     ##      |      ##    |            |\n            # ####        |        ####|####        |        ####\n            #             |            |    ##      |      ##\n            #             |            |      ##    |    ##\n            #             |            |        ####|####\n\n            # However, this looks weird in the middle between two ripples. Therefore the\n            # middle phases do actually use only one appropriately scaled version of the\n            # rate like this:\n\n            # 1 / 4 Time  | 2 / 4 Time            | 1 / 4 Time\n            #         ####|######                 |\n            #       ##    |      ###              |\n            #     ##      |         ##            |\n            # ####        |           #           |        ####\n            #             |            ##         |      ##\n            #             |              ###      |    ##\n            #             |                 ######|####\n\n            # Mirrored looks better in the way the wave is used.\n            t = 1 - t\n\n            # Clamp input\n            if t >= 1 or t <= 0:\n                return 0\n\n            phases = ripples * 2\n            phase = int(t * phases)\n            if phase == 0:\n                # First rising ripple\n                return wave_func(t * phases)\n            elif phase == phases - 1:\n                # last ripple. Rising or falling depending on the number of ripples\n                # The (ripples % 2)-term is used to make this distinction.\n                t -= phase / phases  # Time relative to the phase\n                return (1 - wave_func(t * phases)) * (2 * (ripples % 2) - 1)\n            else:\n                # Longer phases:\n                phase = int((phase - 1) / 2)\n                t -= (2 * phase + 1) / phases\n\n                # Similar to last ripple:\n                return (1 - 2 * wave_func(t * ripples)) * (1 - 2 * ((phase) % 2))\n\n        def homotopy(\n            x: float,\n            y: float,\n            z: float,\n            t: float,\n        ) -> tuple[float, float, float]:\n            upper = interpolate(0, 1 + time_width, t)\n            lower = upper - time_width\n            relative_x = inverse_interpolate(x_min, x_max, x)\n            wave_phase = inverse_interpolate(lower, upper, relative_x)\n            nudge = wave(wave_phase) * vect\n            return np.array([x, y, z]) + nudge\n\n        super().__init__(homotopy, mobject, run_time=run_time, **kwargs)\n\n\n\n\n[docs]\nclass Wiggle(Animation):\n    \"\"\"Wiggle a Mobject.\n\n    Parameters\n    ----------\n    mobject\n        The mobject to wiggle.\n    scale_value\n        The factor by which the mobject will be temporarily scaled.\n    rotation_angle\n        The wiggle angle.\n    n_wiggles\n        The number of wiggles.\n    scale_about_point\n        The point about which the mobject gets scaled.\n    rotate_about_point\n        The point around which the mobject gets rotated.\n    run_time\n        The duration of the animation\n\n    Examples\n    --------\n\n    .. manim:: ApplyingWaves\n\n        class ApplyingWaves(Scene):\n            def construct(self):\n                tex = Tex(\"Wiggle\").scale(3)\n                self.play(Wiggle(tex))\n                self.wait()\n\n    \"\"\"\n\n    def __init__(\n        self,\n        mobject: Mobject,\n        scale_value: float = 1.1,\n        rotation_angle: float = 0.01 * TAU,\n        n_wiggles: int = 6,\n        scale_about_point: np.ndarray | None = None,\n        rotate_about_point: np.ndarray | None = None,\n        run_time: float = 2,\n        **kwargs,\n    ) -> None:\n        self.scale_value = scale_value\n        self.rotation_angle = rotation_angle\n        self.n_wiggles = n_wiggles\n        self.scale_about_point = scale_about_point\n        self.rotate_about_point = rotate_about_point\n        super().__init__(mobject, run_time=run_time, **kwargs)\n\n    def get_scale_about_point(self) -> np.ndarray:\n        if self.scale_about_point is None:\n            return self.mobject.get_center()\n        return self.scale_about_point\n\n    def get_rotate_about_point(self) -> np.ndarray:\n        if self.rotate_about_point is None:\n            return self.mobject.get_center()\n        return self.rotate_about_point\n\n    def interpolate_submobject(\n        self,\n        submobject: Mobject,\n        starting_submobject: Mobject,\n        alpha: float,\n    ) -> None:\n        submobject.points[:, :] = starting_submobject.points\n        submobject.scale(\n            interpolate(1, self.scale_value, there_and_back(alpha)),\n            about_point=self.get_scale_about_point(),\n        )\n        submobject.rotate(\n            wiggle(alpha, self.n_wiggles) * self.rotation_angle,\n            about_point=self.get_rotate_about_point(),\n        )\n\n\n\n\n[docs]\nclass Circumscribe(Succession):\n    r\"\"\"Draw a temporary line surrounding the mobject.\n\n    Parameters\n    ----------\n    mobject\n        The mobject to be circumscribed.\n    shape\n        The shape with which to surround the given mobject. Should be either\n        :class:`~.Rectangle` or :class:`~.Circle`\n    fade_in\n        Whether to make the surrounding shape to fade in. It will be drawn otherwise.\n    fade_out\n        Whether to make the surrounding shape to fade out. It will be undrawn otherwise.\n    time_width\n        The time_width of the drawing and undrawing. Gets ignored if either `fade_in` or `fade_out` is `True`.\n    buff\n        The distance between the surrounding shape and the given mobject.\n    color\n        The color of the surrounding shape.\n    run_time\n        The duration of the entire animation.\n    kwargs\n        Additional arguments to be passed to the :class:`~.Succession` constructor\n\n    Examples\n    --------\n\n    .. manim:: UsingCircumscribe\n\n        class UsingCircumscribe(Scene):\n            def construct(self):\n                lbl = Tex(r\"Circum-\\\\scribe\").scale(2)\n                self.add(lbl)\n                self.play(Circumscribe(lbl))\n                self.play(Circumscribe(lbl, Circle))\n                self.play(Circumscribe(lbl, fade_out=True))\n                self.play(Circumscribe(lbl, time_width=2))\n                self.play(Circumscribe(lbl, Circle, True))\n\n    \"\"\"\n\n    def __init__(\n        self,\n        mobject: Mobject,\n        shape: type = Rectangle,\n        fade_in=False,\n        fade_out=False,\n        time_width=0.3,\n        buff: float = SMALL_BUFF,\n        color: ParsableManimColor = YELLOW,\n        run_time=1,\n        stroke_width=DEFAULT_STROKE_WIDTH,\n        **kwargs,\n    ):\n        if shape is Rectangle:\n            frame = SurroundingRectangle(\n                mobject,\n                color=color,\n                buff=buff,\n                stroke_width=stroke_width,\n            )\n        elif shape is Circle:\n            frame = Circle(color=color, stroke_width=stroke_width).surround(\n                mobject,\n                buffer_factor=1,\n            )\n            radius = frame.width / 2\n            frame.scale((radius + buff) / radius)\n        else:\n            raise ValueError(\"shape should be either Rectangle or Circle.\")\n\n        if fade_in and fade_out:\n            super().__init__(\n                FadeIn(frame, run_time=run_time / 2),\n                FadeOut(frame, run_time=run_time / 2),\n                **kwargs,\n            )\n        elif fade_in:\n            frame.reverse_direction()\n            super().__init__(\n                FadeIn(frame, run_time=run_time / 2),\n                Uncreate(frame, run_time=run_time / 2),\n                **kwargs,\n            )\n        elif fade_out:\n            super().__init__(\n                Create(frame, run_time=run_time / 2),\n                FadeOut(frame, run_time=run_time / 2),\n                **kwargs,\n            )\n        else:\n            super().__init__(\n                ShowPassingFlash(frame, time_width, run_time=run_time), **kwargs\n            )\n\n\n\n\n[docs]\nclass Blink(Succession):\n    \"\"\"Blink the mobject.\n\n    Parameters\n    ----------\n    mobject\n        The mobject to be blinked.\n    time_on\n        The duration that the mobject is shown for one blink.\n    time_off\n        The duration that the mobject is hidden for one blink.\n    blinks\n        The number of blinks\n    hide_at_end\n        Whether to hide the mobject at the end of the animation.\n    kwargs\n        Additional arguments to be passed to the :class:`~.Succession` constructor.\n\n    Examples\n    --------\n\n    .. manim:: BlinkingExample\n\n        class BlinkingExample(Scene):\n            def construct(self):\n                text = Text(\"Blinking\").scale(1.5)\n                self.add(text)\n                self.play(Blink(text, blinks=3))\n\n    \"\"\"\n\n    def __init__(\n        self,\n        mobject: Mobject,\n        time_on: float = 0.5,\n        time_off: float = 0.5,\n        blinks: int = 1,\n        hide_at_end: bool = False,\n        **kwargs,\n    ):\n        animations = [\n            UpdateFromFunc(\n                mobject,\n                update_function=lambda mob: mob.set_opacity(1.0),\n                run_time=time_on,\n            ),\n            UpdateFromFunc(\n                mobject,\n                update_function=lambda mob: mob.set_opacity(0.0),\n                run_time=time_off,\n            ),\n        ] * blinks\n\n        if not hide_at_end:\n            animations.append(\n                UpdateFromFunc(\n                    mobject,\n                    update_function=lambda mob: mob.set_opacity(1.0),\n                    run_time=time_on,\n                ),\n            )\n\n        super().__init__(*animations, **kwargs)", "code_sha1": "17db2f56e03c9cbe3fb829fa2f05f8faf2c9a493"}
{"url": "https://docs.manim.community/en/stable/_modules/manim/animation/movement.html", "depth": 2, "instruction": "A square morphs into a wavy shape over 2 seconds, with vertical oscillations influenced by a sine function. The animation progresses smoothly, showcasing the transformation as the parameter \\( t \\) varies from 0 to 1, creating a dynamic visual effect.", "code": "\"\"\"Animations related to movement.\"\"\"\n\nfrom __future__ import annotations\n\n__all__ = [\n    \"Homotopy\",\n    \"SmoothedVectorizedHomotopy\",\n    \"ComplexHomotopy\",\n    \"PhaseFlow\",\n    \"MoveAlongPath\",\n]\n\nfrom typing import TYPE_CHECKING, Any, Callable\n\nimport numpy as np\n\nfrom ..animation.animation import Animation\nfrom ..utils.rate_functions import linear\n\nif TYPE_CHECKING:\n    from ..mobject.mobject import Mobject, VMobject\n\n\n\n[docs]\nclass Homotopy(Animation):\n    \"\"\"A Homotopy.\n\n    This is an animation transforming the points of a mobject according\n    to the specified transformation function. With the parameter :math:`t`\n    moving from 0 to 1 throughout the animation and :math:`(x, y, z)`\n    describing the coordinates of the point of a mobject,\n    the function passed to the ``homotopy`` keyword argument should\n    transform the tuple :math:`(x, y, z, t)` to :math:`(x', y', z')`,\n    the coordinates the original point is transformed to at time :math:`t`.\n\n    Parameters\n    ----------\n    homotopy\n        A function mapping :math:`(x, y, z, t)` to :math:`(x', y', z')`.\n    mobject\n        The mobject transformed under the given homotopy.\n    run_time\n        The run time of the animation.\n    apply_function_kwargs\n        Keyword arguments propagated to :meth:`.Mobject.apply_function`.\n    kwargs\n        Further keyword arguments passed to the parent class.\n\n    Examples\n    --------\n\n    .. manim:: HomotopyExample\n\n        class HomotopyExample(Scene):\n            def construct(self):\n                square = Square()\n\n                def homotopy(x, y, z, t):\n                    if t <= 0.25:\n                        progress = t / 0.25\n                        return (x, y + progress * 0.2 * np.sin(x), z)\n                    else:\n                        wave_progress = (t - 0.25) / 0.75\n                        return (x, y + 0.2 * np.sin(x + 10 * wave_progress), z)\n\n                self.play(Homotopy(homotopy, square, rate_func= linear, run_time=2))\n\n    \"\"\"\n\n    def __init__(\n        self,\n        homotopy: Callable[[float, float, float, float], tuple[float, float, float]],\n        mobject: Mobject,\n        run_time: float = 3,\n        apply_function_kwargs: dict[str, Any] | None = None,\n        **kwargs,\n    ) -> None:\n        self.homotopy = homotopy\n        self.apply_function_kwargs = (\n            apply_function_kwargs if apply_function_kwargs is not None else {}\n        )\n        super().__init__(mobject, run_time=run_time, **kwargs)\n\n    def function_at_time_t(self, t: float) -> tuple[float, float, float]:\n        return lambda p: self.homotopy(*p, t)\n\n    def interpolate_submobject(\n        self,\n        submobject: Mobject,\n        starting_submobject: Mobject,\n        alpha: float,\n    ) -> None:\n        submobject.points = starting_submobject.points\n        submobject.apply_function(\n            self.function_at_time_t(alpha), **self.apply_function_kwargs\n        )\n\n\n\n\n[docs]\nclass SmoothedVectorizedHomotopy(Homotopy):\n    def interpolate_submobject(\n        self,\n        submobject: Mobject,\n        starting_submobject: Mobject,\n        alpha: float,\n    ) -> None:\n        super().interpolate_submobject(submobject, starting_submobject, alpha)\n        submobject.make_smooth()\n\n\n\n\n[docs]\nclass ComplexHomotopy(Homotopy):\n    def __init__(\n        self, complex_homotopy: Callable[[complex], float], mobject: Mobject, **kwargs\n    ) -> None:\n        \"\"\"Complex Homotopy a function Cx[0, 1] to C\"\"\"\n\n        def homotopy(\n            x: float,\n            y: float,\n            z: float,\n            t: float,\n        ) -> tuple[float, float, float]:\n            c = complex_homotopy(complex(x, y), t)\n            return (c.real, c.imag, z)\n\n        super().__init__(homotopy, mobject, **kwargs)\n\n\n\n\n[docs]\nclass PhaseFlow(Animation):\n    def __init__(\n        self,\n        function: Callable[[np.ndarray], np.ndarray],\n        mobject: Mobject,\n        virtual_time: float = 1,\n        suspend_mobject_updating: bool = False,\n        rate_func: Callable[[float], float] = linear,\n        **kwargs,\n    ) -> None:\n        self.virtual_time = virtual_time\n        self.function = function\n        super().__init__(\n            mobject,\n            suspend_mobject_updating=suspend_mobject_updating,\n            rate_func=rate_func,\n            **kwargs,\n        )\n\n\n[docs]\n    def interpolate_mobject(self, alpha: float) -> None:\n        if hasattr(self, \"last_alpha\"):\n            dt = self.virtual_time * (\n                self.rate_func(alpha) - self.rate_func(self.last_alpha)\n            )\n            self.mobject.apply_function(lambda p: p + dt * self.function(p))\n        self.last_alpha = alpha\n\n\n\n\n\n[docs]\nclass MoveAlongPath(Animation):\n    \"\"\"Make one mobject move along the path of another mobject.\n\n    .. manim:: MoveAlongPathExample\n\n        class MoveAlongPathExample(Scene):\n            def construct(self):\n                d1 = Dot().set_color(ORANGE)\n                l1 = Line(LEFT, RIGHT)\n                l2 = VMobject()\n                self.add(d1, l1, l2)\n                l2.add_updater(lambda x: x.become(Line(LEFT, d1.get_center()).set_color(ORANGE)))\n                self.play(MoveAlongPath(d1, l1), rate_func=linear)\n    \"\"\"\n\n    def __init__(\n        self,\n        mobject: Mobject,\n        path: VMobject,\n        suspend_mobject_updating: bool | None = False,\n        **kwargs,\n    ) -> None:\n        self.path = path\n        super().__init__(\n            mobject, suspend_mobject_updating=suspend_mobject_updating, **kwargs\n        )\n\n\n[docs]\n    def interpolate_mobject(self, alpha: float) -> None:\n        point = self.path.point_from_proportion(self.rate_func(alpha))\n        self.mobject.move_to(point)", "code_sha1": "99f89189fa889227efca1c229444db29d88d2e0f"}
{"url": "https://docs.manim.community/en/stable/_modules/manim/animation/rotation.html", "depth": 2, "instruction": "The code defines two rotation animations for Mobjects: `Rotating` and `Rotate`. Both allow for customizable rotation around specified axes and points, with adjustable angles and durations. The animations smoothly transition the Mobject's position over time, utilizing a linear rate function for consistent speed.", "code": "\"\"\"Animations related to rotation.\"\"\"\n\nfrom __future__ import annotations\n\n__all__ = [\"Rotating\", \"Rotate\"]\n\nfrom collections.abc import Sequence\nfrom typing import TYPE_CHECKING, Callable\n\nimport numpy as np\n\nfrom ..animation.animation import Animation\nfrom ..animation.transform import Transform\nfrom ..constants import OUT, PI, TAU\nfrom ..utils.rate_functions import linear\n\nif TYPE_CHECKING:\n    from ..mobject.mobject import Mobject\n\n\n\n[docs]\nclass Rotating(Animation):\n    def __init__(\n        self,\n        mobject: Mobject,\n        axis: np.ndarray = OUT,\n        radians: np.ndarray = TAU,\n        about_point: np.ndarray | None = None,\n        about_edge: np.ndarray | None = None,\n        run_time: float = 5,\n        rate_func: Callable[[float], float] = linear,\n        **kwargs,\n    ) -> None:\n        self.axis = axis\n        self.radians = radians\n        self.about_point = about_point\n        self.about_edge = about_edge\n        super().__init__(mobject, run_time=run_time, rate_func=rate_func, **kwargs)\n\n\n[docs]\n    def interpolate_mobject(self, alpha: float) -> None:\n        self.mobject.become(self.starting_mobject)\n        self.mobject.rotate(\n            self.rate_func(alpha) * self.radians,\n            axis=self.axis,\n            about_point=self.about_point,\n            about_edge=self.about_edge,\n        )\n\n\n\n\n\n[docs]\nclass Rotate(Transform):\n    \"\"\"Animation that rotates a Mobject.\n\n    Parameters\n    ----------\n    mobject\n        The mobject to be rotated.\n    angle\n        The rotation angle.\n    axis\n        The rotation axis as a numpy vector.\n    about_point\n        The rotation center.\n    about_edge\n        If ``about_point`` is ``None``, this argument specifies\n        the direction of the bounding box point to be taken as\n        the rotation center.\n\n    Examples\n    --------\n    .. manim:: UsingRotate\n\n        class UsingRotate(Scene):\n            def construct(self):\n                self.play(\n                    Rotate(\n                        Square(side_length=0.5).shift(UP * 2),\n                        angle=2*PI,\n                        about_point=ORIGIN,\n                        rate_func=linear,\n                    ),\n                    Rotate(Square(side_length=0.5), angle=2*PI, rate_func=linear),\n                    )\n\n    \"\"\"\n\n    def __init__(\n        self,\n        mobject: Mobject,\n        angle: float = PI,\n        axis: np.ndarray = OUT,\n        about_point: Sequence[float] | None = None,\n        about_edge: Sequence[float] | None = None,\n        **kwargs,\n    ) -> None:\n        if \"path_arc\" not in kwargs:\n            kwargs[\"path_arc\"] = angle\n        if \"path_arc_axis\" not in kwargs:\n            kwargs[\"path_arc_axis\"] = axis\n        self.angle = angle\n        self.axis = axis\n        self.about_edge = about_edge\n        self.about_point = about_point\n        if self.about_point is None:\n            self.about_point = mobject.get_center()\n        super().__init__(mobject, path_arc_centers=self.about_point, **kwargs)\n\n    def create_target(self) -> Mobject:\n        target = self.mobject.copy()\n        target.rotate(\n            self.angle,\n            axis=self.axis,\n            about_point=self.about_point,\n            about_edge=self.about_edge,\n        )\n        return target", "code_sha1": "947609a306a796b007a9d1deda415432183631fe"}
{"url": "https://docs.manim.community/en/stable/_modules/manim/animation/specialized.html", "depth": 2, "instruction": "The code creates a broadcast animation of a teal circle that starts from a focal point, expanding outward into five copies. Each copy begins with an initial width of 0, gradually becoming fully visible with an opacity transition from 1 to 0 over 3 seconds, with a 0.2-second delay between each emergence.", "code": "from __future__ import annotations\n\n__all__ = [\"Broadcast\"]\n\nfrom collections.abc import Sequence\nfrom typing import Any\n\nfrom manim.animation.transform import Restore\n\nfrom ..constants import *\nfrom .composition import LaggedStart\n\n\n\n[docs]\nclass Broadcast(LaggedStart):\n    \"\"\"Broadcast a mobject starting from an ``initial_width``, up to the actual size of the mobject.\n\n    Parameters\n    ----------\n    mobject\n        The mobject to be broadcast.\n    focal_point\n        The center of the broadcast, by default ORIGIN.\n    n_mobs\n        The number of mobjects that emerge from the focal point, by default 5.\n    initial_opacity\n        The starting stroke opacity of the mobjects emitted from the broadcast, by default 1.\n    final_opacity\n        The final stroke opacity of the mobjects emitted from the broadcast, by default 0.\n    initial_width\n        The initial width of the mobjects, by default 0.0.\n    remover\n        Whether the mobjects should be removed from the scene after the animation, by default True.\n    lag_ratio\n        The time between each iteration of the mobject, by default 0.2.\n    run_time\n        The total duration of the animation, by default 3.\n    kwargs\n        Additional arguments to be passed to :class:`~.LaggedStart`.\n\n    Examples\n    ---------\n\n    .. manim:: BroadcastExample\n\n        class BroadcastExample(Scene):\n            def construct(self):\n                mob = Circle(radius=4, color=TEAL_A)\n                self.play(Broadcast(mob))\n    \"\"\"\n\n    def __init__(\n        self,\n        mobject,\n        focal_point: Sequence[float] = ORIGIN,\n        n_mobs: int = 5,\n        initial_opacity: float = 1,\n        final_opacity: float = 0,\n        initial_width: float = 0.0,\n        remover: bool = True,\n        lag_ratio: float = 0.2,\n        run_time: float = 3,\n        **kwargs: Any,\n    ):\n        self.focal_point = focal_point\n        self.n_mobs = n_mobs\n        self.initial_opacity = initial_opacity\n        self.final_opacity = final_opacity\n        self.initial_width = initial_width\n\n        anims = []\n\n        # Works by saving the mob that is passed into the animation, scaling it to 0 (or the initial_width) and then restoring the original mob.\n        fill_o = bool(mobject.fill_opacity)\n\n        for _ in range(self.n_mobs):\n            mob = mobject.copy()\n\n            if fill_o:\n                mob.set_opacity(self.final_opacity)\n            else:\n                mob.set_stroke(opacity=self.final_opacity)\n\n            mob.move_to(self.focal_point)\n            mob.save_state()\n            mob.set(width=self.initial_width)\n\n            if fill_o:\n                mob.set_opacity(self.initial_opacity)\n            else:\n                mob.set_stroke(opacity=self.initial_opacity)\n\n            anims.append(Restore(mob, remover=remover))\n\n        super().__init__(*anims, run_time=run_time, lag_ratio=lag_ratio, **kwargs)", "code_sha1": "22a862470fe617358517ce8af23122dec428b1f2"}
{"url": "https://docs.manim.community/en/stable/_modules/manim/animation/speedmodifier.html", "depth": 2, "instruction": "The code defines a `ChangeSpeed` animation that modifies the speed of other animations based on specified speed factors at different percentages of their run time. It allows for dynamic speed adjustments during animations, affecting both the main animation and any associated updaters, enabling complex motion effects in a scene.", "code": "\"\"\"Utilities for modifying the speed at which animations are played.\"\"\"\n\nfrom __future__ import annotations\n\nimport inspect\nimport types\nfrom typing import TYPE_CHECKING, Callable\n\nfrom numpy import piecewise\n\nfrom ..animation.animation import Animation, Wait, prepare_animation\nfrom ..animation.composition import AnimationGroup\nfrom ..mobject.mobject import Mobject, _AnimationBuilder\nfrom ..scene.scene import Scene\n\nif TYPE_CHECKING:\n    from ..mobject.mobject import Updater\n\n__all__ = [\"ChangeSpeed\"]\n\n\n\n[docs]\nclass ChangeSpeed(Animation):\n    \"\"\"Modifies the speed of passed animation.\n    :class:`AnimationGroup` with different ``lag_ratio`` can also be used\n    which combines multiple animations into one.\n    The ``run_time`` of the passed animation is changed to modify the speed.\n\n    Parameters\n    ----------\n    anim\n        Animation of which the speed is to be modified.\n    speedinfo\n        Contains nodes (percentage of ``run_time``) and its corresponding speed factor.\n    rate_func\n        Overrides ``rate_func`` of passed animation, applied before changing speed.\n\n    Examples\n    --------\n\n    .. manim:: SpeedModifierExample\n\n        class SpeedModifierExample(Scene):\n            def construct(self):\n                a = Dot().shift(LEFT * 4)\n                b = Dot().shift(RIGHT * 4)\n                self.add(a, b)\n                self.play(\n                    ChangeSpeed(\n                        AnimationGroup(\n                            a.animate(run_time=1).shift(RIGHT * 8),\n                            b.animate(run_time=1).shift(LEFT * 8),\n                        ),\n                        speedinfo={0.3: 1, 0.4: 0.1, 0.6: 0.1, 1: 1},\n                        rate_func=linear,\n                    )\n                )\n\n    .. manim:: SpeedModifierUpdaterExample\n\n        class SpeedModifierUpdaterExample(Scene):\n            def construct(self):\n                a = Dot().shift(LEFT * 4)\n                self.add(a)\n\n                ChangeSpeed.add_updater(a, lambda x, dt: x.shift(RIGHT * 4 * dt))\n                self.play(\n                    ChangeSpeed(\n                        Wait(2),\n                        speedinfo={0.4: 1, 0.5: 0.2, 0.8: 0.2, 1: 1},\n                        affects_speed_updaters=True,\n                    )\n                )\n\n    .. manim:: SpeedModifierUpdaterExample2\n\n        class SpeedModifierUpdaterExample2(Scene):\n            def construct(self):\n                a = Dot().shift(LEFT * 4)\n                self.add(a)\n\n                ChangeSpeed.add_updater(a, lambda x, dt: x.shift(RIGHT * 4 * dt))\n                self.wait()\n                self.play(\n                    ChangeSpeed(\n                        Wait(),\n                        speedinfo={1: 0},\n                        affects_speed_updaters=True,\n                    )\n                )\n\n    \"\"\"\n\n    dt = 0\n    is_changing_dt = False\n\n    def __init__(\n        self,\n        anim: Animation | _AnimationBuilder,\n        speedinfo: dict[float, float],\n        rate_func: Callable[[float], float] | None = None,\n        affects_speed_updaters: bool = True,\n        **kwargs,\n    ) -> None:\n        if issubclass(type(anim), AnimationGroup):\n            self.anim = type(anim)(\n                *map(self.setup, anim.animations),\n                group=anim.group,\n                run_time=anim.run_time,\n                rate_func=anim.rate_func,\n                lag_ratio=anim.lag_ratio,\n            )\n        else:\n            self.anim = self.setup(anim)\n\n        if affects_speed_updaters:\n            assert ChangeSpeed.is_changing_dt is False, (\n                \"Only one animation at a time can play that changes speed (dt) for ChangeSpeed updaters\"\n            )\n            ChangeSpeed.is_changing_dt = True\n            self.t = 0\n        self.affects_speed_updaters = affects_speed_updaters\n\n        self.rate_func = self.anim.rate_func if rate_func is None else rate_func\n\n        # A function where, f(0) = 0, f'(0) = initial speed, f'( f-1(1) ) = final speed\n        # Following function obtained when conditions applied to vertical parabola\n        self.speed_modifier = lambda x, init_speed, final_speed: (\n            (final_speed**2 - init_speed**2) * x**2 / 4 + init_speed * x\n        )\n\n        # f-1(1), returns x for which f(x) = 1 in `speed_modifier` function\n        self.f_inv_1 = lambda init_speed, final_speed: 2 / (init_speed + final_speed)\n\n        # if speed factors for the starting node (0) and the final node (1) are\n        # not set, set them to 1 and the penultimate factor, respectively\n        if 0 not in speedinfo:\n            speedinfo[0] = 1\n        if 1 not in speedinfo:\n            speedinfo[1] = sorted(speedinfo.items())[-1][1]\n\n        self.speedinfo = dict(sorted(speedinfo.items()))\n        self.functions = []\n        self.conditions = []\n\n        # Get the time taken by amimation if `run_time` is assumed to be 1\n        scaled_total_time = self.get_scaled_total_time()\n\n        prevnode = 0\n        init_speed = self.speedinfo[0]\n        curr_time = 0\n        for node, final_speed in list(self.speedinfo.items())[1:]:\n            dur = node - prevnode\n\n            def condition(\n                t,\n                curr_time=curr_time,\n                init_speed=init_speed,\n                final_speed=final_speed,\n                dur=dur,\n            ):\n                lower_bound = curr_time / scaled_total_time\n                upper_bound = (\n                    curr_time + self.f_inv_1(init_speed, final_speed) * dur\n                ) / scaled_total_time\n                return lower_bound <= t <= upper_bound\n\n            self.conditions.append(condition)\n\n            def function(\n                t,\n                curr_time=curr_time,\n                init_speed=init_speed,\n                final_speed=final_speed,\n                dur=dur,\n                prevnode=prevnode,\n            ):\n                return (\n                    self.speed_modifier(\n                        (scaled_total_time * t - curr_time) / dur,\n                        init_speed,\n                        final_speed,\n                    )\n                    * dur\n                    + prevnode\n                )\n\n            self.functions.append(function)\n\n            curr_time += self.f_inv_1(init_speed, final_speed) * dur\n            prevnode = node\n            init_speed = final_speed\n\n        def func(t):\n            if t == 1:\n                ChangeSpeed.is_changing_dt = False\n            new_t = piecewise(\n                self.rate_func(t),\n                [condition(self.rate_func(t)) for condition in self.conditions],\n                self.functions,\n            )\n            if self.affects_speed_updaters:\n                ChangeSpeed.dt = (new_t - self.t) * self.anim.run_time\n                self.t = new_t\n            return new_t\n\n        self.anim.set_rate_func(func)\n\n        super().__init__(\n            self.anim.mobject,\n            rate_func=self.rate_func,\n            run_time=scaled_total_time * self.anim.run_time,\n            **kwargs,\n        )\n\n    def setup(self, anim):\n        if type(anim) is Wait:\n            anim.interpolate = types.MethodType(\n                lambda self, alpha: self.rate_func(alpha), anim\n            )\n        return prepare_animation(anim)\n\n\n[docs]\n    def get_scaled_total_time(self) -> float:\n        \"\"\"The time taken by the animation under the assumption that the ``run_time`` is 1.\"\"\"\n        prevnode = 0\n        init_speed = self.speedinfo[0]\n        total_time = 0\n        for node, final_speed in list(self.speedinfo.items())[1:]:\n            dur = node - prevnode\n            total_time += dur * self.f_inv_1(init_speed, final_speed)\n            prevnode = node\n            init_speed = final_speed\n        return total_time\n\n\n\n[docs]\n    @classmethod\n    def add_updater(\n        cls,\n        mobject: Mobject,\n        update_function: Updater,\n        index: int | None = None,\n        call_updater: bool = False,\n    ):\n        \"\"\"This static method can be used to apply speed change to updaters.\n\n        This updater will follow speed and rate function of any :class:`.ChangeSpeed`\n        animation that is playing with ``affects_speed_updaters=True``. By default,\n        updater functions added via the usual :meth:`.Mobject.add_updater` method\n        do not respect the change of animation speed.\n\n        Parameters\n        ----------\n        mobject\n            The mobject to which the updater should be attached.\n        update_function\n            The function that is called whenever a new frame is rendered.\n        index\n            The position in the list of the mobject's updaters at which the\n            function should be inserted.\n        call_updater\n            If ``True``, calls the update function when attaching it to the\n            mobject.\n\n        See also\n        --------\n        :class:`.ChangeSpeed`\n        :meth:`.Mobject.add_updater`\n        \"\"\"\n        if \"dt\" in inspect.signature(update_function).parameters:\n            mobject.add_updater(\n                lambda mob, dt: update_function(\n                    mob, ChangeSpeed.dt if ChangeSpeed.is_changing_dt else dt\n                ),\n                index=index,\n                call_updater=call_updater,\n            )\n        else:\n            mobject.add_updater(update_function, index=index, call_updater=call_updater)\n\n\n\n[docs]\n    def interpolate(self, alpha: float) -> None:\n        self.anim.interpolate(alpha)\n\n\n\n[docs]\n    def update_mobjects(self, dt: float) -> None:\n        self.anim.update_mobjects(dt)\n\n\n\n[docs]\n    def finish(self) -> None:\n        ChangeSpeed.is_changing_dt = False\n        self.anim.finish()\n\n\n\n[docs]\n    def begin(self) -> None:\n        self.anim.begin()\n\n\n\n[docs]\n    def clean_up_from_scene(self, scene: Scene) -> None:\n        self.anim.clean_up_from_scene(scene)\n\n\n\n[docs]\n    def _setup_scene(self, scene) -> None:\n        self.anim._setup_scene(scene)", "code_sha1": "96818ac30eebdab033a625b204e06568893bbfab"}
{"url": "https://docs.manim.community/en/stable/_modules/manim/animation/transform.html", "depth": 2, "instruction": "The code defines various transformation animations for mobjects in Manim, including `Transform`, `ReplacementTransform`, and `FadeTransform`. Each class specifies how one mobject morphs into another, with options for path arcs, color changes, and scene management, allowing for smooth visual transitions in animations.", "code": "\"\"\"Animations transforming one mobject into another.\"\"\"\n\nfrom __future__ import annotations\n\n__all__ = [\n    \"Transform\",\n    \"ReplacementTransform\",\n    \"TransformFromCopy\",\n    \"ClockwiseTransform\",\n    \"CounterclockwiseTransform\",\n    \"MoveToTarget\",\n    \"ApplyMethod\",\n    \"ApplyPointwiseFunction\",\n    \"ApplyPointwiseFunctionToCenter\",\n    \"FadeToColor\",\n    \"FadeTransform\",\n    \"FadeTransformPieces\",\n    \"ScaleInPlace\",\n    \"ShrinkToCenter\",\n    \"Restore\",\n    \"ApplyFunction\",\n    \"ApplyMatrix\",\n    \"ApplyComplexFunction\",\n    \"CyclicReplace\",\n    \"Swap\",\n    \"TransformAnimations\",\n]\n\nimport inspect\nimport types\nfrom collections.abc import Iterable, Sequence\nfrom typing import TYPE_CHECKING, Any, Callable\n\nimport numpy as np\n\nfrom manim.mobject.opengl.opengl_mobject import OpenGLGroup, OpenGLMobject\n\nfrom .. import config\nfrom ..animation.animation import Animation\nfrom ..constants import (\n    DEFAULT_POINTWISE_FUNCTION_RUN_TIME,\n    DEGREES,\n    ORIGIN,\n    OUT,\n    RendererType,\n)\nfrom ..mobject.mobject import Group, Mobject\nfrom ..utils.paths import path_along_arc, path_along_circles\nfrom ..utils.rate_functions import smooth, squish_rate_func\n\nif TYPE_CHECKING:\n    from ..scene.scene import Scene\n\n\n\n[docs]\nclass Transform(Animation):\n    \"\"\"A Transform transforms a Mobject into a target Mobject.\n\n    Parameters\n    ----------\n    mobject\n        The :class:`.Mobject` to be transformed. It will be mutated to become the ``target_mobject``.\n    target_mobject\n        The target of the transformation.\n    path_func\n        A function defining the path that the points of the ``mobject`` are being moved\n        along until they match the points of the ``target_mobject``, see :mod:`.utils.paths`.\n    path_arc\n        The arc angle (in radians) that the points of ``mobject`` will follow to reach\n        the points of the target if using a circular path arc, see ``path_arc_centers``.\n        See also :func:`manim.utils.paths.path_along_arc`.\n    path_arc_axis\n        The axis to rotate along if using a circular path arc, see ``path_arc_centers``.\n    path_arc_centers\n        The center of the circular arcs along which the points of ``mobject`` are\n        moved by the transformation.\n\n        If this is set and ``path_func`` is not set, then a ``path_along_circles`` path will be generated\n        using the ``path_arc`` parameters and stored in ``path_func``. If ``path_func`` is set, this and the\n        other ``path_arc`` fields are set as attributes, but a ``path_func`` is not generated from it.\n    replace_mobject_with_target_in_scene\n        Controls which mobject is replaced when the transformation is complete.\n\n        If set to True, ``mobject`` will be removed from the scene and ``target_mobject`` will\n        replace it. Otherwise, ``target_mobject`` is never added and ``mobject`` just takes its shape.\n\n    Examples\n    --------\n\n    .. manim :: TransformPathArc\n\n        class TransformPathArc(Scene):\n            def construct(self):\n                def make_arc_path(start, end, arc_angle):\n                    points = []\n                    p_fn = path_along_arc(arc_angle)\n                    # alpha animates between 0.0 and 1.0, where 0.0\n                    # is the beginning of the animation and 1.0 is the end.\n                    for alpha in range(0, 11):\n                        points.append(p_fn(start, end, alpha / 10.0))\n                    path = VMobject(stroke_color=YELLOW)\n                    path.set_points_smoothly(points)\n                    return path\n\n                left = Circle(stroke_color=BLUE_E, fill_opacity=1.0, radius=0.5).move_to(LEFT * 2)\n                colors = [TEAL_A, TEAL_B, TEAL_C, TEAL_D, TEAL_E, GREEN_A]\n                # Positive angles move counter-clockwise, negative angles move clockwise.\n                examples = [-90, 0, 30, 90, 180, 270]\n                anims = []\n                for idx, angle in enumerate(examples):\n                    left_c = left.copy().shift((3 - idx) * UP)\n                    left_c.fill_color = colors[idx]\n                    right_c = left_c.copy().shift(4 * RIGHT)\n                    path_arc = make_arc_path(left_c.get_center(), right_c.get_center(),\n                                             arc_angle=angle * DEGREES)\n                    desc = Text('%d°' % examples[idx]).next_to(left_c, LEFT)\n                    # Make the circles in front of the text in front of the arcs.\n                    self.add(\n                        path_arc.set_z_index(1),\n                        desc.set_z_index(2),\n                        left_c.set_z_index(3),\n                    )\n                    anims.append(Transform(left_c, right_c, path_arc=angle * DEGREES))\n\n                self.play(*anims, run_time=2)\n                self.wait()\n    \"\"\"\n\n    def __init__(\n        self,\n        mobject: Mobject | None,\n        target_mobject: Mobject | None = None,\n        path_func: Callable | None = None,\n        path_arc: float = 0,\n        path_arc_axis: np.ndarray = OUT,\n        path_arc_centers: np.ndarray = None,\n        replace_mobject_with_target_in_scene: bool = False,\n        **kwargs,\n    ) -> None:\n        self.path_arc_axis: np.ndarray = path_arc_axis\n        self.path_arc_centers: np.ndarray = path_arc_centers\n        self.path_arc: float = path_arc\n\n        # path_func is a property a few lines below so it doesn't need to be set in any case\n        if path_func is not None:\n            self.path_func: Callable = path_func\n        elif self.path_arc_centers is not None:\n            self.path_func = path_along_circles(\n                path_arc,\n                self.path_arc_centers,\n                self.path_arc_axis,\n            )\n\n        self.replace_mobject_with_target_in_scene: bool = (\n            replace_mobject_with_target_in_scene\n        )\n        self.target_mobject: Mobject = (\n            target_mobject if target_mobject is not None else Mobject()\n        )\n        super().__init__(mobject, **kwargs)\n\n    @property\n    def path_arc(self) -> float:\n        return self._path_arc\n\n    @path_arc.setter\n    def path_arc(self, path_arc: float) -> None:\n        self._path_arc = path_arc\n        self._path_func = path_along_arc(\n            arc_angle=self._path_arc,\n            axis=self.path_arc_axis,\n        )\n\n    @property\n    def path_func(\n        self,\n    ) -> Callable[\n        [Iterable[np.ndarray], Iterable[np.ndarray], float],\n        Iterable[np.ndarray],\n    ]:\n        return self._path_func\n\n    @path_func.setter\n    def path_func(\n        self,\n        path_func: Callable[\n            [Iterable[np.ndarray], Iterable[np.ndarray], float],\n            Iterable[np.ndarray],\n        ],\n    ) -> None:\n        if path_func is not None:\n            self._path_func = path_func\n\n\n[docs]\n    def begin(self) -> None:\n        # Use a copy of target_mobject for the align_data\n        # call so that the actual target_mobject stays\n        # preserved.\n        self.target_mobject = self.create_target()\n        self.target_copy = self.target_mobject.copy()\n        # Note, this potentially changes the structure\n        # of both mobject and target_mobject\n        if config.renderer == RendererType.OPENGL:\n            self.mobject.align_data_and_family(self.target_copy)\n        else:\n            self.mobject.align_data(self.target_copy)\n        super().begin()\n\n\n    def create_target(self) -> Mobject:\n        # Has no meaningful effect here, but may be useful\n        # in subclasses\n        return self.target_mobject\n\n\n[docs]\n    def clean_up_from_scene(self, scene: Scene) -> None:\n        super().clean_up_from_scene(scene)\n        if self.replace_mobject_with_target_in_scene:\n            scene.replace(self.mobject, self.target_mobject)\n\n\n\n[docs]\n    def get_all_mobjects(self) -> Sequence[Mobject]:\n        return [\n            self.mobject,\n            self.starting_mobject,\n            self.target_mobject,\n            self.target_copy,\n        ]\n\n\n    def get_all_families_zipped(self) -> Iterable[tuple]:  # more precise typing?\n        mobs = [\n            self.mobject,\n            self.starting_mobject,\n            self.target_copy,\n        ]\n        if config.renderer == RendererType.OPENGL:\n            return zip(*(mob.get_family() for mob in mobs))\n        return zip(*(mob.family_members_with_points() for mob in mobs))\n\n    def interpolate_submobject(\n        self,\n        submobject: Mobject,\n        starting_submobject: Mobject,\n        target_copy: Mobject,\n        alpha: float,\n    ) -> Transform:\n        submobject.interpolate(starting_submobject, target_copy, alpha, self.path_func)\n        return self\n\n\n\n\n[docs]\nclass ReplacementTransform(Transform):\n    \"\"\"Replaces and morphs a mobject into a target mobject.\n\n    Parameters\n    ----------\n    mobject\n        The starting :class:`~.Mobject`.\n    target_mobject\n        The target :class:`~.Mobject`.\n    kwargs\n        Further keyword arguments that are passed to :class:`Transform`.\n\n    Examples\n    --------\n\n    .. manim:: ReplacementTransformOrTransform\n        :quality: low\n\n        class ReplacementTransformOrTransform(Scene):\n            def construct(self):\n                # set up the numbers\n                r_transform = VGroup(*[Integer(i) for i in range(1,4)])\n                text_1 = Text(\"ReplacementTransform\", color=RED)\n                r_transform.add(text_1)\n\n                transform = VGroup(*[Integer(i) for i in range(4,7)])\n                text_2 = Text(\"Transform\", color=BLUE)\n                transform.add(text_2)\n\n                ints = VGroup(r_transform, transform)\n                texts = VGroup(text_1, text_2).scale(0.75)\n                r_transform.arrange(direction=UP, buff=1)\n                transform.arrange(direction=UP, buff=1)\n\n                ints.arrange(buff=2)\n                self.add(ints, texts)\n\n                # The mobs replace each other and none are left behind\n                self.play(ReplacementTransform(r_transform[0], r_transform[1]))\n                self.play(ReplacementTransform(r_transform[1], r_transform[2]))\n\n                # The mobs linger after the Transform()\n                self.play(Transform(transform[0], transform[1]))\n                self.play(Transform(transform[1], transform[2]))\n                self.wait()\n\n    \"\"\"\n\n    def __init__(self, mobject: Mobject, target_mobject: Mobject, **kwargs) -> None:\n        super().__init__(\n            mobject, target_mobject, replace_mobject_with_target_in_scene=True, **kwargs\n        )\n\n\n\n\n[docs]\nclass TransformFromCopy(Transform):\n    \"\"\"Performs a reversed Transform\"\"\"\n\n    def __init__(self, mobject: Mobject, target_mobject: Mobject, **kwargs) -> None:\n        super().__init__(target_mobject, mobject, **kwargs)\n\n\n[docs]\n    def interpolate(self, alpha: float) -> None:\n        super().interpolate(1 - alpha)\n\n\n\n\n\n[docs]\nclass ClockwiseTransform(Transform):\n    \"\"\"Transforms the points of a mobject along a clockwise oriented arc.\n\n    See also\n    --------\n    :class:`.Transform`, :class:`.CounterclockwiseTransform`\n\n    Examples\n    --------\n\n    .. manim:: ClockwiseExample\n\n        class ClockwiseExample(Scene):\n            def construct(self):\n                dl, dr = Dot(), Dot()\n                sl, sr = Square(), Square()\n\n                VGroup(dl, sl).arrange(DOWN).shift(2*LEFT)\n                VGroup(dr, sr).arrange(DOWN).shift(2*RIGHT)\n\n                self.add(dl, dr)\n                self.wait()\n                self.play(\n                    ClockwiseTransform(dl, sl),\n                    Transform(dr, sr)\n                )\n                self.wait()\n\n    \"\"\"\n\n    def __init__(\n        self,\n        mobject: Mobject,\n        target_mobject: Mobject,\n        path_arc: float = -np.pi,\n        **kwargs,\n    ) -> None:\n        super().__init__(mobject, target_mobject, path_arc=path_arc, **kwargs)\n\n\n\n\n[docs]\nclass CounterclockwiseTransform(Transform):\n    \"\"\"Transforms the points of a mobject along a counterclockwise oriented arc.\n\n    See also\n    --------\n    :class:`.Transform`, :class:`.ClockwiseTransform`\n\n    Examples\n    --------\n\n    .. manim:: CounterclockwiseTransform_vs_Transform\n\n        class CounterclockwiseTransform_vs_Transform(Scene):\n            def construct(self):\n                # set up the numbers\n                c_transform = VGroup(DecimalNumber(number=3.141, num_decimal_places=3), DecimalNumber(number=1.618, num_decimal_places=3))\n                text_1 = Text(\"CounterclockwiseTransform\", color=RED)\n                c_transform.add(text_1)\n\n                transform = VGroup(DecimalNumber(number=1.618, num_decimal_places=3), DecimalNumber(number=3.141, num_decimal_places=3))\n                text_2 = Text(\"Transform\", color=BLUE)\n                transform.add(text_2)\n\n                ints = VGroup(c_transform, transform)\n                texts = VGroup(text_1, text_2).scale(0.75)\n                c_transform.arrange(direction=UP, buff=1)\n                transform.arrange(direction=UP, buff=1)\n\n                ints.arrange(buff=2)\n                self.add(ints, texts)\n\n                # The mobs move in clockwise direction for ClockwiseTransform()\n                self.play(CounterclockwiseTransform(c_transform[0], c_transform[1]))\n\n                # The mobs move straight up for Transform()\n                self.play(Transform(transform[0], transform[1]))\n\n    \"\"\"\n\n    def __init__(\n        self,\n        mobject: Mobject,\n        target_mobject: Mobject,\n        path_arc: float = np.pi,\n        **kwargs,\n    ) -> None:\n        super().__init__(mobject, target_mobject, path_arc=path_arc, **kwargs)\n\n\n\n\n[docs]\nclass MoveToTarget(Transform):\n    \"\"\"Transforms a mobject to the mobject stored in its ``target`` attribute.\n\n    After calling the :meth:`~.Mobject.generate_target` method, the :attr:`target`\n    attribute of the mobject is populated with a copy of it. After modifying the attribute,\n    playing the :class:`.MoveToTarget` animation transforms the original mobject\n    into the modified one stored in the :attr:`target` attribute.\n\n    Examples\n    --------\n\n    .. manim:: MoveToTargetExample\n\n        class MoveToTargetExample(Scene):\n            def construct(self):\n                c = Circle()\n\n                c.generate_target()\n                c.target.set_fill(color=GREEN, opacity=0.5)\n                c.target.shift(2*RIGHT + UP).scale(0.5)\n\n                self.add(c)\n                self.play(MoveToTarget(c))\n\n    \"\"\"\n\n    def __init__(self, mobject: Mobject, **kwargs) -> None:\n        self.check_validity_of_input(mobject)\n        super().__init__(mobject, mobject.target, **kwargs)\n\n    def check_validity_of_input(self, mobject: Mobject) -> None:\n        if not hasattr(mobject, \"target\"):\n            raise ValueError(\n                \"MoveToTarget called on mobjectwithout attribute 'target'\",\n            )\n\n\n\nclass _MethodAnimation(MoveToTarget):\n    def __init__(self, mobject, methods):\n        self.methods = methods\n        super().__init__(mobject)\n\n    def finish(self) -> None:\n        for method, method_args, method_kwargs in self.methods:\n            method.__func__(self.mobject, *method_args, **method_kwargs)\n        super().finish()\n\n\n\n[docs]\nclass ApplyMethod(Transform):\n    \"\"\"Animates a mobject by applying a method.\n\n    Note that only the method needs to be passed to this animation,\n    it is not required to pass the corresponding mobject. Furthermore,\n    this animation class only works if the method returns the modified\n    mobject.\n\n    Parameters\n    ----------\n    method\n        The method that will be applied in the animation.\n    args\n        Any positional arguments to be passed when applying the method.\n    kwargs\n        Any keyword arguments passed to :class:`~.Transform`.\n\n    \"\"\"\n\n    def __init__(\n        self, method: Callable, *args, **kwargs\n    ) -> None:  # method typing (we want to specify Mobject method)? for args?\n        self.check_validity_of_input(method)\n        self.method = method\n        self.method_args = args\n        super().__init__(method.__self__, **kwargs)\n\n    def check_validity_of_input(self, method: Callable) -> None:\n        if not inspect.ismethod(method):\n            raise ValueError(\n                \"Whoops, looks like you accidentally invoked \"\n                \"the method you want to animate\",\n            )\n        assert isinstance(method.__self__, (Mobject, OpenGLMobject))\n\n    def create_target(self) -> Mobject:\n        method = self.method\n        # Make sure it's a list so that args.pop() works\n        args = list(self.method_args)\n\n        if len(args) > 0 and isinstance(args[-1], dict):\n            method_kwargs = args.pop()\n        else:\n            method_kwargs = {}\n        target = method.__self__.copy()\n        method.__func__(target, *args, **method_kwargs)\n        return target\n\n\n\n\n[docs]\nclass ApplyPointwiseFunction(ApplyMethod):\n    \"\"\"Animation that applies a pointwise function to a mobject.\n\n    Examples\n    --------\n\n    .. manim:: WarpSquare\n        :quality: low\n\n        class WarpSquare(Scene):\n            def construct(self):\n                square = Square()\n                self.play(\n                    ApplyPointwiseFunction(\n                        lambda point: complex_to_R3(np.exp(R3_to_complex(point))), square\n                    )\n                )\n                self.wait()\n\n    \"\"\"\n\n    def __init__(\n        self,\n        function: types.MethodType,\n        mobject: Mobject,\n        run_time: float = DEFAULT_POINTWISE_FUNCTION_RUN_TIME,\n        **kwargs,\n    ) -> None:\n        super().__init__(mobject.apply_function, function, run_time=run_time, **kwargs)\n\n\n\n\n[docs]\nclass ApplyPointwiseFunctionToCenter(ApplyPointwiseFunction):\n    def __init__(self, function: types.MethodType, mobject: Mobject, **kwargs) -> None:\n        self.function = function\n        super().__init__(mobject.move_to, **kwargs)\n\n\n[docs]\n    def begin(self) -> None:\n        self.method_args = [self.function(self.mobject.get_center())]\n        super().begin()\n\n\n\n\n\n[docs]\nclass FadeToColor(ApplyMethod):\n    \"\"\"Animation that changes color of a mobject.\n\n    Examples\n    --------\n\n    .. manim:: FadeToColorExample\n\n        class FadeToColorExample(Scene):\n            def construct(self):\n                self.play(FadeToColor(Text(\"Hello World!\"), color=RED))\n\n    \"\"\"\n\n    def __init__(self, mobject: Mobject, color: str, **kwargs) -> None:\n        super().__init__(mobject.set_color, color, **kwargs)\n\n\n\n\n[docs]\nclass ScaleInPlace(ApplyMethod):\n    \"\"\"Animation that scales a mobject by a certain factor.\n\n    Examples\n    --------\n\n    .. manim:: ScaleInPlaceExample\n\n        class ScaleInPlaceExample(Scene):\n            def construct(self):\n                self.play(ScaleInPlace(Text(\"Hello World!\"), 2))\n\n    \"\"\"\n\n    def __init__(self, mobject: Mobject, scale_factor: float, **kwargs) -> None:\n        super().__init__(mobject.scale, scale_factor, **kwargs)\n\n\n\n\n[docs]\nclass ShrinkToCenter(ScaleInPlace):\n    \"\"\"Animation that makes a mobject shrink to center.\n\n    Examples\n    --------\n\n    .. manim:: ShrinkToCenterExample\n\n        class ShrinkToCenterExample(Scene):\n            def construct(self):\n                self.play(ShrinkToCenter(Text(\"Hello World!\")))\n\n    \"\"\"\n\n    def __init__(self, mobject: Mobject, **kwargs) -> None:\n        super().__init__(mobject, 0, **kwargs)\n\n\n\n\n[docs]\nclass Restore(ApplyMethod):\n    \"\"\"Transforms a mobject to its last saved state.\n\n    To save the state of a mobject, use the :meth:`~.Mobject.save_state` method.\n\n    Examples\n    --------\n\n    .. manim:: RestoreExample\n\n        class RestoreExample(Scene):\n            def construct(self):\n                s = Square()\n                s.save_state()\n                self.play(FadeIn(s))\n                self.play(s.animate.set_color(PURPLE).set_opacity(0.5).shift(2*LEFT).scale(3))\n                self.play(s.animate.shift(5*DOWN).rotate(PI/4))\n                self.wait()\n                self.play(Restore(s), run_time=2)\n\n    \"\"\"\n\n    def __init__(self, mobject: Mobject, **kwargs) -> None:\n        super().__init__(mobject.restore, **kwargs)\n\n\n\n\n[docs]\nclass ApplyFunction(Transform):\n    def __init__(self, function: types.MethodType, mobject: Mobject, **kwargs) -> None:\n        self.function = function\n        super().__init__(mobject, **kwargs)\n\n    def create_target(self) -> Any:\n        target = self.function(self.mobject.copy())\n        if not isinstance(target, (Mobject, OpenGLMobject)):\n            raise TypeError(\n                \"Functions passed to ApplyFunction must return object of type Mobject\",\n            )\n        return target\n\n\n\n\n[docs]\nclass ApplyMatrix(ApplyPointwiseFunction):\n    \"\"\"Applies a matrix transform to an mobject.\n\n    Parameters\n    ----------\n    matrix\n        The transformation matrix.\n    mobject\n        The :class:`~.Mobject`.\n    about_point\n        The origin point for the transform. Defaults to ``ORIGIN``.\n    kwargs\n        Further keyword arguments that are passed to :class:`ApplyPointwiseFunction`.\n\n    Examples\n    --------\n\n    .. manim:: ApplyMatrixExample\n\n        class ApplyMatrixExample(Scene):\n            def construct(self):\n                matrix = [[1, 1], [0, 2/3]]\n                self.play(ApplyMatrix(matrix, Text(\"Hello World!\")), ApplyMatrix(matrix, NumberPlane()))\n\n    \"\"\"\n\n    def __init__(\n        self,\n        matrix: np.ndarray,\n        mobject: Mobject,\n        about_point: np.ndarray = ORIGIN,\n        **kwargs,\n    ) -> None:\n        matrix = self.initialize_matrix(matrix)\n\n        def func(p):\n            return np.dot(p - about_point, matrix.T) + about_point\n\n        super().__init__(func, mobject, **kwargs)\n\n    def initialize_matrix(self, matrix: np.ndarray) -> np.ndarray:\n        matrix = np.array(matrix)\n        if matrix.shape == (2, 2):\n            new_matrix = np.identity(3)\n            new_matrix[:2, :2] = matrix\n            matrix = new_matrix\n        elif matrix.shape != (3, 3):\n            raise ValueError(\"Matrix has bad dimensions\")\n        return matrix\n\n\n\n\n[docs]\nclass ApplyComplexFunction(ApplyMethod):\n    def __init__(self, function: types.MethodType, mobject: Mobject, **kwargs) -> None:\n        self.function = function\n        method = mobject.apply_complex_function\n        super().__init__(method, function, **kwargs)\n\n    def _init_path_func(self) -> None:\n        func1 = self.function(complex(1))\n        self.path_arc = np.log(func1).imag\n        super()._init_path_func()\n\n\n\n###\n\n\n\n[docs]\nclass CyclicReplace(Transform):\n    \"\"\"An animation moving mobjects cyclically.\n\n    In particular, this means: the first mobject takes the place\n    of the second mobject, the second one takes the place of\n    the third mobject, and so on. The last mobject takes the\n    place of the first one.\n\n    Parameters\n    ----------\n    mobjects\n        List of mobjects to be transformed.\n    path_arc\n        The angle of the arc (in radians) that the mobjects will follow to reach\n        their target.\n    kwargs\n        Further keyword arguments that are passed to :class:`.Transform`.\n\n    Examples\n    --------\n    .. manim :: CyclicReplaceExample\n\n        class CyclicReplaceExample(Scene):\n            def construct(self):\n                group = VGroup(Square(), Circle(), Triangle(), Star())\n                group.arrange(RIGHT)\n                self.add(group)\n\n                for _ in range(4):\n                    self.play(CyclicReplace(*group))\n    \"\"\"\n\n    def __init__(\n        self, *mobjects: Mobject, path_arc: float = 90 * DEGREES, **kwargs\n    ) -> None:\n        self.group = Group(*mobjects)\n        super().__init__(self.group, path_arc=path_arc, **kwargs)\n\n    def create_target(self) -> Group:\n        target = self.group.copy()\n        cycled_targets = [target[-1], *target[:-1]]\n        for m1, m2 in zip(cycled_targets, self.group):\n            m1.move_to(m2)\n        return target\n\n\n\n\n[docs]\nclass Swap(CyclicReplace):\n    pass  # Renaming, more understandable for two entries\n\n\n\n# TODO, this may be deprecated...worth reimplementing?\n\n[docs]\nclass TransformAnimations(Transform):\n    def __init__(\n        self,\n        start_anim: Animation,\n        end_anim: Animation,\n        rate_func: Callable = squish_rate_func(smooth),\n        **kwargs,\n    ) -> None:\n        self.start_anim = start_anim\n        self.end_anim = end_anim\n        if \"run_time\" in kwargs:\n            self.run_time = kwargs.pop(\"run_time\")\n        else:\n            self.run_time = max(start_anim.run_time, end_anim.run_time)\n        for anim in start_anim, end_anim:\n            anim.set_run_time(self.run_time)\n        if (\n            start_anim.starting_mobject is not None\n            and end_anim.starting_mobject is not None\n            and start_anim.starting_mobject.get_num_points()\n            != end_anim.starting_mobject.get_num_points()\n        ):\n            start_anim.starting_mobject.align_data(end_anim.starting_mobject)\n            for anim in start_anim, end_anim:\n                if isinstance(anim, Transform) and anim.starting_mobject is not None:\n                    anim.starting_mobject.align_data(anim.target_mobject)\n\n        super().__init__(\n            start_anim.mobject, end_anim.mobject, rate_func=rate_func, **kwargs\n        )\n        # Rewire starting and ending mobjects\n        start_anim.mobject = self.starting_mobject\n        end_anim.mobject = self.target_mobject\n\n\n[docs]\n    def interpolate(self, alpha: float) -> None:\n        self.start_anim.interpolate(alpha)\n        self.end_anim.interpolate(alpha)\n        super().interpolate(alpha)\n\n\n\n\n\n[docs]\nclass FadeTransform(Transform):\n    \"\"\"Fades one mobject into another.\n\n    Parameters\n    ----------\n    mobject\n        The starting :class:`~.Mobject`.\n    target_mobject\n        The target :class:`~.Mobject`.\n    stretch\n        Controls whether the target :class:`~.Mobject` is stretched during\n        the animation. Default: ``True``.\n    dim_to_match\n        If the target mobject is not stretched automatically, this allows\n        to adjust the initial scale of the target :class:`~.Mobject` while\n        it is shifted in. Setting this to 0, 1, and 2, respectively,\n        matches the length of the target with the length of the starting\n        :class:`~.Mobject` in x, y, and z direction, respectively.\n    kwargs\n        Further keyword arguments are passed to the parent class.\n\n    Examples\n    --------\n\n    .. manim:: DifferentFadeTransforms\n\n        class DifferentFadeTransforms(Scene):\n            def construct(self):\n                starts = [Rectangle(width=4, height=1) for _ in range(3)]\n                VGroup(*starts).arrange(DOWN, buff=1).shift(3*LEFT)\n                targets = [Circle(fill_opacity=1).scale(0.25) for _ in range(3)]\n                VGroup(*targets).arrange(DOWN, buff=1).shift(3*RIGHT)\n\n                self.play(*[FadeIn(s) for s in starts])\n                self.play(\n                    FadeTransform(starts[0], targets[0], stretch=True),\n                    FadeTransform(starts[1], targets[1], stretch=False, dim_to_match=0),\n                    FadeTransform(starts[2], targets[2], stretch=False, dim_to_match=1)\n                )\n\n                self.play(*[FadeOut(mobj) for mobj in self.mobjects])\n\n    \"\"\"\n\n    def __init__(self, mobject, target_mobject, stretch=True, dim_to_match=1, **kwargs):\n        self.to_add_on_completion = target_mobject\n        self.stretch = stretch\n        self.dim_to_match = dim_to_match\n        mobject.save_state()\n        if config.renderer == RendererType.OPENGL:\n            group = OpenGLGroup(mobject, target_mobject.copy())\n        else:\n            group = Group(mobject, target_mobject.copy())\n        super().__init__(group, **kwargs)\n\n\n[docs]\n    def begin(self):\n        \"\"\"Initial setup for the animation.\n\n        The mobject to which this animation is bound is a group consisting of\n        both the starting and the ending mobject. At the start, the ending\n        mobject replaces the starting mobject (and is completely faded). In the\n        end, it is set to be the other way around.\n        \"\"\"\n        self.ending_mobject = self.mobject.copy()\n        Animation.begin(self)\n        # Both 'start' and 'end' consists of the source and target mobjects.\n        # At the start, the target should be faded replacing the source,\n        # and at the end it should be the other way around.\n        start, end = self.starting_mobject, self.ending_mobject\n        for m0, m1 in ((start[1], start[0]), (end[0], end[1])):\n            self.ghost_to(m0, m1)\n\n\n\n[docs]\n    def ghost_to(self, source, target):\n        \"\"\"Replaces the source by the target and sets the opacity to 0.\n\n        If the provided target has no points, and thus a location of [0, 0, 0]\n        the source will simply fade out where it currently is.\n        \"\"\"\n        # mobject.replace() does not work if the target has no points.\n        if target.get_num_points() or target.submobjects:\n            source.replace(target, stretch=self.stretch, dim_to_match=self.dim_to_match)\n        source.set_opacity(0)\n\n\n\n[docs]\n    def get_all_mobjects(self) -> Sequence[Mobject]:\n        return [\n            self.mobject,\n            self.starting_mobject,\n            self.ending_mobject,\n        ]\n\n\n    def get_all_families_zipped(self):\n        return Animation.get_all_families_zipped(self)\n\n\n[docs]\n    def clean_up_from_scene(self, scene):\n        Animation.clean_up_from_scene(self, scene)\n        scene.remove(self.mobject)\n        self.mobject[0].restore()\n        scene.add(self.to_add_on_completion)\n\n\n\n\n\n[docs]\nclass FadeTransformPieces(FadeTransform):\n    \"\"\"Fades submobjects of one mobject into submobjects of another one.\n\n    See also\n    --------\n    :class:`~.FadeTransform`\n\n    Examples\n    --------\n    .. manim:: FadeTransformSubmobjects\n\n        class FadeTransformSubmobjects(Scene):\n            def construct(self):\n                src = VGroup(Square(), Circle().shift(LEFT + UP))\n                src.shift(3*LEFT + 2*UP)\n                src_copy = src.copy().shift(4*DOWN)\n\n                target = VGroup(Circle(), Triangle().shift(RIGHT + DOWN))\n                target.shift(3*RIGHT + 2*UP)\n                target_copy = target.copy().shift(4*DOWN)\n\n                self.play(FadeIn(src), FadeIn(src_copy))\n                self.play(\n                    FadeTransform(src, target),\n                    FadeTransformPieces(src_copy, target_copy)\n                )\n                self.play(*[FadeOut(mobj) for mobj in self.mobjects])\n\n    \"\"\"\n\n\n[docs]\n    def begin(self):\n        self.mobject[0].align_submobjects(self.mobject[1])\n        super().begin()\n\n\n\n[docs]\n    def ghost_to(self, source, target):\n        \"\"\"Replaces the source submobjects by the target submobjects and sets\n        the opacity to 0.\n        \"\"\"\n        for sm0, sm1 in zip(source.get_family(), target.get_family()):\n            super().ghost_to(sm0, sm1)", "code_sha1": "ee160eabd402b19128798088ff533e00c79450de"}
{"url": "https://docs.manim.community/en/stable/_modules/manim/animation/transform_matching_parts.html", "depth": 2, "instruction": "The code defines two transformation animations, `TransformMatchingShapes` and `TransformMatchingTex`, which animate the transformation of Mobjects by matching their subcomponents based on shape or LaTeX string, respectively. The animations include fading and transforming unmatched parts, with customizable parameters for visual effects and timing.", "code": "\"\"\"Animations that try to transform Mobjects while keeping track of identical parts.\"\"\"\n\nfrom __future__ import annotations\n\n__all__ = [\"TransformMatchingShapes\", \"TransformMatchingTex\"]\n\nfrom typing import TYPE_CHECKING\n\nimport numpy as np\n\nfrom manim.mobject.opengl.opengl_mobject import OpenGLGroup, OpenGLMobject\nfrom manim.mobject.opengl.opengl_vectorized_mobject import OpenGLVGroup, OpenGLVMobject\n\nfrom .._config import config\nfrom ..constants import RendererType\nfrom ..mobject.mobject import Group, Mobject\nfrom ..mobject.types.vectorized_mobject import VGroup, VMobject\nfrom .composition import AnimationGroup\nfrom .fading import FadeIn, FadeOut\nfrom .transform import FadeTransformPieces, Transform\n\nif TYPE_CHECKING:\n    from ..scene.scene import Scene\n\n\n\n[docs]\nclass TransformMatchingAbstractBase(AnimationGroup):\n    \"\"\"Abstract base class for transformations that keep track of matching parts.\n\n    Subclasses have to implement the two static methods\n    :meth:`~.TransformMatchingAbstractBase.get_mobject_parts` and\n    :meth:`~.TransformMatchingAbstractBase.get_mobject_key`.\n\n    Basically, this transformation first maps all submobjects returned\n    by the ``get_mobject_parts`` method to certain keys by applying the\n    ``get_mobject_key`` method. Then, submobjects with matching keys\n    are transformed into each other.\n\n    Parameters\n    ----------\n    mobject\n        The starting :class:`~.Mobject`.\n    target_mobject\n        The target :class:`~.Mobject`.\n    transform_mismatches\n        Controls whether submobjects without a matching key are transformed\n        into each other by using :class:`~.Transform`. Default: ``False``.\n    fade_transform_mismatches\n        Controls whether submobjects without a matching key are transformed\n        into each other by using :class:`~.FadeTransform`. Default: ``False``.\n    key_map\n        Optional. A dictionary mapping keys belonging to some of the starting mobject's\n        submobjects (i.e., the return values of the ``get_mobject_key`` method)\n        to some keys belonging to the target mobject's submobjects that should\n        be transformed although the keys don't match.\n    kwargs\n        All further keyword arguments are passed to the submobject transformations.\n\n\n    Note\n    ----\n    If neither ``transform_mismatches`` nor ``fade_transform_mismatches``\n    are set to ``True``, submobjects without matching keys in the starting\n    mobject are faded out in the direction of the unmatched submobjects in\n    the target mobject, and unmatched submobjects in the target mobject\n    are faded in from the direction of the unmatched submobjects in the\n    start mobject.\n\n    \"\"\"\n\n    def __init__(\n        self,\n        mobject: Mobject,\n        target_mobject: Mobject,\n        transform_mismatches: bool = False,\n        fade_transform_mismatches: bool = False,\n        key_map: dict | None = None,\n        **kwargs,\n    ):\n        if isinstance(mobject, OpenGLVMobject):\n            group_type = OpenGLVGroup\n        elif isinstance(mobject, OpenGLMobject):\n            group_type = OpenGLGroup\n        elif isinstance(mobject, VMobject):\n            group_type = VGroup\n        else:\n            group_type = Group\n\n        source_map = self.get_shape_map(mobject)\n        target_map = self.get_shape_map(target_mobject)\n\n        if key_map is None:\n            key_map = {}\n\n        # Create two mobjects whose submobjects all match each other\n        # according to whatever keys are used for source_map and\n        # target_map\n        transform_source = group_type()\n        transform_target = group_type()\n        kwargs[\"final_alpha_value\"] = 0\n        for key in set(source_map).intersection(target_map):\n            transform_source.add(source_map[key])\n            transform_target.add(target_map[key])\n        anims = [Transform(transform_source, transform_target, **kwargs)]\n        # User can manually specify when one part should transform\n        # into another despite not matching by using key_map\n        key_mapped_source = group_type()\n        key_mapped_target = group_type()\n        for key1, key2 in key_map.items():\n            if key1 in source_map and key2 in target_map:\n                key_mapped_source.add(source_map[key1])\n                key_mapped_target.add(target_map[key2])\n                source_map.pop(key1, None)\n                target_map.pop(key2, None)\n        if len(key_mapped_source) > 0:\n            anims.append(\n                FadeTransformPieces(key_mapped_source, key_mapped_target, **kwargs),\n            )\n\n        fade_source = group_type()\n        fade_target = group_type()\n        for key in set(source_map).difference(target_map):\n            fade_source.add(source_map[key])\n        for key in set(target_map).difference(source_map):\n            fade_target.add(target_map[key])\n        fade_target_copy = fade_target.copy()\n\n        if transform_mismatches:\n            if \"replace_mobject_with_target_in_scene\" not in kwargs:\n                kwargs[\"replace_mobject_with_target_in_scene\"] = True\n            anims.append(Transform(fade_source, fade_target, **kwargs))\n        elif fade_transform_mismatches:\n            anims.append(FadeTransformPieces(fade_source, fade_target, **kwargs))\n        else:\n            anims.append(FadeOut(fade_source, target_position=fade_target, **kwargs))\n            anims.append(\n                FadeIn(fade_target_copy, target_position=fade_target, **kwargs),\n            )\n\n        super().__init__(*anims)\n\n        self.to_remove = [mobject, fade_target_copy]\n        self.to_add = target_mobject\n\n    def get_shape_map(self, mobject: Mobject) -> dict:\n        shape_map = {}\n        for sm in self.get_mobject_parts(mobject):\n            key = self.get_mobject_key(sm)\n            if key not in shape_map:\n                if config[\"renderer\"] == RendererType.OPENGL:\n                    shape_map[key] = OpenGLVGroup()\n                else:\n                    shape_map[key] = VGroup()\n            shape_map[key].add(sm)\n        return shape_map\n\n\n[docs]\n    def clean_up_from_scene(self, scene: Scene) -> None:\n        # Interpolate all animations back to 0 to ensure source mobjects remain unchanged.\n        for anim in self.animations:\n            anim.interpolate(0)\n        scene.remove(self.mobject)\n        scene.remove(*self.to_remove)\n        scene.add(self.to_add)\n\n\n    @staticmethod\n    def get_mobject_parts(mobject: Mobject):\n        raise NotImplementedError(\"To be implemented in subclass.\")\n\n    @staticmethod\n    def get_mobject_key(mobject: Mobject):\n        raise NotImplementedError(\"To be implemented in subclass.\")\n\n\n\n\n[docs]\nclass TransformMatchingShapes(TransformMatchingAbstractBase):\n    \"\"\"An animation trying to transform groups by matching the shape\n    of their submobjects.\n\n    Two submobjects match if the hash of their point coordinates after\n    normalization (i.e., after translation to the origin, fixing the submobject\n    height at 1 unit, and rounding the coordinates to three decimal places)\n    matches.\n\n    See also\n    --------\n    :class:`~.TransformMatchingAbstractBase`\n\n    Examples\n    --------\n\n    .. manim:: Anagram\n\n        class Anagram(Scene):\n            def construct(self):\n                src = Text(\"the morse code\")\n                tar = Text(\"here come dots\")\n                self.play(Write(src))\n                self.wait(0.5)\n                self.play(TransformMatchingShapes(src, tar, path_arc=PI/2))\n                self.wait(0.5)\n\n    \"\"\"\n\n    def __init__(\n        self,\n        mobject: Mobject,\n        target_mobject: Mobject,\n        transform_mismatches: bool = False,\n        fade_transform_mismatches: bool = False,\n        key_map: dict | None = None,\n        **kwargs,\n    ):\n        super().__init__(\n            mobject,\n            target_mobject,\n            transform_mismatches=transform_mismatches,\n            fade_transform_mismatches=fade_transform_mismatches,\n            key_map=key_map,\n            **kwargs,\n        )\n\n    @staticmethod\n    def get_mobject_parts(mobject: Mobject) -> list[Mobject]:\n        return mobject.family_members_with_points()\n\n    @staticmethod\n    def get_mobject_key(mobject: Mobject) -> int:\n        mobject.save_state()\n        mobject.center()\n        mobject.set(height=1)\n        result = hash(np.round(mobject.points, 3).tobytes())\n        mobject.restore()\n        return result\n\n\n\n\n[docs]\nclass TransformMatchingTex(TransformMatchingAbstractBase):\n    \"\"\"A transformation trying to transform rendered LaTeX strings.\n\n    Two submobjects match if their ``tex_string`` matches.\n\n    See also\n    --------\n    :class:`~.TransformMatchingAbstractBase`\n\n    Examples\n    --------\n\n    .. manim:: MatchingEquationParts\n\n        class MatchingEquationParts(Scene):\n            def construct(self):\n                variables = VGroup(MathTex(\"a\"), MathTex(\"b\"), MathTex(\"c\")).arrange_submobjects().shift(UP)\n\n                eq1 = MathTex(\"{{x}}^2\", \"+\", \"{{y}}^2\", \"=\", \"{{z}}^2\")\n                eq2 = MathTex(\"{{a}}^2\", \"+\", \"{{b}}^2\", \"=\", \"{{c}}^2\")\n                eq3 = MathTex(\"{{a}}^2\", \"=\", \"{{c}}^2\", \"-\", \"{{b}}^2\")\n\n                self.add(eq1)\n                self.wait(0.5)\n                self.play(TransformMatchingTex(Group(eq1, variables), eq2))\n                self.wait(0.5)\n                self.play(TransformMatchingTex(eq2, eq3))\n                self.wait(0.5)\n\n    \"\"\"\n\n    def __init__(\n        self,\n        mobject: Mobject,\n        target_mobject: Mobject,\n        transform_mismatches: bool = False,\n        fade_transform_mismatches: bool = False,\n        key_map: dict | None = None,\n        **kwargs,\n    ):\n        super().__init__(\n            mobject,\n            target_mobject,\n            transform_mismatches=transform_mismatches,\n            fade_transform_mismatches=fade_transform_mismatches,\n            key_map=key_map,\n            **kwargs,\n        )\n\n    @staticmethod\n    def get_mobject_parts(mobject: Mobject) -> list[Mobject]:\n        if isinstance(mobject, (Group, VGroup, OpenGLGroup, OpenGLVGroup)):\n            return [\n                p\n                for s in mobject.submobjects\n                for p in TransformMatchingTex.get_mobject_parts(s)\n            ]\n        else:\n            assert hasattr(mobject, \"tex_string\")\n            return mobject.submobjects\n\n    @staticmethod\n    def get_mobject_key(mobject: Mobject) -> str:\n        return mobject.tex_string", "code_sha1": "fc25e2c2febc27e46f7c6993ef0f86736518c9ef"}
{"url": "https://docs.manim.community/en/stable/_modules/manim/animation/updaters/mobject_update_utils.html", "depth": 2, "instruction": "The code provides utility functions for continuously animating mobjects in Manim, allowing for dynamic updates such as shifting, rotating, and redrawing. Key features include methods to attach updaters to mobjects, enabling them to change properties over time, and to convert animations into updaters for ongoing effects during scenes.", "code": "\"\"\"Utility functions for continuous animation of mobjects.\"\"\"\n\nfrom __future__ import annotations\n\n__all__ = [\n    \"assert_is_mobject_method\",\n    \"always\",\n    \"f_always\",\n    \"always_redraw\",\n    \"always_shift\",\n    \"always_rotate\",\n    \"turn_animation_into_updater\",\n    \"cycle_animation\",\n]\n\n\nimport inspect\nfrom typing import TYPE_CHECKING, Callable\n\nimport numpy as np\n\nfrom manim.constants import DEGREES, RIGHT\nfrom manim.mobject.mobject import Mobject\nfrom manim.opengl import OpenGLMobject\nfrom manim.utils.space_ops import normalize\n\nif TYPE_CHECKING:\n    from manim.animation.animation import Animation\n\n\n\n[docs]\ndef assert_is_mobject_method(method: Callable) -> None:\n    assert inspect.ismethod(method)\n    mobject = method.__self__\n    assert isinstance(mobject, (Mobject, OpenGLMobject))\n\n\n\n\n[docs]\ndef always(method: Callable, *args, **kwargs) -> Mobject:\n    assert_is_mobject_method(method)\n    mobject = method.__self__\n    func = method.__func__\n    mobject.add_updater(lambda m: func(m, *args, **kwargs))\n    return mobject\n\n\n\n\n[docs]\ndef f_always(method: Callable[[Mobject], None], *arg_generators, **kwargs) -> Mobject:\n    \"\"\"\n    More functional version of always, where instead\n    of taking in args, it takes in functions which output\n    the relevant arguments.\n    \"\"\"\n    assert_is_mobject_method(method)\n    mobject = method.__self__\n    func = method.__func__\n\n    def updater(mob):\n        args = [arg_generator() for arg_generator in arg_generators]\n        func(mob, *args, **kwargs)\n\n    mobject.add_updater(updater)\n    return mobject\n\n\n\n\n[docs]\ndef always_redraw(func: Callable[[], Mobject]) -> Mobject:\n    \"\"\"Redraw the mobject constructed by a function every frame.\n\n    This function returns a mobject with an attached updater that\n    continuously regenerates the mobject according to the\n    specified function.\n\n    Parameters\n    ----------\n    func\n        A function without (required) input arguments that returns\n        a mobject.\n\n    Examples\n    --------\n\n    .. manim:: TangentAnimation\n\n        class TangentAnimation(Scene):\n            def construct(self):\n                ax = Axes()\n                sine = ax.plot(np.sin, color=RED)\n                alpha = ValueTracker(0)\n                point = always_redraw(\n                    lambda: Dot(\n                        sine.point_from_proportion(alpha.get_value()),\n                        color=BLUE\n                    )\n                )\n                tangent = always_redraw(\n                    lambda: TangentLine(\n                        sine,\n                        alpha=alpha.get_value(),\n                        color=YELLOW,\n                        length=4\n                    )\n                )\n                self.add(ax, sine, point, tangent)\n                self.play(alpha.animate.set_value(1), rate_func=linear, run_time=2)\n    \"\"\"\n    mob = func()\n    mob.add_updater(lambda _: mob.become(func()))\n    return mob\n\n\n\n\n[docs]\ndef always_shift(\n    mobject: Mobject, direction: np.ndarray[np.float64] = RIGHT, rate: float = 0.1\n) -> Mobject:\n    \"\"\"A mobject which is continuously shifted along some direction\n    at a certain rate.\n\n    Parameters\n    ----------\n    mobject\n        The mobject to shift.\n    direction\n        The direction to shift. The vector is normalized, the specified magnitude\n        is not relevant.\n    rate\n        Length in Manim units which the mobject travels in one\n        second along the specified direction.\n\n    Examples\n    --------\n\n    .. manim:: ShiftingSquare\n\n        class ShiftingSquare(Scene):\n            def construct(self):\n                sq = Square().set_fill(opacity=1)\n                tri = Triangle()\n                VGroup(sq, tri).arrange(LEFT)\n\n                # construct a square which is continuously\n                # shifted to the right\n                always_shift(sq, RIGHT, rate=5)\n\n                self.add(sq)\n                self.play(tri.animate.set_fill(opacity=1))\n    \"\"\"\n    mobject.add_updater(lambda m, dt: m.shift(dt * rate * normalize(direction)))\n    return mobject\n\n\n\n\n[docs]\ndef always_rotate(mobject: Mobject, rate: float = 20 * DEGREES, **kwargs) -> Mobject:\n    \"\"\"A mobject which is continuously rotated at a certain rate.\n\n    Parameters\n    ----------\n    mobject\n        The mobject to be rotated.\n    rate\n        The angle which the mobject is rotated by\n        over one second.\n    kwags\n        Further arguments to be passed to :meth:`.Mobject.rotate`.\n\n    Examples\n    --------\n\n    .. manim:: SpinningTriangle\n\n        class SpinningTriangle(Scene):\n            def construct(self):\n                tri = Triangle().set_fill(opacity=1).set_z_index(2)\n                sq = Square().to_edge(LEFT)\n\n                # will keep spinning while there is an animation going on\n                always_rotate(tri, rate=2*PI, about_point=ORIGIN)\n\n                self.add(tri, sq)\n                self.play(sq.animate.to_edge(RIGHT), rate_func=linear, run_time=1)\n    \"\"\"\n    mobject.add_updater(lambda m, dt: m.rotate(dt * rate, **kwargs))\n    return mobject\n\n\n\n\n[docs]\ndef turn_animation_into_updater(\n    animation: Animation, cycle: bool = False, delay: float = 0, **kwargs\n) -> Mobject:\n    \"\"\"\n    Add an updater to the animation's mobject which applies\n    the interpolation and update functions of the animation\n\n    If cycle is True, this repeats over and over.  Otherwise,\n    the updater will be popped upon completion\n\n    The ``delay`` parameter is the delay (in seconds) before the animation starts..\n\n    Examples\n    --------\n\n    .. manim:: WelcomeToManim\n\n        class WelcomeToManim(Scene):\n            def construct(self):\n                words = Text(\"Welcome to\")\n                banner = ManimBanner().scale(0.5)\n                VGroup(words, banner).arrange(DOWN)\n\n                turn_animation_into_updater(Write(words, run_time=0.9))\n                self.add(words)\n                self.wait(0.5)\n                self.play(banner.expand(), run_time=0.5)\n    \"\"\"\n    mobject = animation.mobject\n    animation.suspend_mobject_updating = False\n    animation.begin()\n    animation.total_time = -delay\n\n    def update(m: Mobject, dt: float):\n        if animation.total_time >= 0:\n            run_time = animation.get_run_time()\n            time_ratio = animation.total_time / run_time\n            if cycle:\n                alpha = time_ratio % 1\n            else:\n                alpha = np.clip(time_ratio, 0, 1)\n                if alpha >= 1:\n                    animation.finish()\n                    m.remove_updater(update)\n                    return\n            animation.interpolate(alpha)\n            animation.update_mobjects(dt)\n        animation.total_time += dt\n\n    mobject.add_updater(update)\n    return mobject\n\n\n\n\n[docs]\ndef cycle_animation(animation: Animation, **kwargs) -> Mobject:\n    return turn_animation_into_updater(animation, cycle=True, **kwargs)", "code_sha1": "6c12c44d17b536ac70cae9582c00f03c690bb858"}
{"url": "https://docs.manim.community/en/stable/_modules/manim/camera/camera.html", "depth": 2, "instruction": "The code defines a `Camera` class that captures and displays mobjects in a scene, managing background images and pixel arrays. It includes methods for rendering vectorized and point cloud mobjects, adjusting pixel coordinates, and handling background colors. The `BackgroundColoredVMobjectDisplayer` class aids in displaying mobjects with a background image, resizing as necessary.", "code": "\"\"\"A camera converts the mobjects contained in a Scene into an array of pixels.\"\"\"\n\nfrom __future__ import annotations\n\n__all__ = [\"Camera\", \"BackgroundColoredVMobjectDisplayer\"]\n\nimport copy\nimport itertools as it\nimport operator as op\nimport pathlib\nfrom collections.abc import Iterable\nfrom functools import reduce\nfrom typing import Any, Callable\n\nimport cairo\nimport numpy as np\nfrom PIL import Image\nfrom scipy.spatial.distance import pdist\n\nfrom .. import config, logger\nfrom ..constants import *\nfrom ..mobject.mobject import Mobject\nfrom ..mobject.types.image_mobject import AbstractImageMobject\nfrom ..mobject.types.point_cloud_mobject import PMobject\nfrom ..mobject.types.vectorized_mobject import VMobject\nfrom ..utils.color import ManimColor, ParsableManimColor, color_to_int_rgba\nfrom ..utils.family import extract_mobject_family_members\nfrom ..utils.images import get_full_raster_image_path\nfrom ..utils.iterables import list_difference_update\nfrom ..utils.space_ops import angle_of_vector\n\nLINE_JOIN_MAP = {\n    LineJointType.AUTO: None,  # TODO: this could be improved\n    LineJointType.ROUND: cairo.LineJoin.ROUND,\n    LineJointType.BEVEL: cairo.LineJoin.BEVEL,\n    LineJointType.MITER: cairo.LineJoin.MITER,\n}\n\n\nCAP_STYLE_MAP = {\n    CapStyleType.AUTO: None,  # TODO: this could be improved\n    CapStyleType.ROUND: cairo.LineCap.ROUND,\n    CapStyleType.BUTT: cairo.LineCap.BUTT,\n    CapStyleType.SQUARE: cairo.LineCap.SQUARE,\n}\n\n\n\n[docs]\nclass Camera:\n    \"\"\"Base camera class.\n\n    This is the object which takes care of what exactly is displayed\n    on screen at any given moment.\n\n    Parameters\n    ----------\n    background_image\n        The path to an image that should be the background image.\n        If not set, the background is filled with :attr:`self.background_color`\n    background\n        What :attr:`background` is set to. By default, ``None``.\n    pixel_height\n        The height of the scene in pixels.\n    pixel_width\n        The width of the scene in pixels.\n    kwargs\n        Additional arguments (``background_color``, ``background_opacity``)\n        to be set.\n    \"\"\"\n\n    def __init__(\n        self,\n        background_image: str | None = None,\n        frame_center: np.ndarray = ORIGIN,\n        image_mode: str = \"RGBA\",\n        n_channels: int = 4,\n        pixel_array_dtype: str = \"uint8\",\n        cairo_line_width_multiple: float = 0.01,\n        use_z_index: bool = True,\n        background: np.ndarray | None = None,\n        pixel_height: int | None = None,\n        pixel_width: int | None = None,\n        frame_height: float | None = None,\n        frame_width: float | None = None,\n        frame_rate: float | None = None,\n        background_color: ParsableManimColor | None = None,\n        background_opacity: float | None = None,\n        **kwargs,\n    ):\n        self.background_image = background_image\n        self.frame_center = frame_center\n        self.image_mode = image_mode\n        self.n_channels = n_channels\n        self.pixel_array_dtype = pixel_array_dtype\n        self.cairo_line_width_multiple = cairo_line_width_multiple\n        self.use_z_index = use_z_index\n        self.background = background\n\n        if pixel_height is None:\n            pixel_height = config[\"pixel_height\"]\n        self.pixel_height = pixel_height\n\n        if pixel_width is None:\n            pixel_width = config[\"pixel_width\"]\n        self.pixel_width = pixel_width\n\n        if frame_height is None:\n            frame_height = config[\"frame_height\"]\n        self.frame_height = frame_height\n\n        if frame_width is None:\n            frame_width = config[\"frame_width\"]\n        self.frame_width = frame_width\n\n        if frame_rate is None:\n            frame_rate = config[\"frame_rate\"]\n        self.frame_rate = frame_rate\n\n        if background_color is None:\n            self._background_color = ManimColor.parse(config[\"background_color\"])\n        else:\n            self._background_color = ManimColor.parse(background_color)\n        if background_opacity is None:\n            self._background_opacity = config[\"background_opacity\"]\n        else:\n            self._background_opacity = background_opacity\n\n        # This one is in the same boat as the above, but it doesn't have the\n        # same name as the corresponding key so it has to be handled on its own\n        self.max_allowable_norm = config[\"frame_width\"]\n\n        self.rgb_max_val = np.iinfo(self.pixel_array_dtype).max\n        self.pixel_array_to_cairo_context = {}\n\n        # Contains the correct method to process a list of Mobjects of the\n        # corresponding class.  If a Mobject is not an instance of a class in\n        # this dict (or an instance of a class that inherits from a class in\n        # this dict), then it cannot be rendered.\n\n        self.init_background()\n        self.resize_frame_shape()\n        self.reset()\n\n    def __deepcopy__(self, memo):\n        # This is to address a strange bug where deepcopying\n        # will result in a segfault, which is somehow related\n        # to the aggdraw library\n        self.canvas = None\n        return copy.copy(self)\n\n    @property\n    def background_color(self):\n        return self._background_color\n\n    @background_color.setter\n    def background_color(self, color):\n        self._background_color = color\n        self.init_background()\n\n    @property\n    def background_opacity(self):\n        return self._background_opacity\n\n    @background_opacity.setter\n    def background_opacity(self, alpha):\n        self._background_opacity = alpha\n        self.init_background()\n\n\n[docs]\n    def type_or_raise(self, mobject: Mobject):\n        \"\"\"Return the type of mobject, if it is a type that can be rendered.\n\n        If `mobject` is an instance of a class that inherits from a class that\n        can be rendered, return the super class.  For example, an instance of a\n        Square is also an instance of VMobject, and these can be rendered.\n        Therefore, `type_or_raise(Square())` returns True.\n\n        Parameters\n        ----------\n        mobject\n            The object to take the type of.\n\n        Notes\n        -----\n        For a list of classes that can currently be rendered, see :meth:`display_funcs`.\n\n        Returns\n        -------\n        Type[:class:`~.Mobject`]\n            The type of mobjects, if it can be rendered.\n\n        Raises\n        ------\n        :exc:`TypeError`\n            When mobject is not an instance of a class that can be rendered.\n        \"\"\"\n        self.display_funcs = {\n            VMobject: self.display_multiple_vectorized_mobjects,\n            PMobject: self.display_multiple_point_cloud_mobjects,\n            AbstractImageMobject: self.display_multiple_image_mobjects,\n            Mobject: lambda batch, pa: batch,  # Do nothing\n        }\n        # We have to check each type in turn because we are dealing with\n        # super classes.  For example, if square = Square(), then\n        # type(square) != VMobject, but isinstance(square, VMobject) == True.\n        for _type in self.display_funcs:\n            if isinstance(mobject, _type):\n                return _type\n        raise TypeError(f\"Displaying an object of class {_type} is not supported\")\n\n\n\n[docs]\n    def reset_pixel_shape(self, new_height: float, new_width: float):\n        \"\"\"This method resets the height and width\n        of a single pixel to the passed new_height and new_width.\n\n        Parameters\n        ----------\n        new_height\n            The new height of the entire scene in pixels\n        new_width\n            The new width of the entire scene in pixels\n        \"\"\"\n        self.pixel_width = new_width\n        self.pixel_height = new_height\n        self.init_background()\n        self.resize_frame_shape()\n        self.reset()\n\n\n\n[docs]\n    def resize_frame_shape(self, fixed_dimension: int = 0):\n        \"\"\"\n        Changes frame_shape to match the aspect ratio\n        of the pixels, where fixed_dimension determines\n        whether frame_height or frame_width\n        remains fixed while the other changes accordingly.\n\n        Parameters\n        ----------\n        fixed_dimension\n            If 0, height is scaled with respect to width\n            else, width is scaled with respect to height.\n        \"\"\"\n        pixel_height = self.pixel_height\n        pixel_width = self.pixel_width\n        frame_height = self.frame_height\n        frame_width = self.frame_width\n        aspect_ratio = pixel_width / pixel_height\n        if fixed_dimension == 0:\n            frame_height = frame_width / aspect_ratio\n        else:\n            frame_width = aspect_ratio * frame_height\n        self.frame_height = frame_height\n        self.frame_width = frame_width\n\n\n\n[docs]\n    def init_background(self):\n        \"\"\"Initialize the background.\n        If self.background_image is the path of an image\n        the image is set as background; else, the default\n        background color fills the background.\n        \"\"\"\n        height = self.pixel_height\n        width = self.pixel_width\n        if self.background_image is not None:\n            path = get_full_raster_image_path(self.background_image)\n            image = Image.open(path).convert(self.image_mode)\n            # TODO, how to gracefully handle backgrounds\n            # with different sizes?\n            self.background = np.array(image)[:height, :width]\n            self.background = self.background.astype(self.pixel_array_dtype)\n        else:\n            background_rgba = color_to_int_rgba(\n                self.background_color,\n                self.background_opacity,\n            )\n            self.background = np.zeros(\n                (height, width, self.n_channels),\n                dtype=self.pixel_array_dtype,\n            )\n            self.background[:, :] = background_rgba\n\n\n\n[docs]\n    def get_image(self, pixel_array: np.ndarray | list | tuple | None = None):\n        \"\"\"Returns an image from the passed\n        pixel array, or from the current frame\n        if the passed pixel array is none.\n\n        Parameters\n        ----------\n        pixel_array\n            The pixel array from which to get an image, by default None\n\n        Returns\n        -------\n        PIL.Image\n            The PIL image of the array.\n        \"\"\"\n        if pixel_array is None:\n            pixel_array = self.pixel_array\n        return Image.fromarray(pixel_array, mode=self.image_mode)\n\n\n\n[docs]\n    def convert_pixel_array(\n        self, pixel_array: np.ndarray | list | tuple, convert_from_floats: bool = False\n    ):\n        \"\"\"Converts a pixel array from values that have floats in then\n        to proper RGB values.\n\n        Parameters\n        ----------\n        pixel_array\n            Pixel array to convert.\n        convert_from_floats\n            Whether or not to convert float values to ints, by default False\n\n        Returns\n        -------\n        np.array\n            The new, converted pixel array.\n        \"\"\"\n        retval = np.array(pixel_array)\n        if convert_from_floats:\n            retval = np.apply_along_axis(\n                lambda f: (f * self.rgb_max_val).astype(self.pixel_array_dtype),\n                2,\n                retval,\n            )\n        return retval\n\n\n\n[docs]\n    def set_pixel_array(\n        self, pixel_array: np.ndarray | list | tuple, convert_from_floats: bool = False\n    ):\n        \"\"\"Sets the pixel array of the camera to the passed pixel array.\n\n        Parameters\n        ----------\n        pixel_array\n            The pixel array to convert and then set as the camera's pixel array.\n        convert_from_floats\n            Whether or not to convert float values to proper RGB values, by default False\n        \"\"\"\n        converted_array = self.convert_pixel_array(pixel_array, convert_from_floats)\n        if not (\n            hasattr(self, \"pixel_array\")\n            and self.pixel_array.shape == converted_array.shape\n        ):\n            self.pixel_array = converted_array\n        else:\n            # Set in place\n            self.pixel_array[:, :, :] = converted_array[:, :, :]\n\n\n\n[docs]\n    def set_background(\n        self, pixel_array: np.ndarray | list | tuple, convert_from_floats: bool = False\n    ):\n        \"\"\"Sets the background to the passed pixel_array after converting\n        to valid RGB values.\n\n        Parameters\n        ----------\n        pixel_array\n            The pixel array to set the background to.\n        convert_from_floats\n            Whether or not to convert floats values to proper RGB valid ones, by default False\n        \"\"\"\n        self.background = self.convert_pixel_array(pixel_array, convert_from_floats)\n\n\n    # TODO, this should live in utils, not as a method of Camera\n\n[docs]\n    def make_background_from_func(\n        self, coords_to_colors_func: Callable[[np.ndarray], np.ndarray]\n    ):\n        \"\"\"\n        Makes a pixel array for the background by using coords_to_colors_func to determine each pixel's color. Each input\n        pixel's color. Each input to coords_to_colors_func is an (x, y) pair in space (in ordinary space coordinates; not\n        pixel coordinates), and each output is expected to be an RGBA array of 4 floats.\n\n        Parameters\n        ----------\n        coords_to_colors_func\n            The function whose input is an (x,y) pair of coordinates and\n            whose return values must be the colors for that point\n\n        Returns\n        -------\n        np.array\n            The pixel array which can then be passed to set_background.\n        \"\"\"\n        logger.info(\"Starting set_background\")\n        coords = self.get_coords_of_all_pixels()\n        new_background = np.apply_along_axis(coords_to_colors_func, 2, coords)\n        logger.info(\"Ending set_background\")\n\n        return self.convert_pixel_array(new_background, convert_from_floats=True)\n\n\n\n[docs]\n    def set_background_from_func(\n        self, coords_to_colors_func: Callable[[np.ndarray], np.ndarray]\n    ):\n        \"\"\"\n        Sets the background to a pixel array using coords_to_colors_func to determine each pixel's color. Each input\n        pixel's color. Each input to coords_to_colors_func is an (x, y) pair in space (in ordinary space coordinates; not\n        pixel coordinates), and each output is expected to be an RGBA array of 4 floats.\n\n        Parameters\n        ----------\n        coords_to_colors_func\n            The function whose input is an (x,y) pair of coordinates and\n            whose return values must be the colors for that point\n        \"\"\"\n        self.set_background(self.make_background_from_func(coords_to_colors_func))\n\n\n\n[docs]\n    def reset(self):\n        \"\"\"Resets the camera's pixel array\n        to that of the background\n\n        Returns\n        -------\n        Camera\n            The camera object after setting the pixel array.\n        \"\"\"\n        self.set_pixel_array(self.background)\n        return self\n\n\n    def set_frame_to_background(self, background):\n        self.set_pixel_array(background)\n\n    ####\n\n\n[docs]\n    def get_mobjects_to_display(\n        self,\n        mobjects: Iterable[Mobject],\n        include_submobjects: bool = True,\n        excluded_mobjects: list | None = None,\n    ):\n        \"\"\"Used to get the list of mobjects to display\n        with the camera.\n\n        Parameters\n        ----------\n        mobjects\n            The Mobjects\n        include_submobjects\n            Whether or not to include the submobjects of mobjects, by default True\n        excluded_mobjects\n            Any mobjects to exclude, by default None\n\n        Returns\n        -------\n        list\n            list of mobjects\n        \"\"\"\n        if include_submobjects:\n            mobjects = extract_mobject_family_members(\n                mobjects,\n                use_z_index=self.use_z_index,\n                only_those_with_points=True,\n            )\n            if excluded_mobjects:\n                all_excluded = extract_mobject_family_members(\n                    excluded_mobjects,\n                    use_z_index=self.use_z_index,\n                )\n                mobjects = list_difference_update(mobjects, all_excluded)\n        return list(mobjects)\n\n\n\n[docs]\n    def is_in_frame(self, mobject: Mobject):\n        \"\"\"Checks whether the passed mobject is in\n        frame or not.\n\n        Parameters\n        ----------\n        mobject\n            The mobject for which the checking needs to be done.\n\n        Returns\n        -------\n        bool\n            True if in frame, False otherwise.\n        \"\"\"\n        fc = self.frame_center\n        fh = self.frame_height\n        fw = self.frame_width\n        return not reduce(\n            op.or_,\n            [\n                mobject.get_right()[0] < fc[0] - fw / 2,\n                mobject.get_bottom()[1] > fc[1] + fh / 2,\n                mobject.get_left()[0] > fc[0] + fw / 2,\n                mobject.get_top()[1] < fc[1] - fh / 2,\n            ],\n        )\n\n\n\n[docs]\n    def capture_mobject(self, mobject: Mobject, **kwargs: Any):\n        \"\"\"Capture mobjects by storing it in :attr:`pixel_array`.\n\n        This is a single-mobject version of :meth:`capture_mobjects`.\n\n        Parameters\n        ----------\n        mobject\n            Mobject to capture.\n\n        kwargs\n            Keyword arguments to be passed to :meth:`get_mobjects_to_display`.\n\n        \"\"\"\n        return self.capture_mobjects([mobject], **kwargs)\n\n\n\n[docs]\n    def capture_mobjects(self, mobjects: Iterable[Mobject], **kwargs):\n        \"\"\"Capture mobjects by printing them on :attr:`pixel_array`.\n\n        This is the essential function that converts the contents of a Scene\n        into an array, which is then converted to an image or video.\n\n        Parameters\n        ----------\n        mobjects\n            Mobjects to capture.\n\n        kwargs\n            Keyword arguments to be passed to :meth:`get_mobjects_to_display`.\n\n        Notes\n        -----\n        For a list of classes that can currently be rendered, see :meth:`display_funcs`.\n\n        \"\"\"\n        # The mobjects will be processed in batches (or runs) of mobjects of\n        # the same type.  That is, if the list mobjects contains objects of\n        # types [VMobject, VMobject, VMobject, PMobject, PMobject, VMobject],\n        # then they will be captured in three batches: [VMobject, VMobject,\n        # VMobject], [PMobject, PMobject], and [VMobject].  This must be done\n        # without altering their order.  it.groupby computes exactly this\n        # partition while at the same time preserving order.\n        mobjects = self.get_mobjects_to_display(mobjects, **kwargs)\n        for group_type, group in it.groupby(mobjects, self.type_or_raise):\n            self.display_funcs[group_type](list(group), self.pixel_array)\n\n\n    # Methods associated with svg rendering\n\n    # NOTE: None of the methods below have been mentioned outside of their definitions. Their DocStrings are not as\n    # detailed as possible.\n\n\n[docs]\n    def get_cached_cairo_context(self, pixel_array: np.ndarray):\n        \"\"\"Returns the cached cairo context of the passed\n        pixel array if it exists, and None if it doesn't.\n\n        Parameters\n        ----------\n        pixel_array\n            The pixel array to check.\n\n        Returns\n        -------\n        cairo.Context\n            The cached cairo context.\n        \"\"\"\n        return self.pixel_array_to_cairo_context.get(id(pixel_array), None)\n\n\n\n[docs]\n    def cache_cairo_context(self, pixel_array: np.ndarray, ctx: cairo.Context):\n        \"\"\"Caches the passed Pixel array into a Cairo Context\n\n        Parameters\n        ----------\n        pixel_array\n            The pixel array to cache\n        ctx\n            The context to cache it into.\n        \"\"\"\n        self.pixel_array_to_cairo_context[id(pixel_array)] = ctx\n\n\n\n[docs]\n    def get_cairo_context(self, pixel_array: np.ndarray):\n        \"\"\"Returns the cairo context for a pixel array after\n        caching it to self.pixel_array_to_cairo_context\n        If that array has already been cached, it returns the\n        cached version instead.\n\n        Parameters\n        ----------\n        pixel_array\n            The Pixel array to get the cairo context of.\n\n        Returns\n        -------\n        cairo.Context\n            The cairo context of the pixel array.\n        \"\"\"\n        cached_ctx = self.get_cached_cairo_context(pixel_array)\n        if cached_ctx:\n            return cached_ctx\n        pw = self.pixel_width\n        ph = self.pixel_height\n        fw = self.frame_width\n        fh = self.frame_height\n        fc = self.frame_center\n        surface = cairo.ImageSurface.create_for_data(\n            pixel_array,\n            cairo.FORMAT_ARGB32,\n            pw,\n            ph,\n        )\n        ctx = cairo.Context(surface)\n        ctx.scale(pw, ph)\n        ctx.set_matrix(\n            cairo.Matrix(\n                (pw / fw),\n                0,\n                0,\n                -(ph / fh),\n                (pw / 2) - fc[0] * (pw / fw),\n                (ph / 2) + fc[1] * (ph / fh),\n            ),\n        )\n        self.cache_cairo_context(pixel_array, ctx)\n        return ctx\n\n\n\n[docs]\n    def display_multiple_vectorized_mobjects(\n        self, vmobjects: list, pixel_array: np.ndarray\n    ):\n        \"\"\"Displays multiple VMobjects in the pixel_array\n\n        Parameters\n        ----------\n        vmobjects\n            list of VMobjects to display\n        pixel_array\n            The pixel array\n        \"\"\"\n        if len(vmobjects) == 0:\n            return\n        batch_image_pairs = it.groupby(vmobjects, lambda vm: vm.get_background_image())\n        for image, batch in batch_image_pairs:\n            if image:\n                self.display_multiple_background_colored_vmobjects(batch, pixel_array)\n            else:\n                self.display_multiple_non_background_colored_vmobjects(\n                    batch,\n                    pixel_array,\n                )\n\n\n\n[docs]\n    def display_multiple_non_background_colored_vmobjects(\n        self, vmobjects: list, pixel_array: np.ndarray\n    ):\n        \"\"\"Displays multiple VMobjects in the cairo context, as long as they don't have\n        background colors.\n\n        Parameters\n        ----------\n        vmobjects\n            list of the VMobjects\n        pixel_array\n            The Pixel array to add the VMobjects to.\n        \"\"\"\n        ctx = self.get_cairo_context(pixel_array)\n        for vmobject in vmobjects:\n            self.display_vectorized(vmobject, ctx)\n\n\n\n[docs]\n    def display_vectorized(self, vmobject: VMobject, ctx: cairo.Context):\n        \"\"\"Displays a VMobject in the cairo context\n\n        Parameters\n        ----------\n        vmobject\n            The Vectorized Mobject to display\n        ctx\n            The cairo context to use.\n\n        Returns\n        -------\n        Camera\n            The camera object\n        \"\"\"\n        self.set_cairo_context_path(ctx, vmobject)\n        self.apply_stroke(ctx, vmobject, background=True)\n        self.apply_fill(ctx, vmobject)\n        self.apply_stroke(ctx, vmobject)\n        return self\n\n\n\n[docs]\n    def set_cairo_context_path(self, ctx: cairo.Context, vmobject: VMobject):\n        \"\"\"Sets a path for the cairo context with the vmobject passed\n\n        Parameters\n        ----------\n        ctx\n            The cairo context\n        vmobject\n            The VMobject\n\n        Returns\n        -------\n        Camera\n            Camera object after setting cairo_context_path\n        \"\"\"\n        points = self.transform_points_pre_display(vmobject, vmobject.points)\n        # TODO, shouldn't this be handled in transform_points_pre_display?\n        # points = points - self.get_frame_center()\n        if len(points) == 0:\n            return\n\n        ctx.new_path()\n        subpaths = vmobject.gen_subpaths_from_points_2d(points)\n        for subpath in subpaths:\n            quads = vmobject.gen_cubic_bezier_tuples_from_points(subpath)\n            ctx.new_sub_path()\n            start = subpath[0]\n            ctx.move_to(*start[:2])\n            for _p0, p1, p2, p3 in quads:\n                ctx.curve_to(*p1[:2], *p2[:2], *p3[:2])\n            if vmobject.consider_points_equals_2d(subpath[0], subpath[-1]):\n                ctx.close_path()\n        return self\n\n\n\n[docs]\n    def set_cairo_context_color(\n        self, ctx: cairo.Context, rgbas: np.ndarray, vmobject: VMobject\n    ):\n        \"\"\"Sets the color of the cairo context\n\n        Parameters\n        ----------\n        ctx\n            The cairo context\n        rgbas\n            The RGBA array with which to color the context.\n        vmobject\n            The VMobject with which to set the color.\n\n        Returns\n        -------\n        Camera\n            The camera object\n        \"\"\"\n        if len(rgbas) == 1:\n            # Use reversed rgb because cairo surface is\n            # encodes it in reverse order\n            ctx.set_source_rgba(*rgbas[0][2::-1], rgbas[0][3])\n        else:\n            points = vmobject.get_gradient_start_and_end_points()\n            points = self.transform_points_pre_display(vmobject, points)\n            pat = cairo.LinearGradient(*it.chain(*(point[:2] for point in points)))\n            step = 1.0 / (len(rgbas) - 1)\n            offsets = np.arange(0, 1 + step, step)\n            for rgba, offset in zip(rgbas, offsets):\n                pat.add_color_stop_rgba(offset, *rgba[2::-1], rgba[3])\n            ctx.set_source(pat)\n        return self\n\n\n\n[docs]\n    def apply_fill(self, ctx: cairo.Context, vmobject: VMobject):\n        \"\"\"Fills the cairo context\n\n        Parameters\n        ----------\n        ctx\n            The cairo context\n        vmobject\n            The VMobject\n\n        Returns\n        -------\n        Camera\n            The camera object.\n        \"\"\"\n        self.set_cairo_context_color(ctx, self.get_fill_rgbas(vmobject), vmobject)\n        ctx.fill_preserve()\n        return self\n\n\n\n[docs]\n    def apply_stroke(\n        self, ctx: cairo.Context, vmobject: VMobject, background: bool = False\n    ):\n        \"\"\"Applies a stroke to the VMobject in the cairo context.\n\n        Parameters\n        ----------\n        ctx\n            The cairo context\n        vmobject\n            The VMobject\n        background\n            Whether or not to consider the background when applying this\n            stroke width, by default False\n\n        Returns\n        -------\n        Camera\n            The camera object with the stroke applied.\n        \"\"\"\n        width = vmobject.get_stroke_width(background)\n        if width == 0:\n            return self\n        self.set_cairo_context_color(\n            ctx,\n            self.get_stroke_rgbas(vmobject, background=background),\n            vmobject,\n        )\n        ctx.set_line_width(\n            width\n            * self.cairo_line_width_multiple\n            * (self.frame_width / self.frame_width),\n            # This ensures lines have constant width as you zoom in on them.\n        )\n        if vmobject.joint_type != LineJointType.AUTO:\n            ctx.set_line_join(LINE_JOIN_MAP[vmobject.joint_type])\n        if vmobject.cap_style != CapStyleType.AUTO:\n            ctx.set_line_cap(CAP_STYLE_MAP[vmobject.cap_style])\n        ctx.stroke_preserve()\n        return self\n\n\n\n[docs]\n    def get_stroke_rgbas(self, vmobject: VMobject, background: bool = False):\n        \"\"\"Gets the RGBA array for the stroke of the passed\n        VMobject.\n\n        Parameters\n        ----------\n        vmobject\n            The VMobject\n        background\n            Whether or not to consider the background when getting the stroke\n            RGBAs, by default False\n\n        Returns\n        -------\n        np.ndarray\n            The RGBA array of the stroke.\n        \"\"\"\n        return vmobject.get_stroke_rgbas(background)\n\n\n\n[docs]\n    def get_fill_rgbas(self, vmobject: VMobject):\n        \"\"\"Returns the RGBA array of the fill of the passed VMobject\n\n        Parameters\n        ----------\n        vmobject\n            The VMobject\n\n        Returns\n        -------\n        np.array\n            The RGBA Array of the fill of the VMobject\n        \"\"\"\n        return vmobject.get_fill_rgbas()\n\n\n\n[docs]\n    def get_background_colored_vmobject_displayer(self):\n        \"\"\"Returns the background_colored_vmobject_displayer\n        if it exists or makes one and returns it if not.\n\n        Returns\n        -------\n        BackGroundColoredVMobjectDisplayer\n            Object that displays VMobjects that have the same color\n            as the background.\n        \"\"\"\n        # Quite wordy to type out a bunch\n        bcvd = \"background_colored_vmobject_displayer\"\n        if not hasattr(self, bcvd):\n            setattr(self, bcvd, BackgroundColoredVMobjectDisplayer(self))\n        return getattr(self, bcvd)\n\n\n\n[docs]\n    def display_multiple_background_colored_vmobjects(\n        self, cvmobjects: list, pixel_array: np.ndarray\n    ):\n        \"\"\"Displays multiple vmobjects that have the same color as the background.\n\n        Parameters\n        ----------\n        cvmobjects\n            List of Colored VMobjects\n        pixel_array\n            The pixel array.\n\n        Returns\n        -------\n        Camera\n            The camera object.\n        \"\"\"\n        displayer = self.get_background_colored_vmobject_displayer()\n        cvmobject_pixel_array = displayer.display(*cvmobjects)\n        self.overlay_rgba_array(pixel_array, cvmobject_pixel_array)\n        return self\n\n\n    # Methods for other rendering\n\n    # NOTE: Out of the following methods, only `transform_points_pre_display` and `points_to_pixel_coords` have been mentioned outside of their definitions.\n    # As a result, the other methods do not have as detailed docstrings as would be preferred.\n\n\n[docs]\n    def display_multiple_point_cloud_mobjects(\n        self, pmobjects: list, pixel_array: np.ndarray\n    ):\n        \"\"\"Displays multiple PMobjects by modifying the passed pixel array.\n\n        Parameters\n        ----------\n        pmobjects\n            List of PMobjects\n        pixel_array\n            The pixel array to modify.\n        \"\"\"\n        for pmobject in pmobjects:\n            self.display_point_cloud(\n                pmobject,\n                pmobject.points,\n                pmobject.rgbas,\n                self.adjusted_thickness(pmobject.stroke_width),\n                pixel_array,\n            )\n\n\n\n[docs]\n    def display_point_cloud(\n        self,\n        pmobject: PMobject,\n        points: list,\n        rgbas: np.ndarray,\n        thickness: float,\n        pixel_array: np.ndarray,\n    ):\n        \"\"\"Displays a PMobject by modifying the pixel array suitably.\n\n        TODO: Write a description for the rgbas argument.\n\n        Parameters\n        ----------\n        pmobject\n            Point Cloud Mobject\n        points\n            The points to display in the point cloud mobject\n        rgbas\n\n        thickness\n            The thickness of each point of the PMobject\n        pixel_array\n            The pixel array to modify.\n\n        \"\"\"\n        if len(points) == 0:\n            return\n        pixel_coords = self.points_to_pixel_coords(pmobject, points)\n        pixel_coords = self.thickened_coordinates(pixel_coords, thickness)\n        rgba_len = pixel_array.shape[2]\n\n        rgbas = (self.rgb_max_val * rgbas).astype(self.pixel_array_dtype)\n        target_len = len(pixel_coords)\n        factor = target_len // len(rgbas)\n        rgbas = np.array([rgbas] * factor).reshape((target_len, rgba_len))\n\n        on_screen_indices = self.on_screen_pixels(pixel_coords)\n        pixel_coords = pixel_coords[on_screen_indices]\n        rgbas = rgbas[on_screen_indices]\n\n        ph = self.pixel_height\n        pw = self.pixel_width\n\n        flattener = np.array([1, pw], dtype=\"int\")\n        flattener = flattener.reshape((2, 1))\n        indices = np.dot(pixel_coords, flattener)[:, 0]\n        indices = indices.astype(\"int\")\n\n        new_pa = pixel_array.reshape((ph * pw, rgba_len))\n        new_pa[indices] = rgbas\n        pixel_array[:, :] = new_pa.reshape((ph, pw, rgba_len))\n\n\n\n[docs]\n    def display_multiple_image_mobjects(\n        self, image_mobjects: list, pixel_array: np.ndarray\n    ):\n        \"\"\"Displays multiple image mobjects by modifying the passed pixel_array.\n\n        Parameters\n        ----------\n        image_mobjects\n            list of ImageMobjects\n        pixel_array\n            The pixel array to modify.\n        \"\"\"\n        for image_mobject in image_mobjects:\n            self.display_image_mobject(image_mobject, pixel_array)\n\n\n\n[docs]\n    def display_image_mobject(\n        self, image_mobject: AbstractImageMobject, pixel_array: np.ndarray\n    ):\n        \"\"\"Displays an ImageMobject by changing the pixel_array suitably.\n\n        Parameters\n        ----------\n        image_mobject\n            The imageMobject to display\n        pixel_array\n            The Pixel array to put the imagemobject in.\n        \"\"\"\n        corner_coords = self.points_to_pixel_coords(image_mobject, image_mobject.points)\n        ul_coords, ur_coords, dl_coords, _ = corner_coords\n        right_vect = ur_coords - ul_coords\n        down_vect = dl_coords - ul_coords\n        center_coords = ul_coords + (right_vect + down_vect) / 2\n\n        sub_image = Image.fromarray(image_mobject.get_pixel_array(), mode=\"RGBA\")\n\n        # Reshape\n        pixel_width = max(int(pdist([ul_coords, ur_coords]).item()), 1)\n        pixel_height = max(int(pdist([ul_coords, dl_coords]).item()), 1)\n        sub_image = sub_image.resize(\n            (pixel_width, pixel_height),\n            resample=image_mobject.resampling_algorithm,\n        )\n\n        # Rotate\n        angle = angle_of_vector(right_vect)\n        adjusted_angle = -int(360 * angle / TAU)\n        if adjusted_angle != 0:\n            sub_image = sub_image.rotate(\n                adjusted_angle,\n                resample=image_mobject.resampling_algorithm,\n                expand=1,\n            )\n\n        # TODO, there is no accounting for a shear...\n\n        # Paste into an image as large as the camera's pixel array\n        full_image = Image.fromarray(\n            np.zeros((self.pixel_height, self.pixel_width)),\n            mode=\"RGBA\",\n        )\n        new_ul_coords = center_coords - np.array(sub_image.size) / 2\n        new_ul_coords = new_ul_coords.astype(int)\n        full_image.paste(\n            sub_image,\n            box=(\n                new_ul_coords[0],\n                new_ul_coords[1],\n                new_ul_coords[0] + sub_image.size[0],\n                new_ul_coords[1] + sub_image.size[1],\n            ),\n        )\n        # Paint on top of existing pixel array\n        self.overlay_PIL_image(pixel_array, full_image)\n\n\n\n[docs]\n    def overlay_rgba_array(self, pixel_array: np.ndarray, new_array: np.ndarray):\n        \"\"\"Overlays an RGBA array on top of the given Pixel array.\n\n        Parameters\n        ----------\n        pixel_array\n            The original pixel array to modify.\n        new_array\n            The new pixel array to overlay.\n        \"\"\"\n        self.overlay_PIL_image(pixel_array, self.get_image(new_array))\n\n\n\n[docs]\n    def overlay_PIL_image(self, pixel_array: np.ndarray, image: Image):\n        \"\"\"Overlays a PIL image on the passed pixel array.\n\n        Parameters\n        ----------\n        pixel_array\n            The Pixel array\n        image\n            The Image to overlay.\n        \"\"\"\n        pixel_array[:, :] = np.array(\n            Image.alpha_composite(self.get_image(pixel_array), image),\n            dtype=\"uint8\",\n        )\n\n\n\n[docs]\n    def adjust_out_of_range_points(self, points: np.ndarray):\n        \"\"\"If any of the points in the passed array are out of\n        the viable range, they are adjusted suitably.\n\n        Parameters\n        ----------\n        points\n            The points to adjust\n\n        Returns\n        -------\n        np.array\n            The adjusted points.\n        \"\"\"\n        if not np.any(points > self.max_allowable_norm):\n            return points\n        norms = np.apply_along_axis(np.linalg.norm, 1, points)\n        violator_indices = norms > self.max_allowable_norm\n        violators = points[violator_indices, :]\n        violator_norms = norms[violator_indices]\n        reshaped_norms = np.repeat(\n            violator_norms.reshape((len(violator_norms), 1)),\n            points.shape[1],\n            1,\n        )\n        rescaled = self.max_allowable_norm * violators / reshaped_norms\n        points[violator_indices] = rescaled\n        return points\n\n\n    def transform_points_pre_display(\n        self,\n        mobject,\n        points,\n    ):  # TODO: Write more detailed docstrings for this method.\n        # NOTE: There seems to be an unused argument `mobject`.\n\n        # Subclasses (like ThreeDCamera) may want to\n        # adjust points further before they're shown\n        if not np.all(np.isfinite(points)):\n            # TODO, print some kind of warning about\n            # mobject having invalid points?\n            points = np.zeros((1, 3))\n        return points\n\n    def points_to_pixel_coords(\n        self,\n        mobject,\n        points,\n    ):  # TODO: Write more detailed docstrings for this method.\n        points = self.transform_points_pre_display(mobject, points)\n        shifted_points = points - self.frame_center\n\n        result = np.zeros((len(points), 2))\n        pixel_height = self.pixel_height\n        pixel_width = self.pixel_width\n        frame_height = self.frame_height\n        frame_width = self.frame_width\n        width_mult = pixel_width / frame_width\n        width_add = pixel_width / 2\n        height_mult = pixel_height / frame_height\n        height_add = pixel_height / 2\n        # Flip on y-axis as you go\n        height_mult *= -1\n\n        result[:, 0] = shifted_points[:, 0] * width_mult + width_add\n        result[:, 1] = shifted_points[:, 1] * height_mult + height_add\n        return result.astype(\"int\")\n\n\n[docs]\n    def on_screen_pixels(self, pixel_coords: np.ndarray):\n        \"\"\"Returns array of pixels that are on the screen from a given\n        array of pixel_coordinates\n\n        Parameters\n        ----------\n        pixel_coords\n            The pixel coords to check.\n\n        Returns\n        -------\n        np.array\n            The pixel coords on screen.\n        \"\"\"\n        return reduce(\n            op.and_,\n            [\n                pixel_coords[:, 0] >= 0,\n                pixel_coords[:, 0] < self.pixel_width,\n                pixel_coords[:, 1] >= 0,\n                pixel_coords[:, 1] < self.pixel_height,\n            ],\n        )\n\n\n\n[docs]\n    def adjusted_thickness(self, thickness: float) -> float:\n        \"\"\"Computes the adjusted stroke width for a zoomed camera.\n\n        Parameters\n        ----------\n        thickness\n            The stroke width of a mobject.\n\n        Returns\n        -------\n        float\n            The adjusted stroke width that reflects zooming in with\n            the camera.\n        \"\"\"\n        # TODO: This seems...unsystematic\n        big_sum = op.add(config[\"pixel_height\"], config[\"pixel_width\"])\n        this_sum = op.add(self.pixel_height, self.pixel_width)\n        factor = big_sum / this_sum\n        return 1 + (thickness - 1) * factor\n\n\n\n[docs]\n    def get_thickening_nudges(self, thickness: float):\n        \"\"\"Determine a list of vectors used to nudge\n        two-dimensional pixel coordinates.\n\n        Parameters\n        ----------\n        thickness\n\n        Returns\n        -------\n        np.array\n\n        \"\"\"\n        thickness = int(thickness)\n        _range = list(range(-thickness // 2 + 1, thickness // 2 + 1))\n        return np.array(list(it.product(_range, _range)))\n\n\n\n[docs]\n    def thickened_coordinates(self, pixel_coords: np.ndarray, thickness: float):\n        \"\"\"Returns thickened coordinates for a passed array of pixel coords and\n        a thickness to thicken by.\n\n        Parameters\n        ----------\n        pixel_coords\n            Pixel coordinates\n        thickness\n            Thickness\n\n        Returns\n        -------\n        np.array\n            Array of thickened pixel coords.\n        \"\"\"\n        nudges = self.get_thickening_nudges(thickness)\n        pixel_coords = np.array([pixel_coords + nudge for nudge in nudges])\n        size = pixel_coords.size\n        return pixel_coords.reshape((size // 2, 2))\n\n\n    # TODO, reimplement using cairo matrix\n\n[docs]\n    def get_coords_of_all_pixels(self):\n        \"\"\"Returns the cartesian coordinates of each pixel.\n\n        Returns\n        -------\n        np.ndarray\n            The array of cartesian coordinates.\n        \"\"\"\n        # These are in x, y order, to help me keep things straight\n        full_space_dims = np.array([self.frame_width, self.frame_height])\n        full_pixel_dims = np.array([self.pixel_width, self.pixel_height])\n\n        # These are addressed in the same y, x order as in pixel_array, but the values in them\n        # are listed in x, y order\n        uncentered_pixel_coords = np.indices([self.pixel_height, self.pixel_width])[\n            ::-1\n        ].transpose(1, 2, 0)\n        uncentered_space_coords = (\n            uncentered_pixel_coords * full_space_dims\n        ) / full_pixel_dims\n        # Could structure above line's computation slightly differently, but figured (without much\n        # thought) multiplying by frame_shape first, THEN dividing by pixel_shape, is probably\n        # better than the other order, for avoiding underflow quantization in the division (whereas\n        # overflow is unlikely to be a problem)\n\n        centered_space_coords = uncentered_space_coords - (full_space_dims / 2)\n\n        # Have to also flip the y coordinates to account for pixel array being listed in\n        # top-to-bottom order, opposite of screen coordinate convention\n        centered_space_coords = centered_space_coords * (1, -1)\n\n        return centered_space_coords\n\n\n\n\n# NOTE: The methods of the following class have not been mentioned outside of their definitions.\n# Their DocStrings are not as detailed as preferred.\n\n[docs]\nclass BackgroundColoredVMobjectDisplayer:\n    \"\"\"Auxiliary class that handles displaying vectorized mobjects with\n    a set background image.\n\n    Parameters\n    ----------\n    camera\n        Camera object to use.\n    \"\"\"\n\n    def __init__(self, camera: Camera):\n        self.camera = camera\n        self.file_name_to_pixel_array_map = {}\n        self.pixel_array = np.array(camera.pixel_array)\n        self.reset_pixel_array()\n\n    def reset_pixel_array(self):\n        self.pixel_array[:, :] = 0\n\n\n[docs]\n    def resize_background_array(\n        self,\n        background_array: np.ndarray,\n        new_width: float,\n        new_height: float,\n        mode: str = \"RGBA\",\n    ):\n        \"\"\"Resizes the pixel array representing the background.\n\n        Parameters\n        ----------\n        background_array\n            The pixel\n        new_width\n            The new width of the background\n        new_height\n            The new height of the background\n        mode\n            The PIL image mode, by default \"RGBA\"\n\n        Returns\n        -------\n        np.array\n            The numpy pixel array of the resized background.\n        \"\"\"\n        image = Image.fromarray(background_array)\n        image = image.convert(mode)\n        resized_image = image.resize((new_width, new_height))\n        return np.array(resized_image)\n\n\n\n[docs]\n    def resize_background_array_to_match(\n        self, background_array: np.ndarray, pixel_array: np.ndarray\n    ):\n        \"\"\"Resizes the background array to match the passed pixel array.\n\n        Parameters\n        ----------\n        background_array\n            The prospective pixel array.\n        pixel_array\n            The pixel array whose width and height should be matched.\n\n        Returns\n        -------\n        np.array\n            The resized background array.\n        \"\"\"\n        height, width = pixel_array.shape[:2]\n        mode = \"RGBA\" if pixel_array.shape[2] == 4 else \"RGB\"\n        return self.resize_background_array(background_array, width, height, mode)\n\n\n\n[docs]\n    def get_background_array(self, image: Image.Image | pathlib.Path | str):\n        \"\"\"Gets the background array that has the passed file_name.\n\n        Parameters\n        ----------\n        image\n            The background image or its file name.\n\n        Returns\n        -------\n        np.ndarray\n            The pixel array of the image.\n        \"\"\"\n        image_key = str(image)\n\n        if image_key in self.file_name_to_pixel_array_map:\n            return self.file_name_to_pixel_array_map[image_key]\n        if isinstance(image, str):\n            full_path = get_full_raster_image_path(image)\n            image = Image.open(full_path)\n        back_array = np.array(image)\n\n        pixel_array = self.pixel_array\n        if not np.all(pixel_array.shape == back_array.shape):\n            back_array = self.resize_background_array_to_match(back_array, pixel_array)\n\n        self.file_name_to_pixel_array_map[image_key] = back_array\n        return back_array\n\n\n\n[docs]\n    def display(self, *cvmobjects: VMobject):\n        \"\"\"Displays the colored VMobjects.\n\n        Parameters\n        ----------\n        *cvmobjects\n            The VMobjects\n\n        Returns\n        -------\n        np.array\n            The pixel array with the `cvmobjects` displayed.\n        \"\"\"\n        batch_image_pairs = it.groupby(cvmobjects, lambda cv: cv.get_background_image())\n        curr_array = None\n        for image, batch in batch_image_pairs:\n            background_array = self.get_background_array(image)\n            pixel_array = self.pixel_array\n            self.camera.display_multiple_non_background_colored_vmobjects(\n                batch,\n                pixel_array,\n            )\n            new_array = np.array(\n                (background_array * pixel_array.astype(\"float\") / 255),\n                dtype=self.camera.pixel_array_dtype,\n            )\n            if curr_array is None:\n                curr_array = new_array\n            else:\n                curr_array = np.maximum(curr_array, new_array)\n            self.reset_pixel_array()\n        return curr_array", "code_sha1": "4b2b173d0067b7214f3fa18586ba5a2e3e47952f"}
{"url": "https://docs.manim.community/en/stable/_modules/manim/_config/utils.html", "depth": 2, "instruction": "The code defines a configuration management system for the Manim library, encapsulating settings like frame dimensions, output directories, and rendering options in the `ManimConfig` class. It allows for dynamic updates from configuration files, command-line arguments, and programmatic changes, ensuring a unified interface for accessing and modifying configuration options.", "code": "\"\"\"Utilities to create and set the config.\n\nThe main class exported by this module is :class:`ManimConfig`.  This class\ncontains all configuration options, including frame geometry (e.g. frame\nheight/width, frame rate), output (e.g. directories, logging), styling\n(e.g. background color, transparency), and general behavior (e.g. writing a\nmovie vs writing a single frame).\n\nSee :doc:`/guides/configuration` for an introduction to Manim's configuration system.\n\n\"\"\"\n\nfrom __future__ import annotations\n\nimport argparse\nimport configparser\nimport copy\nimport errno\nimport logging\nimport os\nimport re\nimport sys\nfrom collections.abc import Iterable, Iterator, Mapping, MutableMapping\nfrom pathlib import Path\nfrom typing import TYPE_CHECKING, Any, ClassVar, NoReturn\n\nimport numpy as np\n\nfrom manim import constants\nfrom manim.constants import RendererType\nfrom manim.utils.color import ManimColor\nfrom manim.utils.tex import TexTemplate\n\nif TYPE_CHECKING:\n    from enum import EnumMeta\n\n    from typing_extensions import Self\n\n    from manim.typing import StrPath, Vector3D\n\n__all__ = [\"config_file_paths\", \"make_config_parser\", \"ManimConfig\", \"ManimFrame\"]\n\nlogger = logging.getLogger(\"manim\")\n\n\n\n[docs]\ndef config_file_paths() -> list[Path]:\n    \"\"\"The paths where ``.cfg`` files will be searched for.\n\n    When manim is first imported, it processes any ``.cfg`` files it finds.  This\n    function returns the locations in which these files are searched for.  In\n    ascending order of precedence, these are: the library-wide config file, the\n    user-wide config file, and the folder-wide config file.\n\n    The library-wide config file determines manim's default behavior.  The\n    user-wide config file is stored in the user's home folder, and determines\n    the behavior of manim whenever the user invokes it from anywhere in the\n    system.  The folder-wide config file only affects scenes that are in the\n    same folder.  The latter two files are optional.\n\n    These files, if they exist, are meant to loaded into a single\n    :class:`configparser.ConfigParser` object, and then processed by\n    :class:`ManimConfig`.\n\n    Returns\n    -------\n    List[:class:`Path`]\n        List of paths which may contain ``.cfg`` files, in ascending order of\n        precedence.\n\n    See Also\n    --------\n    :func:`make_config_parser`, :meth:`ManimConfig.digest_file`,\n    :meth:`ManimConfig.digest_parser`\n\n    Notes\n    -----\n    The location of the user-wide config file is OS-specific.\n\n    \"\"\"\n    library_wide = Path.resolve(Path(__file__).parent / \"default.cfg\")\n    if sys.platform.startswith(\"win32\"):\n        user_wide = Path.home() / \"AppData\" / \"Roaming\" / \"Manim\" / \"manim.cfg\"\n    else:\n        user_wide = Path.home() / \".config\" / \"manim\" / \"manim.cfg\"\n    folder_wide = Path(\"manim.cfg\")\n    return [library_wide, user_wide, folder_wide]\n\n\n\n\n[docs]\ndef make_config_parser(\n    custom_file: StrPath | None = None,\n) -> configparser.ConfigParser:\n    \"\"\"Make a :class:`ConfigParser` object and load any ``.cfg`` files.\n\n    The user-wide file, if it exists, overrides the library-wide file.  The\n    folder-wide file, if it exists, overrides the other two.\n\n    The folder-wide file can be ignored by passing ``custom_file``.  However,\n    the user-wide and library-wide config files cannot be ignored.\n\n    Parameters\n    ----------\n    custom_file\n        Path to a custom config file.  If used, the folder-wide file in the\n        relevant directory will be ignored, if it exists.  If None, the\n        folder-wide file will be used, if it exists.\n\n    Returns\n    -------\n    :class:`ConfigParser`\n        A parser containing the config options found in the .cfg files that\n        were found.  It is guaranteed to contain at least the config options\n        found in the library-wide file.\n\n    See Also\n    --------\n    :func:`config_file_paths`\n\n    \"\"\"\n    library_wide, user_wide, folder_wide = config_file_paths()\n    # From the documentation: \"An application which requires initial values to\n    # be loaded from a file should load the required file or files using\n    # read_file() before calling read() for any optional files.\"\n    # https://docs.python.org/3/library/configparser.html#configparser.ConfigParser.read\n    parser = configparser.ConfigParser()\n    with library_wide.open() as file:\n        parser.read_file(file)  # necessary file\n\n    other_files = [user_wide, Path(custom_file) if custom_file else folder_wide]\n    parser.read(other_files)  # optional files\n\n    return parser\n\n\n\ndef _determine_quality(qual: str) -> str:\n    for quality, values in constants.QUALITIES.items():\n        if values[\"flag\"] is not None and values[\"flag\"] == qual:\n            return quality\n\n    return qual\n\n\n\n[docs]\nclass ManimConfig(MutableMapping):\n    \"\"\"Dict-like class storing all config options.\n\n    The global ``config`` object is an instance of this class, and acts as a\n    single source of truth for all of the library's customizable behavior.\n\n    The global ``config`` object is capable of digesting different types of\n    sources and converting them into a uniform interface.  These sources are\n    (in ascending order of precedence): configuration files, command line\n    arguments, and programmatic changes.  Regardless of how the user chooses to\n    set a config option, she can access its current value using\n    :class:`ManimConfig`'s attributes and properties.\n\n    Notes\n    -----\n    Each config option is implemented as a property of this class.\n\n    Each config option can be set via a config file, using the full name of the\n    property.  If a config option has an associated CLI flag, then the flag is\n    equal to the full name of the property.  Those that admit an alternative\n    flag or no flag at all are documented in the individual property's\n    docstring.\n\n    Examples\n    --------\n    We use a copy of the global configuration object in the following\n    examples for the sake of demonstration; you can skip these lines\n    and just import ``config`` directly if you actually want to modify\n    the configuration:\n\n    .. code-block:: pycon\nfrom manim import config as global_config\nconfig = global_config.copy()\n\n    Each config option allows for dict syntax and attribute syntax.  For\n    example, the following two lines are equivalent,\n\n    .. code-block:: pycon\nfrom manim import WHITE\nconfig.background_color = WHITE\nconfig[\"background_color\"] = WHITE\n\n    The former is preferred; the latter is provided mostly for backwards\n    compatibility.\n\n    The config options are designed to keep internal consistency.  For example,\n    setting ``frame_y_radius`` will affect ``frame_height``:\n\n    .. code-block:: pycon\nconfig.frame_height\n        8.0\nconfig.frame_y_radius = 5.0\nconfig.frame_height\n        10.0\n\n    There are many ways of interacting with config options.  Take for example\n    the config option ``background_color``.  There are three ways to change it:\n    via a config file, via CLI flags, or programmatically.\n\n    To set the background color via a config file, save the following\n    ``manim.cfg`` file with the following contents.\n\n    .. code-block::\n\n       [CLI]\n       background_color = WHITE\n\n    In order to have this ``.cfg`` file apply to a manim scene, it needs to be\n    placed in the same directory as the script,\n\n    .. code-block:: bash\n\n          project/\n          ├─scene.py\n          └─manim.cfg\n\n    Now, when the user executes\n\n    .. code-block:: bash\n\n        manim scene.py\n\n    the background of the scene will be set to ``WHITE``.  This applies regardless\n    of where the manim command is invoked from.\n\n    Command line arguments override ``.cfg`` files.  In the previous example,\n    executing\n\n    .. code-block:: bash\n\n        manim scene.py -c BLUE\n\n    will set the background color to BLUE, regardless of the contents of\n    ``manim.cfg``.\n\n    Finally, any programmatic changes made within the scene script itself will\n    override the command line arguments.  For example, if ``scene.py`` contains\n    the following\n\n    .. code-block:: python\n\n        from manim import *\n\n        config.background_color = RED\n\n\n        class MyScene(Scene): ...\n\n    the background color will be set to RED, regardless of the contents of\n    ``manim.cfg`` or the CLI arguments used when invoking manim.\n\n    \"\"\"\n\n    _OPTS = {\n        \"assets_dir\",\n        \"background_color\",\n        \"background_opacity\",\n        \"custom_folders\",\n        \"disable_caching\",\n        \"disable_caching_warning\",\n        \"dry_run\",\n        \"enable_wireframe\",\n        \"ffmpeg_loglevel\",\n        \"format\",\n        \"flush_cache\",\n        \"frame_height\",\n        \"frame_rate\",\n        \"frame_width\",\n        \"frame_x_radius\",\n        \"frame_y_radius\",\n        \"from_animation_number\",\n        \"images_dir\",\n        \"input_file\",\n        \"media_embed\",\n        \"media_width\",\n        \"log_dir\",\n        \"log_to_file\",\n        \"max_files_cached\",\n        \"media_dir\",\n        \"movie_file_extension\",\n        \"notify_outdated_version\",\n        \"output_file\",\n        \"partial_movie_dir\",\n        \"pixel_height\",\n        \"pixel_width\",\n        \"plugins\",\n        \"preview\",\n        \"progress_bar\",\n        \"quality\",\n        \"save_as_gif\",\n        \"save_sections\",\n        \"save_last_frame\",\n        \"save_pngs\",\n        \"scene_names\",\n        \"show_in_file_browser\",\n        \"tex_dir\",\n        \"tex_template\",\n        \"tex_template_file\",\n        \"text_dir\",\n        \"upto_animation_number\",\n        \"renderer\",\n        \"enable_gui\",\n        \"gui_location\",\n        \"use_projection_fill_shaders\",\n        \"use_projection_stroke_shaders\",\n        \"verbosity\",\n        \"video_dir\",\n        \"sections_dir\",\n        \"fullscreen\",\n        \"window_position\",\n        \"window_size\",\n        \"window_monitor\",\n        \"write_all\",\n        \"write_to_movie\",\n        \"zero_pad\",\n        \"force_window\",\n        \"no_latex_cleanup\",\n        \"preview_command\",\n    }\n\n    def __init__(self) -> None:\n        self._d: dict[str, Any | None] = dict.fromkeys(self._OPTS)\n\n    # behave like a dict\n    def __iter__(self) -> Iterator[str]:\n        return iter(self._d)\n\n    def __len__(self) -> int:\n        return len(self._d)\n\n    def __contains__(self, key: object) -> bool:\n        try:\n            self.__getitem__(key)\n            return True\n        except AttributeError:\n            return False\n\n    def __getitem__(self, key: str) -> Any:\n        return getattr(self, key)\n\n    def __setitem__(self, key: str, val: Any) -> None:\n        getattr(ManimConfig, key).fset(self, val)  # fset is the property's setter\n\n\n[docs]\n    def update(self, obj: ManimConfig | dict[str, Any]) -> None:  # type: ignore[override]\n        \"\"\"Digest the options found in another :class:`ManimConfig` or in a dict.\n\n        Similar to :meth:`dict.update`, replaces the values of this object with\n        those of ``obj``.\n\n        Parameters\n        ----------\n        obj\n            The object to copy values from.\n\n        Returns\n        -------\n        None\n\n        Raises\n        -----\n        :class:`AttributeError`\n            If ``obj`` is a dict but contains keys that do not belong to any\n            config options.\n\n        See Also\n        --------\n        :meth:`~ManimConfig.digest_file`, :meth:`~ManimConfig.digest_args`,\n        :meth:`~ManimConfig.digest_parser`\n\n        \"\"\"\n        if isinstance(obj, ManimConfig):\n            self._d.update(obj._d)\n            if obj.tex_template:\n                self.tex_template = obj.tex_template\n\n        elif isinstance(obj, dict):\n            # First update the underlying _d, then update other properties\n            _dict = {k: v for k, v in obj.items() if k in self._d}\n            for k, v in _dict.items():\n                self[k] = v\n\n            _dict = {k: v for k, v in obj.items() if k not in self._d}\n            for k, v in _dict.items():\n                self[k] = v\n\n\n    # don't allow to delete anything\n    def __delitem__(self, key: str) -> NoReturn:\n        raise AttributeError(\"'ManimConfig' object does not support item deletion\")\n\n    def __delattr__(self, key: str) -> NoReturn:\n        raise AttributeError(\"'ManimConfig' object does not support item deletion\")\n\n    # copy functions\n\n[docs]\n    def copy(self) -> Self:\n        \"\"\"Deepcopy the contents of this ManimConfig.\n\n        Returns\n        -------\n        :class:`ManimConfig`\n            A copy of this object containing no shared references.\n\n        See Also\n        --------\n        :func:`tempconfig`\n\n        Notes\n        -----\n        This is the main mechanism behind :func:`tempconfig`.\n\n        \"\"\"\n        return copy.deepcopy(self)\n\n\n    def __copy__(self) -> Self:\n        \"\"\"See ManimConfig.copy().\"\"\"\n        return copy.deepcopy(self)\n\n    def __deepcopy__(self, memo: dict[str, Any]) -> Self:\n        \"\"\"See ManimConfig.copy().\"\"\"\n        c = type(self)()\n        # Deepcopying the underlying dict is enough because all properties\n        # either read directly from it or compute their value on the fly from\n        # values read directly from it.\n        c._d = copy.deepcopy(self._d, memo)\n        return c\n\n    # helper type-checking methods\n\n[docs]\n    def _set_from_list(self, key: str, val: Any, values: list[Any]) -> None:\n        \"\"\"Set ``key`` to ``val`` if ``val`` is contained in ``values``.\"\"\"\n        if val in values:\n            self._d[key] = val\n        else:\n            raise ValueError(f\"attempted to set {key} to {val}; must be in {values}\")\n\n\n\n[docs]\n    def _set_from_enum(self, key: str, enum_value: Any, enum_class: EnumMeta) -> None:\n        \"\"\"Set ``key`` to the enum object with value ``enum_value`` in the given\n        ``enum_class``.\n\n        Tests::\nfrom enum import Enum\nclass Fruit(Enum):\n    APPLE = 1\n    BANANA = 2\n    CANTALOUPE = 3\ntest_config = ManimConfig()\ntest_config._set_from_enum(\"fruit\", 1, Fruit)\ntest_config._d['fruit']\n            <Fruit.APPLE: 1>\ntest_config._set_from_enum(\"fruit\", Fruit.BANANA, Fruit)\ntest_config._d['fruit']\n            <Fruit.BANANA: 2>\ntest_config._set_from_enum(\"fruit\", 42, Fruit)\n            Traceback (most recent call last):\n\n            ValueError: 42 is not a valid Fruit\n        \"\"\"\n        self._d[key] = enum_class(enum_value)\n\n\n\n[docs]\n    def _set_boolean(self, key: str, val: Any) -> None:\n        \"\"\"Set ``key`` to ``val`` if ``val`` is Boolean.\"\"\"\n        if val in [True, False]:\n            self._d[key] = val\n        else:\n            raise ValueError(f\"{key} must be boolean\")\n\n\n    def _set_tuple(self, key: str, val: tuple[Any]) -> None:\n        if isinstance(val, tuple):\n            self._d[key] = val\n        else:\n            raise ValueError(f\"{key} must be tuple\")\n\n\n[docs]\n    def _set_str(self, key: str, val: Any) -> None:\n        \"\"\"Set ``key`` to ``val`` if ``val`` is a string.\"\"\"\n        if isinstance(val, str):\n            self._d[key] = val\n        elif not val:\n            self._d[key] = \"\"\n        else:\n            raise ValueError(f\"{key} must be str or falsy value\")\n\n\n\n[docs]\n    def _set_between(self, key: str, val: float, lo: float, hi: float) -> None:\n        \"\"\"Set ``key`` to ``val`` if lo <= val <= hi.\"\"\"\n        if lo <= val <= hi:\n            self._d[key] = val\n        else:\n            raise ValueError(f\"{key} must be {lo} <= {key} <= {hi}\")\n\n\n\n[docs]\n    def _set_int_between(self, key: str, val: int, lo: int, hi: int) -> None:\n        \"\"\"Set ``key`` to ``val`` if lo <= val <= hi.\"\"\"\n        if lo <= val <= hi:\n            self._d[key] = val\n        else:\n            raise ValueError(\n                f\"{key} must be an integer such that {lo} <= {key} <= {hi}\",\n            )\n\n\n\n[docs]\n    def _set_pos_number(self, key: str, val: int, allow_inf: bool) -> None:\n        \"\"\"Set ``key`` to ``val`` if ``val`` is a positive integer.\"\"\"\n        if isinstance(val, int) and val > -1:\n            self._d[key] = val\n        elif allow_inf and val in [-1, float(\"inf\")]:\n            self._d[key] = float(\"inf\")\n        else:\n            raise ValueError(\n                f\"{key} must be a non-negative integer (use -1 for infinity)\",\n            )\n\n\n    def __repr__(self) -> str:\n        rep = \"\"\n        for k, v in sorted(self._d.items(), key=lambda x: x[0]):\n            rep += f\"{k}: {v}, \"\n        return rep\n\n    # builders\n\n[docs]\n    def digest_parser(self, parser: configparser.ConfigParser) -> Self:\n        \"\"\"Process the config options present in a :class:`ConfigParser` object.\n\n        This method processes arbitrary parsers, not only those read from a\n        single file, whereas :meth:`~ManimConfig.digest_file` can only process one\n        file at a time.\n\n        Parameters\n        ----------\n        parser\n            An object reflecting the contents of one or many ``.cfg`` files.  In\n            particular, it may reflect the contents of multiple files that have\n            been parsed in a cascading fashion.\n\n        Returns\n        -------\n        self : :class:`ManimConfig`\n            This object, after processing the contents of ``parser``.\n\n        See Also\n        --------\n        :func:`make_config_parser`, :meth:`~.ManimConfig.digest_file`,\n        :meth:`~.ManimConfig.digest_args`,\n\n        Notes\n        -----\n        If there are multiple ``.cfg`` files to process, it is always more\n        efficient to parse them into a single :class:`ConfigParser` object\n        first, and then call this function once (instead of calling\n        :meth:`~.ManimConfig.digest_file` multiple times).\n\n        Examples\n        --------\n        To digest the config options set in two files, first create a\n        ConfigParser and parse both files and then digest the parser:\n\n        .. code-block:: python\n\n            parser = configparser.ConfigParser()\n            parser.read([file1, file2])\n            config = ManimConfig().digest_parser(parser)\n\n        In fact, the global ``config`` object is initialized like so:\n\n        .. code-block:: python\n\n            parser = make_config_parser()\n            config = ManimConfig().digest_parser(parser)\n\n        \"\"\"\n        self._parser = parser\n\n        # boolean keys\n        for key in [\n            \"notify_outdated_version\",\n            \"write_to_movie\",\n            \"save_last_frame\",\n            \"write_all\",\n            \"save_pngs\",\n            \"save_as_gif\",\n            \"save_sections\",\n            \"preview\",\n            \"show_in_file_browser\",\n            \"log_to_file\",\n            \"disable_caching\",\n            \"disable_caching_warning\",\n            \"flush_cache\",\n            \"custom_folders\",\n            \"enable_gui\",\n            \"fullscreen\",\n            \"use_projection_fill_shaders\",\n            \"use_projection_stroke_shaders\",\n            \"enable_wireframe\",\n            \"force_window\",\n            \"no_latex_cleanup\",\n        ]:\n            setattr(self, key, parser[\"CLI\"].getboolean(key, fallback=False))\n\n        # int keys\n        for key in [\n            \"from_animation_number\",\n            \"upto_animation_number\",\n            \"max_files_cached\",\n            # the next two must be set BEFORE digesting frame_width and frame_height\n            \"pixel_height\",\n            \"pixel_width\",\n            \"window_monitor\",\n            \"zero_pad\",\n        ]:\n            setattr(self, key, parser[\"CLI\"].getint(key))\n\n        # str keys\n        for key in [\n            \"assets_dir\",\n            \"verbosity\",\n            \"media_dir\",\n            \"log_dir\",\n            \"video_dir\",\n            \"sections_dir\",\n            \"images_dir\",\n            \"text_dir\",\n            \"tex_dir\",\n            \"partial_movie_dir\",\n            \"input_file\",\n            \"output_file\",\n            \"movie_file_extension\",\n            \"background_color\",\n            \"renderer\",\n            \"window_position\",\n        ]:\n            setattr(self, key, parser[\"CLI\"].get(key, fallback=\"\", raw=True))\n\n        # float keys\n        for key in [\n            \"background_opacity\",\n            \"frame_rate\",\n            # the next two are floats but have their own logic, applied later\n            # \"frame_width\",\n            # \"frame_height\",\n        ]:\n            setattr(self, key, parser[\"CLI\"].getfloat(key))\n\n        # tuple keys\n        gui_location = tuple(\n            map(int, re.split(r\"[;,\\-]\", parser[\"CLI\"][\"gui_location\"])),\n        )\n        self.gui_location = gui_location\n\n        window_size = parser[\"CLI\"][\n            \"window_size\"\n        ]  # if not \"default\", get a tuple of the position\n        if window_size != \"default\":\n            window_size = tuple(map(int, re.split(r\"[;,\\-]\", window_size)))\n        self.window_size = window_size\n\n        # plugins\n        plugins = parser[\"CLI\"].get(\"plugins\", fallback=\"\", raw=True)\n        plugins = [] if plugins == \"\" else plugins.split(\",\")\n        self.plugins = plugins\n        # the next two must be set AFTER digesting pixel_width and pixel_height\n        self[\"frame_height\"] = parser[\"CLI\"].getfloat(\"frame_height\", 8.0)\n        width = parser[\"CLI\"].getfloat(\"frame_width\", None)\n        if width is None:\n            self[\"frame_width\"] = self[\"frame_height\"] * self[\"aspect_ratio\"]\n        else:\n            self[\"frame_width\"] = width\n\n        # other logic\n        val = parser[\"CLI\"].get(\"tex_template_file\")\n        if val:\n            self.tex_template_file = val\n\n        val = parser[\"CLI\"].get(\"progress_bar\")\n        if val:\n            self.progress_bar = val\n\n        val = parser[\"ffmpeg\"].get(\"loglevel\")\n        if val:\n            self.ffmpeg_loglevel = val\n\n        try:\n            val = parser[\"jupyter\"].getboolean(\"media_embed\")\n        except ValueError:\n            val = None\n        self.media_embed = val\n\n        val = parser[\"jupyter\"].get(\"media_width\")\n        if val:\n            self.media_width = val\n\n        val = parser[\"CLI\"].get(\"quality\", fallback=\"\", raw=True)\n        if val:\n            self.quality = _determine_quality(val)\n\n        return self\n\n\n\n[docs]\n    def digest_args(self, args: argparse.Namespace) -> Self:\n        \"\"\"Process the config options present in CLI arguments.\n\n        Parameters\n        ----------\n        args\n            An object returned by :func:`.main_utils.parse_args()`.\n\n        Returns\n        -------\n        self : :class:`ManimConfig`\n            This object, after processing the contents of ``parser``.\n\n        See Also\n        --------\n        :func:`.main_utils.parse_args()`, :meth:`~.ManimConfig.digest_parser`,\n        :meth:`~.ManimConfig.digest_file`\n\n        Notes\n        -----\n        If ``args.config_file`` is a non-empty string, ``ManimConfig`` tries to digest the\n        contents of said file with :meth:`~ManimConfig.digest_file` before\n        digesting any other CLI arguments.\n\n        \"\"\"\n        # if the input file is a config file, parse it properly\n        if args.file.suffix == \".cfg\":\n            args.config_file = args.file\n\n        # if args.file is `-`, the animation code has to be taken from STDIN, so the\n        # input file path shouldn't be absolute, since that file won't be read.\n        if str(args.file) == \"-\":\n            self.input_file = args.file\n\n        # if a config file has been passed, digest it first so that other CLI\n        # flags supersede it\n        if args.config_file:\n            self.digest_file(args.config_file)\n\n        # read input_file from the args if it wasn't set by the config file\n        if not self.input_file:\n            self.input_file = Path(args.file).absolute()\n\n        self.scene_names = args.scene_names if args.scene_names is not None else []\n        self.output_file = args.output_file\n\n        for key in [\n            \"notify_outdated_version\",\n            \"preview\",\n            \"show_in_file_browser\",\n            \"write_to_movie\",\n            \"save_last_frame\",\n            \"save_pngs\",\n            \"save_as_gif\",\n            \"save_sections\",\n            \"write_all\",\n            \"disable_caching\",\n            \"format\",\n            \"flush_cache\",\n            \"progress_bar\",\n            \"transparent\",\n            \"scene_names\",\n            \"verbosity\",\n            \"renderer\",\n            \"background_color\",\n            \"enable_gui\",\n            \"fullscreen\",\n            \"use_projection_fill_shaders\",\n            \"use_projection_stroke_shaders\",\n            \"zero_pad\",\n            \"enable_wireframe\",\n            \"force_window\",\n            \"dry_run\",\n            \"no_latex_cleanup\",\n            \"preview_command\",\n        ]:\n            if hasattr(args, key):\n                attr = getattr(args, key)\n                # if attr is None, then no argument was passed and we should\n                # not change the current config\n                if attr is not None:\n                    self[key] = attr\n\n        for key in [\n            \"media_dir\",  # always set this one first\n            \"log_dir\",\n            \"log_to_file\",  # always set this one last\n        ]:\n            if hasattr(args, key):\n                attr = getattr(args, key)\n                # if attr is None, then no argument was passed and we should\n                # not change the current config\n                if attr is not None:\n                    self[key] = attr\n\n        if self[\"save_last_frame\"]:\n            self[\"write_to_movie\"] = False\n\n        # Handle the -n flag.\n        nflag = args.from_animation_number\n        if nflag:\n            self.from_animation_number = nflag[0]\n            try:\n                self.upto_animation_number = nflag[1]\n            except Exception:\n                logger.info(\n                    f\"No end scene number specified in -n option. Rendering from {nflag[0]} onwards...\",\n                )\n\n        # Handle the quality flags\n        self.quality = _determine_quality(getattr(args, \"quality\", None))\n\n        # Handle the -r flag.\n        rflag = args.resolution\n        if rflag:\n            self.pixel_width = int(rflag[0])\n            self.pixel_height = int(rflag[1])\n\n        fps = args.frame_rate\n        if fps:\n            self.frame_rate = float(fps)\n\n        # Handle --custom_folders\n        if args.custom_folders:\n            for opt in [\n                \"media_dir\",\n                \"video_dir\",\n                \"sections_dir\",\n                \"images_dir\",\n                \"text_dir\",\n                \"tex_dir\",\n                \"log_dir\",\n                \"partial_movie_dir\",\n            ]:\n                self[opt] = self._parser[\"custom_folders\"].get(opt, raw=True)\n            # --media_dir overrides the default.cfg file\n            if hasattr(args, \"media_dir\") and args.media_dir:\n                self.media_dir = args.media_dir\n\n        # Handle --tex_template\n        if args.tex_template:\n            self.tex_template = TexTemplate.from_file(args.tex_template)\n\n        if self.renderer == RendererType.OPENGL and args.write_to_movie is None:\n            # --write_to_movie was not passed on the command line, so don't generate video.\n            self[\"write_to_movie\"] = False\n\n        # Handle --gui_location flag.\n        if args.gui_location is not None:\n            self.gui_location = args.gui_location\n\n        return self\n\n\n\n[docs]\n    def digest_file(self, filename: StrPath) -> Self:\n        \"\"\"Process the config options present in a ``.cfg`` file.\n\n        This method processes a single ``.cfg`` file, whereas\n        :meth:`~ManimConfig.digest_parser` can process arbitrary parsers, built\n        perhaps from multiple ``.cfg`` files.\n\n        Parameters\n        ----------\n        filename\n            Path to the ``.cfg`` file.\n\n        Returns\n        -------\n        self : :class:`ManimConfig`\n            This object, after processing the contents of ``filename``.\n\n        See Also\n        --------\n        :meth:`~ManimConfig.digest_file`, :meth:`~ManimConfig.digest_args`,\n        :func:`make_config_parser`\n\n        Notes\n        -----\n        If there are multiple ``.cfg`` files to process, it is always more\n        efficient to parse them into a single :class:`ConfigParser` object\n        first and digesting them with one call to\n        :meth:`~ManimConfig.digest_parser`, instead of calling this method\n        multiple times.\n\n        \"\"\"\n        if not Path(filename).is_file():\n            raise FileNotFoundError(\n                errno.ENOENT,\n                \"Error: --config_file could not find a valid config file.\",\n                str(filename),\n            )\n\n        return self.digest_parser(make_config_parser(filename))\n\n\n    # config options are properties\n\n    @property\n    def preview(self) -> bool:\n        \"\"\"Whether to play the rendered movie (-p).\"\"\"\n        return self._d[\"preview\"] or self._d[\"enable_gui\"]\n\n    @preview.setter\n    def preview(self, value: bool) -> None:\n        self._set_boolean(\"preview\", value)\n\n    @property\n    def show_in_file_browser(self) -> bool:\n        \"\"\"Whether to show the output file in the file browser (-f).\"\"\"\n        return self._d[\"show_in_file_browser\"]\n\n    @show_in_file_browser.setter\n    def show_in_file_browser(self, value: bool) -> None:\n        self._set_boolean(\"show_in_file_browser\", value)\n\n    @property\n    def progress_bar(self) -> str:\n        \"\"\"Whether to show progress bars while rendering animations.\"\"\"\n        return self._d[\"progress_bar\"]\n\n    @progress_bar.setter\n    def progress_bar(self, value: str) -> None:\n        self._set_from_list(\"progress_bar\", value, [\"none\", \"display\", \"leave\"])\n\n    @property\n    def log_to_file(self) -> bool:\n        \"\"\"Whether to save logs to a file.\"\"\"\n        return self._d[\"log_to_file\"]\n\n    @log_to_file.setter\n    def log_to_file(self, value: bool) -> None:\n        self._set_boolean(\"log_to_file\", value)\n\n    @property\n    def notify_outdated_version(self) -> bool:\n        \"\"\"Whether to notify if there is a version update available.\"\"\"\n        return self._d[\"notify_outdated_version\"]\n\n    @notify_outdated_version.setter\n    def notify_outdated_version(self, value: bool) -> None:\n        self._set_boolean(\"notify_outdated_version\", value)\n\n    @property\n    def write_to_movie(self) -> bool:\n        \"\"\"Whether to render the scene to a movie file (-w).\"\"\"\n        return self._d[\"write_to_movie\"]\n\n    @write_to_movie.setter\n    def write_to_movie(self, value: bool) -> None:\n        self._set_boolean(\"write_to_movie\", value)\n\n    @property\n    def save_last_frame(self) -> bool:\n        \"\"\"Whether to save the last frame of the scene as an image file (-s).\"\"\"\n        return self._d[\"save_last_frame\"]\n\n    @save_last_frame.setter\n    def save_last_frame(self, value: bool) -> None:\n        self._set_boolean(\"save_last_frame\", value)\n\n    @property\n    def write_all(self) -> bool:\n        \"\"\"Whether to render all scenes in the input file (-a).\"\"\"\n        return self._d[\"write_all\"]\n\n    @write_all.setter\n    def write_all(self, value: bool) -> None:\n        self._set_boolean(\"write_all\", value)\n\n    @property\n    def save_pngs(self) -> bool:\n        \"\"\"Whether to save all frames in the scene as images files (-g).\"\"\"\n        return self._d[\"save_pngs\"]\n\n    @save_pngs.setter\n    def save_pngs(self, value: bool) -> None:\n        self._set_boolean(\"save_pngs\", value)\n\n    @property\n    def save_as_gif(self) -> bool:\n        \"\"\"Whether to save the rendered scene in .gif format (-i).\"\"\"\n        return self._d[\"save_as_gif\"]\n\n    @save_as_gif.setter\n    def save_as_gif(self, value: bool) -> None:\n        self._set_boolean(\"save_as_gif\", value)\n\n    @property\n    def save_sections(self) -> bool:\n        \"\"\"Whether to save single videos for each section in addition to the movie file.\"\"\"\n        return self._d[\"save_sections\"]\n\n    @save_sections.setter\n    def save_sections(self, value: bool) -> None:\n        self._set_boolean(\"save_sections\", value)\n\n    @property\n    def enable_wireframe(self) -> bool:\n        \"\"\"Whether to enable wireframe debugging mode in opengl.\"\"\"\n        return self._d[\"enable_wireframe\"]\n\n    @enable_wireframe.setter\n    def enable_wireframe(self, value: bool) -> None:\n        self._set_boolean(\"enable_wireframe\", value)\n\n    @property\n    def force_window(self) -> bool:\n        \"\"\"Whether to force window when using the opengl renderer.\"\"\"\n        return self._d[\"force_window\"]\n\n    @force_window.setter\n    def force_window(self, value: bool) -> None:\n        self._set_boolean(\"force_window\", value)\n\n    @property\n    def no_latex_cleanup(self) -> bool:\n        \"\"\"Prevents deletion of .aux, .dvi, and .log files produced by Tex and MathTex.\"\"\"\n        return self._d[\"no_latex_cleanup\"]\n\n    @no_latex_cleanup.setter\n    def no_latex_cleanup(self, value: bool) -> None:\n        self._set_boolean(\"no_latex_cleanup\", value)\n\n    @property\n    def preview_command(self) -> str:\n        return self._d[\"preview_command\"]\n\n    @preview_command.setter\n    def preview_command(self, value: str) -> None:\n        self._set_str(\"preview_command\", value)\n\n    @property\n    def verbosity(self) -> str:\n        \"\"\"Logger verbosity; \"DEBUG\", \"INFO\", \"WARNING\", \"ERROR\", or \"CRITICAL\" (-v).\"\"\"\n        return self._d[\"verbosity\"]\n\n    @verbosity.setter\n    def verbosity(self, val: str) -> None:\n        self._set_from_list(\n            \"verbosity\",\n            val,\n            [\"DEBUG\", \"INFO\", \"WARNING\", \"ERROR\", \"CRITICAL\"],\n        )\n        logger.setLevel(val)\n\n    @property\n    def format(self) -> str:\n        \"\"\"File format; \"png\", \"gif\", \"mp4\", \"webm\" or \"mov\".\"\"\"\n        return self._d[\"format\"]\n\n    @format.setter\n    def format(self, val: str) -> None:\n        self._set_from_list(\n            \"format\",\n            val,\n            [None, \"png\", \"gif\", \"mp4\", \"mov\", \"webm\"],\n        )\n        self.resolve_movie_file_extension(self.transparent)\n        if self.format == \"webm\":\n            logger.warning(\n                \"Output format set as webm, this can be slower than other formats\",\n            )\n\n    @property\n    def ffmpeg_loglevel(self) -> str:\n        \"\"\"Verbosity level of ffmpeg (no flag).\"\"\"\n        return self._d[\"ffmpeg_loglevel\"]\n\n    @ffmpeg_loglevel.setter\n    def ffmpeg_loglevel(self, val: str) -> None:\n        self._set_from_list(\n            \"ffmpeg_loglevel\",\n            val,\n            [\"DEBUG\", \"INFO\", \"WARNING\", \"ERROR\", \"CRITICAL\"],\n        )\n        logging.getLogger(\"libav\").setLevel(self.ffmpeg_loglevel)\n\n    @property\n    def media_embed(self) -> bool:\n        \"\"\"Whether to embed videos in Jupyter notebook.\"\"\"\n        return self._d[\"media_embed\"]\n\n    @media_embed.setter\n    def media_embed(self, value: bool) -> None:\n        self._set_boolean(\"media_embed\", value)\n\n    @property\n    def media_width(self) -> str:\n        \"\"\"Media width in Jupyter notebook.\"\"\"\n        return self._d[\"media_width\"]\n\n    @media_width.setter\n    def media_width(self, value: str) -> None:\n        self._set_str(\"media_width\", value)\n\n    @property\n    def pixel_width(self) -> int:\n        \"\"\"Frame width in pixels (--resolution, -r).\"\"\"\n        return self._d[\"pixel_width\"]\n\n    @pixel_width.setter\n    def pixel_width(self, value: int) -> None:\n        self._set_pos_number(\"pixel_width\", value, False)\n\n    @property\n    def pixel_height(self) -> int:\n        \"\"\"Frame height in pixels (--resolution, -r).\"\"\"\n        return self._d[\"pixel_height\"]\n\n    @pixel_height.setter\n    def pixel_height(self, value: int) -> None:\n        self._set_pos_number(\"pixel_height\", value, False)\n\n    @property\n    def aspect_ratio(self) -> int:\n        \"\"\"Aspect ratio (width / height) in pixels (--resolution, -r).\"\"\"\n        return self._d[\"pixel_width\"] / self._d[\"pixel_height\"]\n\n    @property\n    def frame_height(self) -> float:\n        \"\"\"Frame height in logical units (no flag).\"\"\"\n        return self._d[\"frame_height\"]\n\n    @frame_height.setter\n    def frame_height(self, value: float) -> None:\n        self._d.__setitem__(\"frame_height\", value)\n\n    @property\n    def frame_width(self) -> float:\n        \"\"\"Frame width in logical units (no flag).\"\"\"\n        return self._d[\"frame_width\"]\n\n    @frame_width.setter\n    def frame_width(self, value: float) -> None:\n        self._d.__setitem__(\"frame_width\", value)\n\n    @property\n    def frame_y_radius(self) -> float:\n        \"\"\"Half the frame height (no flag).\"\"\"\n        return self._d[\"frame_height\"] / 2\n\n    @frame_y_radius.setter\n    def frame_y_radius(self, value: float) -> None:\n        self._d.__setitem__(\"frame_y_radius\", value) or self._d.__setitem__(\n            \"frame_height\", 2 * value\n        )\n\n    @property\n    def frame_x_radius(self) -> float:\n        \"\"\"Half the frame width (no flag).\"\"\"\n        return self._d[\"frame_width\"] / 2\n\n    @frame_x_radius.setter\n    def frame_x_radius(self, value: float) -> None:\n        self._d.__setitem__(\"frame_x_radius\", value) or self._d.__setitem__(\n            \"frame_width\", 2 * value\n        )\n\n    @property\n    def top(self) -> Vector3D:\n        \"\"\"Coordinate at the center top of the frame.\"\"\"\n        return self.frame_y_radius * constants.UP\n\n    @property\n    def bottom(self) -> Vector3D:\n        \"\"\"Coordinate at the center bottom of the frame.\"\"\"\n        return self.frame_y_radius * constants.DOWN\n\n    @property\n    def left_side(self) -> Vector3D:\n        \"\"\"Coordinate at the middle left of the frame.\"\"\"\n        return self.frame_x_radius * constants.LEFT\n\n    @property\n    def right_side(self) -> Vector3D:\n        \"\"\"Coordinate at the middle right of the frame.\"\"\"\n        return self.frame_x_radius * constants.RIGHT\n\n    @property\n    def frame_rate(self) -> float:\n        \"\"\"Frame rate in frames per second.\"\"\"\n        return self._d[\"frame_rate\"]\n\n    @frame_rate.setter\n    def frame_rate(self, value: float) -> None:\n        self._d.__setitem__(\"frame_rate\", value)\n\n    # TODO: This was parsed before maybe add ManimColor(val), but results in circular import\n    @property\n    def background_color(self) -> ManimColor:\n        \"\"\"Background color of the scene (-c).\"\"\"\n        return self._d[\"background_color\"]\n\n    @background_color.setter\n    def background_color(self, value: Any) -> None:\n        self._d.__setitem__(\"background_color\", ManimColor(value))\n\n    @property\n    def from_animation_number(self) -> int:\n        \"\"\"Start rendering animations at this number (-n).\"\"\"\n        return self._d[\"from_animation_number\"]\n\n    @from_animation_number.setter\n    def from_animation_number(self, value: int) -> None:\n        self._d.__setitem__(\"from_animation_number\", value)\n\n    @property\n    def upto_animation_number(self) -> int:\n        \"\"\"Stop rendering animations at this number. Use -1 to avoid skipping (-n).\"\"\"\n        return self._d[\"upto_animation_number\"]\n\n    @upto_animation_number.setter\n    def upto_animation_number(self, value: int) -> None:\n        self._set_pos_number(\"upto_animation_number\", value, True)\n\n    @property\n    def max_files_cached(self) -> int:\n        \"\"\"Maximum number of files cached.  Use -1 for infinity (no flag).\"\"\"\n        return self._d[\"max_files_cached\"]\n\n    @max_files_cached.setter\n    def max_files_cached(self, value: int) -> None:\n        self._set_pos_number(\"max_files_cached\", value, True)\n\n    @property\n    def window_monitor(self) -> int:\n        \"\"\"The monitor on which the scene will be rendered.\"\"\"\n        return self._d[\"window_monitor\"]\n\n    @window_monitor.setter\n    def window_monitor(self, value: int) -> None:\n        self._set_pos_number(\"window_monitor\", value, True)\n\n    @property\n    def flush_cache(self) -> bool:\n        \"\"\"Whether to delete all the cached partial movie files.\"\"\"\n        return self._d[\"flush_cache\"]\n\n    @flush_cache.setter\n    def flush_cache(self, value: bool) -> None:\n        self._set_boolean(\"flush_cache\", value)\n\n    @property\n    def disable_caching(self) -> bool:\n        \"\"\"Whether to use scene caching.\"\"\"\n        return self._d[\"disable_caching\"]\n\n    @disable_caching.setter\n    def disable_caching(self, value: bool) -> None:\n        self._set_boolean(\"disable_caching\", value)\n\n    @property\n    def disable_caching_warning(self) -> bool:\n        \"\"\"Whether a warning is raised if there are too much submobjects to hash.\"\"\"\n        return self._d[\"disable_caching_warning\"]\n\n    @disable_caching_warning.setter\n    def disable_caching_warning(self, value: bool) -> None:\n        self._set_boolean(\"disable_caching_warning\", value)\n\n    @property\n    def movie_file_extension(self) -> str:\n        \"\"\"Either .mp4, .webm or .mov.\"\"\"\n        return self._d[\"movie_file_extension\"]\n\n    @movie_file_extension.setter\n    def movie_file_extension(self, value: str) -> None:\n        self._set_from_list(\"movie_file_extension\", value, [\".mp4\", \".mov\", \".webm\"])\n\n    @property\n    def background_opacity(self) -> float:\n        \"\"\"A number between 0.0 (fully transparent) and 1.0 (fully opaque).\"\"\"\n        return self._d[\"background_opacity\"]\n\n    @background_opacity.setter\n    def background_opacity(self, value: float) -> None:\n        self._set_between(\"background_opacity\", value, 0, 1)\n        if self.background_opacity < 1:\n            self.resolve_movie_file_extension(is_transparent=True)\n\n    @property\n    def frame_size(self) -> tuple[int, int]:\n        \"\"\"Tuple with (pixel width, pixel height) (no flag).\"\"\"\n        return (self._d[\"pixel_width\"], self._d[\"pixel_height\"])\n\n    @frame_size.setter\n    def frame_size(self, value: tuple[int, int]) -> None:\n        self._d.__setitem__(\"pixel_width\", value[0]) or self._d.__setitem__(\n            \"pixel_height\", value[1]\n        )\n\n    @property\n    def quality(self) -> str | None:\n        \"\"\"Video quality (-q).\"\"\"\n        keys = [\"pixel_width\", \"pixel_height\", \"frame_rate\"]\n        q = {k: self[k] for k in keys}\n        for qual in constants.QUALITIES:\n            if all(q[k] == constants.QUALITIES[qual][k] for k in keys):\n                return qual\n        return None\n\n    @quality.setter\n    def quality(self, value: str | None) -> None:\n        if value is None:\n            return\n        if value not in constants.QUALITIES:\n            raise KeyError(f\"quality must be one of {list(constants.QUALITIES.keys())}\")\n        q = constants.QUALITIES[value]\n        self.frame_size = q[\"pixel_width\"], q[\"pixel_height\"]\n        self.frame_rate = q[\"frame_rate\"]\n\n    @property\n    def transparent(self) -> bool:\n        \"\"\"Whether the background opacity is less than 1.0 (-t).\"\"\"\n        return self._d[\"background_opacity\"] < 1.0\n\n    @transparent.setter\n    def transparent(self, value: bool) -> None:\n        self._d[\"background_opacity\"] = float(not value)\n        self.resolve_movie_file_extension(value)\n\n    @property\n    def dry_run(self) -> bool:\n        \"\"\"Whether dry run is enabled.\"\"\"\n        return self._d[\"dry_run\"]\n\n    @dry_run.setter\n    def dry_run(self, val: bool) -> None:\n        self._d[\"dry_run\"] = val\n        if val:\n            self.write_to_movie = False\n            self.write_all = False\n            self.save_last_frame = False\n            self.format = None\n\n    @property\n    def renderer(self) -> RendererType:\n        \"\"\"The currently active renderer.\n\n        Populated with one of the available renderers in :class:`.RendererType`.\n\n        Tests::\ntest_config = ManimConfig()\ntest_config.renderer is None  # a new ManimConfig is unpopulated\n            True\ntest_config.renderer = 'opengl'\ntest_config.renderer\n            <RendererType.OPENGL: 'opengl'>\ntest_config.renderer = 42\n            Traceback (most recent call last):\n\n            ValueError: 42 is not a valid RendererType\n\n        Check that capitalization of renderer types is irrelevant::\ntest_config.renderer = 'OpenGL'\ntest_config.renderer = 'cAirO'\n        \"\"\"\n        return self._d[\"renderer\"]\n\n    @renderer.setter\n    def renderer(self, value: str | RendererType) -> None:\n        \"\"\"The setter of the renderer property.\n\n        Takes care of switching inheritance bases using the\n        :class:`.ConvertToOpenGL` metaclass.\n        \"\"\"\n        if isinstance(value, str):\n            value = value.lower()\n        renderer = RendererType(value)\n        try:\n            from manim.mobject.opengl.opengl_compatibility import ConvertToOpenGL\n            from manim.mobject.opengl.opengl_mobject import OpenGLMobject\n            from manim.mobject.opengl.opengl_vectorized_mobject import OpenGLVMobject\n\n            from ..mobject.mobject import Mobject\n            from ..mobject.types.vectorized_mobject import VMobject\n\n            for cls in ConvertToOpenGL._converted_classes:\n                if renderer == RendererType.OPENGL:\n                    conversion_dict = {\n                        Mobject: OpenGLMobject,\n                        VMobject: OpenGLVMobject,\n                    }\n                else:\n                    conversion_dict = {\n                        OpenGLMobject: Mobject,\n                        OpenGLVMobject: VMobject,\n                    }\n\n                cls.__bases__ = tuple(\n                    conversion_dict.get(base, base) for base in cls.__bases__\n                )\n        except ImportError:\n            # The renderer is set during the initial import of the\n            # library for the first time. The imports above cause an\n            # ImportError due to circular imports. However, the\n            # metaclass sets stuff up correctly in this case, so we\n            # can just do nothing.\n            pass\n\n        self._set_from_enum(\"renderer\", renderer, RendererType)\n\n    @property\n    def media_dir(self) -> str:\n        \"\"\"Main output directory.  See :meth:`ManimConfig.get_dir`.\"\"\"\n        return self._d[\"media_dir\"]\n\n    @media_dir.setter\n    def media_dir(self, value: str | Path) -> None:\n        self._set_dir(\"media_dir\", value)\n\n    @property\n    def window_position(self) -> str:\n        \"\"\"Set the position of preview window. You can use directions, e.g. UL/DR/ORIGIN/LEFT...or the position(pixel) of the upper left corner of the window, e.g. '960,540'.\"\"\"\n        return self._d[\"window_position\"]\n\n    @window_position.setter\n    def window_position(self, value: str) -> None:\n        self._d.__setitem__(\"window_position\", value)\n\n    @property\n    def window_size(self) -> str:\n        \"\"\"The size of the opengl window. 'default' to automatically scale the window based on the display monitor.\"\"\"\n        return self._d[\"window_size\"]\n\n    @window_size.setter\n    def window_size(self, value: str) -> None:\n        self._d.__setitem__(\"window_size\", value)\n\n    def resolve_movie_file_extension(self, is_transparent: bool) -> None:\n        prev_file_extension = self.movie_file_extension\n        if is_transparent:\n            self.movie_file_extension = \".webm\" if self.format == \"webm\" else \".mov\"\n        elif self.format == \"webm\":\n            self.movie_file_extension = \".webm\"\n        elif self.format == \"mov\":\n            self.movie_file_extension = \".mov\"\n        else:\n            self.movie_file_extension = \".mp4\"\n        if self.movie_file_extension != prev_file_extension:\n            logger.warning(\n                f\"Output format changed to '{self.movie_file_extension}' \"\n                \"to support transparency\",\n            )\n\n    @property\n    def enable_gui(self) -> bool:\n        \"\"\"Enable GUI interaction.\"\"\"\n        return self._d[\"enable_gui\"]\n\n    @enable_gui.setter\n    def enable_gui(self, value: bool) -> None:\n        self._set_boolean(\"enable_gui\", value)\n\n    @property\n    def gui_location(self) -> tuple[Any]:\n        \"\"\"Enable GUI interaction.\"\"\"\n        return self._d[\"gui_location\"]\n\n    @gui_location.setter\n    def gui_location(self, value: tuple[Any]) -> None:\n        self._set_tuple(\"gui_location\", value)\n\n    @property\n    def fullscreen(self) -> bool:\n        \"\"\"Expand the window to its maximum possible size.\"\"\"\n        return self._d[\"fullscreen\"]\n\n    @fullscreen.setter\n    def fullscreen(self, value: bool) -> None:\n        self._set_boolean(\"fullscreen\", value)\n\n    @property\n    def use_projection_fill_shaders(self) -> bool:\n        \"\"\"Use shaders for OpenGLVMobject fill which are compatible with transformation matrices.\"\"\"\n        return self._d[\"use_projection_fill_shaders\"]\n\n    @use_projection_fill_shaders.setter\n    def use_projection_fill_shaders(self, value: bool) -> None:\n        self._set_boolean(\"use_projection_fill_shaders\", value)\n\n    @property\n    def use_projection_stroke_shaders(self) -> bool:\n        \"\"\"Use shaders for OpenGLVMobject stroke which are compatible with transformation matrices.\"\"\"\n        return self._d[\"use_projection_stroke_shaders\"]\n\n    @use_projection_stroke_shaders.setter\n    def use_projection_stroke_shaders(self, value: bool) -> None:\n        self._set_boolean(\"use_projection_stroke_shaders\", value)\n\n    @property\n    def zero_pad(self) -> int:\n        \"\"\"PNG zero padding. A number between 0 (no zero padding) and 9 (9 columns minimum).\"\"\"\n        return self._d[\"zero_pad\"]\n\n    @zero_pad.setter\n    def zero_pad(self, value: int) -> None:\n        self._set_int_between(\"zero_pad\", value, 0, 9)\n\n\n[docs]\n    def get_dir(self, key: str, **kwargs: Any) -> Path:\n        \"\"\"Resolve a config option that stores a directory.\n\n        Config options that store directories may depend on one another.  This\n        method is used to provide the actual directory to the end user.\n\n        Parameters\n        ----------\n        key\n            The config option to be resolved.  Must be an option ending in\n            ``'_dir'``, for example ``'media_dir'`` or ``'video_dir'``.\n\n        kwargs\n            Any strings to be used when resolving the directory.\n\n        Returns\n        -------\n        :class:`pathlib.Path`\n            Path to the requested directory.  If the path resolves to the empty\n            string, return ``None`` instead.\n\n        Raises\n        ------\n        :class:`KeyError`\n            When ``key`` is not a config option that stores a directory and\n            thus :meth:`~ManimConfig.get_dir` is not appropriate; or when\n            ``key`` is appropriate but there is not enough information to\n            resolve the directory.\n\n        Notes\n        -----\n        Standard :meth:`str.format` syntax is used to resolve the paths so the\n        paths may contain arbitrary placeholders using f-string notation.\n        However, these will require ``kwargs`` to contain the required values.\n\n        Examples\n        --------\n\n        The value of ``config.tex_dir`` is ``'{media_dir}/Tex'`` by default,\n        i.e. it is a subfolder of wherever ``config.media_dir`` is located.  In\n        order to get the *actual* directory, use :meth:`~ManimConfig.get_dir`.\n\n        .. code-block:: pycon\nfrom manim import config as globalconfig\nconfig = globalconfig.copy()\nconfig.tex_dir\n            '{media_dir}/Tex'\nconfig.media_dir\n            './media'\nconfig.get_dir(\"tex_dir\").as_posix()\n            'media/Tex'\n\n        Resolving directories is done in a lazy way, at the last possible\n        moment, to reflect any changes in other config options:\n\n        .. code-block:: pycon\nconfig.media_dir = \"my_media_dir\"\nconfig.get_dir(\"tex_dir\").as_posix()\n            'my_media_dir/Tex'\n\n        Some directories depend on information that is not available to\n        :class:`ManimConfig`. For example, the default value of `video_dir`\n        includes the name of the input file and the video quality\n        (e.g. 480p15). This informamtion has to be supplied via ``kwargs``:\n\n        .. code-block:: pycon\nconfig.video_dir\n            '{media_dir}/videos/{module_name}/{quality}'\nconfig.get_dir(\"video_dir\")\n            Traceback (most recent call last):\n            KeyError: 'video_dir {media_dir}/videos/{module_name}/{quality} requires the following keyword arguments: module_name'\nconfig.get_dir(\"video_dir\", module_name=\"myfile\").as_posix()\n            'my_media_dir/videos/myfile/1080p60'\n\n        Note the quality does not need to be passed as keyword argument since\n        :class:`ManimConfig` does store information about quality.\n\n        Directories may be recursively defined.  For example, the config option\n        ``partial_movie_dir`` depends on ``video_dir``, which in turn depends\n        on ``media_dir``:\n\n        .. code-block:: pycon\nconfig.partial_movie_dir\n            '{video_dir}/partial_movie_files/{scene_name}'\nconfig.get_dir(\"partial_movie_dir\")\n            Traceback (most recent call last):\n            KeyError: 'partial_movie_dir {video_dir}/partial_movie_files/{scene_name} requires the following keyword arguments: scene_name'\nconfig.get_dir(\n    \"partial_movie_dir\", module_name=\"myfile\", scene_name=\"myscene\"\n).as_posix()\n            'my_media_dir/videos/myfile/1080p60/partial_movie_files/myscene'\n\n        Standard f-string syntax is used.  Arbitrary names can be used when\n        defining directories, as long as the corresponding values are passed to\n        :meth:`ManimConfig.get_dir` via ``kwargs``.\n\n        .. code-block:: pycon\nconfig.media_dir = \"{dir1}/{dir2}\"\nconfig.get_dir(\"media_dir\")\n            Traceback (most recent call last):\n            KeyError: 'media_dir {dir1}/{dir2} requires the following keyword arguments: dir1'\nconfig.get_dir(\"media_dir\", dir1=\"foo\", dir2=\"bar\").as_posix()\n            'foo/bar'\nconfig.media_dir = \"./media\"\nconfig.get_dir(\"media_dir\").as_posix()\n            'media'\n\n        \"\"\"\n        dirs = [\n            \"assets_dir\",\n            \"media_dir\",\n            \"video_dir\",\n            \"sections_dir\",\n            \"images_dir\",\n            \"text_dir\",\n            \"tex_dir\",\n            \"log_dir\",\n            \"input_file\",\n            \"output_file\",\n            \"partial_movie_dir\",\n        ]\n        if key not in dirs:\n            raise KeyError(\n                \"must pass one of \"\n                \"{media,video,images,text,tex,log}_dir \"\n                \"or {input,output}_file\",\n            )\n\n        dirs.remove(key)  # a path cannot contain itself\n\n        all_args = {k: self._d[k] for k in dirs}\n        all_args.update(kwargs)\n        all_args[\"quality\"] = f\"{self.pixel_height}p{self.frame_rate:g}\"\n\n        path = self._d[key]\n        while \"{\" in path:\n            try:\n                path = path.format(**all_args)\n            except KeyError as exc:\n                raise KeyError(\n                    f\"{key} {self._d[key]} requires the following \"\n                    + \"keyword arguments: \"\n                    + \" \".join(exc.args),\n                ) from exc\n        return Path(path) if path else None\n\n\n    def _set_dir(self, key: str, val: str | Path) -> None:\n        if isinstance(val, Path):\n            self._d.__setitem__(key, str(val))\n        else:\n            self._d.__setitem__(key, val)\n\n    @property\n    def assets_dir(self) -> str:\n        \"\"\"Directory to locate video assets (no flag).\"\"\"\n        return self._d[\"assets_dir\"]\n\n    @assets_dir.setter\n    def assets_dir(self, value: str | Path) -> None:\n        self._set_dir(\"assets_dir\", value)\n\n    @property\n    def log_dir(self) -> str:\n        \"\"\"Directory to place logs. See :meth:`ManimConfig.get_dir`.\"\"\"\n        return self._d[\"log_dir\"]\n\n    @log_dir.setter\n    def log_dir(self, value: str | Path) -> None:\n        self._set_dir(\"log_dir\", value)\n\n    @property\n    def video_dir(self) -> str:\n        \"\"\"Directory to place videos (no flag). See :meth:`ManimConfig.get_dir`.\"\"\"\n        return self._d[\"video_dir\"]\n\n    @video_dir.setter\n    def video_dir(self, value: str | Path) -> None:\n        self._set_dir(\"video_dir\", value)\n\n    @property\n    def sections_dir(self) -> str:\n        \"\"\"Directory to place section videos (no flag). See :meth:`ManimConfig.get_dir`.\"\"\"\n        return self._d[\"sections_dir\"]\n\n    @sections_dir.setter\n    def sections_dir(self, value: str | Path) -> None:\n        self._set_dir(\"sections_dir\", value)\n\n    @property\n    def images_dir(self) -> str:\n        \"\"\"Directory to place images (no flag).  See :meth:`ManimConfig.get_dir`.\"\"\"\n        return self._d[\"images_dir\"]\n\n    @images_dir.setter\n    def images_dir(self, value: str | Path) -> None:\n        self._set_dir(\"images_dir\", value)\n\n    @property\n    def text_dir(self) -> str:\n        \"\"\"Directory to place text (no flag).  See :meth:`ManimConfig.get_dir`.\"\"\"\n        return self._d[\"text_dir\"]\n\n    @text_dir.setter\n    def text_dir(self, value: str | Path) -> None:\n        self._set_dir(\"text_dir\", value)\n\n    @property\n    def tex_dir(self) -> str:\n        \"\"\"Directory to place tex (no flag).  See :meth:`ManimConfig.get_dir`.\"\"\"\n        return self._d[\"tex_dir\"]\n\n    @tex_dir.setter\n    def tex_dir(self, value: str | Path) -> None:\n        self._set_dir(\"tex_dir\", value)\n\n    @property\n    def partial_movie_dir(self) -> str:\n        \"\"\"Directory to place partial movie files (no flag).  See :meth:`ManimConfig.get_dir`.\"\"\"\n        return self._d[\"partial_movie_dir\"]\n\n    @partial_movie_dir.setter\n    def partial_movie_dir(self, value: str | Path) -> None:\n        self._set_dir(\"partial_movie_dir\", value)\n\n    @property\n    def custom_folders(self) -> str:\n        \"\"\"Whether to use custom folder output.\"\"\"\n        return self._d[\"custom_folders\"]\n\n    @custom_folders.setter\n    def custom_folders(self, value: str | Path) -> None:\n        self._set_dir(\"custom_folders\", value)\n\n    @property\n    def input_file(self) -> str:\n        \"\"\"Input file name.\"\"\"\n        return self._d[\"input_file\"]\n\n    @input_file.setter\n    def input_file(self, value: str | Path) -> None:\n        self._set_dir(\"input_file\", value)\n\n    @property\n    def output_file(self) -> str:\n        \"\"\"Output file name (-o).\"\"\"\n        return self._d[\"output_file\"]\n\n    @output_file.setter\n    def output_file(self, value: str | Path) -> None:\n        self._set_dir(\"output_file\", value)\n\n    @property\n    def scene_names(self) -> list[str]:\n        \"\"\"Scenes to play from file.\"\"\"\n        return self._d[\"scene_names\"]\n\n    @scene_names.setter\n    def scene_names(self, value: list[str]) -> None:\n        self._d.__setitem__(\"scene_names\", value)\n\n    @property\n    def tex_template(self) -> TexTemplate:\n        \"\"\"Template used when rendering Tex.  See :class:`.TexTemplate`.\"\"\"\n        if not hasattr(self, \"_tex_template\") or not self._tex_template:\n            fn = self._d[\"tex_template_file\"]\n            if fn:\n                self._tex_template = TexTemplate.from_file(fn)\n            else:\n                self._tex_template = TexTemplate()\n        return self._tex_template\n\n    @tex_template.setter\n    def tex_template(self, val: TexTemplate) -> None:\n        if isinstance(val, TexTemplate):\n            self._tex_template = val\n\n    @property\n    def tex_template_file(self) -> Path:\n        \"\"\"File to read Tex template from (no flag).  See :class:`.TexTemplate`.\"\"\"\n        return self._d[\"tex_template_file\"]\n\n    @tex_template_file.setter\n    def tex_template_file(self, val: str) -> None:\n        if val:\n            if not os.access(val, os.R_OK):\n                logger.warning(\n                    f\"Custom TeX template {val} not found or not readable.\",\n                )\n            else:\n                self._d[\"tex_template_file\"] = Path(val)\n        else:\n            self._d[\"tex_template_file\"] = val  # actually set the falsy value\n\n    @property\n    def plugins(self) -> list[str]:\n        \"\"\"List of plugins to enable.\"\"\"\n        return self._d[\"plugins\"]\n\n    @plugins.setter\n    def plugins(self, value: list[str]):\n        self._d[\"plugins\"] = value\n\n\n\n# TODO: to be used in the future - see PR #620\n# https://github.com/ManimCommunity/manim/pull/620\n\n[docs]\nclass ManimFrame(Mapping):\n    _OPTS: ClassVar[set[str]] = {\n        \"pixel_width\",\n        \"pixel_height\",\n        \"aspect_ratio\",\n        \"frame_height\",\n        \"frame_width\",\n        \"frame_y_radius\",\n        \"frame_x_radius\",\n        \"top\",\n        \"bottom\",\n        \"left_side\",\n        \"right_side\",\n    }\n    _CONSTANTS: ClassVar[dict[str, Vector3D]] = {\n        \"UP\": np.array((0.0, 1.0, 0.0)),\n        \"DOWN\": np.array((0.0, -1.0, 0.0)),\n        \"RIGHT\": np.array((1.0, 0.0, 0.0)),\n        \"LEFT\": np.array((-1.0, 0.0, 0.0)),\n        \"IN\": np.array((0.0, 0.0, -1.0)),\n        \"OUT\": np.array((0.0, 0.0, 1.0)),\n        \"ORIGIN\": np.array((0.0, 0.0, 0.0)),\n        \"X_AXIS\": np.array((1.0, 0.0, 0.0)),\n        \"Y_AXIS\": np.array((0.0, 1.0, 0.0)),\n        \"Z_AXIS\": np.array((0.0, 0.0, 1.0)),\n        \"UL\": np.array((-1.0, 1.0, 0.0)),\n        \"UR\": np.array((1.0, 1.0, 0.0)),\n        \"DL\": np.array((-1.0, -1.0, 0.0)),\n        \"DR\": np.array((1.0, -1.0, 0.0)),\n    }\n\n    _c: ManimConfig\n\n    def __init__(self, c: ManimConfig) -> None:\n        if not isinstance(c, ManimConfig):\n            raise TypeError(\"argument must be instance of 'ManimConfig'\")\n        # need to use __dict__ directly because setting attributes is not\n        # allowed (see __setattr__)\n        self.__dict__[\"_c\"] = c\n\n    # there are required by parent class Mapping to behave like a dict\n    def __getitem__(self, key: str | int) -> Any:\n        if key in self._OPTS:\n            return self._c[key]\n        elif key in self._CONSTANTS:\n            return self._CONSTANTS[key]\n        else:\n            raise KeyError(key)\n\n    def __iter__(self) -> Iterable[str]:\n        return iter(list(self._OPTS) + list(self._CONSTANTS))\n\n    def __len__(self) -> int:\n        return len(self._OPTS)\n\n    # make this truly immutable\n    def __setattr__(self, attr: Any, val: Any) -> NoReturn:\n        raise TypeError(\"'ManimFrame' object does not support item assignment\")\n\n    def __setitem__(self, key: Any, val: Any) -> NoReturn:\n        raise TypeError(\"'ManimFrame' object does not support item assignment\")\n\n    def __delitem__(self, key: Any) -> NoReturn:\n        raise TypeError(\"'ManimFrame' object does not support item deletion\")\n\n\n\nfor opt in list(ManimFrame._OPTS) + list(ManimFrame._CONSTANTS):\n    setattr(ManimFrame, opt, property(lambda self, o=opt: self[o]))", "code_sha1": "9dffd69364bd9177594c1a1b0cdd8ba68124e45c"}
{"url": "https://docs.manim.community/en/stable/_modules/manim/mobject/geometry/arc.html", "depth": 2, "instruction": "The scene displays a vertical arrangement of six mobjects: a small white dot, a larger blue annotation dot, and three labeled dots with varying colors and labels, positioned around a central square. A yellow curved arrow connects the first and last dots, while a second curved arrow with a different radius is also present, creating a visually dynamic composition.", "code": "r\"\"\"Mobjects that are curved.\n\nExamples\n--------\n.. manim:: UsefulAnnotations\n    :save_last_frame:\n\n    class UsefulAnnotations(Scene):\n        def construct(self):\n            m0 = Dot()\n            m1 = AnnotationDot()\n            m2 = LabeledDot(\"ii\")\n            m3 = LabeledDot(MathTex(r\"\\alpha\").set_color(ORANGE))\n            m4 = CurvedArrow(2*LEFT, 2*RIGHT, radius= -5)\n            m5 = CurvedArrow(2*LEFT, 2*RIGHT, radius= 8)\n            m6 = CurvedDoubleArrow(ORIGIN, 2*RIGHT)\n\n            self.add(m0, m1, m2, m3, m4, m5, m6)\n            for i, mobj in enumerate(self.mobjects):\n                mobj.shift(DOWN * (i-3))\n\n\"\"\"\n\nfrom __future__ import annotations\n\n__all__ = [\n    \"TipableVMobject\",\n    \"Arc\",\n    \"ArcBetweenPoints\",\n    \"CurvedArrow\",\n    \"CurvedDoubleArrow\",\n    \"Circle\",\n    \"Dot\",\n    \"AnnotationDot\",\n    \"LabeledDot\",\n    \"Ellipse\",\n    \"AnnularSector\",\n    \"Sector\",\n    \"Annulus\",\n    \"CubicBezier\",\n    \"ArcPolygon\",\n    \"ArcPolygonFromArcs\",\n]\n\nimport itertools\nimport warnings\nfrom typing import TYPE_CHECKING, cast\n\nimport numpy as np\nfrom typing_extensions import Self\n\nfrom manim.constants import *\nfrom manim.mobject.opengl.opengl_compatibility import ConvertToOpenGL\nfrom manim.mobject.types.vectorized_mobject import VGroup, VMobject\nfrom manim.utils.color import BLACK, BLUE, RED, WHITE, ParsableManimColor\nfrom manim.utils.iterables import adjacent_pairs\nfrom manim.utils.space_ops import (\n    angle_of_vector,\n    cartesian_to_spherical,\n    line_intersection,\n    perpendicular_bisector,\n    rotate_vector,\n)\n\nif TYPE_CHECKING:\n    from collections.abc import Iterable\n    from typing import Any\n\n    import manim.mobject.geometry.tips as tips\n    from manim.mobject.mobject import Mobject\n    from manim.mobject.text.tex_mobject import SingleStringMathTex, Tex\n    from manim.mobject.text.text_mobject import Text\n    from manim.typing import (\n        Point3D,\n        Point3DLike,\n        QuadraticSpline,\n        Vector3D,\n    )\n\n\n\n[docs]\nclass TipableVMobject(VMobject, metaclass=ConvertToOpenGL):\n    \"\"\"Meant for shared functionality between Arc and Line.\n    Functionality can be classified broadly into these groups:\n\n        * Adding, Creating, Modifying tips\n            - add_tip calls create_tip, before pushing the new tip\n                into the TipableVMobject's list of submobjects\n            - stylistic and positional configuration\n\n        * Checking for tips\n            - Boolean checks for whether the TipableVMobject has a tip\n                and a starting tip\n\n        * Getters\n            - Straightforward accessors, returning information pertaining\n                to the TipableVMobject instance's tip(s), its length etc\n    \"\"\"\n\n    def __init__(\n        self,\n        tip_length: float = DEFAULT_ARROW_TIP_LENGTH,\n        normal_vector: Vector3D = OUT,\n        tip_style: dict = {},\n        **kwargs: Any,\n    ) -> None:\n        self.tip_length: float = tip_length\n        self.normal_vector: Vector3D = normal_vector\n        self.tip_style: dict = tip_style\n        super().__init__(**kwargs)\n\n    # Adding, Creating, Modifying tips\n\n\n[docs]\n    def add_tip(\n        self,\n        tip: tips.ArrowTip | None = None,\n        tip_shape: type[tips.ArrowTip] | None = None,\n        tip_length: float | None = None,\n        tip_width: float | None = None,\n        at_start: bool = False,\n    ) -> Self:\n        \"\"\"Adds a tip to the TipableVMobject instance, recognising\n        that the endpoints might need to be switched if it's\n        a 'starting tip' or not.\n        \"\"\"\n        if tip is None:\n            tip = self.create_tip(tip_shape, tip_length, tip_width, at_start)\n        else:\n            self.position_tip(tip, at_start)\n        self.reset_endpoints_based_on_tip(tip, at_start)\n        self.asign_tip_attr(tip, at_start)\n        self.add(tip)\n        return self\n\n\n\n[docs]\n    def create_tip(\n        self,\n        tip_shape: type[tips.ArrowTip] | None = None,\n        tip_length: float | None = None,\n        tip_width: float | None = None,\n        at_start: bool = False,\n    ) -> tips.ArrowTip:\n        \"\"\"Stylises the tip, positions it spatially, and returns\n        the newly instantiated tip to the caller.\n        \"\"\"\n        tip = self.get_unpositioned_tip(tip_shape, tip_length, tip_width)\n        self.position_tip(tip, at_start)\n        return tip\n\n\n\n[docs]\n    def get_unpositioned_tip(\n        self,\n        tip_shape: type[tips.ArrowTip] | None = None,\n        tip_length: float | None = None,\n        tip_width: float | None = None,\n    ) -> tips.ArrowTip | tips.ArrowTriangleFilledTip:\n        \"\"\"Returns a tip that has been stylistically configured,\n        but has not yet been given a position in space.\n        \"\"\"\n        from manim.mobject.geometry.tips import ArrowTriangleFilledTip\n\n        style: dict[str, Any] = {}\n\n        if tip_shape is None:\n            tip_shape = ArrowTriangleFilledTip\n\n        if tip_shape is ArrowTriangleFilledTip:\n            if tip_width is None:\n                tip_width = self.get_default_tip_length()\n            style.update({\"width\": tip_width})\n        if tip_length is None:\n            tip_length = self.get_default_tip_length()\n\n        color = self.get_color()\n        style.update({\"fill_color\": color, \"stroke_color\": color})\n        style.update(self.tip_style)\n        tip = tip_shape(length=tip_length, **style)\n        return tip\n\n\n    def position_tip(self, tip: tips.ArrowTip, at_start: bool = False) -> tips.ArrowTip:\n        # Last two control points, defining both\n        # the end, and the tangency direction\n        if at_start:\n            anchor = self.get_start()\n            handle = self.get_first_handle()\n        else:\n            handle = self.get_last_handle()\n            anchor = self.get_end()\n        angles = cartesian_to_spherical((handle - anchor).tolist())\n        tip.rotate(\n            angles[1] - PI - tip.tip_angle,\n        )  # Rotates the tip along the azimuthal\n        if not hasattr(self, \"_init_positioning_axis\"):\n            axis = np.array(\n                [\n                    np.sin(angles[1]),\n                    -np.cos(angles[1]),\n                    0,\n                ]\n            )  # Obtains the perpendicular of the tip\n            tip.rotate(\n                -angles[2] + PI / 2,\n                axis=axis,\n            )  # Rotates the tip along the vertical wrt the axis\n            self._init_positioning_axis = axis\n        tip.shift(anchor - tip.tip_point)\n        return tip\n\n    def reset_endpoints_based_on_tip(self, tip: tips.ArrowTip, at_start: bool) -> Self:\n        if self.get_length() == 0:\n            # Zero length, put_start_and_end_on wouldn't work\n            return self\n\n        if at_start:\n            self.put_start_and_end_on(tip.base, self.get_end())\n        else:\n            self.put_start_and_end_on(self.get_start(), tip.base)\n        return self\n\n    def asign_tip_attr(self, tip: tips.ArrowTip, at_start: bool) -> Self:\n        if at_start:\n            self.start_tip = tip\n        else:\n            self.tip = tip\n        return self\n\n    # Checking for tips\n\n    def has_tip(self) -> bool:\n        return hasattr(self, \"tip\") and self.tip in self\n\n    def has_start_tip(self) -> bool:\n        return hasattr(self, \"start_tip\") and self.start_tip in self\n\n    # Getters\n\n    def pop_tips(self) -> VGroup:\n        start, end = self.get_start_and_end()\n        result = self.get_group_class()()\n        if self.has_tip():\n            result.add(self.tip)\n            self.remove(self.tip)\n        if self.has_start_tip():\n            result.add(self.start_tip)\n            self.remove(self.start_tip)\n        self.put_start_and_end_on(start, end)\n        return result\n\n\n[docs]\n    def get_tips(self) -> VGroup:\n        \"\"\"Returns a VGroup (collection of VMobjects) containing\n        the TipableVMObject instance's tips.\n        \"\"\"\n        result = self.get_group_class()()\n        if hasattr(self, \"tip\"):\n            result.add(self.tip)\n        if hasattr(self, \"start_tip\"):\n            result.add(self.start_tip)\n        return result\n\n\n\n[docs]\n    def get_tip(self) -> VMobject:\n        \"\"\"Returns the TipableVMobject instance's (first) tip,\n        otherwise throws an exception.\n        \"\"\"\n        tips = self.get_tips()\n        if len(tips) == 0:\n            raise Exception(\"tip not found\")\n        else:\n            tip: VMobject = tips[0]\n            return tip\n\n\n    def get_default_tip_length(self) -> float:\n        return self.tip_length\n\n    def get_first_handle(self) -> Point3D:\n        # Type inference of extracting an element from a list, is not\n        # supported by numpy, see this numpy issue\n        # https://github.com/numpy/numpy/issues/16544\n        first_handle: Point3D = self.points[1]\n        return first_handle\n\n    def get_last_handle(self) -> Point3D:\n        # Type inference of extracting an element from a list, is not\n        # supported by numpy, see this numpy issue\n        # https://github.com/numpy/numpy/issues/16544\n        last_handle: Point3D = self.points[-2]\n        return last_handle\n\n\n[docs]\n    def get_end(self) -> Point3D:\n        if self.has_tip():\n            return self.tip.get_start()\n        else:\n            return super().get_end()\n\n\n\n[docs]\n    def get_start(self) -> Point3D:\n        if self.has_start_tip():\n            return self.start_tip.get_start()\n        else:\n            return super().get_start()\n\n\n    def get_length(self) -> float:\n        start, end = self.get_start_and_end()\n        return float(np.linalg.norm(start - end))\n\n\n\n\n[docs]\nclass Arc(TipableVMobject):\n    \"\"\"A circular arc.\n\n    Examples\n    --------\n    A simple arc of angle Pi.\n\n    .. manim:: ArcExample\n        :save_last_frame:\n\n        class ArcExample(Scene):\n            def construct(self):\n                self.add(Arc(angle=PI))\n    \"\"\"\n\n    def __init__(\n        self,\n        radius: float | None = 1.0,\n        start_angle: float = 0,\n        angle: float = TAU / 4,\n        num_components: int = 9,\n        arc_center: Point3DLike = ORIGIN,\n        **kwargs: Any,\n    ):\n        if radius is None:  # apparently None is passed by ArcBetweenPoints\n            radius = 1.0\n        self.radius = radius\n        self.num_components = num_components\n        self.arc_center: Point3D = np.asarray(arc_center)\n        self.start_angle = start_angle\n        self.angle = angle\n        self._failed_to_get_center: bool = False\n        super().__init__(**kwargs)\n\n\n[docs]\n    def generate_points(self) -> None:\n        self._set_pre_positioned_points()\n        self.scale(self.radius, about_point=ORIGIN)\n        self.shift(self.arc_center)\n\n\n    # Points are set a bit differently when rendering via OpenGL.\n    # TODO: refactor Arc so that only one strategy for setting points\n    # has to be used.\n    def init_points(self) -> None:\n        self.set_points(\n            Arc._create_quadratic_bezier_points(\n                angle=self.angle,\n                start_angle=self.start_angle,\n                n_components=self.num_components,\n            ),\n        )\n        self.scale(self.radius, about_point=ORIGIN)\n        self.shift(self.arc_center)\n\n    @staticmethod\n    def _create_quadratic_bezier_points(\n        angle: float, start_angle: float = 0, n_components: int = 8\n    ) -> QuadraticSpline:\n        samples = np.array(\n            [\n                [np.cos(a), np.sin(a), 0]\n                for a in np.linspace(\n                    start_angle,\n                    start_angle + angle,\n                    2 * n_components + 1,\n                )\n            ],\n        )\n        theta = angle / n_components\n        samples[1::2] /= np.cos(theta / 2)\n\n        points = np.zeros((3 * n_components, 3))\n        points[0::3] = samples[0:-1:2]\n        points[1::3] = samples[1::2]\n        points[2::3] = samples[2::2]\n        return points\n\n    def _set_pre_positioned_points(self) -> None:\n        anchors = np.array(\n            [\n                np.cos(a) * RIGHT + np.sin(a) * UP\n                for a in np.linspace(\n                    self.start_angle,\n                    self.start_angle + self.angle,\n                    self.num_components,\n                )\n            ],\n        )\n        # Figure out which control points will give the\n        # Appropriate tangent lines to the circle\n        d_theta = self.angle / (self.num_components - 1.0)\n        tangent_vectors = np.zeros(anchors.shape)\n        # Rotate all 90 degrees, via (x, y) -> (-y, x)\n        tangent_vectors[:, 1] = anchors[:, 0]\n        tangent_vectors[:, 0] = -anchors[:, 1]\n        # Use tangent vectors to deduce anchors\n        factor = 4 / 3 * np.tan(d_theta / 4)\n        handles1 = anchors[:-1] + factor * tangent_vectors[:-1]\n        handles2 = anchors[1:] - factor * tangent_vectors[1:]\n        self.set_anchors_and_handles(anchors[:-1], handles1, handles2, anchors[1:])\n\n\n[docs]\n    def get_arc_center(self, warning: bool = True) -> Point3D:\n        \"\"\"Looks at the normals to the first two\n        anchors, and finds their intersection points\n        \"\"\"\n        # First two anchors and handles\n        a1, h1, h2, a2 = self.points[:4]\n\n        if np.all(a1 == a2):\n            # For a1 and a2 to lie at the same point arc radius\n            # must be zero. Thus arc_center will also lie at\n            # that point.\n            return np.copy(a1)\n        # Tangent vectors\n        t1 = h1 - a1\n        t2 = h2 - a2\n        # Normals\n        n1 = rotate_vector(t1, TAU / 4)\n        n2 = rotate_vector(t2, TAU / 4)\n        try:\n            return line_intersection(line1=(a1, a1 + n1), line2=(a2, a2 + n2))\n        except Exception:\n            if warning:\n                warnings.warn(\n                    \"Can't find Arc center, using ORIGIN instead\", stacklevel=1\n                )\n            self._failed_to_get_center = True\n            return np.array(ORIGIN)\n\n\n    def move_arc_center_to(self, point: Point3DLike) -> Self:\n        self.shift(point - self.get_arc_center())\n        return self\n\n    def stop_angle(self) -> float:\n        return cast(\n            float,\n            angle_of_vector(self.points[-1] - self.get_arc_center()) % TAU,\n        )\n\n\n\n\n[docs]\nclass ArcBetweenPoints(Arc):\n    \"\"\"Inherits from Arc and additionally takes 2 points between which the arc is spanned.\n\n    Example\n    -------\n    .. manim:: ArcBetweenPointsExample\n\n      class ArcBetweenPointsExample(Scene):\n          def construct(self):\n              circle = Circle(radius=2, stroke_color=GREY)\n              dot_1 = Dot(color=GREEN).move_to([2, 0, 0]).scale(0.5)\n              dot_1_text = Tex(\"(2,0)\").scale(0.5).next_to(dot_1, RIGHT).set_color(BLUE)\n              dot_2 = Dot(color=GREEN).move_to([0, 2, 0]).scale(0.5)\n              dot_2_text = Tex(\"(0,2)\").scale(0.5).next_to(dot_2, UP).set_color(BLUE)\n              arc= ArcBetweenPoints(start=2 * RIGHT, end=2 * UP, stroke_color=YELLOW)\n              self.add(circle, dot_1, dot_2, dot_1_text, dot_2_text)\n              self.play(Create(arc))\n    \"\"\"\n\n    def __init__(\n        self,\n        start: Point3DLike,\n        end: Point3DLike,\n        angle: float = TAU / 4,\n        radius: float | None = None,\n        **kwargs: Any,\n    ) -> None:\n        if radius is not None:\n            self.radius = radius\n            if radius < 0:\n                sign = -2\n                radius *= -1\n            else:\n                sign = 2\n            halfdist = np.linalg.norm(np.array(start) - np.array(end)) / 2\n            if radius < halfdist:\n                raise ValueError(\n                    \"\"\"ArcBetweenPoints called with a radius that is\n                            smaller than half the distance between the points.\"\"\",\n                )\n            arc_height = radius - np.sqrt(radius**2 - halfdist**2)\n            angle = np.arccos((radius - arc_height) / radius) * sign\n\n        super().__init__(radius=radius, angle=angle, **kwargs)\n        if angle == 0:\n            self.set_points_as_corners(np.array([LEFT, RIGHT]))\n        self.put_start_and_end_on(start, end)\n\n        if radius is None:\n            center = self.get_arc_center(warning=False)\n            if not self._failed_to_get_center:\n                # np.linalg.norm returns floating[Any] which is not compatible with float\n                self.radius = cast(\n                    float, np.linalg.norm(np.array(start) - np.array(center))\n                )\n            else:\n                self.radius = np.inf\n\n\n\n\n[docs]\nclass CurvedArrow(ArcBetweenPoints):\n    def __init__(\n        self, start_point: Point3DLike, end_point: Point3DLike, **kwargs: Any\n    ) -> None:\n        from manim.mobject.geometry.tips import ArrowTriangleFilledTip\n\n        tip_shape = kwargs.pop(\"tip_shape\", ArrowTriangleFilledTip)\n        super().__init__(start_point, end_point, **kwargs)\n        self.add_tip(tip_shape=tip_shape)\n\n\n\n\n[docs]\nclass CurvedDoubleArrow(CurvedArrow):\n    def __init__(\n        self, start_point: Point3DLike, end_point: Point3DLike, **kwargs: Any\n    ) -> None:\n        if \"tip_shape_end\" in kwargs:\n            kwargs[\"tip_shape\"] = kwargs.pop(\"tip_shape_end\")\n        from manim.mobject.geometry.tips import ArrowTriangleFilledTip\n\n        tip_shape_start = kwargs.pop(\"tip_shape_start\", ArrowTriangleFilledTip)\n        super().__init__(start_point, end_point, **kwargs)\n        self.add_tip(at_start=True, tip_shape=tip_shape_start)\n\n\n\n\n[docs]\nclass Circle(Arc):\n    \"\"\"A circle.\n\n    Parameters\n    ----------\n    color\n        The color of the shape.\n    kwargs\n        Additional arguments to be passed to :class:`Arc`\n\n    Examples\n    --------\n    .. manim:: CircleExample\n        :save_last_frame:\n\n        class CircleExample(Scene):\n            def construct(self):\n                circle_1 = Circle(radius=1.0)\n                circle_2 = Circle(radius=1.5, color=GREEN)\n                circle_3 = Circle(radius=1.0, color=BLUE_B, fill_opacity=1)\n\n                circle_group = Group(circle_1, circle_2, circle_3).arrange(buff=1)\n                self.add(circle_group)\n    \"\"\"\n\n    def __init__(\n        self,\n        radius: float | None = None,\n        color: ParsableManimColor = RED,\n        **kwargs: Any,\n    ) -> None:\n        super().__init__(\n            radius=radius,\n            start_angle=0,\n            angle=TAU,\n            color=color,\n            **kwargs,\n        )\n\n\n[docs]\n    def surround(\n        self,\n        mobject: Mobject,\n        dim_to_match: int = 0,\n        stretch: bool = False,\n        buffer_factor: float = 1.2,\n    ) -> Self:\n        \"\"\"Modifies a circle so that it surrounds a given mobject.\n\n        Parameters\n        ----------\n        mobject\n            The mobject that the circle will be surrounding.\n        dim_to_match\n        buffer_factor\n            Scales the circle with respect to the mobject. A `buffer_factor` < 1 makes the circle smaller than the mobject.\n        stretch\n            Stretches the circle to fit more tightly around the mobject. Note: Does not work with :class:`Line`\n\n        Examples\n        --------\n        .. manim:: CircleSurround\n            :save_last_frame:\n\n            class CircleSurround(Scene):\n                def construct(self):\n                    triangle1 = Triangle()\n                    circle1 = Circle().surround(triangle1)\n                    group1 = Group(triangle1,circle1) # treat the two mobjects as one\n\n                    line2 = Line()\n                    circle2 = Circle().surround(line2, buffer_factor=2.0)\n                    group2 = Group(line2,circle2)\n\n                    # buffer_factor < 1, so the circle is smaller than the square\n                    square3 = Square()\n                    circle3 = Circle().surround(square3, buffer_factor=0.5)\n                    group3 = Group(square3, circle3)\n\n                    group = Group(group1, group2, group3).arrange(buff=1)\n                    self.add(group)\n        \"\"\"\n        # Ignores dim_to_match and stretch; result will always be a circle\n        # TODO: Perhaps create an ellipse class to handle single-dimension stretching\n\n        # Something goes wrong here when surrounding lines?\n        # TODO: Figure out and fix\n        self.replace(mobject, dim_to_match, stretch)\n\n        self.width = np.sqrt(mobject.width**2 + mobject.height**2)\n        return self.scale(buffer_factor)\n\n\n\n[docs]\n    def point_at_angle(self, angle: float) -> Point3D:\n        \"\"\"Returns the position of a point on the circle.\n\n        Parameters\n        ----------\n        angle\n            The angle of the point along the circle in radians.\n\n        Returns\n        -------\n        :class:`numpy.ndarray`\n            The location of the point along the circle's circumference.\n\n        Examples\n        --------\n        .. manim:: PointAtAngleExample\n            :save_last_frame:\n\n            class PointAtAngleExample(Scene):\n                def construct(self):\n                    circle = Circle(radius=2.0)\n                    p1 = circle.point_at_angle(PI/2)\n                    p2 = circle.point_at_angle(270*DEGREES)\n\n                    s1 = Square(side_length=0.25).move_to(p1)\n                    s2 = Square(side_length=0.25).move_to(p2)\n                    self.add(circle, s1, s2)\n\n        \"\"\"\n        start_angle = angle_of_vector(self.points[0] - self.get_center())\n        proportion = (angle - start_angle) / TAU\n        proportion -= np.floor(proportion)\n        return self.point_from_proportion(proportion)\n\n\n\n[docs]\n    @staticmethod\n    def from_three_points(\n        p1: Point3DLike, p2: Point3DLike, p3: Point3DLike, **kwargs: Any\n    ) -> Circle:\n        \"\"\"Returns a circle passing through the specified\n        three points.\n\n        Example\n        -------\n        .. manim:: CircleFromPointsExample\n            :save_last_frame:\n\n            class CircleFromPointsExample(Scene):\n                def construct(self):\n                    circle = Circle.from_three_points(LEFT, LEFT + UP, UP * 2, color=RED)\n                    dots = VGroup(\n                        Dot(LEFT),\n                        Dot(LEFT + UP),\n                        Dot(UP * 2),\n                    )\n                    self.add(NumberPlane(), circle, dots)\n        \"\"\"\n        center = line_intersection(\n            perpendicular_bisector([np.asarray(p1), np.asarray(p2)]),\n            perpendicular_bisector([np.asarray(p2), np.asarray(p3)]),\n        )\n        # np.linalg.norm returns floating[Any] which is not compatible with float\n        radius = cast(float, np.linalg.norm(p1 - center))\n        return Circle(radius=radius, **kwargs).shift(center)\n\n\n\n\n\n[docs]\nclass Dot(Circle):\n    \"\"\"A circle with a very small radius.\n\n    Parameters\n    ----------\n    point\n        The location of the dot.\n    radius\n        The radius of the dot.\n    stroke_width\n        The thickness of the outline of the dot.\n    fill_opacity\n        The opacity of the dot's fill_colour\n    color\n        The color of the dot.\n    kwargs\n        Additional arguments to be passed to :class:`Circle`\n\n    Examples\n    --------\n    .. manim:: DotExample\n        :save_last_frame:\n\n        class DotExample(Scene):\n            def construct(self):\n                dot1 = Dot(point=LEFT, radius=0.08)\n                dot2 = Dot(point=ORIGIN)\n                dot3 = Dot(point=RIGHT)\n                self.add(dot1,dot2,dot3)\n    \"\"\"\n\n    def __init__(\n        self,\n        point: Point3DLike = ORIGIN,\n        radius: float = DEFAULT_DOT_RADIUS,\n        stroke_width: float = 0,\n        fill_opacity: float = 1.0,\n        color: ParsableManimColor = WHITE,\n        **kwargs: Any,\n    ) -> None:\n        super().__init__(\n            arc_center=point,\n            radius=radius,\n            stroke_width=stroke_width,\n            fill_opacity=fill_opacity,\n            color=color,\n            **kwargs,\n        )\n\n\n\n\n[docs]\nclass AnnotationDot(Dot):\n    \"\"\"A dot with bigger radius and bold stroke to annotate scenes.\"\"\"\n\n    def __init__(\n        self,\n        radius: float = DEFAULT_DOT_RADIUS * 1.3,\n        stroke_width: float = 5,\n        stroke_color: ParsableManimColor = WHITE,\n        fill_color: ParsableManimColor = BLUE,\n        **kwargs: Any,\n    ) -> None:\n        super().__init__(\n            radius=radius,\n            stroke_width=stroke_width,\n            stroke_color=stroke_color,\n            fill_color=fill_color,\n            **kwargs,\n        )\n\n\n\n\n[docs]\nclass LabeledDot(Dot):\n    \"\"\"A :class:`Dot` containing a label in its center.\n\n    Parameters\n    ----------\n    label\n        The label of the :class:`Dot`. This is rendered as :class:`~.MathTex`\n        by default (i.e., when passing a :class:`str`), but other classes\n        representing rendered strings like :class:`~.Text` or :class:`~.Tex`\n        can be passed as well.\n    radius\n        The radius of the :class:`Dot`. If ``None`` (the default), the radius\n        is calculated based on the size of the ``label``.\n\n    Examples\n    --------\n    .. manim:: SeveralLabeledDots\n        :save_last_frame:\n\n        class SeveralLabeledDots(Scene):\n            def construct(self):\n                sq = Square(fill_color=RED, fill_opacity=1)\n                self.add(sq)\n                dot1 = LabeledDot(Tex(\"42\", color=RED))\n                dot2 = LabeledDot(MathTex(\"a\", color=GREEN))\n                dot3 = LabeledDot(Text(\"ii\", color=BLUE))\n                dot4 = LabeledDot(\"3\")\n                dot1.next_to(sq, UL)\n                dot2.next_to(sq, UR)\n                dot3.next_to(sq, DL)\n                dot4.next_to(sq, DR)\n                self.add(dot1, dot2, dot3, dot4)\n    \"\"\"\n\n    def __init__(\n        self,\n        label: str | SingleStringMathTex | Text | Tex,\n        radius: float | None = None,\n        **kwargs: Any,\n    ) -> None:\n        if isinstance(label, str):\n            from manim import MathTex\n\n            rendered_label: VMobject = MathTex(label, color=BLACK)\n        else:\n            rendered_label = label\n\n        if radius is None:\n            radius = 0.1 + max(rendered_label.width, rendered_label.height) / 2\n        super().__init__(radius=radius, **kwargs)\n        rendered_label.move_to(self.get_center())\n        self.add(rendered_label)\n\n\n\n\n[docs]\nclass Ellipse(Circle):\n    \"\"\"A circular shape; oval, circle.\n\n    Parameters\n    ----------\n    width\n       The horizontal width of the ellipse.\n    height\n       The vertical height of the ellipse.\n    kwargs\n       Additional arguments to be passed to :class:`Circle`.\n\n    Examples\n    --------\n    .. manim:: EllipseExample\n        :save_last_frame:\n\n        class EllipseExample(Scene):\n            def construct(self):\n                ellipse_1 = Ellipse(width=2.0, height=4.0, color=BLUE_B)\n                ellipse_2 = Ellipse(width=4.0, height=1.0, color=BLUE_D)\n                ellipse_group = Group(ellipse_1,ellipse_2).arrange(buff=1)\n                self.add(ellipse_group)\n    \"\"\"\n\n    def __init__(self, width: float = 2, height: float = 1, **kwargs: Any) -> None:\n        super().__init__(**kwargs)\n        self.stretch_to_fit_width(width)\n        self.stretch_to_fit_height(height)\n\n\n\n\n[docs]\nclass AnnularSector(Arc):\n    \"\"\"A sector of an annulus.\n\n\n    Parameters\n    ----------\n    inner_radius\n       The inside radius of the Annular Sector.\n    outer_radius\n       The outside radius of the Annular Sector.\n    angle\n       The clockwise angle of the Annular Sector.\n    start_angle\n       The starting clockwise angle of the Annular Sector.\n    fill_opacity\n       The opacity of the color filled in the Annular Sector.\n    stroke_width\n       The stroke width of the Annular Sector.\n    color\n       The color filled into the Annular Sector.\n\n    Examples\n    --------\n    .. manim:: AnnularSectorExample\n        :save_last_frame:\n\n        class AnnularSectorExample(Scene):\n            def construct(self):\n                # Changes background color to clearly visualize changes in fill_opacity.\n                self.camera.background_color = WHITE\n\n                # The default parameter start_angle is 0, so the AnnularSector starts from the +x-axis.\n                s1 = AnnularSector(color=YELLOW).move_to(2 * UL)\n\n                # Different inner_radius and outer_radius than the default.\n                s2 = AnnularSector(inner_radius=1.5, outer_radius=2, angle=45 * DEGREES, color=RED).move_to(2 * UR)\n\n                # fill_opacity is typically a number > 0 and <= 1. If fill_opacity=0, the AnnularSector is transparent.\n                s3 = AnnularSector(inner_radius=1, outer_radius=1.5, angle=PI, fill_opacity=0.25, color=BLUE).move_to(2 * DL)\n\n                # With a negative value for the angle, the AnnularSector is drawn clockwise from the start value.\n                s4 = AnnularSector(inner_radius=1, outer_radius=1.5, angle=-3 * PI / 2, color=GREEN).move_to(2 * DR)\n\n                self.add(s1, s2, s3, s4)\n    \"\"\"\n\n    def __init__(\n        self,\n        inner_radius: float = 1,\n        outer_radius: float = 2,\n        angle: float = TAU / 4,\n        start_angle: float = 0,\n        fill_opacity: float = 1,\n        stroke_width: float = 0,\n        color: ParsableManimColor = WHITE,\n        **kwargs: Any,\n    ) -> None:\n        self.inner_radius = inner_radius\n        self.outer_radius = outer_radius\n        super().__init__(\n            start_angle=start_angle,\n            angle=angle,\n            fill_opacity=fill_opacity,\n            stroke_width=stroke_width,\n            color=color,\n            **kwargs,\n        )\n\n\n[docs]\n    def generate_points(self) -> None:\n        inner_arc, outer_arc = (\n            Arc(\n                start_angle=self.start_angle,\n                angle=self.angle,\n                radius=radius,\n                arc_center=self.arc_center,\n            )\n            for radius in (self.inner_radius, self.outer_radius)\n        )\n        outer_arc.reverse_points()\n        self.append_points(inner_arc.points)\n        self.add_line_to(outer_arc.points[0])\n        self.append_points(outer_arc.points)\n        self.add_line_to(inner_arc.points[0])\n\n\n    init_points = generate_points\n\n\n\n\n[docs]\nclass Sector(AnnularSector):\n    \"\"\"A sector of a circle.\n\n    Examples\n    --------\n    .. manim:: ExampleSector\n        :save_last_frame:\n\n        class ExampleSector(Scene):\n            def construct(self):\n                sector = Sector(radius=2)\n                sector2 = Sector(radius=2.5, angle=60*DEGREES).move_to([-3, 0, 0])\n                sector.set_color(RED)\n                sector2.set_color(PINK)\n                self.add(sector, sector2)\n    \"\"\"\n\n    def __init__(self, radius: float = 1, **kwargs: Any) -> None:\n        super().__init__(inner_radius=0, outer_radius=radius, **kwargs)\n\n\n\n\n[docs]\nclass Annulus(Circle):\n    \"\"\"Region between two concentric :class:`Circles <.Circle>`.\n\n    Parameters\n    ----------\n    inner_radius\n        The radius of the inner :class:`Circle`.\n    outer_radius\n        The radius of the outer :class:`Circle`.\n    kwargs\n        Additional arguments to be passed to :class:`Annulus`\n\n    Examples\n    --------\n    .. manim:: AnnulusExample\n        :save_last_frame:\n\n        class AnnulusExample(Scene):\n            def construct(self):\n                annulus_1 = Annulus(inner_radius=0.5, outer_radius=1).shift(UP)\n                annulus_2 = Annulus(inner_radius=0.3, outer_radius=0.6, color=RED).next_to(annulus_1, DOWN)\n                self.add(annulus_1, annulus_2)\n    \"\"\"\n\n    def __init__(\n        self,\n        inner_radius: float = 1,\n        outer_radius: float = 2,\n        fill_opacity: float = 1,\n        stroke_width: float = 0,\n        color: ParsableManimColor = WHITE,\n        mark_paths_closed: bool = False,\n        **kwargs: Any,\n    ) -> None:\n        self.mark_paths_closed = mark_paths_closed  # is this even used?\n        self.inner_radius = inner_radius\n        self.outer_radius = outer_radius\n        super().__init__(\n            fill_opacity=fill_opacity, stroke_width=stroke_width, color=color, **kwargs\n        )\n\n\n[docs]\n    def generate_points(self) -> None:\n        self.radius = self.outer_radius\n        outer_circle = Circle(radius=self.outer_radius)\n        inner_circle = Circle(radius=self.inner_radius)\n        inner_circle.reverse_points()\n        self.append_points(outer_circle.points)\n        self.append_points(inner_circle.points)\n        self.shift(self.arc_center)\n\n\n    init_points = generate_points\n\n\n\n\n[docs]\nclass CubicBezier(VMobject, metaclass=ConvertToOpenGL):\n    \"\"\"A cubic Bézier curve.\n\n    Example\n    -------\n    .. manim:: BezierSplineExample\n        :save_last_frame:\n\n        class BezierSplineExample(Scene):\n            def construct(self):\n                p1 = np.array([-3, 1, 0])\n                p1b = p1 + [1, 0, 0]\n                d1 = Dot(point=p1).set_color(BLUE)\n                l1 = Line(p1, p1b)\n                p2 = np.array([3, -1, 0])\n                p2b = p2 - [1, 0, 0]\n                d2 = Dot(point=p2).set_color(RED)\n                l2 = Line(p2, p2b)\n                bezier = CubicBezier(p1b, p1b + 3 * RIGHT, p2b - 3 * RIGHT, p2b)\n                self.add(l1, d1, l2, d2, bezier)\n\n    \"\"\"\n\n    def __init__(\n        self,\n        start_anchor: Point3DLike,\n        start_handle: Point3DLike,\n        end_handle: Point3DLike,\n        end_anchor: Point3DLike,\n        **kwargs: Any,\n    ) -> None:\n        super().__init__(**kwargs)\n        self.add_cubic_bezier_curve(start_anchor, start_handle, end_handle, end_anchor)\n\n\n\n\n[docs]\nclass ArcPolygon(VMobject, metaclass=ConvertToOpenGL):\n    \"\"\"A generalized polygon allowing for points to be connected with arcs.\n\n    This version tries to stick close to the way :class:`Polygon` is used. Points\n    can be passed to it directly which are used to generate the according arcs\n    (using :class:`ArcBetweenPoints`). An angle or radius can be passed to it to\n    use across all arcs, but to configure arcs individually an ``arc_config`` list\n    has to be passed with the syntax explained below.\n\n    Parameters\n    ----------\n    vertices\n        A list of vertices, start and end points for the arc segments.\n    angle\n        The angle used for constructing the arcs. If no other parameters\n        are set, this angle is used to construct all arcs.\n    radius\n        The circle radius used to construct the arcs. If specified,\n        overrides the specified ``angle``.\n    arc_config\n        When passing a ``dict``, its content will be passed as keyword\n        arguments to :class:`~.ArcBetweenPoints`. Otherwise, a list\n        of dictionaries containing values that are passed as keyword\n        arguments for every individual arc can be passed.\n    kwargs\n        Further keyword arguments that are passed to the constructor of\n        :class:`~.VMobject`.\n\n    Attributes\n    ----------\n    arcs : :class:`list`\n        The arcs created from the input parameters::\nfrom manim import ArcPolygon\nap = ArcPolygon([0, 0, 0], [2, 0, 0], [0, 2, 0])\nap.arcs\n            [ArcBetweenPoints, ArcBetweenPoints, ArcBetweenPoints]\n\n\n    .. tip::\n\n        Two instances of :class:`ArcPolygon` can be transformed properly into one\n        another as well. Be advised that any arc initialized with ``angle=0``\n        will actually be a straight line, so if a straight section should seamlessly\n        transform into an arced section or vice versa, initialize the straight section\n        with a negligible angle instead (such as ``angle=0.0001``).\n\n    .. note::\n        There is an alternative version (:class:`ArcPolygonFromArcs`) that is instantiated\n        with pre-defined arcs.\n\n    See Also\n    --------\n    :class:`ArcPolygonFromArcs`\n\n\n    Examples\n    --------\n    .. manim:: SeveralArcPolygons\n\n        class SeveralArcPolygons(Scene):\n            def construct(self):\n                a = [0, 0, 0]\n                b = [2, 0, 0]\n                c = [0, 2, 0]\n                ap1 = ArcPolygon(a, b, c, radius=2)\n                ap2 = ArcPolygon(a, b, c, angle=45*DEGREES)\n                ap3 = ArcPolygon(a, b, c, arc_config={'radius': 1.7, 'color': RED})\n                ap4 = ArcPolygon(a, b, c, color=RED, fill_opacity=1,\n                                            arc_config=[{'radius': 1.7, 'color': RED},\n                                            {'angle': 20*DEGREES, 'color': BLUE},\n                                            {'radius': 1}])\n                ap_group = VGroup(ap1, ap2, ap3, ap4).arrange()\n                self.play(*[Create(ap) for ap in [ap1, ap2, ap3, ap4]])\n                self.wait()\n\n    For further examples see :class:`ArcPolygonFromArcs`.\n    \"\"\"\n\n    def __init__(\n        self,\n        *vertices: Point3DLike,\n        angle: float = PI / 4,\n        radius: float | None = None,\n        arc_config: list[dict] | None = None,\n        **kwargs: Any,\n    ) -> None:\n        n = len(vertices)\n        point_pairs = [(vertices[k], vertices[(k + 1) % n]) for k in range(n)]\n\n        if not arc_config:\n            if radius:\n                all_arc_configs: Iterable[dict] = itertools.repeat(\n                    {\"radius\": radius}, len(point_pairs)\n                )\n            else:\n                all_arc_configs = itertools.repeat({\"angle\": angle}, len(point_pairs))\n        elif isinstance(arc_config, dict):\n            all_arc_configs = itertools.repeat(arc_config, len(point_pairs))\n        else:\n            assert len(arc_config) == n\n            all_arc_configs = arc_config\n\n        arcs = [\n            ArcBetweenPoints(*pair, **conf)\n            for (pair, conf) in zip(point_pairs, all_arc_configs)\n        ]\n\n        super().__init__(**kwargs)\n        # Adding the arcs like this makes ArcPolygon double as a VGroup.\n        # Also makes changes to the ArcPolygon, such as scaling, affect\n        # the arcs, so that their new values are usable.\n        self.add(*arcs)\n        for arc in arcs:\n            self.append_points(arc.points)\n\n        # This enables the use of ArcPolygon.arcs as a convenience\n        # because ArcPolygon[0] returns itself, not the first Arc.\n        self.arcs = arcs\n\n\n\n\n[docs]\nclass ArcPolygonFromArcs(VMobject, metaclass=ConvertToOpenGL):\n    \"\"\"A generalized polygon allowing for points to be connected with arcs.\n\n    This version takes in pre-defined arcs to generate the arcpolygon and introduces\n    little new syntax. However unlike :class:`Polygon` it can't be created with points\n    directly.\n\n    For proper appearance the passed arcs should connect seamlessly:\n    ``[a,b][b,c][c,a]``\n\n    If there are any gaps between the arcs, those will be filled in\n    with straight lines, which can be used deliberately for any straight\n    sections. Arcs can also be passed as straight lines such as an arc\n    initialized with ``angle=0``.\n\n    Parameters\n    ----------\n    arcs\n        These are the arcs from which the arcpolygon is assembled.\n    kwargs\n        Keyword arguments that are passed to the constructor of\n        :class:`~.VMobject`. Affects how the ArcPolygon itself is drawn,\n        but doesn't affect passed arcs.\n\n    Attributes\n    ----------\n    arcs\n        The arcs used to initialize the ArcPolygonFromArcs::\nfrom manim import ArcPolygonFromArcs, Arc, ArcBetweenPoints\nap = ArcPolygonFromArcs(Arc(), ArcBetweenPoints([1,0,0], [0,1,0]), Arc())\nap.arcs\n            [Arc, ArcBetweenPoints, Arc]\n\n\n    .. tip::\n\n        Two instances of :class:`ArcPolygon` can be transformed properly into\n        one another as well. Be advised that any arc initialized with ``angle=0``\n        will actually be a straight line, so if a straight section should seamlessly\n        transform into an arced section or vice versa, initialize the straight\n        section with a negligible angle instead (such as ``angle=0.0001``).\n\n    .. note::\n        There is an alternative version (:class:`ArcPolygon`) that can be instantiated\n        with points.\n\n    .. seealso::\n        :class:`ArcPolygon`\n\n    Examples\n    --------\n    One example of an arcpolygon is the Reuleaux triangle.\n    Instead of 3 straight lines connecting the outer points,\n    a Reuleaux triangle has 3 arcs connecting those points,\n    making a shape with constant width.\n\n    Passed arcs are stored as submobjects in the arcpolygon.\n    This means that the arcs are changed along with the arcpolygon,\n    for example when it's shifted, and these arcs can be manipulated\n    after the arcpolygon has been initialized.\n\n    Also both the arcs contained in an :class:`~.ArcPolygonFromArcs`, as well as the\n    arcpolygon itself are drawn, which affects draw time in :class:`~.Create`\n    for example. In most cases the arcs themselves don't\n    need to be drawn, in which case they can be passed as invisible.\n\n    .. manim:: ArcPolygonExample\n\n        class ArcPolygonExample(Scene):\n            def construct(self):\n                arc_conf = {\"stroke_width\": 0}\n                poly_conf = {\"stroke_width\": 10, \"stroke_color\": BLUE,\n                      \"fill_opacity\": 1, \"color\": PURPLE}\n                a = [-1, 0, 0]\n                b = [1, 0, 0]\n                c = [0, np.sqrt(3), 0]\n                arc0 = ArcBetweenPoints(a, b, radius=2, **arc_conf)\n                arc1 = ArcBetweenPoints(b, c, radius=2, **arc_conf)\n                arc2 = ArcBetweenPoints(c, a, radius=2, **arc_conf)\n                reuleaux_tri = ArcPolygonFromArcs(arc0, arc1, arc2, **poly_conf)\n                self.play(FadeIn(reuleaux_tri))\n                self.wait(2)\n\n    The arcpolygon itself can also be hidden so that instead only the contained\n    arcs are drawn. This can be used to easily debug arcs or to highlight them.\n\n    .. manim:: ArcPolygonExample2\n\n        class ArcPolygonExample2(Scene):\n            def construct(self):\n                arc_conf = {\"stroke_width\": 3, \"stroke_color\": BLUE,\n                    \"fill_opacity\": 0.5, \"color\": GREEN}\n                poly_conf = {\"color\": None}\n                a = [-1, 0, 0]\n                b = [1, 0, 0]\n                c = [0, np.sqrt(3), 0]\n                arc0 = ArcBetweenPoints(a, b, radius=2, **arc_conf)\n                arc1 = ArcBetweenPoints(b, c, radius=2, **arc_conf)\n                arc2 = ArcBetweenPoints(c, a, radius=2, stroke_color=RED)\n                reuleaux_tri = ArcPolygonFromArcs(arc0, arc1, arc2, **poly_conf)\n                self.play(FadeIn(reuleaux_tri))\n                self.wait(2)\n    \"\"\"\n\n    def __init__(self, *arcs: Arc | ArcBetweenPoints, **kwargs: Any) -> None:\n        if not all(isinstance(m, (Arc, ArcBetweenPoints)) for m in arcs):\n            raise ValueError(\n                \"All ArcPolygon submobjects must be of type Arc/ArcBetweenPoints\",\n            )\n        super().__init__(**kwargs)\n        # Adding the arcs like this makes ArcPolygonFromArcs double as a VGroup.\n        # Also makes changes to the ArcPolygonFromArcs, such as scaling, affect\n        # the arcs, so that their new values are usable.\n        self.add(*arcs)\n        # This enables the use of ArcPolygonFromArcs.arcs as a convenience\n        # because ArcPolygonFromArcs[0] returns itself, not the first Arc.\n        self.arcs = [*arcs]\n        from .line import Line\n\n        for arc1, arc2 in adjacent_pairs(arcs):\n            self.append_points(arc1.points)\n            line = Line(arc1.get_end(), arc2.get_start())\n            len_ratio = line.get_length() / arc1.get_arc_length()\n            if np.isnan(len_ratio) or np.isinf(len_ratio):\n                continue\n            line.insert_n_curves(int(arc1.get_num_curves() * len_ratio))\n            self.append_points(line.points)", "code_sha1": "716a9a88d84f239e08de6b54942d8e4a4c97e412"}
{"url": "https://docs.manim.community/en/stable/_modules/manim/mobject/geometry/boolean_ops.html", "depth": 2, "instruction": "The code defines classes for performing boolean operations (Union, Difference, Intersection, Exclusion) on 2D vectorized mobjects in Manim. Each operation creates a new mobject representing the result of the boolean operation, with specified colors and fill opacity, positioned in a scene alongside the original shapes.", "code": "\"\"\"Boolean operations for two-dimensional mobjects.\"\"\"\n\nfrom __future__ import annotations\n\nfrom typing import TYPE_CHECKING\n\nimport numpy as np\nfrom pathops import Path as SkiaPath\nfrom pathops import PathVerb, difference, intersection, union, xor\n\nfrom manim import config\nfrom manim.mobject.opengl.opengl_compatibility import ConvertToOpenGL\nfrom manim.mobject.types.vectorized_mobject import VMobject\n\nif TYPE_CHECKING:\n    from typing import Any\n\n    from manim.typing import Point2DLike_Array, Point3D_Array, Point3DLike_Array\n\nfrom ...constants import RendererType\n\n__all__ = [\"Union\", \"Intersection\", \"Difference\", \"Exclusion\"]\n\n\nclass _BooleanOps(VMobject, metaclass=ConvertToOpenGL):\n    \"\"\"This class contains some helper functions which\n    helps to convert to and from skia objects and manim\n    objects (:class:`~.VMobject`).\n    \"\"\"\n\n    def _convert_2d_to_3d_array(\n        self,\n        points: Point2DLike_Array | Point3DLike_Array,\n        z_dim: float = 0.0,\n    ) -> Point3D_Array:\n        \"\"\"Converts an iterable with coordinates in 2D to 3D by adding\n        :attr:`z_dim` as the Z coordinate.\n\n        Parameters\n        ----------\n        points\n            An iterable of points.\n        z_dim\n            Default value for the Z coordinate.\n\n        Returns\n        -------\n        Point3D_Array\n            A list of the points converted to 3D.\n\n        Example\n        -------\na = _BooleanOps()\np = [(1, 2), (3, 4)]\na._convert_2d_to_3d_array(p)\n        array([[1., 2., 0.],\n               [3., 4., 0.]])\n        \"\"\"\n        list_of_points = list(points)\n        for i, point in enumerate(list_of_points):\n            if len(point) == 2:\n                list_of_points[i] = np.array(list(point) + [z_dim])\n        return np.asarray(list_of_points)\n\n    def _convert_vmobject_to_skia_path(self, vmobject: VMobject) -> SkiaPath:\n        \"\"\"Converts a :class:`~.VMobject` to SkiaPath. This method only works for\n        cairo renderer because it treats the points as Cubic beizer curves.\n\n        Parameters\n        ----------\n        vmobject:\n            The :class:`~.VMobject` to convert from.\n\n        Returns\n        -------\n        SkiaPath\n            The converted path.\n        \"\"\"\n        path = SkiaPath()\n\n        if not np.all(np.isfinite(vmobject.points)):\n            points = np.zeros((1, 3))  # point invalid?\n        else:\n            points = vmobject.points\n\n        if len(points) == 0:  # what? No points so return empty path\n            return path\n\n        # In OpenGL it's quadratic beizer curves while on Cairo it's cubic...\n        if config.renderer == RendererType.OPENGL:\n            subpaths = vmobject.get_subpaths_from_points(points)\n            for subpath in subpaths:\n                quads = vmobject.get_bezier_tuples_from_points(subpath)\n                start = subpath[0]\n                path.moveTo(*start[:2])\n                for _p0, p1, p2 in quads:\n                    path.quadTo(*p1[:2], *p2[:2])\n                if vmobject.consider_points_equals(subpath[0], subpath[-1]):\n                    path.close()\n        elif config.renderer == RendererType.CAIRO:\n            subpaths = vmobject.gen_subpaths_from_points_2d(points)  # type: ignore[assignment]\n            for subpath in subpaths:\n                quads = vmobject.gen_cubic_bezier_tuples_from_points(subpath)\n                start = subpath[0]\n                path.moveTo(*start[:2])\n                for _p0, p1, p2, p3 in quads:\n                    path.cubicTo(*p1[:2], *p2[:2], *p3[:2])\n\n                if vmobject.consider_points_equals_2d(subpath[0], subpath[-1]):\n                    path.close()\n\n        return path\n\n    def _convert_skia_path_to_vmobject(self, path: SkiaPath) -> VMobject:\n        \"\"\"Converts SkiaPath back to VMobject.\n        Parameters\n        ----------\n        path:\n            The SkiaPath to convert.\n\n        Returns\n        -------\n        VMobject:\n            The converted VMobject.\n        \"\"\"\n        vmobject = self\n        current_path_start = np.array([0, 0, 0])\n\n        for path_verb, points in path:\n            if path_verb == PathVerb.MOVE:\n                parts = self._convert_2d_to_3d_array(points)\n                for part in parts:\n                    current_path_start = part\n                    vmobject.start_new_path(part)\n                    # vmobject.move_to(*part)\n            elif path_verb == PathVerb.CUBIC:\n                n1, n2, n3 = self._convert_2d_to_3d_array(points)\n                vmobject.add_cubic_bezier_curve_to(n1, n2, n3)\n            elif path_verb == PathVerb.LINE:\n                parts = self._convert_2d_to_3d_array(points)\n                vmobject.add_line_to(parts[0])\n            elif path_verb == PathVerb.CLOSE:\n                vmobject.add_line_to(current_path_start)\n            elif path_verb == PathVerb.QUAD:\n                n1, n2 = self._convert_2d_to_3d_array(points)\n                vmobject.add_quadratic_bezier_curve_to(n1, n2)\n            else:\n                raise Exception(f\"Unsupported: {path_verb}\")\n        return vmobject\n\n\n\n[docs]\nclass Union(_BooleanOps):\n    \"\"\"Union of two or more :class:`~.VMobject` s. This returns the common region of\n    the :class:`~VMobject` s.\n\n    Parameters\n    ----------\n    vmobjects\n        The :class:`~.VMobject` s to find the union of.\n\n    Raises\n    ------\n    ValueError\n        If less than 2 :class:`~.VMobject` s are passed.\n\n    Example\n    -------\n    .. manim:: UnionExample\n        :save_last_frame:\n\n        class UnionExample(Scene):\n            def construct(self):\n                sq = Square(color=RED, fill_opacity=1)\n                sq.move_to([-2, 0, 0])\n                cr = Circle(color=BLUE, fill_opacity=1)\n                cr.move_to([-1.3, 0.7, 0])\n                un = Union(sq, cr, color=GREEN, fill_opacity=1)\n                un.move_to([1.5, 0.3, 0])\n                self.add(sq, cr, un)\n\n    \"\"\"\n\n    def __init__(self, *vmobjects: VMobject, **kwargs: Any) -> None:\n        if len(vmobjects) < 2:\n            raise ValueError(\"At least 2 mobjects needed for Union.\")\n        super().__init__(**kwargs)\n        paths = []\n        for vmobject in vmobjects:\n            paths.append(self._convert_vmobject_to_skia_path(vmobject))\n        outpen = SkiaPath()\n        union(paths, outpen.getPen())\n        self._convert_skia_path_to_vmobject(outpen)\n\n\n\n\n[docs]\nclass Difference(_BooleanOps):\n    \"\"\"Subtracts one :class:`~.VMobject` from another one.\n\n    Parameters\n    ----------\n    subject\n        The 1st :class:`~.VMobject`.\n    clip\n        The 2nd :class:`~.VMobject`\n\n    Example\n    -------\n    .. manim:: DifferenceExample\n        :save_last_frame:\n\n        class DifferenceExample(Scene):\n            def construct(self):\n                sq = Square(color=RED, fill_opacity=1)\n                sq.move_to([-2, 0, 0])\n                cr = Circle(color=BLUE, fill_opacity=1)\n                cr.move_to([-1.3, 0.7, 0])\n                un = Difference(sq, cr, color=GREEN, fill_opacity=1)\n                un.move_to([1.5, 0, 0])\n                self.add(sq, cr, un)\n\n    \"\"\"\n\n    def __init__(self, subject: VMobject, clip: VMobject, **kwargs: Any) -> None:\n        super().__init__(**kwargs)\n        outpen = SkiaPath()\n        difference(\n            [self._convert_vmobject_to_skia_path(subject)],\n            [self._convert_vmobject_to_skia_path(clip)],\n            outpen.getPen(),\n        )\n        self._convert_skia_path_to_vmobject(outpen)\n\n\n\n\n[docs]\nclass Intersection(_BooleanOps):\n    \"\"\"Find the intersection of two :class:`~.VMobject` s.\n    This keeps the parts covered by both :class:`~.VMobject` s.\n\n    Parameters\n    ----------\n    vmobjects\n        The :class:`~.VMobject` to find the intersection.\n\n    Raises\n    ------\n    ValueError\n        If less the 2 :class:`~.VMobject` are passed.\n\n    Example\n    -------\n    .. manim:: IntersectionExample\n        :save_last_frame:\n\n        class IntersectionExample(Scene):\n            def construct(self):\n                sq = Square(color=RED, fill_opacity=1)\n                sq.move_to([-2, 0, 0])\n                cr = Circle(color=BLUE, fill_opacity=1)\n                cr.move_to([-1.3, 0.7, 0])\n                un = Intersection(sq, cr, color=GREEN, fill_opacity=1)\n                un.move_to([1.5, 0, 0])\n                self.add(sq, cr, un)\n\n    \"\"\"\n\n    def __init__(self, *vmobjects: VMobject, **kwargs: Any) -> None:\n        if len(vmobjects) < 2:\n            raise ValueError(\"At least 2 mobjects needed for Intersection.\")\n\n        super().__init__(**kwargs)\n        outpen = SkiaPath()\n        intersection(\n            [self._convert_vmobject_to_skia_path(vmobjects[0])],\n            [self._convert_vmobject_to_skia_path(vmobjects[1])],\n            outpen.getPen(),\n        )\n        new_outpen = outpen\n        for _i in range(2, len(vmobjects)):\n            new_outpen = SkiaPath()\n            intersection(\n                [outpen],\n                [self._convert_vmobject_to_skia_path(vmobjects[_i])],\n                new_outpen.getPen(),\n            )\n            outpen = new_outpen\n\n        self._convert_skia_path_to_vmobject(outpen)\n\n\n\n\n[docs]\nclass Exclusion(_BooleanOps):\n    \"\"\"Find the XOR between two :class:`~.VMobject`.\n    This creates a new :class:`~.VMobject` consisting of the region\n    covered by exactly one of them.\n\n    Parameters\n    ----------\n    subject\n        The 1st :class:`~.VMobject`.\n    clip\n        The 2nd :class:`~.VMobject`\n\n    Example\n    -------\n    .. manim:: IntersectionExample\n        :save_last_frame:\n\n        class IntersectionExample(Scene):\n            def construct(self):\n                sq = Square(color=RED, fill_opacity=1)\n                sq.move_to([-2, 0, 0])\n                cr = Circle(color=BLUE, fill_opacity=1)\n                cr.move_to([-1.3, 0.7, 0])\n                un = Exclusion(sq, cr, color=GREEN, fill_opacity=1)\n                un.move_to([1.5, 0.4, 0])\n                self.add(sq, cr, un)\n\n    \"\"\"\n\n    def __init__(self, subject: VMobject, clip: VMobject, **kwargs: Any) -> None:\n        super().__init__(**kwargs)\n        outpen = SkiaPath()\n        xor(\n            [self._convert_vmobject_to_skia_path(subject)],\n            [self._convert_vmobject_to_skia_path(clip)],\n            outpen.getPen(),\n        )\n        self._convert_skia_path_to_vmobject(outpen)", "code_sha1": "22f19d66b88090e5afbb3126a91ae6bdf13f1127"}
{"url": "https://docs.manim.community/en/stable/_modules/manim/mobject/geometry/labeled.html", "depth": 2, "instruction": "The code defines classes for labeled geometric objects in Manim, including lines, arrows, and polygrams, each containing a customizable label. The label is displayed at specified positions with configurable background boxes and frames, allowing for visual clarity and emphasis on the labeled elements in animations.", "code": "r\"\"\"Mobjects that inherit from lines and contain a label along the length.\"\"\"\n\nfrom __future__ import annotations\n\n__all__ = [\"Label\", \"LabeledLine\", \"LabeledArrow\", \"LabeledPolygram\"]\n\nfrom typing import TYPE_CHECKING\n\nimport numpy as np\n\nfrom manim.constants import *\nfrom manim.mobject.geometry.line import Arrow, Line\nfrom manim.mobject.geometry.polygram import Polygram\nfrom manim.mobject.geometry.shape_matchers import (\n    BackgroundRectangle,\n    SurroundingRectangle,\n)\nfrom manim.mobject.text.tex_mobject import MathTex, Tex\nfrom manim.mobject.text.text_mobject import Text\nfrom manim.mobject.types.vectorized_mobject import VGroup\nfrom manim.utils.color import WHITE\nfrom manim.utils.polylabel import polylabel\n\nif TYPE_CHECKING:\n    from typing import Any\n\n    from manim.typing import Point3DLike_Array\n\n\n\n[docs]\nclass Label(VGroup):\n    \"\"\"A Label consisting of text surrounded by a frame.\n\n    Parameters\n    ----------\n    label\n        Label that will be displayed.\n    label_config\n        A dictionary containing the configuration for the label.\n        This is only applied if ``label`` is of type ``str``.\n    box_config\n        A dictionary containing the configuration for the background box.\n    frame_config\n         A dictionary containing the configuration for the frame.\n\n    Examples\n    --------\n    .. manim:: LabelExample\n        :save_last_frame:\n        :quality: high\n\n        class LabelExample(Scene):\n            def construct(self):\n                label = Label(\n                    label=Text('Label Text', font='sans-serif'),\n                    box_config = {\n                        \"color\" : BLUE,\n                        \"fill_opacity\" : 0.75\n                    }\n                )\n                label.scale(3)\n                self.add(label)\n    \"\"\"\n\n    def __init__(\n        self,\n        label: str | Tex | MathTex | Text,\n        label_config: dict[str, Any] | None = None,\n        box_config: dict[str, Any] | None = None,\n        frame_config: dict[str, Any] | None = None,\n        **kwargs: Any,\n    ) -> None:\n        super().__init__(**kwargs)\n\n        # Setup Defaults\n        default_label_config: dict[str, Any] = {\n            \"color\": WHITE,\n            \"font_size\": DEFAULT_FONT_SIZE,\n        }\n\n        default_box_config: dict[str, Any] = {\n            \"color\": None,\n            \"buff\": 0.05,\n            \"fill_opacity\": 1,\n            \"stroke_width\": 0.5,\n        }\n\n        default_frame_config: dict[str, Any] = {\n            \"color\": WHITE,\n            \"buff\": 0.05,\n            \"stroke_width\": 0.5,\n        }\n\n        # Merge Defaults\n        label_config = default_label_config | (label_config or {})\n        box_config = default_box_config | (box_config or {})\n        frame_config = default_frame_config | (frame_config or {})\n\n        # Determine the type of label and instantiate the appropriate object\n        self.rendered_label: MathTex | Tex | Text\n        if isinstance(label, str):\n            self.rendered_label = MathTex(label, **label_config)\n        elif isinstance(label, (MathTex, Tex, Text)):\n            self.rendered_label = label\n        else:\n            raise TypeError(\"Unsupported label type. Must be MathTex, Tex, or Text.\")\n\n        # Add a background box\n        self.background_rect = BackgroundRectangle(self.rendered_label, **box_config)\n\n        # Add a frame around the label\n        self.frame = SurroundingRectangle(self.rendered_label, **frame_config)\n\n        # Add components to the VGroup\n        self.add(self.background_rect, self.rendered_label, self.frame)\n\n\n\n\n[docs]\nclass LabeledLine(Line):\n    \"\"\"Constructs a line containing a label box somewhere along its length.\n\n    Parameters\n    ----------\n    label\n        Label that will be displayed on the line.\n    label_position\n        A ratio in the range [0-1] to indicate the position of the label with respect to the length of the line. Default value is 0.5.\n    label_config\n        A dictionary containing the configuration for the label.\n        This is only applied if ``label`` is of type ``str``.\n    box_config\n        A dictionary containing the configuration for the background box.\n    frame_config\n         A dictionary containing the configuration for the frame.\n\n        .. seealso::\n            :class:`LabeledArrow`\n\n    Examples\n    --------\n    .. manim:: LabeledLineExample\n        :save_last_frame:\n        :quality: high\n\n        class LabeledLineExample(Scene):\n            def construct(self):\n                line = LabeledLine(\n                    label          = '0.5',\n                    label_position = 0.8,\n                    label_config = {\n                        \"font_size\" : 20\n                    },\n                    start=LEFT+DOWN,\n                    end=RIGHT+UP)\n\n                line.set_length(line.get_length() * 2)\n                self.add(line)\n    \"\"\"\n\n    def __init__(\n        self,\n        label: str | Tex | MathTex | Text,\n        label_position: float = 0.5,\n        label_config: dict[str, Any] | None = None,\n        box_config: dict[str, Any] | None = None,\n        frame_config: dict[str, Any] | None = None,\n        *args: Any,\n        **kwargs: Any,\n    ) -> None:\n        super().__init__(*args, **kwargs)\n\n        # Create Label\n        self.label = Label(\n            label=label,\n            label_config=label_config,\n            box_config=box_config,\n            frame_config=frame_config,\n        )\n\n        # Compute Label Position\n        line_start, line_end = self.get_start_and_end()\n        new_vec = (line_end - line_start) * label_position\n        label_coords = line_start + new_vec\n\n        self.label.move_to(label_coords)\n        self.add(self.label)\n\n\n\n\n[docs]\nclass LabeledArrow(LabeledLine, Arrow):\n    \"\"\"Constructs an arrow containing a label box somewhere along its length.\n    This class inherits its label properties from `LabeledLine`, so the main parameters controlling it are the same.\n\n    Parameters\n    ----------\n    label\n        Label that will be displayed on the Arrow.\n    label_position\n        A ratio in the range [0-1] to indicate the position of the label with respect to the length of the line. Default value is 0.5.\n    label_config\n        A dictionary containing the configuration for the label.\n        This is only applied if ``label`` is of type ``str``.\n    box_config\n        A dictionary containing the configuration for the background box.\n    frame_config\n         A dictionary containing the configuration for the frame.\n\n        .. seealso::\n            :class:`LabeledLine`\n\n    Examples\n    --------\n    .. manim:: LabeledArrowExample\n        :save_last_frame:\n        :quality: high\n\n        class LabeledArrowExample(Scene):\n            def construct(self):\n                l_arrow = LabeledArrow(\"0.5\", start=LEFT*3, end=RIGHT*3 + UP*2, label_position=0.5)\n\n                self.add(l_arrow)\n    \"\"\"\n\n    def __init__(\n        self,\n        *args: Any,\n        **kwargs: Any,\n    ) -> None:\n        super().__init__(*args, **kwargs)\n\n\n\n\n[docs]\nclass LabeledPolygram(Polygram):\n    \"\"\"Constructs a polygram containing a label box at its pole of inaccessibility.\n\n    Parameters\n    ----------\n    vertex_groups\n        Vertices passed to the :class:`~.Polygram` constructor.\n    label\n        Label that will be displayed on the Polygram.\n    precision\n        The precision used by the PolyLabel algorithm.\n    label_config\n        A dictionary containing the configuration for the label.\n        This is only applied if ``label`` is of type ``str``.\n    box_config\n        A dictionary containing the configuration for the background box.\n    frame_config\n         A dictionary containing the configuration for the frame.\n\n        .. note::\n            The PolyLabel Algorithm expects each vertex group to form a closed ring.\n            If the input is open, :class:`LabeledPolygram` will attempt to close it.\n            This may cause the polygon to intersect itself leading to unexpected results.\n\n        .. tip::\n            Make sure the precision corresponds to the scale of your inputs!\n            For instance, if the bounding box of your polygon stretches from 0 to 10,000, a precision of 1.0 or 10.0 should be sufficient.\n\n    Examples\n    --------\n    .. manim:: LabeledPolygramExample\n        :save_last_frame:\n        :quality: high\n\n        class LabeledPolygramExample(Scene):\n            def construct(self):\n                # Define Rings\n                ring1 = [\n                    [-3.8, -2.4, 0], [-2.4, -2.5, 0], [-1.3, -1.6, 0], [-0.2, -1.7, 0],\n                    [1.7, -2.5, 0], [2.9, -2.6, 0], [3.5, -1.5, 0], [4.9, -1.4, 0],\n                    [4.5, 0.2, 0], [4.7, 1.6, 0], [3.5, 2.4, 0], [1.1, 2.5, 0],\n                    [-0.1, 0.9, 0], [-1.2, 0.5, 0], [-1.6, 0.7, 0], [-1.4, 1.9, 0],\n                    [-2.6, 2.6, 0], [-4.4, 1.2, 0], [-4.9, -0.8, 0], [-3.8, -2.4, 0]\n                ]\n                ring2 = [\n                    [0.2, -1.2, 0], [0.9, -1.2, 0], [1.4, -2.0, 0], [2.1, -1.6, 0],\n                    [2.2, -0.5, 0], [1.4, 0.0, 0], [0.4, -0.2, 0], [0.2, -1.2, 0]\n                ]\n                ring3 = [[-2.7, 1.4, 0], [-2.3, 1.7, 0], [-2.8, 1.9, 0], [-2.7, 1.4, 0]]\n\n                # Create Polygons (for reference)\n                p1 = Polygon(*ring1, fill_opacity=0.75)\n                p2 = Polygon(*ring2, fill_color=BLACK, fill_opacity=1)\n                p3 = Polygon(*ring3, fill_color=BLACK, fill_opacity=1)\n\n                # Create Labeled Polygram\n                polygram = LabeledPolygram(\n                    *[ring1, ring2, ring3],\n                    label=Text('Pole', font='sans-serif'),\n                    precision=0.01,\n                )\n\n                # Display Circle (for reference)\n                circle = Circle(radius=polygram.radius, color=WHITE).move_to(polygram.pole)\n\n                self.add(p1, p2, p3)\n                self.add(polygram)\n                self.add(circle)\n\n    .. manim:: LabeledCountryExample\n        :save_last_frame:\n        :quality: high\n\n        import requests\n        import json\n\n        class LabeledCountryExample(Scene):\n            def construct(self):\n                # Fetch JSON data and process arcs\n                data = requests.get('https://cdn.jsdelivr.net/npm/us-atlas@3/nation-10m.json').json()\n                arcs, transform = data['arcs'], data['transform']\n                sarcs = [np.cumsum(arc, axis=0) * transform['scale'] + transform['translate'] for arc in arcs]\n                ssarcs = sorted(sarcs, key=len, reverse=True)[:1]\n\n                # Compute Bounding Box\n                points = np.concatenate(ssarcs)\n                mins, maxs = np.min(points, axis=0), np.max(points, axis=0)\n\n                # Build Axes\n                ax = Axes(\n                    x_range=[mins[0], maxs[0], maxs[0] - mins[0]], x_length=10,\n                    y_range=[mins[1], maxs[1], maxs[1] - mins[1]], y_length=7,\n                    tips=False\n                )\n\n                # Adjust Coordinates\n                array = [[ax.c2p(*point) for point in sarc] for sarc in ssarcs]\n\n                # Add Polygram\n                polygram = LabeledPolygram(\n                    *array,\n                    label=Text('USA', font='sans-serif'),\n                    precision=0.01,\n                    fill_color=BLUE,\n                    stroke_width=0,\n                    fill_opacity=0.75\n                )\n\n                # Display Circle (for reference)\n                circle = Circle(radius=polygram.radius, color=WHITE).move_to(polygram.pole)\n\n                self.add(ax)\n                self.add(polygram)\n                self.add(circle)\n    \"\"\"\n\n    def __init__(\n        self,\n        *vertex_groups: Point3DLike_Array,\n        label: str | Tex | MathTex | Text,\n        precision: float = 0.01,\n        label_config: dict[str, Any] | None = None,\n        box_config: dict[str, Any] | None = None,\n        frame_config: dict[str, Any] | None = None,\n        **kwargs: Any,\n    ) -> None:\n        # Initialize the Polygram with the vertex groups\n        super().__init__(*vertex_groups, **kwargs)\n\n        # Create Label\n        self.label = Label(\n            label=label,\n            label_config=label_config,\n            box_config=box_config,\n            frame_config=frame_config,\n        )\n\n        # Close Vertex Groups\n        rings = [\n            group if np.array_equal(group[0], group[-1]) else list(group) + [group[0]]\n            for group in vertex_groups\n        ]\n\n        # Compute the Pole of Inaccessibility\n        cell = polylabel(rings, precision=precision)\n        self.pole, self.radius = np.pad(cell.c, (0, 1), \"constant\"), cell.d\n\n        # Position the label at the pole\n        self.label.move_to(self.pole)\n        self.add(self.label)", "code_sha1": "c887f9d93b412e84711ba0ba66c29d250a84ddc7"}
{"url": "https://docs.manim.community/en/stable/_modules/manim/mobject/geometry/line.html", "depth": 2, "instruction": "The code defines various line and angle objects in Manim, including `Line`, `DashedLine`, `Arrow`, and `Angle`. Each class has customizable properties like color, length, and stroke width. The `Angle` class can represent angles between lines, with options for right angles and dots. The visual output includes lines and angles with specified attributes, arranged in a scene.", "code": "r\"\"\"Mobjects that are lines or variations of them.\"\"\"\n\nfrom __future__ import annotations\n\n__all__ = [\n    \"Line\",\n    \"DashedLine\",\n    \"TangentLine\",\n    \"Elbow\",\n    \"Arrow\",\n    \"Vector\",\n    \"DoubleArrow\",\n    \"Angle\",\n    \"RightAngle\",\n]\n\nfrom typing import TYPE_CHECKING\n\nimport numpy as np\n\nfrom manim import config\nfrom manim.constants import *\nfrom manim.mobject.geometry.arc import Arc, ArcBetweenPoints, Dot, TipableVMobject\nfrom manim.mobject.geometry.tips import ArrowTriangleFilledTip\nfrom manim.mobject.mobject import Mobject\nfrom manim.mobject.opengl.opengl_compatibility import ConvertToOpenGL\nfrom manim.mobject.opengl.opengl_mobject import OpenGLMobject\nfrom manim.mobject.types.vectorized_mobject import DashedVMobject, VGroup, VMobject\nfrom manim.utils.color import WHITE\nfrom manim.utils.space_ops import angle_of_vector, line_intersection, normalize\n\nif TYPE_CHECKING:\n    from typing import Any\n\n    from typing_extensions import Literal, Self, TypeAlias\n\n    from manim.typing import Point2DLike, Point3D, Point3DLike, Vector3D\n    from manim.utils.color import ParsableManimColor\n\n    from ..matrix import Matrix  # Avoid circular import\n\n    AngleQuadrant: TypeAlias = tuple[Literal[-1, 1], Literal[-1, 1]]\n    r\"\"\"A tuple of 2 integers which can be either +1 or -1, allowing to select\n    one of the 4 quadrants of the Cartesian plane.\n\n    Let :math:`L_1,\\ L_2` be two lines defined by start points\n    :math:`S_1,\\ S_2` and end points :math:`E_1,\\ E_2`. We define the \"positive\n    direction\" of :math:`L_1` as the direction from :math:`S_1` to :math:`E_1`,\n    and its \"negative direction\" as the opposite one. We do the same with\n    :math:`L_2`.\n\n    If :math:`L_1` and :math:`L_2` intersect, they divide the plane into 4\n    quadrants. To pick one quadrant, choose the integers in this tuple in the\n    following way:\n\n    -   If the 1st integer is +1, select one of the 2 quadrants towards the\n        positive direction of :math:`L_1`, i.e. closest to `E_1`. Otherwise, if\n        the 1st integer is -1, select one of the 2 quadrants towards the\n        negative direction of :math:`L_1`, i.e. closest to `S_1`.\n\n    -   Similarly, the sign of the 2nd integer picks the positive or negative\n        direction of :math:`L_2` and, thus, selects one of the 2 quadrants\n        which  are closest to :math:`E_2` or :math:`S_2` respectively.\n    \"\"\"\n\n\n\n[docs]\nclass Line(TipableVMobject):\n    def __init__(\n        self,\n        start: Point3DLike | Mobject = LEFT,\n        end: Point3DLike | Mobject = RIGHT,\n        buff: float = 0,\n        path_arc: float | None = None,\n        **kwargs: Any,\n    ) -> None:\n        self.dim = 3\n        self.buff = buff\n        self.path_arc = path_arc\n        self._set_start_and_end_attrs(start, end)\n        super().__init__(**kwargs)\n        # TODO: Deal with the situation where path_arc is None\n\n\n[docs]\n    def generate_points(self) -> None:\n        self.set_points_by_ends(\n            start=self.start,\n            end=self.end,\n            buff=self.buff,\n            path_arc=self.path_arc,  # type: ignore[arg-type]\n        )\n\n\n\n[docs]\n    def set_points_by_ends(\n        self,\n        start: Point3DLike | Mobject,\n        end: Point3DLike | Mobject,\n        buff: float = 0,\n        path_arc: float = 0,\n    ) -> None:\n        \"\"\"Sets the points of the line based on its start and end points.\n        Unlike :meth:`put_start_and_end_on`, this method respects `self.buff` and\n        Mobject bounding boxes.\n\n        Parameters\n        ----------\n        start\n            The start point or Mobject of the line.\n        end\n            The end point or Mobject of the line.\n        buff\n            The empty space between the start and end of the line, by default 0.\n        path_arc\n            The angle of a circle spanned by this arc, by default 0 which is a straight line.\n        \"\"\"\n        self._set_start_and_end_attrs(start, end)\n        if path_arc:\n            # self.path_arc could potentially be None, which is not accepted\n            # as parameter.\n            assert self.path_arc is not None\n            arc = ArcBetweenPoints(self.start, self.end, angle=self.path_arc)\n            self.set_points(arc.points)\n        else:\n            self.set_points_as_corners(np.asarray([self.start, self.end]))\n\n        self._account_for_buff(buff)\n\n\n    init_points = generate_points\n\n    def _account_for_buff(self, buff: float) -> None:\n        if buff == 0:\n            return\n        #\n        length = self.get_length() if self.path_arc == 0 else self.get_arc_length()\n        #\n        if length < 2 * buff:\n            return\n        buff_proportion = buff / length\n        self.pointwise_become_partial(self, buff_proportion, 1 - buff_proportion)\n        return\n\n    def _set_start_and_end_attrs(\n        self, start: Point3DLike | Mobject, end: Point3DLike | Mobject\n    ) -> None:\n        # If either start or end are Mobjects, this\n        # gives their centers\n        rough_start = self._pointify(start)\n        rough_end = self._pointify(end)\n        vect = normalize(rough_end - rough_start)\n        # Now that we know the direction between them,\n        # we can find the appropriate boundary point from\n        # start and end, if they're mobjects\n        self.start = self._pointify(start, vect)\n        self.end = self._pointify(end, -vect)\n\n\n[docs]\n    def _pointify(\n        self,\n        mob_or_point: Mobject | Point3DLike,\n        direction: Vector3D | None = None,\n    ) -> Point3D:\n        \"\"\"Transforms a mobject into its corresponding point. Does nothing if a point is passed.\n\n        ``direction`` determines the location of the point along its bounding box in that direction.\n\n        Parameters\n        ----------\n        mob_or_point\n            The mobject or point.\n        direction\n            The direction.\n        \"\"\"\n        if isinstance(mob_or_point, (Mobject, OpenGLMobject)):\n            mob = mob_or_point\n            if direction is None:\n                return mob.get_center()\n            else:\n                return mob.get_boundary_point(direction)\n        return np.array(mob_or_point)\n\n\n    def set_path_arc(self, new_value: float) -> None:\n        self.path_arc = new_value\n        self.init_points()\n\n\n[docs]\n    def put_start_and_end_on(\n        self,\n        start: Point3DLike,\n        end: Point3DLike,\n    ) -> Self:\n        \"\"\"Sets starts and end coordinates of a line.\n\n        Examples\n        --------\n        .. manim:: LineExample\n\n            class LineExample(Scene):\n                def construct(self):\n                    d = VGroup()\n                    for i in range(0,10):\n                        d.add(Dot())\n                    d.arrange_in_grid(buff=1)\n                    self.add(d)\n                    l= Line(d[0], d[1])\n                    self.add(l)\n                    self.wait()\n                    l.put_start_and_end_on(d[1].get_center(), d[2].get_center())\n                    self.wait()\n                    l.put_start_and_end_on(d[4].get_center(), d[7].get_center())\n                    self.wait()\n        \"\"\"\n        curr_start, curr_end = self.get_start_and_end()\n        if np.all(curr_start == curr_end):\n            # TODO, any problems with resetting\n            # these attrs?\n            self.start = np.asarray(start)\n            self.end = np.asarray(end)\n            self.generate_points()\n        return super().put_start_and_end_on(start, end)\n\n\n    def get_vector(self) -> Vector3D:\n        return self.get_end() - self.get_start()\n\n    def get_unit_vector(self) -> Vector3D:\n        return normalize(self.get_vector())\n\n    def get_angle(self) -> float:\n        return angle_of_vector(self.get_vector())\n\n\n[docs]\n    def get_projection(self, point: Point3DLike) -> Point3D:\n        \"\"\"Returns the projection of a point onto a line.\n\n        Parameters\n        ----------\n        point\n            The point to which the line is projected.\n        \"\"\"\n        start = self.get_start()\n        end = self.get_end()\n        unit_vect = normalize(end - start)\n        return start + float(np.dot(point - start, unit_vect)) * unit_vect\n\n\n    def get_slope(self) -> float:\n        return float(np.tan(self.get_angle()))\n\n    def set_angle(self, angle: float, about_point: Point3DLike | None = None) -> Self:\n        if about_point is None:\n            about_point = self.get_start()\n\n        self.rotate(\n            angle - self.get_angle(),\n            about_point=about_point,\n        )\n\n        return self\n\n    def set_length(self, length: float) -> Self:\n        scale_factor: float = length / self.get_length()\n        return self.scale(scale_factor)\n\n\n\n\n[docs]\nclass DashedLine(Line):\n    \"\"\"A dashed :class:`Line`.\n\n    Parameters\n    ----------\n    args\n        Arguments to be passed to :class:`Line`\n    dash_length\n        The length of each individual dash of the line.\n    dashed_ratio\n        The ratio of dash space to empty space. Range of 0-1.\n    kwargs\n        Additional arguments to be passed to :class:`Line`\n\n\n    .. seealso::\n        :class:`~.DashedVMobject`\n\n    Examples\n    --------\n    .. manim:: DashedLineExample\n        :save_last_frame:\n\n        class DashedLineExample(Scene):\n            def construct(self):\n                # dash_length increased\n                dashed_1 = DashedLine(config.left_side, config.right_side, dash_length=2.0).shift(UP*2)\n                # normal\n                dashed_2 = DashedLine(config.left_side, config.right_side)\n                # dashed_ratio decreased\n                dashed_3 = DashedLine(config.left_side, config.right_side, dashed_ratio=0.1).shift(DOWN*2)\n                self.add(dashed_1, dashed_2, dashed_3)\n    \"\"\"\n\n    def __init__(\n        self,\n        *args: Any,\n        dash_length: float = DEFAULT_DASH_LENGTH,\n        dashed_ratio: float = 0.5,\n        **kwargs: Any,\n    ) -> None:\n        self.dash_length = dash_length\n        self.dashed_ratio = dashed_ratio\n        super().__init__(*args, **kwargs)\n        dashes = DashedVMobject(\n            self,\n            num_dashes=self._calculate_num_dashes(),\n            dashed_ratio=dashed_ratio,\n        )\n        self.clear_points()\n        self.add(*dashes)\n\n\n[docs]\n    def _calculate_num_dashes(self) -> int:\n        \"\"\"Returns the number of dashes in the dashed line.\n\n        Examples\n        --------\n        ::\nDashedLine()._calculate_num_dashes()\n            20\n        \"\"\"\n        # Minimum number of dashes has to be 2\n        return max(\n            2,\n            int(np.ceil((self.get_length() / self.dash_length) * self.dashed_ratio)),\n        )\n\n\n\n[docs]\n    def get_start(self) -> Point3D:\n        \"\"\"Returns the start point of the line.\n\n        Examples\n        --------\n        ::\nDashedLine().get_start()\n            array([-1.,  0.,  0.])\n        \"\"\"\n        if len(self.submobjects) > 0:\n            return self.submobjects[0].get_start()\n        else:\n            return super().get_start()\n\n\n\n[docs]\n    def get_end(self) -> Point3D:\n        \"\"\"Returns the end point of the line.\n\n        Examples\n        --------\n        ::\nDashedLine().get_end()\n            array([1., 0., 0.])\n        \"\"\"\n        if len(self.submobjects) > 0:\n            return self.submobjects[-1].get_end()\n        else:\n            return super().get_end()\n\n\n\n[docs]\n    def get_first_handle(self) -> Point3D:\n        \"\"\"Returns the point of the first handle.\n\n        Examples\n        --------\n        ::\nDashedLine().get_first_handle()\n            array([-0.98333333,  0.        ,  0.        ])\n        \"\"\"\n        # Type inference of extracting an element from a list, is not\n        # supported by numpy, see this numpy issue\n        # https://github.com/numpy/numpy/issues/16544\n        first_handle: Point3D = self.submobjects[0].points[1]\n        return first_handle\n\n\n\n[docs]\n    def get_last_handle(self) -> Point3D:\n        \"\"\"Returns the point of the last handle.\n\n        Examples\n        --------\n        ::\nDashedLine().get_last_handle()\n            array([0.98333333, 0.        , 0.        ])\n        \"\"\"\n        # Type inference of extracting an element from a list, is not\n        # supported by numpy, see this numpy issue\n        # https://github.com/numpy/numpy/issues/16544\n        last_handle: Point3D = self.submobjects[-1].points[2]\n        return last_handle\n\n\n\n\n\n[docs]\nclass TangentLine(Line):\n    \"\"\"Constructs a line tangent to a :class:`~.VMobject` at a specific point.\n\n    Parameters\n    ----------\n    vmob\n        The VMobject on which the tangent line is drawn.\n    alpha\n        How far along the shape that the line will be constructed. range: 0-1.\n    length\n        Length of the tangent line.\n    d_alpha\n        The ``dx`` value\n    kwargs\n        Additional arguments to be passed to :class:`Line`\n\n\n    .. seealso::\n        :meth:`~.VMobject.point_from_proportion`\n\n    Examples\n    --------\n    .. manim:: TangentLineExample\n        :save_last_frame:\n\n        class TangentLineExample(Scene):\n            def construct(self):\n                circle = Circle(radius=2)\n                line_1 = TangentLine(circle, alpha=0.0, length=4, color=BLUE_D) # right\n                line_2 = TangentLine(circle, alpha=0.4, length=4, color=GREEN) # top left\n                self.add(circle, line_1, line_2)\n    \"\"\"\n\n    def __init__(\n        self,\n        vmob: VMobject,\n        alpha: float,\n        length: float = 1,\n        d_alpha: float = 1e-6,\n        **kwargs: Any,\n    ) -> None:\n        self.length = length\n        self.d_alpha = d_alpha\n        da = self.d_alpha\n        a1 = np.clip(alpha - da, 0, 1)\n        a2 = np.clip(alpha + da, 0, 1)\n        super().__init__(\n            vmob.point_from_proportion(a1), vmob.point_from_proportion(a2), **kwargs\n        )\n        self.scale(self.length / self.get_length())\n\n\n\n\n[docs]\nclass Elbow(VMobject, metaclass=ConvertToOpenGL):\n    \"\"\"Two lines that create a right angle about each other: L-shape.\n\n    Parameters\n    ----------\n    width\n        The length of the elbow's sides.\n    angle\n        The rotation of the elbow.\n    kwargs\n        Additional arguments to be passed to :class:`~.VMobject`\n\n    .. seealso::\n        :class:`RightAngle`\n\n    Examples\n    --------\n    .. manim:: ElbowExample\n        :save_last_frame:\n\n        class ElbowExample(Scene):\n            def construct(self):\n                elbow_1 = Elbow()\n                elbow_2 = Elbow(width=2.0)\n                elbow_3 = Elbow(width=2.0, angle=5*PI/4)\n\n                elbow_group = Group(elbow_1, elbow_2, elbow_3).arrange(buff=1)\n                self.add(elbow_group)\n    \"\"\"\n\n    def __init__(self, width: float = 0.2, angle: float = 0, **kwargs: Any) -> None:\n        self.angle = angle\n        super().__init__(**kwargs)\n        self.set_points_as_corners(np.array([UP, UP + RIGHT, RIGHT]))\n        self.scale_to_fit_width(width, about_point=ORIGIN)\n        self.rotate(self.angle, about_point=ORIGIN)\n\n\n\n\n[docs]\nclass Arrow(Line):\n    \"\"\"An arrow.\n\n    Parameters\n    ----------\n    args\n        Arguments to be passed to :class:`Line`.\n    stroke_width\n        The thickness of the arrow. Influenced by :attr:`max_stroke_width_to_length_ratio`.\n    buff\n        The distance of the arrow from its start and end points.\n    max_tip_length_to_length_ratio\n        :attr:`tip_length` scales with the length of the arrow. Increasing this ratio raises the max value of :attr:`tip_length`.\n    max_stroke_width_to_length_ratio\n        :attr:`stroke_width` scales with the length of the arrow. Increasing this ratio ratios the max value of :attr:`stroke_width`.\n    kwargs\n        Additional arguments to be passed to :class:`Line`.\n\n\n    .. seealso::\n        :class:`ArrowTip`\n        :class:`CurvedArrow`\n\n    Examples\n    --------\n    .. manim:: ArrowExample\n        :save_last_frame:\n\n        from manim.mobject.geometry.tips import ArrowSquareTip\n        class ArrowExample(Scene):\n            def construct(self):\n                arrow_1 = Arrow(start=RIGHT, end=LEFT, color=GOLD)\n                arrow_2 = Arrow(start=RIGHT, end=LEFT, color=GOLD, tip_shape=ArrowSquareTip).shift(DOWN)\n                g1 = Group(arrow_1, arrow_2)\n\n                # the effect of buff\n                square = Square(color=MAROON_A)\n                arrow_3 = Arrow(start=LEFT, end=RIGHT)\n                arrow_4 = Arrow(start=LEFT, end=RIGHT, buff=0).next_to(arrow_1, UP)\n                g2 = Group(arrow_3, arrow_4, square)\n\n                # a shorter arrow has a shorter tip and smaller stroke width\n                arrow_5 = Arrow(start=ORIGIN, end=config.top).shift(LEFT * 4)\n                arrow_6 = Arrow(start=config.top + DOWN, end=config.top).shift(LEFT * 3)\n                g3 = Group(arrow_5, arrow_6)\n\n                self.add(Group(g1, g2, g3).arrange(buff=2))\n\n\n    .. manim:: ArrowExample\n        :save_last_frame:\n\n        class ArrowExample(Scene):\n            def construct(self):\n                left_group = VGroup()\n                # As buff increases, the size of the arrow decreases.\n                for buff in np.arange(0, 2.2, 0.45):\n                    left_group += Arrow(buff=buff, start=2 * LEFT, end=2 * RIGHT)\n                # Required to arrange arrows.\n                left_group.arrange(DOWN)\n                left_group.move_to(4 * LEFT)\n\n                middle_group = VGroup()\n                # As max_stroke_width_to_length_ratio gets bigger,\n                # the width of stroke increases.\n                for i in np.arange(0, 5, 0.5):\n                    middle_group += Arrow(max_stroke_width_to_length_ratio=i)\n                middle_group.arrange(DOWN)\n\n                UR_group = VGroup()\n                # As max_tip_length_to_length_ratio increases,\n                # the length of the tip increases.\n                for i in np.arange(0, 0.3, 0.1):\n                    UR_group += Arrow(max_tip_length_to_length_ratio=i)\n                UR_group.arrange(DOWN)\n                UR_group.move_to(4 * RIGHT + 2 * UP)\n\n                DR_group = VGroup()\n                DR_group += Arrow(start=LEFT, end=RIGHT, color=BLUE, tip_shape=ArrowSquareTip)\n                DR_group += Arrow(start=LEFT, end=RIGHT, color=BLUE, tip_shape=ArrowSquareFilledTip)\n                DR_group += Arrow(start=LEFT, end=RIGHT, color=YELLOW, tip_shape=ArrowCircleTip)\n                DR_group += Arrow(start=LEFT, end=RIGHT, color=YELLOW, tip_shape=ArrowCircleFilledTip)\n                DR_group.arrange(DOWN)\n                DR_group.move_to(4 * RIGHT + 2 * DOWN)\n\n                self.add(left_group, middle_group, UR_group, DR_group)\n    \"\"\"\n\n    def __init__(\n        self,\n        *args: Any,\n        stroke_width: float = 6,\n        buff: float = MED_SMALL_BUFF,\n        max_tip_length_to_length_ratio: float = 0.25,\n        max_stroke_width_to_length_ratio: float = 5,\n        **kwargs: Any,\n    ) -> None:\n        self.max_tip_length_to_length_ratio = max_tip_length_to_length_ratio\n        self.max_stroke_width_to_length_ratio = max_stroke_width_to_length_ratio\n        tip_shape = kwargs.pop(\"tip_shape\", ArrowTriangleFilledTip)\n        super().__init__(*args, buff=buff, stroke_width=stroke_width, **kwargs)  # type: ignore[misc]\n        # TODO, should this be affected when\n        # Arrow.set_stroke is called?\n        self.initial_stroke_width = self.stroke_width\n        self.add_tip(tip_shape=tip_shape)\n        self._set_stroke_width_from_length()\n\n\n[docs]\n    def scale(self, factor: float, scale_tips: bool = False, **kwargs: Any) -> Self:  # type: ignore[override]\n        r\"\"\"Scale an arrow, but keep stroke width and arrow tip size fixed.\n\n\n        .. seealso::\n            :meth:`~.Mobject.scale`\n\n        Examples\n        --------\n        ::\narrow = Arrow(np.array([-1, -1, 0]), np.array([1, 1, 0]), buff=0)\nscaled_arrow = arrow.scale(2)\nnp.round(scaled_arrow.get_start_and_end(), 8) + 0\n            array([[-2., -2.,  0.],\n                   [ 2.,  2.,  0.]])\narrow.tip.length == scaled_arrow.tip.length\n            True\n\n        Manually scaling the object using the default method\n        :meth:`~.Mobject.scale` does not have the same properties::\nnew_arrow = Arrow(np.array([-1, -1, 0]), np.array([1, 1, 0]), buff=0)\nanother_scaled_arrow = VMobject.scale(new_arrow, 2)\nanother_scaled_arrow.tip.length == arrow.tip.length\n            False\n\n        \"\"\"\n        if self.get_length() == 0:\n            return self\n\n        if scale_tips:\n            super().scale(factor, **kwargs)\n            self._set_stroke_width_from_length()\n            return self\n\n        has_tip = self.has_tip()\n        has_start_tip = self.has_start_tip()\n        if has_tip or has_start_tip:\n            old_tips = self.pop_tips()\n\n        super().scale(factor, **kwargs)\n        self._set_stroke_width_from_length()\n\n        if has_tip:\n            self.add_tip(tip=old_tips[0])\n        if has_start_tip:\n            self.add_tip(tip=old_tips[1], at_start=True)\n        return self\n\n\n\n[docs]\n    def get_normal_vector(self) -> Vector3D:\n        \"\"\"Returns the normal of a vector.\n\n        Examples\n        --------\n        ::\nnp.round(Arrow().get_normal_vector()) + 0. # add 0. to avoid negative 0 in output\n            array([ 0.,  0., -1.])\n        \"\"\"\n        p0, p1, p2 = self.tip.get_start_anchors()[:3]\n        return normalize(np.cross(p2 - p1, p1 - p0))\n\n\n\n[docs]\n    def reset_normal_vector(self) -> Self:\n        \"\"\"Resets the normal of a vector\"\"\"\n        self.normal_vector = self.get_normal_vector()\n        return self\n\n\n\n[docs]\n    def get_default_tip_length(self) -> float:\n        \"\"\"Returns the default tip_length of the arrow.\n\n        Examples\n        --------\n\n        ::\nArrow().get_default_tip_length()\n            0.35\n        \"\"\"\n        max_ratio = self.max_tip_length_to_length_ratio\n        return min(self.tip_length, max_ratio * self.get_length())\n\n\n\n[docs]\n    def _set_stroke_width_from_length(self) -> Self:\n        \"\"\"Sets stroke width based on length.\"\"\"\n        max_ratio = self.max_stroke_width_to_length_ratio\n        if config.renderer == RendererType.OPENGL:\n            # Mypy does not recognize that the self object in this case\n            # is a OpenGLVMobject and that the set_stroke method is\n            # defined here:\n            # mobject/opengl/opengl_vectorized_mobject.py#L248\n            self.set_stroke(  # type: ignore[call-arg]\n                width=min(self.initial_stroke_width, max_ratio * self.get_length()),\n                recurse=False,\n            )\n        else:\n            self.set_stroke(\n                width=min(self.initial_stroke_width, max_ratio * self.get_length()),\n                family=False,\n            )\n        return self\n\n\n\n\n\n[docs]\nclass Vector(Arrow):\n    \"\"\"A vector specialized for use in graphs.\n\n    .. caution::\n        Do not confuse with the :class:`~.Vector2D`,\n        :class:`~.Vector3D` or :class:`~.VectorND` type aliases,\n        which are not Mobjects!\n\n    Parameters\n    ----------\n    direction\n        The direction of the arrow.\n    buff\n         The distance of the vector from its endpoints.\n    kwargs\n        Additional arguments to be passed to :class:`Arrow`\n\n    Examples\n    --------\n    .. manim:: VectorExample\n        :save_last_frame:\n\n        class VectorExample(Scene):\n            def construct(self):\n                plane = NumberPlane()\n                vector_1 = Vector([1,2])\n                vector_2 = Vector([-5,-2])\n                self.add(plane, vector_1, vector_2)\n    \"\"\"\n\n    def __init__(\n        self,\n        direction: Point2DLike | Point3DLike = RIGHT,\n        buff: float = 0,\n        **kwargs: Any,\n    ) -> None:\n        self.buff = buff\n        if len(direction) == 2:\n            direction = np.hstack([direction, 0])\n\n        super().__init__(ORIGIN, direction, buff=buff, **kwargs)\n\n\n[docs]\n    def coordinate_label(\n        self,\n        integer_labels: bool = True,\n        n_dim: int = 2,\n        color: ParsableManimColor | None = None,\n        **kwargs: Any,\n    ) -> Matrix:\n        \"\"\"Creates a label based on the coordinates of the vector.\n\n        Parameters\n        ----------\n        integer_labels\n            Whether or not to round the coordinates to integers.\n        n_dim\n            The number of dimensions of the vector.\n        color\n            Sets the color of label, optional.\n        kwargs\n            Additional arguments to be passed to :class:`~.Matrix`.\n\n        Returns\n        -------\n        :class:`~.Matrix`\n            The label.\n\n        Examples\n        --------\n        .. manim:: VectorCoordinateLabel\n            :save_last_frame:\n\n            class VectorCoordinateLabel(Scene):\n                def construct(self):\n                    plane = NumberPlane()\n\n                    vec_1 = Vector([1, 2])\n                    vec_2 = Vector([-3, -2])\n                    label_1 = vec_1.coordinate_label()\n                    label_2 = vec_2.coordinate_label(color=YELLOW)\n\n                    self.add(plane, vec_1, vec_2, label_1, label_2)\n        \"\"\"\n        # avoiding circular imports\n        from ..matrix import Matrix\n\n        vect = np.array(self.get_end())\n        if integer_labels:\n            vect = np.round(vect).astype(int)\n        vect = vect[:n_dim]\n        vect = vect.reshape((n_dim, 1))\n        label = Matrix(vect, **kwargs)\n        label.scale(LARGE_BUFF - 0.2)\n\n        shift_dir = np.array(self.get_end())\n        if shift_dir[0] >= 0:  # Pointing right\n            shift_dir -= label.get_left() + DEFAULT_MOBJECT_TO_MOBJECT_BUFFER * LEFT\n        else:  # Pointing left\n            shift_dir -= label.get_right() + DEFAULT_MOBJECT_TO_MOBJECT_BUFFER * RIGHT\n        label.shift(shift_dir)\n        if color is not None:\n            label.set_color(color)\n        return label\n\n\n\n\n\n[docs]\nclass DoubleArrow(Arrow):\n    \"\"\"An arrow with tips on both ends.\n\n    Parameters\n    ----------\n    args\n        Arguments to be passed to :class:`Arrow`\n    kwargs\n        Additional arguments to be passed to :class:`Arrow`\n\n\n    .. seealso::\n        :class:`.~ArrowTip`\n        :class:`.~CurvedDoubleArrow`\n\n    Examples\n    --------\n    .. manim:: DoubleArrowExample\n        :save_last_frame:\n\n        from manim.mobject.geometry.tips import ArrowCircleFilledTip\n        class DoubleArrowExample(Scene):\n            def construct(self):\n                circle = Circle(radius=2.0)\n                d_arrow = DoubleArrow(start=circle.get_left(), end=circle.get_right())\n                d_arrow_2 = DoubleArrow(tip_shape_end=ArrowCircleFilledTip, tip_shape_start=ArrowCircleFilledTip)\n                group = Group(Group(circle, d_arrow), d_arrow_2).arrange(UP, buff=1)\n                self.add(group)\n\n\n    .. manim:: DoubleArrowExample2\n        :save_last_frame:\n\n        class DoubleArrowExample2(Scene):\n            def construct(self):\n                box = Square()\n                p1 = box.get_left()\n                p2 = box.get_right()\n                d1 = DoubleArrow(p1, p2, buff=0)\n                d2 = DoubleArrow(p1, p2, buff=0, tip_length=0.2, color=YELLOW)\n                d3 = DoubleArrow(p1, p2, buff=0, tip_length=0.4, color=BLUE)\n                Group(d1, d2, d3).arrange(DOWN)\n                self.add(box, d1, d2, d3)\n    \"\"\"\n\n    def __init__(self, *args: Any, **kwargs: Any) -> None:\n        if \"tip_shape_end\" in kwargs:\n            kwargs[\"tip_shape\"] = kwargs.pop(\"tip_shape_end\")\n        tip_shape_start = kwargs.pop(\"tip_shape_start\", ArrowTriangleFilledTip)\n        super().__init__(*args, **kwargs)\n        self.add_tip(at_start=True, tip_shape=tip_shape_start)\n\n\n\n\n[docs]\nclass Angle(VMobject, metaclass=ConvertToOpenGL):\n    \"\"\"A circular arc or elbow-type mobject representing an angle of two lines.\n\n    Parameters\n    ----------\n    line1 :\n        The first line.\n    line2 :\n        The second line.\n    radius :\n        The radius of the :class:`Arc`.\n    quadrant\n        A sequence of two :class:`int` numbers determining which of the 4 quadrants should be used.\n        The first value indicates whether to anchor the arc on the first line closer to the end point (1)\n        or start point (-1), and the second value functions similarly for the\n        end (1) or start (-1) of the second line.\n        Possibilities: (1,1), (-1,1), (1,-1), (-1,-1).\n    other_angle :\n        Toggles between the two possible angles defined by two points and an arc center. If set to\n        False (default), the arc will always go counterclockwise from the point on line1 until\n        the point on line2 is reached. If set to True, the angle will go clockwise from line1 to line2.\n    dot\n        Allows for a :class:`Dot` in the arc. Mainly used as an convention to indicate a right angle.\n        The dot can be customized in the next three parameters.\n    dot_radius\n        The radius of the :class:`Dot`. If not specified otherwise, this radius will be 1/10 of the arc radius.\n    dot_distance\n        Relative distance from the center to the arc: 0 puts the dot in the center and 1 on the arc itself.\n    dot_color\n        The color of the :class:`Dot`.\n    elbow\n        Produces an elbow-type mobject indicating a right angle, see :class:`RightAngle` for more information\n        and a shorthand.\n    **kwargs\n        Further keyword arguments that are passed to the constructor of :class:`Arc` or :class:`Elbow`.\n\n    Examples\n    --------\n    The first example shows some right angles with a dot in the middle while the second example shows\n    all 8 possible angles defined by two lines.\n\n    .. manim:: RightArcAngleExample\n        :save_last_frame:\n\n        class RightArcAngleExample(Scene):\n            def construct(self):\n                line1 = Line( LEFT, RIGHT )\n                line2 = Line( DOWN, UP )\n                rightarcangles = [\n                    Angle(line1, line2, dot=True),\n                    Angle(line1, line2, radius=0.4, quadrant=(1,-1), dot=True, other_angle=True),\n                    Angle(line1, line2, radius=0.5, quadrant=(-1,1), stroke_width=8, dot=True, dot_color=YELLOW, dot_radius=0.04, other_angle=True),\n                    Angle(line1, line2, radius=0.7, quadrant=(-1,-1), color=RED, dot=True, dot_color=GREEN, dot_radius=0.08),\n                ]\n                plots = VGroup()\n                for angle in rightarcangles:\n                    plot=VGroup(line1.copy(),line2.copy(), angle)\n                    plots.add(plot)\n                plots.arrange(buff=1.5)\n                self.add(plots)\n\n    .. manim:: AngleExample\n        :save_last_frame:\n\n        class AngleExample(Scene):\n            def construct(self):\n                line1 = Line( LEFT + (1/3) * UP, RIGHT + (1/3) * DOWN )\n                line2 = Line( DOWN + (1/3) * RIGHT, UP + (1/3) * LEFT )\n                angles = [\n                    Angle(line1, line2),\n                    Angle(line1, line2, radius=0.4, quadrant=(1,-1), other_angle=True),\n                    Angle(line1, line2, radius=0.5, quadrant=(-1,1), stroke_width=8, other_angle=True),\n                    Angle(line1, line2, radius=0.7, quadrant=(-1,-1), color=RED),\n                    Angle(line1, line2, other_angle=True),\n                    Angle(line1, line2, radius=0.4, quadrant=(1,-1)),\n                    Angle(line1, line2, radius=0.5, quadrant=(-1,1), stroke_width=8),\n                    Angle(line1, line2, radius=0.7, quadrant=(-1,-1), color=RED, other_angle=True),\n                ]\n                plots = VGroup()\n                for angle in angles:\n                    plot=VGroup(line1.copy(),line2.copy(), angle)\n                    plots.add(VGroup(plot,SurroundingRectangle(plot, buff=0.3)))\n                plots.arrange_in_grid(rows=2,buff=1)\n                self.add(plots)\n\n    .. manim:: FilledAngle\n        :save_last_frame:\n\n        class FilledAngle(Scene):\n            def construct(self):\n                l1 = Line(ORIGIN, 2 * UP + RIGHT).set_color(GREEN)\n                l2 = (\n                    Line(ORIGIN, 2 * UP + RIGHT)\n                    .set_color(GREEN)\n                    .rotate(-20 * DEGREES, about_point=ORIGIN)\n                )\n                norm = l1.get_length()\n                a1 = Angle(l1, l2, other_angle=True, radius=norm - 0.5).set_color(GREEN)\n                a2 = Angle(l1, l2, other_angle=True, radius=norm).set_color(GREEN)\n                q1 = a1.points #  save all coordinates of points of angle a1\n                q2 = a2.reverse_direction().points  #  save all coordinates of points of angle a1 (in reversed direction)\n                pnts = np.concatenate([q1, q2, q1[0].reshape(1, 3)])  # adds points and ensures that path starts and ends at same point\n                mfill = VMobject().set_color(ORANGE)\n                mfill.set_points_as_corners(pnts).set_fill(GREEN, opacity=1)\n                self.add(l1, l2)\n                self.add(mfill)\n\n    \"\"\"\n\n    def __init__(\n        self,\n        line1: Line,\n        line2: Line,\n        radius: float | None = None,\n        quadrant: AngleQuadrant = (1, 1),\n        other_angle: bool = False,\n        dot: bool = False,\n        dot_radius: float | None = None,\n        dot_distance: float = 0.55,\n        dot_color: ParsableManimColor = WHITE,\n        elbow: bool = False,\n        **kwargs: Any,\n    ) -> None:\n        super().__init__(**kwargs)\n        self.lines = (line1, line2)\n        self.quadrant = quadrant\n        self.dot_distance = dot_distance\n        self.elbow = elbow\n        inter = line_intersection(\n            [line1.get_start(), line1.get_end()],\n            [line2.get_start(), line2.get_end()],\n        )\n\n        if radius is None:\n            if quadrant[0] == 1:\n                dist_1 = np.linalg.norm(line1.get_end() - inter)\n            else:\n                dist_1 = np.linalg.norm(line1.get_start() - inter)\n            if quadrant[1] == 1:\n                dist_2 = np.linalg.norm(line2.get_end() - inter)\n            else:\n                dist_2 = np.linalg.norm(line2.get_start() - inter)\n            if np.minimum(dist_1, dist_2) < 0.6:\n                radius = (2 / 3) * np.minimum(dist_1, dist_2)\n            else:\n                radius = 0.4\n        else:\n            self.radius = radius\n\n        anchor_angle_1 = inter + quadrant[0] * radius * line1.get_unit_vector()\n        anchor_angle_2 = inter + quadrant[1] * radius * line2.get_unit_vector()\n\n        if elbow:\n            anchor_middle = (\n                inter\n                + quadrant[0] * radius * line1.get_unit_vector()\n                + quadrant[1] * radius * line2.get_unit_vector()\n            )\n            angle_mobject: VMobject = Elbow(**kwargs)\n            angle_mobject.set_points_as_corners(\n                np.array([anchor_angle_1, anchor_middle, anchor_angle_2]),\n            )\n        else:\n            angle_1 = angle_of_vector(anchor_angle_1 - inter)\n            angle_2 = angle_of_vector(anchor_angle_2 - inter)\n\n            if not other_angle:\n                start_angle = angle_1\n                if angle_2 > angle_1:\n                    angle_fin = angle_2 - angle_1\n                else:\n                    angle_fin = 2 * np.pi - (angle_1 - angle_2)\n            else:\n                start_angle = angle_1\n                if angle_2 < angle_1:\n                    angle_fin = -angle_1 + angle_2\n                else:\n                    angle_fin = -2 * np.pi + (angle_2 - angle_1)\n\n            self.angle_value = angle_fin\n\n            angle_mobject = Arc(\n                radius=radius,\n                angle=self.angle_value,\n                start_angle=start_angle,\n                arc_center=inter,\n                **kwargs,\n            )\n\n            if dot:\n                if dot_radius is None:\n                    dot_radius = radius / 10\n                else:\n                    self.dot_radius = dot_radius\n                right_dot = Dot(ORIGIN, radius=dot_radius, color=dot_color)\n                dot_anchor = (\n                    inter\n                    + (angle_mobject.get_center() - inter)\n                    / np.linalg.norm(angle_mobject.get_center() - inter)\n                    * radius\n                    * dot_distance\n                )\n                right_dot.move_to(dot_anchor)\n                self.add(right_dot)\n\n        self.set_points(angle_mobject.points)\n\n\n[docs]\n    def get_lines(self) -> VGroup:\n        \"\"\"Get the lines forming an angle of the :class:`Angle` class.\n\n        Returns\n        -------\n        :class:`~.VGroup`\n            A :class:`~.VGroup` containing the lines that form the angle of the :class:`Angle` class.\n\n        Examples\n        --------\n        ::\nline_1, line_2 = Line(ORIGIN, RIGHT), Line(ORIGIN, UR)\nangle = Angle(line_1, line_2)\nangle.get_lines()\n            VGroup(Line, Line)\n        \"\"\"\n        return VGroup(*self.lines)\n\n\n\n[docs]\n    def get_value(self, degrees: bool = False) -> float:\n        r\"\"\"Get the value of an angle of the :class:`Angle` class.\n\n        Parameters\n        ----------\n        degrees\n            A boolean to decide the unit (deg/rad) in which the value of the angle is returned.\n\n        Returns\n        -------\n        :class:`float`\n            The value in degrees/radians of an angle of the :class:`Angle` class.\n\n        Examples\n        --------\n\n        .. manim:: GetValueExample\n            :save_last_frame:\n\n            class GetValueExample(Scene):\n                def construct(self):\n                    line1 = Line(LEFT+(1/3)*UP, RIGHT+(1/3)*DOWN)\n                    line2 = Line(DOWN+(1/3)*RIGHT, UP+(1/3)*LEFT)\n\n                    angle = Angle(line1, line2, radius=0.4)\n\n                    value = DecimalNumber(angle.get_value(degrees=True), unit=r\"^{\\circ}\")\n                    value.next_to(angle, UR)\n\n                    self.add(line1, line2, angle, value)\n        \"\"\"\n        return self.angle_value / DEGREES if degrees else self.angle_value\n\n\n\n[docs]\n    @staticmethod\n    def from_three_points(\n        A: Point3DLike, B: Point3DLike, C: Point3DLike, **kwargs: Any\n    ) -> Angle:\n        r\"\"\"The angle between the lines AB and BC.\n\n        This constructs the angle :math:`\\\\angle ABC`.\n\n        Parameters\n        ----------\n        A\n            The endpoint of the first angle leg\n        B\n            The vertex of the angle\n        C\n            The endpoint of the second angle leg\n\n        **kwargs\n            Further keyword arguments are passed to :class:`.Angle`\n\n        Returns\n        -------\n        The Angle calculated from the three points\n\n                    Angle(line1, line2, radius=0.5, quadrant=(-1,1), stroke_width=8),\n                    Angle(line1, line2, radius=0.7, quadrant=(-1,-1), color=RED, other_angle=True),\n\n        Examples\n        --------\n        .. manim:: AngleFromThreePointsExample\n            :save_last_frame:\n\n            class AngleFromThreePointsExample(Scene):\n                def construct(self):\n                    sample_angle = Angle.from_three_points(UP, ORIGIN, LEFT)\n                    red_angle = Angle.from_three_points(LEFT + UP, ORIGIN, RIGHT, radius=.8, quadrant=(-1,-1), color=RED, stroke_width=8, other_angle=True)\n                    self.add(red_angle, sample_angle)\n        \"\"\"\n        return Angle(Line(B, A), Line(B, C), **kwargs)\n\n\n\n\n\n[docs]\nclass RightAngle(Angle):\n    \"\"\"An elbow-type mobject representing a right angle between two lines.\n\n    Parameters\n    ----------\n    line1\n        The first line.\n    line2\n        The second line.\n    length\n        The length of the arms.\n    **kwargs\n        Further keyword arguments that are passed to the constructor of :class:`Angle`.\n\n    Examples\n    --------\n    .. manim:: RightAngleExample\n        :save_last_frame:\n\n        class RightAngleExample(Scene):\n            def construct(self):\n                line1 = Line( LEFT, RIGHT )\n                line2 = Line( DOWN, UP )\n                rightangles = [\n                    RightAngle(line1, line2),\n                    RightAngle(line1, line2, length=0.4, quadrant=(1,-1)),\n                    RightAngle(line1, line2, length=0.5, quadrant=(-1,1), stroke_width=8),\n                    RightAngle(line1, line2, length=0.7, quadrant=(-1,-1), color=RED),\n                ]\n                plots = VGroup()\n                for rightangle in rightangles:\n                    plot=VGroup(line1.copy(),line2.copy(), rightangle)\n                    plots.add(plot)\n                plots.arrange(buff=1.5)\n                self.add(plots)\n    \"\"\"\n\n    def __init__(\n        self,\n        line1: Line,\n        line2: Line,\n        length: float | None = None,\n        **kwargs: Any,\n    ) -> None:\n        super().__init__(line1, line2, radius=length, elbow=True, **kwargs)", "code_sha1": "79acadc668b278a0325007617436052cf728e87c"}
{"url": "https://docs.manim.community/en/stable/_modules/manim/mobject/geometry/polygram.html", "depth": 2, "instruction": "The code defines a `Polygram` class that creates a geometric shape with multiple disconnected edges, allowing for various configurations of vertices. In the example, a hexagram is displayed, with a dot moving along its path over 5 seconds, while the hexagram is added to the scene. The final frame remains visible after the animation.", "code": "r\"\"\"Mobjects that are simple geometric shapes.\"\"\"\n\nfrom __future__ import annotations\n\n__all__ = [\n    \"Polygram\",\n    \"Polygon\",\n    \"RegularPolygram\",\n    \"RegularPolygon\",\n    \"Star\",\n    \"Triangle\",\n    \"Rectangle\",\n    \"Square\",\n    \"RoundedRectangle\",\n    \"Cutout\",\n    \"ConvexHull\",\n]\n\n\nfrom math import ceil\nfrom typing import TYPE_CHECKING\n\nimport numpy as np\n\nfrom manim.constants import *\nfrom manim.mobject.geometry.arc import ArcBetweenPoints\nfrom manim.mobject.opengl.opengl_compatibility import ConvertToOpenGL\nfrom manim.mobject.types.vectorized_mobject import VGroup, VMobject\nfrom manim.utils.color import BLUE, WHITE, ParsableManimColor\nfrom manim.utils.iterables import adjacent_n_tuples, adjacent_pairs\nfrom manim.utils.qhull import QuickHull\nfrom manim.utils.space_ops import angle_between_vectors, normalize, regular_vertices\n\nif TYPE_CHECKING:\n    from typing import Any, Literal\n\n    import numpy.typing as npt\n    from typing_extensions import Self\n\n    from manim.typing import (\n        ManimFloat,\n        Point3D,\n        Point3D_Array,\n        Point3DLike,\n        Point3DLike_Array,\n    )\n    from manim.utils.color import ParsableManimColor\n\n\n\n[docs]\nclass Polygram(VMobject, metaclass=ConvertToOpenGL):\n    \"\"\"A generalized :class:`Polygon`, allowing for disconnected sets of edges.\n\n    Parameters\n    ----------\n    vertex_groups\n        The groups of vertices making up the :class:`Polygram`.\n\n        The first vertex in each group is repeated to close the shape.\n        Each point must be 3-dimensional: ``[x,y,z]``\n    color\n        The color of the :class:`Polygram`.\n    kwargs\n        Forwarded to the parent constructor.\n\n    Examples\n    --------\n    .. manim:: PolygramExample\n\n        import numpy as np\n\n        class PolygramExample(Scene):\n            def construct(self):\n                hexagram = Polygram(\n                    [[0, 2, 0], [-np.sqrt(3), -1, 0], [np.sqrt(3), -1, 0]],\n                    [[-np.sqrt(3), 1, 0], [0, -2, 0], [np.sqrt(3), 1, 0]],\n                )\n                self.add(hexagram)\n\n                dot = Dot()\n                self.play(MoveAlongPath(dot, hexagram), run_time=5, rate_func=linear)\n                self.remove(dot)\n                self.wait()\n    \"\"\"\n\n    def __init__(\n        self,\n        *vertex_groups: Point3DLike_Array,\n        color: ParsableManimColor = BLUE,\n        **kwargs: Any,\n    ):\n        super().__init__(color=color, **kwargs)\n\n        for vertices in vertex_groups:\n            # The inferred type for *vertices is Any, but it should be\n            # Point3D_Array\n            first_vertex, *vertices = vertices\n            first_vertex = np.array(first_vertex)\n\n            self.start_new_path(first_vertex)\n            self.add_points_as_corners(\n                [*(np.array(vertex) for vertex in vertices), first_vertex],\n            )\n\n\n[docs]\n    def get_vertices(self) -> Point3D_Array:\n        \"\"\"Gets the vertices of the :class:`Polygram`.\n\n        Returns\n        -------\n        :class:`numpy.ndarray`\n            The vertices of the :class:`Polygram`.\n\n        Examples\n        --------\n        ::\nsq = Square()\nsq.get_vertices()\n            array([[ 1.,  1.,  0.],\n                   [-1.,  1.,  0.],\n                   [-1., -1.,  0.],\n                   [ 1., -1.,  0.]])\n        \"\"\"\n        return self.get_start_anchors()\n\n\n\n[docs]\n    def get_vertex_groups(self) -> npt.NDArray[ManimFloat]:\n        \"\"\"Gets the vertex groups of the :class:`Polygram`.\n\n        Returns\n        -------\n        :class:`numpy.ndarray`\n            The vertex groups of the :class:`Polygram`.\n\n        Examples\n        --------\n        ::\npoly = Polygram([ORIGIN, RIGHT, UP], [LEFT, LEFT + UP, 2 * LEFT])\npoly.get_vertex_groups()\n            array([[[ 0.,  0.,  0.],\n                    [ 1.,  0.,  0.],\n                    [ 0.,  1.,  0.]],\n            <BLANKLINE>\n                   [[-1.,  0.,  0.],\n                    [-1.,  1.,  0.],\n                    [-2.,  0.,  0.]]])\n        \"\"\"\n        vertex_groups = []\n\n        group = []\n        for start, end in zip(self.get_start_anchors(), self.get_end_anchors()):\n            group.append(start)\n\n            if self.consider_points_equals(end, group[0]):\n                vertex_groups.append(group)\n                group = []\n\n        return np.array(vertex_groups)\n\n\n\n[docs]\n    def round_corners(\n        self,\n        radius: float | list[float] = 0.5,\n        evenly_distribute_anchors: bool = False,\n        components_per_rounded_corner: int = 2,\n    ) -> Self:\n        \"\"\"Rounds off the corners of the :class:`Polygram`.\n\n        Parameters\n        ----------\n        radius\n            The curvature of the corners of the :class:`Polygram`.\n        evenly_distribute_anchors\n            Break long line segments into proportionally-sized segments.\n        components_per_rounded_corner\n            The number of points used to represent the rounded corner curve.\n\n\n        .. seealso::\n            :class:`.~RoundedRectangle`\n\n        .. note::\n            If `radius` is supplied as a single value, then the same radius\n            will be applied to all corners.  If `radius` is a list, then the\n            individual values will be applied sequentially, with the first\n            corner receiving `radius[0]`, the second corner receiving\n            `radius[1]`, etc.  The radius list will be repeated as necessary.\n\n            The `components_per_rounded_corner` value is provided so that the\n            fidelity of the rounded corner may be fine-tuned as needed.  2 is\n            an appropriate value for most shapes, however a larger value may be\n            need if the rounded corner is particularly large.  2 is the minimum\n            number allowed, representing the start and end of the curve.  3 will\n            result in a start, middle, and end point, meaning 2 curves will be\n            generated.\n\n            The option to `evenly_distribute_anchors` is provided so that the\n            line segments (the part part of each line remaining after rounding\n            off the corners) can be subdivided to a density similar to that of\n            the average density of the rounded corners.  This may be desirable\n            in situations in which an even distribution of curves is desired\n            for use in later transformation animations.  Be aware, though, that\n            enabling this option can result in an an object containing\n            significantly more points than the original, especially when the\n            rounded corner curves are small.\n\n        Examples\n        --------\n        .. manim:: PolygramRoundCorners\n            :save_last_frame:\n\n            class PolygramRoundCorners(Scene):\n                def construct(self):\n                    star = Star(outer_radius=2)\n\n                    shapes = VGroup(star)\n                    shapes.add(star.copy().round_corners(radius=0.1))\n                    shapes.add(star.copy().round_corners(radius=0.25))\n\n                    shapes.arrange(RIGHT)\n                    self.add(shapes)\n        \"\"\"\n        if radius == 0:\n            return self\n\n        new_points: list[Point3D] = []\n\n        for vertices in self.get_vertex_groups():\n            arcs = []\n\n            # Repeat the radius list as necessary in order to provide a radius\n            # for each vertex.\n            if isinstance(radius, (int, float)):\n                radius_list = [radius] * len(vertices)\n            else:\n                radius_list = radius * ceil(len(vertices) / len(radius))\n\n            for currentRadius, (v1, v2, v3) in zip(\n                radius_list, adjacent_n_tuples(vertices, 3)\n            ):\n                vect1 = v2 - v1\n                vect2 = v3 - v2\n                unit_vect1 = normalize(vect1)\n                unit_vect2 = normalize(vect2)\n\n                angle = angle_between_vectors(vect1, vect2)\n                # Negative radius gives concave curves\n                angle *= np.sign(currentRadius)\n\n                # Distance between vertex and start of the arc\n                cut_off_length = currentRadius * np.tan(angle / 2)\n\n                # Determines counterclockwise vs. clockwise\n                sign = np.sign(np.cross(vect1, vect2)[2])\n\n                arc = ArcBetweenPoints(\n                    v2 - unit_vect1 * cut_off_length,\n                    v2 + unit_vect2 * cut_off_length,\n                    angle=sign * angle,\n                    num_components=components_per_rounded_corner,\n                )\n                arcs.append(arc)\n\n            if evenly_distribute_anchors:\n                # Determine the average length of each curve\n                nonZeroLengthArcs = [arc for arc in arcs if len(arc.points) > 4]\n                if len(nonZeroLengthArcs):\n                    totalArcLength = sum(\n                        [arc.get_arc_length() for arc in nonZeroLengthArcs]\n                    )\n                    totalCurveCount = (\n                        sum([len(arc.points) for arc in nonZeroLengthArcs]) / 4\n                    )\n                    averageLengthPerCurve = totalArcLength / totalCurveCount\n                else:\n                    averageLengthPerCurve = 1\n\n            # To ensure that we loop through starting with last\n            arcs = [arcs[-1], *arcs[:-1]]\n            from manim.mobject.geometry.line import Line\n\n            for arc1, arc2 in adjacent_pairs(arcs):\n                new_points.extend(arc1.points)\n\n                line = Line(arc1.get_end(), arc2.get_start())\n\n                # Make sure anchors are evenly distributed, if necessary\n                if evenly_distribute_anchors:\n                    line.insert_n_curves(\n                        ceil(line.get_length() / averageLengthPerCurve)\n                    )\n\n                new_points.extend(line.points)\n\n        self.set_points(np.array(new_points))\n\n        return self\n\n\n\n\n\n[docs]\nclass Polygon(Polygram):\n    \"\"\"A shape consisting of one closed loop of vertices.\n\n    Parameters\n    ----------\n    vertices\n        The vertices of the :class:`Polygon`.\n    kwargs\n        Forwarded to the parent constructor.\n\n    Examples\n    --------\n    .. manim:: PolygonExample\n        :save_last_frame:\n\n        class PolygonExample(Scene):\n            def construct(self):\n                isosceles = Polygon([-5, 1.5, 0], [-2, 1.5, 0], [-3.5, -2, 0])\n                position_list = [\n                    [4, 1, 0],  # middle right\n                    [4, -2.5, 0],  # bottom right\n                    [0, -2.5, 0],  # bottom left\n                    [0, 3, 0],  # top left\n                    [2, 1, 0],  # middle\n                    [4, 3, 0],  # top right\n                ]\n                square_and_triangles = Polygon(*position_list, color=PURPLE_B)\n                self.add(isosceles, square_and_triangles)\n    \"\"\"\n\n    def __init__(self, *vertices: Point3DLike, **kwargs: Any) -> None:\n        super().__init__(vertices, **kwargs)\n\n\n\n\n[docs]\nclass RegularPolygram(Polygram):\n    \"\"\"A :class:`Polygram` with regularly spaced vertices.\n\n    Parameters\n    ----------\n    num_vertices\n        The number of vertices.\n    density\n        The density of the :class:`RegularPolygram`.\n\n        Can be thought of as how many vertices to hop\n        to draw a line between them. Every ``density``-th\n        vertex is connected.\n    radius\n        The radius of the circle that the vertices are placed on.\n    start_angle\n        The angle the vertices start at; the rotation of\n        the :class:`RegularPolygram`.\n    kwargs\n        Forwarded to the parent constructor.\n\n    Examples\n    --------\n    .. manim:: RegularPolygramExample\n        :save_last_frame:\n\n        class RegularPolygramExample(Scene):\n            def construct(self):\n                pentagram = RegularPolygram(5, radius=2)\n                self.add(pentagram)\n    \"\"\"\n\n    def __init__(\n        self,\n        num_vertices: int,\n        *,\n        density: int = 2,\n        radius: float = 1,\n        start_angle: float | None = None,\n        **kwargs: Any,\n    ) -> None:\n        # Regular polygrams can be expressed by the number of their vertices\n        # and their density. This relation can be expressed as its Schläfli\n        # symbol: {num_vertices/density}.\n        #\n        # For instance, a pentagon can be expressed as {5/1} or just {5}.\n        # A pentagram, however, can be expressed as {5/2}.\n        # A hexagram *would* be expressed as {6/2}, except that 6 and 2\n        # are not coprime, and it can be simplified to 2{3}, which corresponds\n        # to the fact that a hexagram is actually made up of 2 triangles.\n        #\n        # See https://en.wikipedia.org/wiki/Polygram_(geometry)#Generalized_regular_polygons\n        # for more information.\n\n        num_gons = np.gcd(num_vertices, density)\n        num_vertices //= num_gons\n        density //= num_gons\n\n        # Utility function for generating the individual\n        # polygon vertices.\n        def gen_polygon_vertices(start_angle: float | None) -> tuple[list[Any], float]:\n            reg_vertices, start_angle = regular_vertices(\n                num_vertices,\n                radius=radius,\n                start_angle=start_angle,\n            )\n\n            vertices = []\n            i = 0\n            while True:\n                vertices.append(reg_vertices[i])\n\n                i += density\n                i %= num_vertices\n                if i == 0:\n                    break\n\n            return vertices, start_angle\n\n        first_group, self.start_angle = gen_polygon_vertices(start_angle)\n        vertex_groups = [first_group]\n\n        for i in range(1, num_gons):\n            start_angle = self.start_angle + (i / num_gons) * TAU / num_vertices\n            group, _ = gen_polygon_vertices(start_angle)\n\n            vertex_groups.append(group)\n\n        super().__init__(*vertex_groups, **kwargs)\n\n\n\n\n[docs]\nclass RegularPolygon(RegularPolygram):\n    \"\"\"An n-sided regular :class:`Polygon`.\n\n    Parameters\n    ----------\n    n\n        The number of sides of the :class:`RegularPolygon`.\n    kwargs\n        Forwarded to the parent constructor.\n\n    Examples\n    --------\n    .. manim:: RegularPolygonExample\n        :save_last_frame:\n\n        class RegularPolygonExample(Scene):\n            def construct(self):\n                poly_1 = RegularPolygon(n=6)\n                poly_2 = RegularPolygon(n=6, start_angle=30*DEGREES, color=GREEN)\n                poly_3 = RegularPolygon(n=10, color=RED)\n\n                poly_group = Group(poly_1, poly_2, poly_3).scale(1.5).arrange(buff=1)\n                self.add(poly_group)\n    \"\"\"\n\n    def __init__(self, n: int = 6, **kwargs: Any) -> None:\n        super().__init__(n, density=1, **kwargs)\n\n\n\n\n[docs]\nclass Star(Polygon):\n    \"\"\"A regular polygram without the intersecting lines.\n\n    Parameters\n    ----------\n    n\n        How many points on the :class:`Star`.\n    outer_radius\n        The radius of the circle that the outer vertices are placed on.\n    inner_radius\n        The radius of the circle that the inner vertices are placed on.\n\n        If unspecified, the inner radius will be\n        calculated such that the edges of the :class:`Star`\n        perfectly follow the edges of its :class:`RegularPolygram`\n        counterpart.\n    density\n        The density of the :class:`Star`. Only used if\n        ``inner_radius`` is unspecified.\n\n        See :class:`RegularPolygram` for more information.\n    start_angle\n        The angle the vertices start at; the rotation of\n        the :class:`Star`.\n    kwargs\n        Forwardeds to the parent constructor.\n\n    Raises\n    ------\n    :exc:`ValueError`\n        If ``inner_radius`` is unspecified and ``density``\n        is not in the range ``[1, n/2)``.\n\n    Examples\n    --------\n    .. manim:: StarExample\n\n        class StarExample(Scene):\n            def construct(self):\n                pentagram = RegularPolygram(5, radius=2)\n                star = Star(outer_radius=2, color=RED)\n\n                self.add(pentagram)\n                self.play(Create(star), run_time=3)\n                self.play(FadeOut(star), run_time=2)\n\n    .. manim:: DifferentDensitiesExample\n        :save_last_frame:\n\n        class DifferentDensitiesExample(Scene):\n            def construct(self):\n                density_2 = Star(7, outer_radius=2, density=2, color=RED)\n                density_3 = Star(7, outer_radius=2, density=3, color=PURPLE)\n\n                self.add(VGroup(density_2, density_3).arrange(RIGHT))\n\n    \"\"\"\n\n    def __init__(\n        self,\n        n: int = 5,\n        *,\n        outer_radius: float = 1,\n        inner_radius: float | None = None,\n        density: int = 2,\n        start_angle: float | None = TAU / 4,\n        **kwargs: Any,\n    ) -> None:\n        inner_angle = TAU / (2 * n)\n\n        if inner_radius is None:\n            # See https://math.stackexchange.com/a/2136292 for an\n            # overview of how to calculate the inner radius of a\n            # perfect star.\n\n            if density <= 0 or density >= n / 2:\n                raise ValueError(\n                    f\"Incompatible density {density} for number of points {n}\",\n                )\n\n            outer_angle = TAU * density / n\n            inverse_x = 1 - np.tan(inner_angle) * (\n                (np.cos(outer_angle) - 1) / np.sin(outer_angle)\n            )\n\n            inner_radius = outer_radius / (np.cos(inner_angle) * inverse_x)\n\n        outer_vertices, self.start_angle = regular_vertices(\n            n,\n            radius=outer_radius,\n            start_angle=start_angle,\n        )\n        inner_vertices, _ = regular_vertices(\n            n,\n            radius=inner_radius,\n            start_angle=self.start_angle + inner_angle,\n        )\n\n        vertices: list[npt.NDArray] = []\n        for pair in zip(outer_vertices, inner_vertices):\n            vertices.extend(pair)\n\n        super().__init__(*vertices, **kwargs)\n\n\n\n\n[docs]\nclass Triangle(RegularPolygon):\n    \"\"\"An equilateral triangle.\n\n    Parameters\n    ----------\n    kwargs\n        Additional arguments to be passed to :class:`RegularPolygon`\n\n    Examples\n    --------\n    .. manim:: TriangleExample\n        :save_last_frame:\n\n        class TriangleExample(Scene):\n            def construct(self):\n                triangle_1 = Triangle()\n                triangle_2 = Triangle().scale(2).rotate(60*DEGREES)\n                tri_group = Group(triangle_1, triangle_2).arrange(buff=1)\n                self.add(tri_group)\n    \"\"\"\n\n    def __init__(self, **kwargs: Any) -> None:\n        super().__init__(n=3, **kwargs)\n\n\n\n\n[docs]\nclass Rectangle(Polygon):\n    \"\"\"A quadrilateral with two sets of parallel sides.\n\n    Parameters\n    ----------\n    color\n        The color of the rectangle.\n    height\n        The vertical height of the rectangle.\n    width\n        The horizontal width of the rectangle.\n    grid_xstep\n        Space between vertical grid lines.\n    grid_ystep\n        Space between horizontal grid lines.\n    mark_paths_closed\n        No purpose.\n    close_new_points\n        No purpose.\n    kwargs\n        Additional arguments to be passed to :class:`Polygon`\n\n    Examples\n    ----------\n    .. manim:: RectangleExample\n        :save_last_frame:\n\n        class RectangleExample(Scene):\n            def construct(self):\n                rect1 = Rectangle(width=4.0, height=2.0, grid_xstep=1.0, grid_ystep=0.5)\n                rect2 = Rectangle(width=1.0, height=4.0)\n                rect3 = Rectangle(width=2.0, height=2.0, grid_xstep=1.0, grid_ystep=1.0)\n                rect3.grid_lines.set_stroke(width=1)\n\n                rects = Group(rect1, rect2, rect3).arrange(buff=1)\n                self.add(rects)\n    \"\"\"\n\n    def __init__(\n        self,\n        color: ParsableManimColor = WHITE,\n        height: float = 2.0,\n        width: float = 4.0,\n        grid_xstep: float | None = None,\n        grid_ystep: float | None = None,\n        mark_paths_closed: bool = True,\n        close_new_points: bool = True,\n        **kwargs: Any,\n    ):\n        super().__init__(UR, UL, DL, DR, color=color, **kwargs)\n        self.stretch_to_fit_width(width)\n        self.stretch_to_fit_height(height)\n\n        v = self.get_vertices()\n        self.grid_lines = VGroup()\n\n        if grid_xstep or grid_ystep:\n            from manim.mobject.geometry.line import Line\n\n            v = self.get_vertices()\n\n        if grid_xstep:\n            grid_xstep = abs(grid_xstep)\n            count = int(width / grid_xstep)\n            grid = VGroup(\n                *(\n                    Line(\n                        v[1] + i * grid_xstep * RIGHT,\n                        v[1] + i * grid_xstep * RIGHT + height * DOWN,\n                        color=color,\n                    )\n                    for i in range(1, count)\n                )\n            )\n            self.grid_lines.add(grid)\n\n        if grid_ystep:\n            grid_ystep = abs(grid_ystep)\n            count = int(height / grid_ystep)\n            grid = VGroup(\n                *(\n                    Line(\n                        v[1] + i * grid_ystep * DOWN,\n                        v[1] + i * grid_ystep * DOWN + width * RIGHT,\n                        color=color,\n                    )\n                    for i in range(1, count)\n                )\n            )\n            self.grid_lines.add(grid)\n\n        if self.grid_lines:\n            self.add(self.grid_lines)\n\n\n\n\n[docs]\nclass Square(Rectangle):\n    \"\"\"A rectangle with equal side lengths.\n\n    Parameters\n    ----------\n    side_length\n        The length of the sides of the square.\n    kwargs\n        Additional arguments to be passed to :class:`Rectangle`.\n\n    Examples\n    --------\n    .. manim:: SquareExample\n        :save_last_frame:\n\n        class SquareExample(Scene):\n            def construct(self):\n                square_1 = Square(side_length=2.0).shift(DOWN)\n                square_2 = Square(side_length=1.0).next_to(square_1, direction=UP)\n                square_3 = Square(side_length=0.5).next_to(square_2, direction=UP)\n                self.add(square_1, square_2, square_3)\n    \"\"\"\n\n    def __init__(self, side_length: float = 2.0, **kwargs: Any) -> None:\n        super().__init__(height=side_length, width=side_length, **kwargs)\n\n    @property\n    def side_length(self) -> float:\n        return float(np.linalg.norm(self.get_vertices()[0] - self.get_vertices()[1]))\n\n    @side_length.setter\n    def side_length(self, value: float) -> None:\n        self.scale(value / self.side_length)\n\n\n\n\n[docs]\nclass RoundedRectangle(Rectangle):\n    \"\"\"A rectangle with rounded corners.\n\n    Parameters\n    ----------\n    corner_radius\n        The curvature of the corners of the rectangle.\n    kwargs\n        Additional arguments to be passed to :class:`Rectangle`\n\n    Examples\n    --------\n    .. manim:: RoundedRectangleExample\n        :save_last_frame:\n\n        class RoundedRectangleExample(Scene):\n            def construct(self):\n                rect_1 = RoundedRectangle(corner_radius=0.5)\n                rect_2 = RoundedRectangle(corner_radius=1.5, height=4.0, width=4.0)\n\n                rect_group = Group(rect_1, rect_2).arrange(buff=1)\n                self.add(rect_group)\n    \"\"\"\n\n    def __init__(self, corner_radius: float | list[float] = 0.5, **kwargs: Any):\n        super().__init__(**kwargs)\n        self.corner_radius = corner_radius\n        self.round_corners(self.corner_radius)\n\n\n\n\n[docs]\nclass Cutout(VMobject, metaclass=ConvertToOpenGL):\n    \"\"\"A shape with smaller cutouts.\n\n    Parameters\n    ----------\n    main_shape\n        The primary shape from which cutouts are made.\n    mobjects\n        The smaller shapes which are to be cut out of the ``main_shape``.\n    kwargs\n        Further keyword arguments that are passed to the constructor of\n        :class:`~.VMobject`.\n\n\n    .. warning::\n        Technically, this class behaves similar to a symmetric difference: if\n        parts of the ``mobjects`` are not located within the ``main_shape``,\n        these parts will be added to the resulting :class:`~.VMobject`.\n\n    Examples\n    --------\n    .. manim:: CutoutExample\n\n        class CutoutExample(Scene):\n            def construct(self):\n                s1 = Square().scale(2.5)\n                s2 = Triangle().shift(DOWN + RIGHT).scale(0.5)\n                s3 = Square().shift(UP + RIGHT).scale(0.5)\n                s4 = RegularPolygon(5).shift(DOWN + LEFT).scale(0.5)\n                s5 = RegularPolygon(6).shift(UP + LEFT).scale(0.5)\n                c = Cutout(s1, s2, s3, s4, s5, fill_opacity=1, color=BLUE, stroke_color=RED)\n                self.play(Write(c), run_time=4)\n                self.wait()\n    \"\"\"\n\n    def __init__(\n        self, main_shape: VMobject, *mobjects: VMobject, **kwargs: Any\n    ) -> None:\n        super().__init__(**kwargs)\n        self.append_points(main_shape.points)\n        sub_direction: Literal[\"CCW\", \"CW\"] = (\n            \"CCW\" if main_shape.get_direction() == \"CW\" else \"CW\"\n        )\n        for mobject in mobjects:\n            self.append_points(mobject.force_direction(sub_direction).points)\n\n\n\n\n[docs]\nclass ConvexHull(Polygram):\n    \"\"\"Constructs a convex hull for a set of points in no particular order.\n\n    Parameters\n    ----------\n    points\n        The points to consider.\n    tolerance\n        The tolerance used by quickhull.\n    kwargs\n        Forwarded to the parent constructor.\n\n    Examples\n    --------\n    .. manim:: ConvexHullExample\n        :save_last_frame:\n        :quality: high\n\n        class ConvexHullExample(Scene):\n            def construct(self):\n                points = [\n                    [-2.35, -2.25, 0],\n                    [1.65, -2.25, 0],\n                    [2.65, -0.25, 0],\n                    [1.65, 1.75, 0],\n                    [-0.35, 2.75, 0],\n                    [-2.35, 0.75, 0],\n                    [-0.35, -1.25, 0],\n                    [0.65, -0.25, 0],\n                    [-1.35, 0.25, 0],\n                    [0.15, 0.75, 0]\n                ]\n                hull = ConvexHull(*points, color=BLUE)\n                dots = VGroup(*[Dot(point) for point in points])\n                self.add(hull)\n                self.add(dots)\n    \"\"\"\n\n    def __init__(\n        self, *points: Point3DLike, tolerance: float = 1e-5, **kwargs: Any\n    ) -> None:\n        # Build Convex Hull\n        array = np.array(points)[:, :2]\n        hull = QuickHull(tolerance)\n        hull.build(array)\n\n        # Extract Vertices\n        facets = set(hull.facets) - hull.removed\n        facet = facets.pop()\n        subfacets = list(facet.subfacets)\n        while len(subfacets) <= len(facets):\n            sf = subfacets[-1]\n            (facet,) = hull.neighbors[sf] - {facet}\n            (sf,) = facet.subfacets - {sf}\n            subfacets.append(sf)\n\n        # Setup Vertices as Point3D\n        coordinates = np.vstack([sf.coordinates for sf in subfacets])\n        vertices = np.hstack((coordinates, np.zeros((len(coordinates), 1))))\n\n        # Call Polygram\n        super().__init__(vertices, **kwargs)", "code_sha1": "710cbf97803c357d0667610c6934179d61b622bd"}
{"url": "https://docs.manim.community/en/stable/_modules/manim/mobject/geometry/shape_matchers.html", "depth": 2, "instruction": "The code defines several mobjects for marking and annotating other mobjects, including `SurroundingRectangle`, `BackgroundRectangle`, `Cross`, and `Underline`. Each class has customizable properties like color, stroke width, and opacity, allowing for visual enhancements in animations, such as surrounding text with rectangles or adding crosses and underlines, with specific arrangements and transformations.", "code": "\"\"\"Mobjects used to mark and annotate other mobjects.\"\"\"\n\nfrom __future__ import annotations\n\n__all__ = [\"SurroundingRectangle\", \"BackgroundRectangle\", \"Cross\", \"Underline\"]\n\nfrom typing import Any\n\nfrom typing_extensions import Self\n\nfrom manim import logger\nfrom manim._config import config\nfrom manim.constants import (\n    DOWN,\n    LEFT,\n    RIGHT,\n    SMALL_BUFF,\n    UP,\n)\nfrom manim.mobject.geometry.line import Line\nfrom manim.mobject.geometry.polygram import RoundedRectangle\nfrom manim.mobject.mobject import Mobject\nfrom manim.mobject.types.vectorized_mobject import VGroup\nfrom manim.utils.color import BLACK, RED, YELLOW, ManimColor, ParsableManimColor\n\n\n\n[docs]\nclass SurroundingRectangle(RoundedRectangle):\n    r\"\"\"A rectangle surrounding a :class:`~.Mobject`\n\n    Examples\n    --------\n    .. manim:: SurroundingRectExample\n        :save_last_frame:\n\n        class SurroundingRectExample(Scene):\n            def construct(self):\n                title = Title(\"A Quote from Newton\")\n                quote = Text(\n                    \"If I have seen further than others, \\n\"\n                    \"it is by standing upon the shoulders of giants.\",\n                    color=BLUE,\n                ).scale(0.75)\n                box = SurroundingRectangle(quote, color=YELLOW, buff=MED_LARGE_BUFF)\n\n                t2 = Tex(r\"Hello World\").scale(1.5)\n                box2 = SurroundingRectangle(t2, corner_radius=0.2)\n                mobjects = VGroup(VGroup(box, quote), VGroup(t2, box2)).arrange(DOWN)\n                self.add(title, mobjects)\n    \"\"\"\n\n    def __init__(\n        self,\n        *mobjects: Mobject,\n        color: ParsableManimColor = YELLOW,\n        buff: float = SMALL_BUFF,\n        corner_radius: float = 0.0,\n        **kwargs: Any,\n    ) -> None:\n        from manim.mobject.mobject import Group\n\n        if not all(isinstance(mob, Mobject) for mob in mobjects):\n            raise TypeError(\n                \"Expected all inputs for parameter mobjects to be a Mobjects\"\n            )\n\n        group = Group(*mobjects)\n        super().__init__(\n            color=color,\n            width=group.width + 2 * buff,\n            height=group.height + 2 * buff,\n            corner_radius=corner_radius,\n            **kwargs,\n        )\n        self.buff = buff\n        self.move_to(group)\n\n\n\n\n[docs]\nclass BackgroundRectangle(SurroundingRectangle):\n    \"\"\"A background rectangle. Its default color is the background color\n    of the scene.\n\n    Examples\n    --------\n    .. manim:: ExampleBackgroundRectangle\n        :save_last_frame:\n\n        class ExampleBackgroundRectangle(Scene):\n            def construct(self):\n                circle = Circle().shift(LEFT)\n                circle.set_stroke(color=GREEN, width=20)\n                triangle = Triangle().shift(2 * RIGHT)\n                triangle.set_fill(PINK, opacity=0.5)\n                backgroundRectangle1 = BackgroundRectangle(circle, color=WHITE, fill_opacity=0.15)\n                backgroundRectangle2 = BackgroundRectangle(triangle, color=WHITE, fill_opacity=0.15)\n                self.add(backgroundRectangle1)\n                self.add(backgroundRectangle2)\n                self.add(circle)\n                self.add(triangle)\n                self.play(Rotate(backgroundRectangle1, PI / 4))\n                self.play(Rotate(backgroundRectangle2, PI / 2))\n    \"\"\"\n\n    def __init__(\n        self,\n        *mobjects: Mobject,\n        color: ParsableManimColor | None = None,\n        stroke_width: float = 0,\n        stroke_opacity: float = 0,\n        fill_opacity: float = 0.75,\n        buff: float = 0,\n        **kwargs: Any,\n    ) -> None:\n        if color is None:\n            color = config.background_color\n\n        super().__init__(\n            *mobjects,\n            color=color,\n            stroke_width=stroke_width,\n            stroke_opacity=stroke_opacity,\n            fill_opacity=fill_opacity,\n            buff=buff,\n            **kwargs,\n        )\n        self.original_fill_opacity: float = self.fill_opacity\n\n\n[docs]\n    def pointwise_become_partial(self, mobject: Mobject, a: Any, b: float) -> Self:\n        self.set_fill(opacity=b * self.original_fill_opacity)\n        return self\n\n\n    def set_style(self, fill_opacity: float, **kwargs: Any) -> Self:  # type: ignore[override]\n        # Unchangeable style, except for fill_opacity\n        # All other style arguments are ignored\n        super().set_style(\n            stroke_color=BLACK,\n            stroke_width=0,\n            fill_color=BLACK,\n            fill_opacity=fill_opacity,\n        )\n        if len(kwargs) > 0:\n            logger.info(\n                \"Argument %s is ignored in BackgroundRectangle.set_style.\",\n                kwargs,\n            )\n        return self\n\n\n[docs]\n    def get_fill_color(self) -> ManimColor:\n        # The type of the color property is set to Any using the property decorator\n        # vectorized_mobject.py#L571\n        temp_color: ManimColor = self.color\n        return temp_color\n\n\n\n\n\n[docs]\nclass Cross(VGroup):\n    \"\"\"Creates a cross.\n\n    Parameters\n    ----------\n    mobject\n        The mobject linked to this instance. It fits the mobject when specified. Defaults to None.\n    stroke_color\n        Specifies the color of the cross lines. Defaults to RED.\n    stroke_width\n        Specifies the width of the cross lines. Defaults to 6.\n    scale_factor\n        Scales the cross to the provided units. Defaults to 1.\n\n    Examples\n    --------\n    .. manim:: ExampleCross\n        :save_last_frame:\n\n        class ExampleCross(Scene):\n            def construct(self):\n                cross = Cross()\n                self.add(cross)\n    \"\"\"\n\n    def __init__(\n        self,\n        mobject: Mobject | None = None,\n        stroke_color: ParsableManimColor = RED,\n        stroke_width: float = 6.0,\n        scale_factor: float = 1.0,\n        **kwargs: Any,\n    ) -> None:\n        super().__init__(\n            Line(UP + LEFT, DOWN + RIGHT), Line(UP + RIGHT, DOWN + LEFT), **kwargs\n        )\n        if mobject is not None:\n            self.replace(mobject, stretch=True)\n        self.scale(scale_factor)\n        self.set_stroke(color=stroke_color, width=stroke_width)\n\n\n\n\n[docs]\nclass Underline(Line):\n    \"\"\"Creates an underline.\n\n    Examples\n    --------\n    .. manim:: UnderLine\n        :save_last_frame:\n\n        class UnderLine(Scene):\n            def construct(self):\n                man = Tex(\"Manim\")  # Full Word\n                ul = Underline(man)  # Underlining the word\n                self.add(man, ul)\n    \"\"\"\n\n    def __init__(\n        self, mobject: Mobject, buff: float = SMALL_BUFF, **kwargs: Any\n    ) -> None:\n        super().__init__(LEFT, RIGHT, buff=buff, **kwargs)\n        self.match_width(mobject)\n        self.next_to(mobject, DOWN, buff=self.buff)", "code_sha1": "5e104742f0ddd5184f5f62b4adc40603b9b9c40a"}
{"url": "https://docs.manim.community/en/stable/_modules/manim/mobject/geometry/tips.html", "depth": 2, "instruction": "The code defines various arrow tip shapes (triangle, square, circle, stealth) for use with arrows in Manim, showcasing different styles and properties such as fill opacity and stroke width. Each tip class inherits from a base class, allowing for customization and specific visual characteristics, but cannot be instantiated directly.", "code": "r\"\"\"A collection of tip mobjects for use with :class:`~.TipableVMobject`.\"\"\"\n\nfrom __future__ import annotations\n\n__all__ = [\n    \"ArrowTip\",\n    \"ArrowCircleFilledTip\",\n    \"ArrowCircleTip\",\n    \"ArrowSquareTip\",\n    \"ArrowSquareFilledTip\",\n    \"ArrowTriangleTip\",\n    \"ArrowTriangleFilledTip\",\n    \"StealthTip\",\n]\n\nfrom typing import TYPE_CHECKING\n\nimport numpy as np\n\nfrom manim.constants import *\nfrom manim.mobject.geometry.arc import Circle\nfrom manim.mobject.geometry.polygram import Square, Triangle\nfrom manim.mobject.opengl.opengl_compatibility import ConvertToOpenGL\nfrom manim.mobject.types.vectorized_mobject import VMobject\nfrom manim.utils.space_ops import angle_of_vector\n\nif TYPE_CHECKING:\n    from typing import Any\n\n    from manim.typing import Point3D, Vector3D\n\n\n\n[docs]\nclass ArrowTip(VMobject, metaclass=ConvertToOpenGL):\n    r\"\"\"Base class for arrow tips.\n\n    .. seealso::\n        :class:`ArrowTriangleTip`\n        :class:`ArrowTriangleFilledTip`\n        :class:`ArrowCircleTip`\n        :class:`ArrowCircleFilledTip`\n        :class:`ArrowSquareTip`\n        :class:`ArrowSquareFilledTip`\n        :class:`StealthTip`\n\n    Examples\n    --------\n    Cannot be used directly, only intended for inheritance::\ntip = ArrowTip()\n        Traceback (most recent call last):\n\n        NotImplementedError: Has to be implemented in inheriting subclasses.\n\n    Instead, use one of the pre-defined ones, or make\n    a custom one like this:\n\n    .. manim:: CustomTipExample\nfrom manim import RegularPolygon, Arrow\nclass MyCustomArrowTip(ArrowTip, RegularPolygon):\n    def __init__(self, length=0.35, **kwargs):\n        RegularPolygon.__init__(self, n=5, **kwargs)\n        self.width = length\n        self.stretch_to_fit_height(length)\narr = Arrow(\n    np.array([-2, -2, 0]), np.array([2, 2, 0]), tip_shape=MyCustomArrowTip\n)\nisinstance(arr.tip, RegularPolygon)\n        True\nfrom manim import Scene, Create\nclass CustomTipExample(Scene):\n    def construct(self):\n        self.play(Create(arr))\n\n    Using a class inherited from :class:`ArrowTip` to get a non-filled\n    tip is a shorthand to manually specifying the arrow tip style as follows::\narrow = Arrow(np.array([0, 0, 0]), np.array([1, 1, 0]),\n              tip_style={'fill_opacity': 0, 'stroke_width': 3})\n\n    The following example illustrates the usage of all of the predefined\n    arrow tips.\n\n    .. manim:: ArrowTipsShowcase\n        :save_last_frame:\n\n        class ArrowTipsShowcase(Scene):\n            def construct(self):\n                tip_names = [\n                    'Default (YELLOW)', 'ArrowTriangleTip', 'Default', 'ArrowSquareTip',\n                    'ArrowSquareFilledTip', 'ArrowCircleTip', 'ArrowCircleFilledTip', 'StealthTip'\n                ]\n\n                big_arrows = [\n                    Arrow(start=[-4, 3.5, 0], end=[2, 3.5, 0], color=YELLOW),\n                    Arrow(start=[-4, 2.5, 0], end=[2, 2.5, 0], tip_shape=ArrowTriangleTip),\n                    Arrow(start=[-4, 1.5, 0], end=[2, 1.5, 0]),\n                    Arrow(start=[-4, 0.5, 0], end=[2, 0.5, 0], tip_shape=ArrowSquareTip),\n\n                    Arrow([-4, -0.5, 0], [2, -0.5, 0], tip_shape=ArrowSquareFilledTip),\n                    Arrow([-4, -1.5, 0], [2, -1.5, 0], tip_shape=ArrowCircleTip),\n                    Arrow([-4, -2.5, 0], [2, -2.5, 0], tip_shape=ArrowCircleFilledTip),\n                    Arrow([-4, -3.5, 0], [2, -3.5, 0], tip_shape=StealthTip)\n                ]\n\n                small_arrows = (\n                    arrow.copy().scale(0.5, scale_tips=True).next_to(arrow, RIGHT) for arrow in big_arrows\n                )\n\n                labels = (\n                    Text(tip_names[i], font='monospace', font_size=20, color=BLUE).next_to(big_arrows[i], LEFT) for i in range(len(big_arrows))\n                )\n\n                self.add(*big_arrows, *small_arrows, *labels)\n    \"\"\"\n\n    def __init__(self, *args: Any, **kwargs: Any) -> None:\n        raise NotImplementedError(\"Has to be implemented in inheriting subclasses.\")\n\n    @property\n    def base(self) -> Point3D:\n        r\"\"\"The base point of the arrow tip.\n\n        This is the point connecting to the arrow line.\n\n        Examples\n        --------\n        ::\nfrom manim import Arrow\narrow = Arrow(np.array([0, 0, 0]), np.array([2, 0, 0]), buff=0)\narrow.tip.base.round(2) + 0.  # add 0. to avoid negative 0 in output\n            array([1.65, 0.  , 0.  ])\n\n        \"\"\"\n        return self.point_from_proportion(0.5)\n\n    @property\n    def tip_point(self) -> Point3D:\n        r\"\"\"The tip point of the arrow tip.\n\n        Examples\n        --------\n        ::\nfrom manim import Arrow\narrow = Arrow(np.array([0, 0, 0]), np.array([2, 0, 0]), buff=0)\narrow.tip.tip_point.round(2) + 0.\n            array([2., 0., 0.])\n\n        \"\"\"\n        # Type inference of extracting an element from a list, is not\n        # supported by numpy, see this numpy issue\n        # https://github.com/numpy/numpy/issues/16544\n        tip_point: Point3D = self.points[0]\n        return tip_point\n\n    @property\n    def vector(self) -> Vector3D:\n        r\"\"\"The vector pointing from the base point to the tip point.\n\n        Examples\n        --------\n        ::\nfrom manim import Arrow\narrow = Arrow(np.array([0, 0, 0]), np.array([2, 2, 0]), buff=0)\narrow.tip.vector.round(2) + 0.\n            array([0.25, 0.25, 0.  ])\n\n        \"\"\"\n        return self.tip_point - self.base\n\n    @property\n    def tip_angle(self) -> float:\n        r\"\"\"The angle of the arrow tip.\n\n        Examples\n        --------\n        ::\nfrom manim import Arrow\narrow = Arrow(np.array([0, 0, 0]), np.array([1, 1, 0]), buff=0)\nbool(round(arrow.tip.tip_angle, 5) == round(PI/4, 5))\n            True\n\n        \"\"\"\n        return angle_of_vector(self.vector)\n\n    @property\n    def length(self) -> float:\n        r\"\"\"The length of the arrow tip.\n\n        Examples\n        --------\n        ::\nfrom manim import Arrow\narrow = Arrow(np.array([0, 0, 0]), np.array([1, 2, 0]))\nround(arrow.tip.length, 3)\n            0.35\n\n        \"\"\"\n        return float(np.linalg.norm(self.vector))\n\n\n\n\n[docs]\nclass StealthTip(ArrowTip):\n    r\"\"\"'Stealth' fighter / kite arrow shape.\n\n    Naming is inspired by the corresponding\n    `TikZ arrow shape <https://tikz.dev/tikz-arrows#sec-16.3>`__.\n    \"\"\"\n\n    def __init__(\n        self,\n        fill_opacity: float = 1,\n        stroke_width: float = 3,\n        length: float = DEFAULT_ARROW_TIP_LENGTH / 2,\n        start_angle: float = PI,\n        **kwargs: Any,\n    ):\n        self.start_angle = start_angle\n        VMobject.__init__(\n            self, fill_opacity=fill_opacity, stroke_width=stroke_width, **kwargs\n        )\n        self.set_points_as_corners(\n            np.array(\n                [\n                    [2, 0, 0],  # tip\n                    [-1.2, 1.6, 0],\n                    [0, 0, 0],  # base\n                    [-1.2, -1.6, 0],\n                    [2, 0, 0],  # close path, back to tip\n                ]\n            )\n        )\n        self.scale(length / self.length)\n\n    @property\n    def length(self) -> float:\n        \"\"\"The length of the arrow tip.\n\n        In this case, the length is computed as the height of\n        the triangle encompassing the stealth tip (otherwise,\n        the tip is scaled too large).\n        \"\"\"\n        return float(np.linalg.norm(self.vector) * 1.6)\n\n\n\n\n[docs]\nclass ArrowTriangleTip(ArrowTip, Triangle):\n    r\"\"\"Triangular arrow tip.\"\"\"\n\n    def __init__(\n        self,\n        fill_opacity: float = 0,\n        stroke_width: float = 3,\n        length: float = DEFAULT_ARROW_TIP_LENGTH,\n        width: float = DEFAULT_ARROW_TIP_LENGTH,\n        start_angle: float = PI,\n        **kwargs: Any,\n    ) -> None:\n        Triangle.__init__(\n            self,\n            fill_opacity=fill_opacity,\n            stroke_width=stroke_width,\n            start_angle=start_angle,\n            **kwargs,\n        )\n        self.width = width\n\n        self.stretch_to_fit_width(length)\n        self.stretch_to_fit_height(width)\n\n\n\n\n[docs]\nclass ArrowTriangleFilledTip(ArrowTriangleTip):\n    r\"\"\"Triangular arrow tip with filled tip.\n\n    This is the default arrow tip shape.\n    \"\"\"\n\n    def __init__(\n        self, fill_opacity: float = 1, stroke_width: float = 0, **kwargs: Any\n    ) -> None:\n        super().__init__(fill_opacity=fill_opacity, stroke_width=stroke_width, **kwargs)\n\n\n\n\n[docs]\nclass ArrowCircleTip(ArrowTip, Circle):\n    r\"\"\"Circular arrow tip.\"\"\"\n\n    def __init__(\n        self,\n        fill_opacity: float = 0,\n        stroke_width: float = 3,\n        length: float = DEFAULT_ARROW_TIP_LENGTH,\n        start_angle: float = PI,\n        **kwargs: Any,\n    ) -> None:\n        self.start_angle = start_angle\n        Circle.__init__(\n            self, fill_opacity=fill_opacity, stroke_width=stroke_width, **kwargs\n        )\n        self.width = length\n        self.stretch_to_fit_height(length)\n\n\n\n\n[docs]\nclass ArrowCircleFilledTip(ArrowCircleTip):\n    r\"\"\"Circular arrow tip with filled tip.\"\"\"\n\n    def __init__(\n        self, fill_opacity: float = 1, stroke_width: float = 0, **kwargs: Any\n    ) -> None:\n        super().__init__(fill_opacity=fill_opacity, stroke_width=stroke_width, **kwargs)\n\n\n\n\n[docs]\nclass ArrowSquareTip(ArrowTip, Square):\n    r\"\"\"Square arrow tip.\"\"\"\n\n    def __init__(\n        self,\n        fill_opacity: float = 0,\n        stroke_width: float = 3,\n        length: float = DEFAULT_ARROW_TIP_LENGTH,\n        start_angle: float = PI,\n        **kwargs: Any,\n    ) -> None:\n        self.start_angle = start_angle\n        Square.__init__(\n            self,\n            fill_opacity=fill_opacity,\n            stroke_width=stroke_width,\n            side_length=length,\n            **kwargs,\n        )\n        self.width = length\n        self.stretch_to_fit_height(length)\n\n\n\n\n[docs]\nclass ArrowSquareFilledTip(ArrowSquareTip):\n    r\"\"\"Square arrow tip with filled tip.\"\"\"\n\n    def __init__(\n        self, fill_opacity: float = 1, stroke_width: float = 0, **kwargs: Any\n    ) -> None:\n        super().__init__(fill_opacity=fill_opacity, stroke_width=stroke_width, **kwargs)", "code_sha1": "73b1a0e0aaff68fb3b082add61ab453423e4bb65"}
{"url": "https://docs.manim.community/en/stable/_modules/manim/mobject/graph.html", "depth": 2, "instruction": "The code defines a `Graph` class in Manim that visually represents undirected graphs with customizable vertices and edges. It supports various layouts (e.g., circular, spring) and allows for animated vertex movements and edge updates, displaying vertices as dots or labeled dots, and edges as lines.", "code": "\"\"\"Mobjects used to represent mathematical graphs (think graph theory, not plotting).\"\"\"\n\nfrom __future__ import annotations\n\n__all__ = [\n    \"Graph\",\n    \"DiGraph\",\n]\n\nimport itertools as it\nfrom collections.abc import Hashable, Iterable, Sequence\nfrom copy import copy\nfrom typing import TYPE_CHECKING, Any, Literal, Protocol, cast\n\nimport networkx as nx\nimport numpy as np\n\nif TYPE_CHECKING:\n    from typing_extensions import TypeAlias\n\n    from manim.scene.scene import Scene\n    from manim.typing import Point3D, Point3DLike\n\n    NxGraph: TypeAlias = nx.classes.graph.Graph | nx.classes.digraph.DiGraph\n\nfrom manim.animation.composition import AnimationGroup\nfrom manim.animation.creation import Create, Uncreate\nfrom manim.mobject.geometry.arc import Dot, LabeledDot\nfrom manim.mobject.geometry.line import Line\nfrom manim.mobject.mobject import Mobject, override_animate\nfrom manim.mobject.opengl.opengl_compatibility import ConvertToOpenGL\nfrom manim.mobject.opengl.opengl_mobject import OpenGLMobject\nfrom manim.mobject.text.tex_mobject import MathTex\nfrom manim.mobject.types.vectorized_mobject import VMobject\nfrom manim.utils.color import BLACK\n\n\n\n[docs]\nclass LayoutFunction(Protocol):\n    \"\"\"A protocol for automatic layout functions that compute a layout for a graph to be used in :meth:`~.Graph.change_layout`.\n\n    .. note:: The layout function must be a pure function, i.e., it must not modify the graph passed to it.\n\n    Examples\n    --------\n\n    Here is an example that arranges nodes in an n x m grid in sorted order.\n\n    .. manim:: CustomLayoutExample\n        :save_last_frame:\n\n        class CustomLayoutExample(Scene):\n            def construct(self):\n                import numpy as np\n                import networkx as nx\n\n                # create custom layout\n                def custom_layout(\n                    graph: nx.Graph,\n                    scale: float | tuple[float, float, float] = 2,\n                    n: int | None = None,\n                    *args: Any,\n                    **kwargs: Any,\n                ):\n                    nodes = sorted(list(graph))\n                    height = len(nodes) // n\n                    return {\n                        node: (scale * np.array([\n                            (i % n) - (n-1)/2,\n                            -(i // n) + height/2,\n                            0\n                        ])) for i, node in enumerate(graph)\n                    }\n\n                # draw graph\n                n = 4\n                graph = Graph(\n                    [i for i in range(4 * 2 - 1)],\n                    [(0, 1), (0, 4), (1, 2), (1, 5), (2, 3), (2, 6), (4, 5), (5, 6)],\n                    labels=True,\n                    layout=custom_layout,\n                    layout_config={'n': n}\n                )\n                self.add(graph)\n\n    Several automatic layouts are provided by manim, and can be used by passing their name as the ``layout`` parameter to :meth:`~.Graph.change_layout`.\n    Alternatively, a custom layout function can be passed to :meth:`~.Graph.change_layout` as the ``layout`` parameter. Such a function must adhere to the :class:`~.LayoutFunction` protocol.\n\n    The :class:`~.LayoutFunction` s provided by manim are illustrated below:\n\n    - Circular Layout: places the vertices on a circle\n\n    .. manim:: CircularLayout\n        :save_last_frame:\n\n        class CircularLayout(Scene):\n            def construct(self):\n                graph = Graph(\n                    [1, 2, 3, 4, 5, 6],\n                    [(1, 2), (2, 3), (3, 4), (4, 5), (5, 6), (6, 1), (5, 1), (1, 3), (3, 5)],\n                    layout=\"circular\",\n                    labels=True\n                )\n                self.add(graph)\n\n    - Kamada Kawai Layout: tries to place the vertices such that the given distances between them are respected\n\n    .. manim:: KamadaKawaiLayout\n        :save_last_frame:\n\n        class KamadaKawaiLayout(Scene):\n            def construct(self):\n                from collections import defaultdict\n                distances: dict[int, dict[int, float]] = defaultdict(dict)\n\n                # set desired distances\n                distances[1][2] = 1  # distance between vertices 1 and 2 is 1\n                distances[2][3] = 1  # distance between vertices 2 and 3 is 1\n                distances[3][4] = 2  # etc\n                distances[4][5] = 3\n                distances[5][6] = 5\n                distances[6][1] = 8\n\n                graph = Graph(\n                    [1, 2, 3, 4, 5, 6],\n                    [(1, 2), (2, 3), (3, 4), (4, 5), (5, 6), (6, 1)],\n                    layout=\"kamada_kawai\",\n                    layout_config={\"dist\": distances},\n                    layout_scale=4,\n                    labels=True\n                )\n                self.add(graph)\n\n    - Partite Layout: places vertices into distinct partitions\n\n    .. manim:: PartiteLayout\n        :save_last_frame:\n\n        class PartiteLayout(Scene):\n            def construct(self):\n                graph = Graph(\n                    [1, 2, 3, 4, 5, 6],\n                    [(1, 2), (2, 3), (3, 4), (4, 5), (5, 6), (6, 1), (5, 1), (1, 3), (3, 5)],\n                    layout=\"partite\",\n                    layout_config={\"partitions\": [[1,2],[3,4],[5,6]]},\n                    labels=True\n                )\n                self.add(graph)\n\n    - Planar Layout: places vertices such that edges do not cross\n\n    .. manim:: PlanarLayout\n        :save_last_frame:\n\n        class PlanarLayout(Scene):\n            def construct(self):\n                graph = Graph(\n                    [1, 2, 3, 4, 5, 6],\n                    [(1, 2), (2, 3), (3, 4), (4, 5), (5, 6), (6, 1), (5, 1), (1, 3), (3, 5)],\n                    layout=\"planar\",\n                    layout_scale=4,\n                    labels=True\n                )\n                self.add(graph)\n\n    - Random Layout: randomly places vertices\n\n    .. manim:: RandomLayout\n        :save_last_frame:\n\n        class RandomLayout(Scene):\n            def construct(self):\n                graph = Graph(\n                    [1, 2, 3, 4, 5, 6],\n                    [(1, 2), (2, 3), (3, 4), (4, 5), (5, 6), (6, 1), (5, 1), (1, 3), (3, 5)],\n                    layout=\"random\",\n                    labels=True\n                )\n                self.add(graph)\n\n    - Shell Layout: places vertices in concentric circles\n\n    .. manim:: ShellLayout\n        :save_last_frame:\n\n        class ShellLayout(Scene):\n            def construct(self):\n                nlist = [[1, 2, 3], [4, 5, 6, 7, 8, 9]]\n                graph = Graph(\n                    [1, 2, 3, 4, 5, 6, 7, 8, 9],\n                    [(1, 2), (2, 3), (3, 1), (4, 1), (4, 2), (5, 2), (6, 2), (6, 3), (7, 3), (8, 3), (8, 1), (9, 1)],\n                    layout=\"shell\",\n                    layout_config={\"nlist\": nlist},\n                    labels=True\n                )\n                self.add(graph)\n\n    - Spectral Layout: places vertices using the eigenvectors of the graph Laplacian (clusters nodes which are an approximation of the ratio cut)\n\n    .. manim:: SpectralLayout\n        :save_last_frame:\n\n        class SpectralLayout(Scene):\n            def construct(self):\n                graph = Graph(\n                    [1, 2, 3, 4, 5, 6],\n                    [(1, 2), (2, 3), (3, 4), (4, 5), (5, 6), (6, 1), (5, 1), (1, 3), (3, 5)],\n                    layout=\"spectral\",\n                    labels=True\n                )\n                self.add(graph)\n\n    - Sprial Layout: places vertices in a spiraling pattern\n\n    .. manim:: SpiralLayout\n        :save_last_frame:\n\n        class SpiralLayout(Scene):\n            def construct(self):\n                graph = Graph(\n                    [1, 2, 3, 4, 5, 6],\n                    [(1, 2), (2, 3), (3, 4), (4, 5), (5, 6), (6, 1), (5, 1), (1, 3), (3, 5)],\n                    layout=\"spiral\",\n                    labels=True\n                )\n                self.add(graph)\n\n    - Spring Layout: places nodes according to the Fruchterman-Reingold force-directed algorithm (attempts to minimize edge length while maximizing node separation)\n\n    .. manim:: SpringLayout\n        :save_last_frame:\n\n        class SpringLayout(Scene):\n            def construct(self):\n                graph = Graph(\n                    [1, 2, 3, 4, 5, 6],\n                    [(1, 2), (2, 3), (3, 4), (4, 5), (5, 6), (6, 1), (5, 1), (1, 3), (3, 5)],\n                    layout=\"spring\",\n                    labels=True\n                )\n                self.add(graph)\n\n    - Tree Layout: places vertices into a tree with a root node and branches (can only be used with legal trees)\n\n    .. manim:: TreeLayout\n        :save_last_frame:\n\n        class TreeLayout(Scene):\n            def construct(self):\n                graph = Graph(\n                    [1, 2, 3, 4, 5, 6, 7],\n                    [(1, 2), (1, 3), (2, 4), (2, 5), (3, 6), (3, 7)],\n                    layout=\"tree\",\n                    layout_config={\"root_vertex\": 1},\n                    labels=True\n                )\n                self.add(graph)\n\n    \"\"\"\n\n    def __call__(\n        self,\n        graph: NxGraph,\n        scale: float | tuple[float, float, float] = 2,\n        *args: Any,\n        **kwargs: Any,\n    ) -> dict[Hashable, Point3D]:\n        \"\"\"Given a graph and a scale, return a dictionary of coordinates.\n\n        Parameters\n        ----------\n        graph\n            The underlying NetworkX graph to be laid out. DO NOT MODIFY.\n        scale\n            Either a single float value, or a tuple of three float values specifying the scale along each axis.\n\n        Returns\n        -------\n        dict[Hashable, Point3D]\n            A dictionary mapping vertices to their positions.\n        \"\"\"\n\n\n\n\ndef _partite_layout(\n    nx_graph: NxGraph,\n    scale: float = 2,\n    partitions: Sequence[Sequence[Hashable]] | None = None,\n    **kwargs: Any,\n) -> dict[Hashable, Point3D]:\n    if partitions is None or len(partitions) == 0:\n        raise ValueError(\n            \"The partite layout requires partitions parameter to contain the partition of the vertices\",\n        )\n    partition_count = len(partitions)\n    for i in range(partition_count):\n        for v in partitions[i]:\n            if nx_graph.nodes[v] is None:\n                raise ValueError(\n                    \"The partition must contain arrays of vertices in the graph\",\n                )\n            nx_graph.nodes[v][\"subset\"] = i\n    # Add missing vertices to their own side\n    for v in nx_graph.nodes:\n        if \"subset\" not in nx_graph.nodes[v]:\n            nx_graph.nodes[v][\"subset\"] = partition_count\n\n    return nx.layout.multipartite_layout(nx_graph, scale=scale, **kwargs)\n\n\ndef _random_layout(nx_graph: NxGraph, scale: float = 2, **kwargs: Any):\n    # the random layout places coordinates in [0, 1)\n    # we need to rescale manually afterwards...\n    auto_layout = nx.layout.random_layout(nx_graph, **kwargs)\n    for k, v in auto_layout.items():\n        auto_layout[k] = 2 * scale * (v - np.array([0.5, 0.5]))\n    return {k: np.append(v, [0]) for k, v in auto_layout.items()}\n\n\ndef _tree_layout(\n    T: NxGraph,\n    root_vertex: Hashable | None = None,\n    scale: float | tuple | None = 2,\n    vertex_spacing: tuple | None = None,\n    orientation: str = \"down\",\n):\n    if root_vertex is None:\n        raise ValueError(\"The tree layout requires the root_vertex parameter\")\n    if not nx.is_tree(T):\n        raise ValueError(\"The tree layout must be used with trees\")\n\n    children = {root_vertex: list(T.neighbors(root_vertex))}\n    # The following code is SageMath's tree layout implementation, taken from\n    # https://github.com/sagemath/sage/blob/cc60cfebc4576fed8b01f0fc487271bdee3cefed/src/sage/graphs/graph_plot.py#L1447\n\n    # Always make a copy of the children because they get eaten\n    stack = [list(children[root_vertex]).copy()]\n    stick = [root_vertex]\n    parent = {u: root_vertex for u in children[root_vertex]}\n    pos = {}\n    obstruction = [0.0] * len(T)\n    o = -1 if orientation == \"down\" else 1\n\n    def slide(v, dx):\n        \"\"\"\n        Shift the vertex v and its descendants to the right by dx.\n        Precondition: v and its descendents have already had their\n        positions computed.\n        \"\"\"\n        level = [v]\n        while level:\n            nextlevel = []\n            for u in level:\n                x, y = pos[u]\n                x += dx\n                obstruction[y] = max(x + 1, obstruction[y])\n                pos[u] = x, y\n                nextlevel += children[u]\n            level = nextlevel\n\n    while stack:\n        C = stack[-1]\n        if not C:\n            p = stick.pop()\n            stack.pop()\n            cp = children[p]\n            y = o * len(stack)\n            if not cp:\n                x = obstruction[y]\n                pos[p] = x, y\n            else:\n                x = sum(pos[c][0] for c in cp) / float(len(cp))\n                pos[p] = x, y\n                ox = obstruction[y]\n                if x < ox:\n                    slide(p, ox - x)\n                    x = ox\n            obstruction[y] = x + 1\n            continue\n\n        t = C.pop()\n        pt = parent[t]\n\n        ct = [u for u in list(T.neighbors(t)) if u != pt]\n        for c in ct:\n            parent[c] = t\n        children[t] = copy(ct)\n\n        stack.append(ct)\n        stick.append(t)\n\n    # the resulting layout is then rescaled again to fit on Manim's canvas\n\n    x_min = min(pos.values(), key=lambda t: t[0])[0]\n    x_max = max(pos.values(), key=lambda t: t[0])[0]\n    y_min = min(pos.values(), key=lambda t: t[1])[1]\n    y_max = max(pos.values(), key=lambda t: t[1])[1]\n    center = np.array([x_min + x_max, y_min + y_max, 0]) / 2\n    height = y_max - y_min\n    width = x_max - x_min\n    if vertex_spacing is None:\n        if isinstance(scale, (float, int)) and (width > 0 or height > 0):\n            sf = 2 * scale / max(width, height)\n        elif isinstance(scale, tuple):\n            sw = 2 * scale[0] / width if scale[0] is not None and width > 0 else 1\n\n            sh = 2 * scale[1] / height if scale[1] is not None and height > 0 else 1\n\n            sf = np.array([sw, sh, 0])\n        else:\n            sf = 1\n    else:\n        sx, sy = vertex_spacing\n        sf = np.array([sx, sy, 0])\n    return {v: (np.array([x, y, 0]) - center) * sf for v, (x, y) in pos.items()}\n\n\nLayoutName = Literal[\n    \"circular\",\n    \"kamada_kawai\",\n    \"partite\",\n    \"planar\",\n    \"random\",\n    \"shell\",\n    \"spectral\",\n    \"spiral\",\n    \"spring\",\n    \"tree\",\n]\n\n_layouts: dict[LayoutName, LayoutFunction] = {\n    \"circular\": cast(LayoutFunction, nx.layout.circular_layout),\n    \"kamada_kawai\": cast(LayoutFunction, nx.layout.kamada_kawai_layout),\n    \"partite\": cast(LayoutFunction, _partite_layout),\n    \"planar\": cast(LayoutFunction, nx.layout.planar_layout),\n    \"random\": cast(LayoutFunction, _random_layout),\n    \"shell\": cast(LayoutFunction, nx.layout.shell_layout),\n    \"spectral\": cast(LayoutFunction, nx.layout.spectral_layout),\n    \"spiral\": cast(LayoutFunction, nx.layout.spiral_layout),\n    \"spring\": cast(LayoutFunction, nx.layout.spring_layout),\n    \"tree\": cast(LayoutFunction, _tree_layout),\n}\n\n\ndef _determine_graph_layout(\n    nx_graph: nx.classes.graph.Graph | nx.classes.digraph.DiGraph,\n    layout: LayoutName | dict[Hashable, Point3DLike] | LayoutFunction = \"spring\",\n    layout_scale: float | tuple[float, float, float] = 2,\n    layout_config: dict[str, Any] | None = None,\n) -> dict[Hashable, Point3DLike]:\n    if layout_config is None:\n        layout_config = {}\n\n    if isinstance(layout, dict):\n        return layout\n    elif layout in _layouts:\n        auto_layout = _layouts[layout](nx_graph, scale=layout_scale, **layout_config)\n        # NetworkX returns a dictionary of 3D points if the dimension\n        # is specified to be 3. Otherwise, it returns a dictionary of\n        # 2D points, so adjusting is required.\n        if (\n            layout_config.get(\"dim\") == 3\n            or auto_layout[next(auto_layout.__iter__())].shape[0] == 3\n        ):\n            return auto_layout\n        else:\n            return {k: np.append(v, [0]) for k, v in auto_layout.items()}\n    else:\n        try:\n            return cast(LayoutFunction, layout)(\n                nx_graph, scale=layout_scale, **layout_config\n            )\n        except TypeError as e:\n            raise ValueError(\n                f\"The layout '{layout}' is neither a recognized layout, a layout function,\"\n                \"nor a vertex placement dictionary.\",\n            ) from e\n\n\n\n[docs]\nclass GenericGraph(VMobject, metaclass=ConvertToOpenGL):\n    \"\"\"Abstract base class for graphs (that is, a collection of vertices\n    connected with edges).\n\n    Graphs can be instantiated by passing both a list of (distinct, hashable)\n    vertex names, together with list of edges (as tuples of vertex names). See\n    the examples for concrete implementations of this class for details.\n\n    .. note::\n\n        This implementation uses updaters to make the edges move with\n        the vertices.\n\n\n    See also\n    --------\n\n    :class:`.Graph`\n    :class:`.DiGraph`\n\n\n    Parameters\n    ----------\n\n    vertices\n        A list of vertices. Must be hashable elements.\n    edges\n        A list of edges, specified as tuples ``(u, v)`` where both ``u``\n        and ``v`` are vertices.\n    labels\n        Controls whether or not vertices are labeled. If ``False`` (the default),\n        the vertices are not labeled; if ``True`` they are labeled using their\n        names (as specified in ``vertices``) via :class:`~.MathTex`. Alternatively,\n        custom labels can be specified by passing a dictionary whose keys are\n        the vertices, and whose values are the corresponding vertex labels\n        (rendered via, e.g., :class:`~.Text` or :class:`~.Tex`).\n    label_fill_color\n        Sets the fill color of the default labels generated when ``labels``\n        is set to ``True``. Has no effect for other values of ``labels``.\n    layout\n        Either one of ``\"spring\"`` (the default), ``\"circular\"``, ``\"kamada_kawai\"``,\n        ``\"planar\"``, ``\"random\"``, ``\"shell\"``, ``\"spectral\"``, ``\"spiral\"``, ``\"tree\"``, and ``\"partite\"``\n        for automatic vertex positioning primarily using ``networkx``\n        (see `their documentation <https://networkx.org/documentation/stable/reference/drawing.html#module-networkx.drawing.layout>`_\n        for more details), a dictionary specifying a coordinate (value)\n        for each vertex (key) for manual positioning, or a .:class:`~.LayoutFunction` with a user-defined automatic layout.\n    layout_config\n        Only for automatic layouts. A dictionary whose entries\n        are passed as keyword arguments to the named layout or automatic layout function\n        specified via ``layout``.\n        The ``tree`` layout also accepts a special parameter ``vertex_spacing``\n        passed as a keyword argument inside the ``layout_config`` dictionary.\n        Passing a tuple ``(space_x, space_y)`` as this argument overrides\n        the value of ``layout_scale`` and ensures that vertices are arranged\n        in a way such that the centers of siblings in the same layer are\n        at least ``space_x`` units apart horizontally, and neighboring layers\n        are spaced ``space_y`` units vertically.\n    layout_scale\n        The scale of automatically generated layouts: the vertices will\n        be arranged such that the coordinates are located within the\n        interval ``[-scale, scale]``. Some layouts accept a tuple ``(scale_x, scale_y)``\n        causing the first coordinate to be in the interval ``[-scale_x, scale_x]``,\n        and the second in ``[-scale_y, scale_y]``. Default: 2.\n    vertex_type\n        The mobject class used for displaying vertices in the scene.\n    vertex_config\n        Either a dictionary containing keyword arguments to be passed to\n        the class specified via ``vertex_type``, or a dictionary whose keys\n        are the vertices, and whose values are dictionaries containing keyword\n        arguments for the mobject related to the corresponding vertex.\n    vertex_mobjects\n        A dictionary whose keys are the vertices, and whose values are\n        mobjects to be used as vertices. Passing vertices here overrides\n        all other configuration options for a vertex.\n    edge_type\n        The mobject class used for displaying edges in the scene.\n        Must be a subclass of :class:`~.Line` for default updaters to work.\n    edge_config\n        Either a dictionary containing keyword arguments to be passed\n        to the class specified via ``edge_type``, or a dictionary whose\n        keys are the edges, and whose values are dictionaries containing\n        keyword arguments for the mobject related to the corresponding edge.\n    \"\"\"\n\n    def __init__(\n        self,\n        vertices: Sequence[Hashable],\n        edges: Sequence[tuple[Hashable, Hashable]],\n        labels: bool | dict = False,\n        label_fill_color: str = BLACK,\n        layout: LayoutName | dict[Hashable, Point3DLike] | LayoutFunction = \"spring\",\n        layout_scale: float | tuple[float, float, float] = 2,\n        layout_config: dict | None = None,\n        vertex_type: type[Mobject] = Dot,\n        vertex_config: dict | None = None,\n        vertex_mobjects: dict | None = None,\n        edge_type: type[Mobject] = Line,\n        partitions: Sequence[Sequence[Hashable]] | None = None,\n        root_vertex: Hashable | None = None,\n        edge_config: dict | None = None,\n    ) -> None:\n        super().__init__()\n\n        nx_graph = self._empty_networkx_graph()\n        nx_graph.add_nodes_from(vertices)\n        nx_graph.add_edges_from(edges)\n        self._graph = nx_graph\n\n        if isinstance(labels, dict):\n            self._labels = labels\n        elif isinstance(labels, bool):\n            if labels:\n                self._labels = {\n                    v: MathTex(v, fill_color=label_fill_color) for v in vertices\n                }\n            else:\n                self._labels = {}\n\n        if self._labels and vertex_type is Dot:\n            vertex_type = LabeledDot\n\n        if vertex_mobjects is None:\n            vertex_mobjects = {}\n\n        # build vertex_config\n        if vertex_config is None:\n            vertex_config = {}\n        default_vertex_config = {}\n        if vertex_config:\n            default_vertex_config = {\n                k: v for k, v in vertex_config.items() if k not in vertices\n            }\n        self._vertex_config = {\n            v: vertex_config.get(v, copy(default_vertex_config)) for v in vertices\n        }\n        self.default_vertex_config = default_vertex_config\n        for v, label in self._labels.items():\n            self._vertex_config[v][\"label\"] = label\n\n        self.vertices = {v: vertex_type(**self._vertex_config[v]) for v in vertices}\n        self.vertices.update(vertex_mobjects)\n\n        self.change_layout(\n            layout=layout,\n            layout_scale=layout_scale,\n            layout_config=layout_config,\n            partitions=partitions,\n            root_vertex=root_vertex,\n        )\n\n        # build edge_config\n        if edge_config is None:\n            edge_config = {}\n        default_tip_config = {}\n        default_edge_config = {}\n        if edge_config:\n            default_tip_config = edge_config.pop(\"tip_config\", {})\n            default_edge_config = {\n                k: v\n                for k, v in edge_config.items()\n                if not isinstance(\n                    k, tuple\n                )  # everything that is not an edge is an option\n            }\n        self._edge_config = {}\n        self._tip_config = {}\n        for e in edges:\n            if e in edge_config:\n                self._tip_config[e] = edge_config[e].pop(\n                    \"tip_config\", copy(default_tip_config)\n                )\n                self._edge_config[e] = edge_config[e]\n            else:\n                self._tip_config[e] = copy(default_tip_config)\n                self._edge_config[e] = copy(default_edge_config)\n\n        self.default_edge_config = default_edge_config\n        self._populate_edge_dict(edges, edge_type)\n\n        self.add(*self.vertices.values())\n        self.add(*self.edges.values())\n\n        self.add_updater(self.update_edges)\n\n\n[docs]\n    @staticmethod\n    def _empty_networkx_graph() -> nx.classes.graph.Graph:\n        \"\"\"Return an empty networkx graph for the given graph type.\"\"\"\n        raise NotImplementedError(\"To be implemented in concrete subclasses\")\n\n\n\n[docs]\n    def _populate_edge_dict(\n        self, edges: list[tuple[Hashable, Hashable]], edge_type: type[Mobject]\n    ):\n        \"\"\"Helper method for populating the edges of the graph.\"\"\"\n        raise NotImplementedError(\"To be implemented in concrete subclasses\")\n\n\n    def __getitem__(self: Graph, v: Hashable) -> Mobject:\n        return self.vertices[v]\n\n    def _create_vertex(\n        self,\n        vertex: Hashable,\n        position: Point3DLike | None = None,\n        label: bool = False,\n        label_fill_color: str = BLACK,\n        vertex_type: type[Mobject] = Dot,\n        vertex_config: dict | None = None,\n        vertex_mobject: dict | None = None,\n    ) -> tuple[Hashable, Point3D, dict, Mobject]:\n        np_position: Point3D = (\n            self.get_center() if position is None else np.asarray(position)\n        )\n\n        if vertex_config is None:\n            vertex_config = {}\n\n        if vertex in self.vertices:\n            raise ValueError(\n                f\"Vertex identifier '{vertex}' is already used for a vertex in this graph.\",\n            )\n\n        if label is True:\n            label = MathTex(vertex, fill_color=label_fill_color)\n        elif vertex in self._labels:\n            label = self._labels[vertex]\n        elif not isinstance(label, (Mobject, OpenGLMobject)):\n            label = None\n\n        base_vertex_config = copy(self.default_vertex_config)\n        base_vertex_config.update(vertex_config)\n        vertex_config = base_vertex_config\n\n        if label is not None:\n            vertex_config[\"label\"] = label\n            if vertex_type is Dot:\n                vertex_type = LabeledDot\n\n        if vertex_mobject is None:\n            vertex_mobject = vertex_type(**vertex_config)\n\n        vertex_mobject.move_to(np_position)\n\n        return (vertex, np_position, vertex_config, vertex_mobject)\n\n    def _add_created_vertex(\n        self,\n        vertex: Hashable,\n        position: Point3DLike,\n        vertex_config: dict,\n        vertex_mobject: Mobject,\n    ) -> Mobject:\n        if vertex in self.vertices:\n            raise ValueError(\n                f\"Vertex identifier '{vertex}' is already used for a vertex in this graph.\",\n            )\n\n        self._graph.add_node(vertex)\n        self._layout[vertex] = position\n\n        if \"label\" in vertex_config:\n            self._labels[vertex] = vertex_config[\"label\"]\n\n        self._vertex_config[vertex] = vertex_config\n\n        self.vertices[vertex] = vertex_mobject\n        self.vertices[vertex].move_to(position)\n        self.add(self.vertices[vertex])\n\n        return self.vertices[vertex]\n\n\n[docs]\n    def _add_vertex(\n        self,\n        vertex: Hashable,\n        position: Point3DLike | None = None,\n        label: bool = False,\n        label_fill_color: str = BLACK,\n        vertex_type: type[Mobject] = Dot,\n        vertex_config: dict | None = None,\n        vertex_mobject: dict | None = None,\n    ) -> Mobject:\n        \"\"\"Add a vertex to the graph.\n\n        Parameters\n        ----------\n\n        vertex\n            A hashable vertex identifier.\n        position\n            The coordinates where the new vertex should be added. If ``None``, the center\n            of the graph is used.\n        label\n            Controls whether or not the vertex is labeled. If ``False`` (the default),\n            the vertex is not labeled; if ``True`` it is labeled using its\n            names (as specified in ``vertex``) via :class:`~.MathTex`. Alternatively,\n            any :class:`~.Mobject` can be passed to be used as the label.\n        label_fill_color\n            Sets the fill color of the default labels generated when ``labels``\n            is set to ``True``. Has no effect for other values of ``label``.\n        vertex_type\n            The mobject class used for displaying vertices in the scene.\n        vertex_config\n            A dictionary containing keyword arguments to be passed to\n            the class specified via ``vertex_type``.\n        vertex_mobject\n            The mobject to be used as the vertex. Overrides all other\n            vertex customization options.\n        \"\"\"\n        return self._add_created_vertex(\n            *self._create_vertex(\n                vertex=vertex,\n                position=position,\n                label=label,\n                label_fill_color=label_fill_color,\n                vertex_type=vertex_type,\n                vertex_config=vertex_config,\n                vertex_mobject=vertex_mobject,\n            )\n        )\n\n\n    def _create_vertices(\n        self: Graph,\n        *vertices: Hashable,\n        positions: dict | None = None,\n        labels: bool = False,\n        label_fill_color: str = BLACK,\n        vertex_type: type[Mobject] = Dot,\n        vertex_config: dict | None = None,\n        vertex_mobjects: dict | None = None,\n    ) -> Iterable[tuple[Hashable, Point3D, dict, Mobject]]:\n        if positions is None:\n            positions = {}\n        if vertex_mobjects is None:\n            vertex_mobjects = {}\n\n        graph_center = self.get_center()\n        base_positions = {v: graph_center for v in vertices}\n        base_positions.update(positions)\n        positions = base_positions\n\n        if isinstance(labels, bool):\n            labels = {v: labels for v in vertices}\n        else:\n            assert isinstance(labels, dict)\n            base_labels = dict.fromkeys(vertices, False)\n            base_labels.update(labels)\n            labels = base_labels\n\n        if vertex_config is None:\n            vertex_config = copy(self.default_vertex_config)\n\n        assert isinstance(vertex_config, dict)\n        base_vertex_config = copy(self.default_vertex_config)\n        base_vertex_config.update(\n            {key: val for key, val in vertex_config.items() if key not in vertices},\n        )\n        vertex_config = {\n            v: (vertex_config[v] if v in vertex_config else copy(base_vertex_config))\n            for v in vertices\n        }\n\n        return [\n            self._create_vertex(\n                v,\n                position=positions[v],\n                label=labels[v],\n                label_fill_color=label_fill_color,\n                vertex_type=vertex_type,\n                vertex_config=vertex_config[v],\n                vertex_mobject=vertex_mobjects.get(v),\n            )\n            for v in vertices\n        ]\n\n\n[docs]\n    def add_vertices(\n        self: Graph,\n        *vertices: Hashable,\n        positions: dict | None = None,\n        labels: bool = False,\n        label_fill_color: str = BLACK,\n        vertex_type: type[Mobject] = Dot,\n        vertex_config: dict | None = None,\n        vertex_mobjects: dict | None = None,\n    ):\n        \"\"\"Add a list of vertices to the graph.\n\n        Parameters\n        ----------\n\n        vertices\n            Hashable vertex identifiers.\n        positions\n            A dictionary specifying the coordinates where the new vertices should be added.\n            If ``None``, all vertices are created at the center of the graph.\n        labels\n            Controls whether or not the vertex is labeled. If ``False`` (the default),\n            the vertex is not labeled; if ``True`` it is labeled using its\n            names (as specified in ``vertex``) via :class:`~.MathTex`. Alternatively,\n            any :class:`~.Mobject` can be passed to be used as the label.\n        label_fill_color\n            Sets the fill color of the default labels generated when ``labels``\n            is set to ``True``. Has no effect for other values of ``labels``.\n        vertex_type\n            The mobject class used for displaying vertices in the scene.\n        vertex_config\n            A dictionary containing keyword arguments to be passed to\n            the class specified via ``vertex_type``.\n        vertex_mobjects\n            A dictionary whose keys are the vertex identifiers, and whose\n            values are mobjects that should be used as vertices. Overrides\n            all other vertex customization options.\n        \"\"\"\n        return [\n            self._add_created_vertex(*v)\n            for v in self._create_vertices(\n                *vertices,\n                positions=positions,\n                labels=labels,\n                label_fill_color=label_fill_color,\n                vertex_type=vertex_type,\n                vertex_config=vertex_config,\n                vertex_mobjects=vertex_mobjects,\n            )\n        ]\n\n\n    @override_animate(add_vertices)\n    def _add_vertices_animation(self, *args, anim_args=None, **kwargs):\n        if anim_args is None:\n            anim_args = {}\n\n        animation = anim_args.pop(\"animation\", Create)\n\n        vertex_mobjects = self._create_vertices(*args, **kwargs)\n\n        def on_finish(scene: Scene):\n            for v in vertex_mobjects:\n                scene.remove(v[-1])\n                self._add_created_vertex(*v)\n\n        return AnimationGroup(\n            *(animation(v[-1], **anim_args) for v in vertex_mobjects),\n            group=self,\n            _on_finish=on_finish,\n        )\n\n\n[docs]\n    def _remove_vertex(self, vertex):\n        \"\"\"Remove a vertex (as well as all incident edges) from the graph.\n\n        Parameters\n        ----------\n\n        vertex\n            The identifier of a vertex to be removed.\n\n        Returns\n        -------\n\n        Group\n            A mobject containing all removed objects.\n\n        \"\"\"\n        if vertex not in self.vertices:\n            raise ValueError(\n                f\"The graph does not contain a vertex with identifier '{vertex}'\",\n            )\n\n        self._graph.remove_node(vertex)\n        self._layout.pop(vertex)\n        if vertex in self._labels:\n            self._labels.pop(vertex)\n        self._vertex_config.pop(vertex)\n\n        edge_tuples = [e for e in self.edges if vertex in e]\n        for e in edge_tuples:\n            self._edge_config.pop(e)\n        to_remove = [self.edges.pop(e) for e in edge_tuples]\n        to_remove.append(self.vertices.pop(vertex))\n\n        self.remove(*to_remove)\n        return self.get_group_class()(*to_remove)\n\n\n\n[docs]\n    def remove_vertices(self, *vertices):\n        \"\"\"Remove several vertices from the graph.\n\n        Parameters\n        ----------\n\n        vertices\n            Vertices to be removed from the graph.\n\n        Examples\n        --------\n        ::\nG = Graph([1, 2, 3], [(1, 2), (2, 3)])\nremoved = G.remove_vertices(2, 3); removed\n            VGroup(Line, Line, Dot, Dot)\nG\n            Undirected graph on 1 vertices and 0 edges\n\n        \"\"\"\n        mobjects = []\n        for v in vertices:\n            mobjects.extend(self._remove_vertex(v).submobjects)\n        return self.get_group_class()(*mobjects)\n\n\n    @override_animate(remove_vertices)\n    def _remove_vertices_animation(self, *vertices, anim_args=None):\n        if anim_args is None:\n            anim_args = {}\n\n        animation = anim_args.pop(\"animation\", Uncreate)\n\n        mobjects = self.remove_vertices(*vertices)\n        return AnimationGroup(\n            *(animation(mobj, **anim_args) for mobj in mobjects), group=self\n        )\n\n\n[docs]\n    def _add_edge(\n        self,\n        edge: tuple[Hashable, Hashable],\n        edge_type: type[Mobject] = Line,\n        edge_config: dict | None = None,\n    ):\n        \"\"\"Add a new edge to the graph.\n\n        Parameters\n        ----------\n\n        edge\n            The edge (as a tuple of vertex identifiers) to be added. If a non-existing\n            vertex is passed, a new vertex with default settings will be created. Create\n            new vertices yourself beforehand to customize them.\n        edge_type\n            The mobject class used for displaying edges in the scene.\n        edge_config\n            A dictionary containing keyword arguments to be passed\n            to the class specified via ``edge_type``.\n\n        Returns\n        -------\n        Group\n            A group containing all newly added vertices and edges.\n\n        \"\"\"\n        if edge_config is None:\n            edge_config = self.default_edge_config.copy()\n        added_mobjects = []\n        for v in edge:\n            if v not in self.vertices:\n                added_mobjects.append(self._add_vertex(v))\n        u, v = edge\n\n        self._graph.add_edge(u, v)\n\n        base_edge_config = self.default_edge_config.copy()\n        base_edge_config.update(edge_config)\n        edge_config = base_edge_config\n        self._edge_config[(u, v)] = edge_config\n\n        edge_mobject = edge_type(\n            self[u].get_center(), self[v].get_center(), z_index=-1, **edge_config\n        )\n        self.edges[(u, v)] = edge_mobject\n\n        self.add(edge_mobject)\n        added_mobjects.append(edge_mobject)\n        return self.get_group_class()(*added_mobjects)\n\n\n\n[docs]\n    def add_edges(\n        self,\n        *edges: tuple[Hashable, Hashable],\n        edge_type: type[Mobject] = Line,\n        edge_config: dict | None = None,\n        **kwargs,\n    ):\n        \"\"\"Add new edges to the graph.\n\n        Parameters\n        ----------\n\n        edges\n            Edges (as tuples of vertex identifiers) to be added. If a non-existing\n            vertex is passed, a new vertex with default settings will be created. Create\n            new vertices yourself beforehand to customize them.\n        edge_type\n            The mobject class used for displaying edges in the scene.\n        edge_config\n            A dictionary either containing keyword arguments to be passed\n            to the class specified via ``edge_type``, or a dictionary\n            whose keys are the edge tuples, and whose values are dictionaries\n            containing keyword arguments to be passed for the construction\n            of the corresponding edge.\n        kwargs\n            Any further keyword arguments are passed to :meth:`.add_vertices`\n            which is used to create new vertices in the passed edges.\n\n        Returns\n        -------\n        Group\n            A group containing all newly added vertices and edges.\n\n        \"\"\"\n        if edge_config is None:\n            edge_config = {}\n        non_edge_settings = {k: v for (k, v) in edge_config.items() if k not in edges}\n        base_edge_config = self.default_edge_config.copy()\n        base_edge_config.update(non_edge_settings)\n        base_edge_config = {e: base_edge_config.copy() for e in edges}\n        for e in edges:\n            base_edge_config[e].update(edge_config.get(e, {}))\n        edge_config = base_edge_config\n\n        edge_vertices = set(it.chain(*edges))\n        new_vertices = [v for v in edge_vertices if v not in self.vertices]\n        added_vertices = self.add_vertices(*new_vertices, **kwargs)\n\n        added_mobjects = sum(\n            (\n                self._add_edge(\n                    edge,\n                    edge_type=edge_type,\n                    edge_config=edge_config[edge],\n                ).submobjects\n                for edge in edges\n            ),\n            added_vertices,\n        )\n        return self.get_group_class()(*added_mobjects)\n\n\n    @override_animate(add_edges)\n    def _add_edges_animation(self, *args, anim_args=None, **kwargs):\n        if anim_args is None:\n            anim_args = {}\n        animation = anim_args.pop(\"animation\", Create)\n\n        mobjects = self.add_edges(*args, **kwargs)\n        return AnimationGroup(\n            *(animation(mobj, **anim_args) for mobj in mobjects), group=self\n        )\n\n\n[docs]\n    def _remove_edge(self, edge: tuple[Hashable]):\n        \"\"\"Remove an edge from the graph.\n\n        Parameters\n        ----------\n\n        edge\n            The edge (i.e., a tuple of vertex identifiers) to be removed from the graph.\n\n        Returns\n        -------\n\n        Mobject\n            The removed edge.\n\n        \"\"\"\n        if edge not in self.edges:\n            raise ValueError(f\"The graph does not contain a edge '{edge}'\")\n\n        edge_mobject = self.edges.pop(edge)\n\n        self._graph.remove_edge(*edge)\n        self._edge_config.pop(edge, None)\n\n        self.remove(edge_mobject)\n        return edge_mobject\n\n\n\n[docs]\n    def remove_edges(self, *edges: tuple[Hashable]):\n        \"\"\"Remove several edges from the graph.\n\n        Parameters\n        ----------\n        edges\n            Edges to be removed from the graph.\n\n        Returns\n        -------\n        Group\n            A group containing all removed edges.\n\n        \"\"\"\n        edge_mobjects = [self._remove_edge(edge) for edge in edges]\n        return self.get_group_class()(*edge_mobjects)\n\n\n    @override_animate(remove_edges)\n    def _remove_edges_animation(self, *edges, anim_args=None):\n        if anim_args is None:\n            anim_args = {}\n\n        animation = anim_args.pop(\"animation\", Uncreate)\n\n        mobjects = self.remove_edges(*edges)\n        return AnimationGroup(*(animation(mobj, **anim_args) for mobj in mobjects))\n\n\n[docs]\n    @classmethod\n    def from_networkx(\n        cls, nxgraph: nx.classes.graph.Graph | nx.classes.digraph.DiGraph, **kwargs\n    ):\n        \"\"\"Build a :class:`~.Graph` or :class:`~.DiGraph` from a\n        given ``networkx`` graph.\n\n        Parameters\n        ----------\n\n        nxgraph\n            A ``networkx`` graph or digraph.\n        **kwargs\n            Keywords to be passed to the constructor of :class:`~.Graph`.\n\n        Examples\n        --------\n\n        .. manim:: ImportNetworkxGraph\n\n            import networkx as nx\n\n            nxgraph = nx.erdos_renyi_graph(14, 0.5)\n\n            class ImportNetworkxGraph(Scene):\n                def construct(self):\n                    G = Graph.from_networkx(nxgraph, layout=\"spring\", layout_scale=3.5)\n                    self.play(Create(G))\n                    self.play(*[G[v].animate.move_to(5*RIGHT*np.cos(ind/7 * PI) +\n                                                     3*UP*np.sin(ind/7 * PI))\n                                for ind, v in enumerate(G.vertices)])\n                    self.play(Uncreate(G))\n\n        \"\"\"\n        return cls(list(nxgraph.nodes), list(nxgraph.edges), **kwargs)\n\n\n\n[docs]\n    def change_layout(\n        self,\n        layout: LayoutName | dict[Hashable, Point3DLike] | LayoutFunction = \"spring\",\n        layout_scale: float | tuple[float, float, float] = 2,\n        layout_config: dict[str, Any] | None = None,\n        partitions: list[list[Hashable]] | None = None,\n        root_vertex: Hashable | None = None,\n    ) -> Graph:\n        \"\"\"Change the layout of this graph.\n\n        See the documentation of :class:`~.Graph` for details about the\n        keyword arguments.\n\n        Examples\n        --------\n\n        .. manim:: ChangeGraphLayout\n\n            class ChangeGraphLayout(Scene):\n                def construct(self):\n                    G = Graph([1, 2, 3, 4, 5], [(1, 2), (2, 3), (3, 4), (4, 5)],\n                              layout={1: [-2, 0, 0], 2: [-1, 0, 0], 3: [0, 0, 0],\n                                      4: [1, 0, 0], 5: [2, 0, 0]}\n                              )\n                    self.play(Create(G))\n                    self.play(G.animate.change_layout(\"circular\"))\n                    self.wait()\n        \"\"\"\n        layout_config = {} if layout_config is None else layout_config\n        if partitions is not None and \"partitions\" not in layout_config:\n            layout_config[\"partitions\"] = partitions\n        if root_vertex is not None and \"root_vertex\" not in layout_config:\n            layout_config[\"root_vertex\"] = root_vertex\n\n        self._layout = _determine_graph_layout(\n            self._graph,\n            layout=layout,\n            layout_scale=layout_scale,\n            layout_config=layout_config,\n        )\n\n        for v in self.vertices:\n            self[v].move_to(self._layout[v])\n        return self\n\n\n\n\n\n[docs]\nclass Graph(GenericGraph):\n    \"\"\"An undirected graph (vertices connected with edges).\n\n    The graph comes with an updater which makes the edges stick to\n    the vertices when moved around. See :class:`.DiGraph` for\n    a version with directed edges.\n\n    See also\n    --------\n\n    :class:`.GenericGraph`\n\n    Parameters\n    ----------\n\n    vertices\n        A list of vertices. Must be hashable elements.\n    edges\n        A list of edges, specified as tuples ``(u, v)`` where both ``u``\n        and ``v`` are vertices. The vertex order is irrelevant.\n    labels\n        Controls whether or not vertices are labeled. If ``False`` (the default),\n        the vertices are not labeled; if ``True`` they are labeled using their\n        names (as specified in ``vertices``) via :class:`~.MathTex`. Alternatively,\n        custom labels can be specified by passing a dictionary whose keys are\n        the vertices, and whose values are the corresponding vertex labels\n        (rendered via, e.g., :class:`~.Text` or :class:`~.Tex`).\n    label_fill_color\n        Sets the fill color of the default labels generated when ``labels``\n        is set to ``True``. Has no effect for other values of ``labels``.\n    layout\n        Either one of ``\"spring\"`` (the default), ``\"circular\"``, ``\"kamada_kawai\"``,\n        ``\"planar\"``, ``\"random\"``, ``\"shell\"``, ``\"spectral\"``, ``\"spiral\"``, ``\"tree\"``, and ``\"partite\"``\n        for automatic vertex positioning using ``networkx``\n        (see `their documentation <https://networkx.org/documentation/stable/reference/drawing.html#module-networkx.drawing.layout>`_\n        for more details), or a dictionary specifying a coordinate (value)\n        for each vertex (key) for manual positioning.\n    layout_config\n        Only for automatically generated layouts. A dictionary whose entries\n        are passed as keyword arguments to the automatic layout algorithm\n        specified via ``layout`` of ``networkx``.\n        The ``tree`` layout also accepts a special parameter ``vertex_spacing``\n        passed as a keyword argument inside the ``layout_config`` dictionary.\n        Passing a tuple ``(space_x, space_y)`` as this argument overrides\n        the value of ``layout_scale`` and ensures that vertices are arranged\n        in a way such that the centers of siblings in the same layer are\n        at least ``space_x`` units apart horizontally, and neighboring layers\n        are spaced ``space_y`` units vertically.\n    layout_scale\n        The scale of automatically generated layouts: the vertices will\n        be arranged such that the coordinates are located within the\n        interval ``[-scale, scale]``. Some layouts accept a tuple ``(scale_x, scale_y)``\n        causing the first coordinate to be in the interval ``[-scale_x, scale_x]``,\n        and the second in ``[-scale_y, scale_y]``. Default: 2.\n    vertex_type\n        The mobject class used for displaying vertices in the scene.\n    vertex_config\n        Either a dictionary containing keyword arguments to be passed to\n        the class specified via ``vertex_type``, or a dictionary whose keys\n        are the vertices, and whose values are dictionaries containing keyword\n        arguments for the mobject related to the corresponding vertex.\n    vertex_mobjects\n        A dictionary whose keys are the vertices, and whose values are\n        mobjects to be used as vertices. Passing vertices here overrides\n        all other configuration options for a vertex.\n    edge_type\n        The mobject class used for displaying edges in the scene.\n    edge_config\n        Either a dictionary containing keyword arguments to be passed\n        to the class specified via ``edge_type``, or a dictionary whose\n        keys are the edges, and whose values are dictionaries containing\n        keyword arguments for the mobject related to the corresponding edge.\n\n\n    Examples\n    --------\n\n    First, we create a small graph and demonstrate that the edges move\n    together with the vertices.\n\n    .. manim:: MovingVertices\n\n        class MovingVertices(Scene):\n            def construct(self):\n                vertices = [1, 2, 3, 4]\n                edges = [(1, 2), (2, 3), (3, 4), (1, 3), (1, 4)]\n                g = Graph(vertices, edges)\n                self.play(Create(g))\n                self.wait()\n                self.play(g[1].animate.move_to([1, 1, 0]),\n                          g[2].animate.move_to([-1, 1, 0]),\n                          g[3].animate.move_to([1, -1, 0]),\n                          g[4].animate.move_to([-1, -1, 0]))\n                self.wait()\n\n    There are several automatic positioning algorithms to choose from:\n\n    .. manim:: GraphAutoPosition\n        :save_last_frame:\n\n        class GraphAutoPosition(Scene):\n            def construct(self):\n                vertices = [1, 2, 3, 4, 5, 6, 7, 8]\n                edges = [(1, 7), (1, 8), (2, 3), (2, 4), (2, 5),\n                         (2, 8), (3, 4), (6, 1), (6, 2),\n                         (6, 3), (7, 2), (7, 4)]\n                autolayouts = [\"spring\", \"circular\", \"kamada_kawai\",\n                               \"planar\", \"random\", \"shell\",\n                               \"spectral\", \"spiral\"]\n                graphs = [Graph(vertices, edges, layout=lt).scale(0.5)\n                          for lt in autolayouts]\n                r1 = VGroup(*graphs[:3]).arrange()\n                r2 = VGroup(*graphs[3:6]).arrange()\n                r3 = VGroup(*graphs[6:]).arrange()\n                self.add(VGroup(r1, r2, r3).arrange(direction=DOWN))\n\n    Vertices can also be positioned manually:\n\n    .. manim:: GraphManualPosition\n        :save_last_frame:\n\n        class GraphManualPosition(Scene):\n            def construct(self):\n                vertices = [1, 2, 3, 4]\n                edges = [(1, 2), (2, 3), (3, 4), (4, 1)]\n                lt = {1: [0, 0, 0], 2: [1, 1, 0], 3: [1, -1, 0], 4: [-1, 0, 0]}\n                G = Graph(vertices, edges, layout=lt)\n                self.add(G)\n\n    The vertices in graphs can be labeled, and configurations for vertices\n    and edges can be modified both by default and for specific vertices and\n    edges.\n\n    .. note::\n\n        In ``edge_config``, edges can be passed in both directions: if\n        ``(u, v)`` is an edge in the graph, both ``(u, v)`` as well\n        as ``(v, u)`` can be used as keys in the dictionary.\n\n    .. manim:: LabeledModifiedGraph\n        :save_last_frame:\n\n        class LabeledModifiedGraph(Scene):\n            def construct(self):\n                vertices = [1, 2, 3, 4, 5, 6, 7, 8]\n                edges = [(1, 7), (1, 8), (2, 3), (2, 4), (2, 5),\n                         (2, 8), (3, 4), (6, 1), (6, 2),\n                         (6, 3), (7, 2), (7, 4)]\n                g = Graph(vertices, edges, layout=\"circular\", layout_scale=3,\n                          labels=True, vertex_config={7: {\"fill_color\": RED}},\n                          edge_config={(1, 7): {\"stroke_color\": RED},\n                                       (2, 7): {\"stroke_color\": RED},\n                                       (4, 7): {\"stroke_color\": RED}})\n                self.add(g)\n\n    You can also lay out a partite graph on columns by specifying\n    a list of the vertices on each side and choosing the partite layout.\n\n    .. note::\n\n        All vertices in your graph which are not listed in any of the partitions\n        are collected in their own partition and rendered in the rightmost column.\n\n    .. manim:: PartiteGraph\n        :save_last_frame:\n\n        import networkx as nx\n\n        class PartiteGraph(Scene):\n            def construct(self):\n                G = nx.Graph()\n                G.add_nodes_from([0, 1, 2, 3])\n                G.add_edges_from([(0, 2), (0,3), (1, 2)])\n                graph = Graph(list(G.nodes), list(G.edges), layout=\"partite\", partitions=[[0, 1]])\n                self.play(Create(graph))\n\n    The representation of a linear artificial neural network is facilitated\n    by the use of the partite layout and defining partitions for each layer.\n\n    .. manim:: LinearNN\n        :save_last_frame:\n\n        class LinearNN(Scene):\n            def construct(self):\n                edges = []\n                partitions = []\n                c = 0\n                layers = [2, 3, 3, 2]  # the number of neurons in each layer\n\n                for i in layers:\n                    partitions.append(list(range(c + 1, c + i + 1)))\n                    c += i\n                for i, v in enumerate(layers[1:]):\n                        last = sum(layers[:i+1])\n                        for j in range(v):\n                            for k in range(last - layers[i], last):\n                                edges.append((k + 1, j + last + 1))\n\n                vertices = np.arange(1, sum(layers) + 1)\n\n                graph = Graph(\n                    vertices,\n                    edges,\n                    layout='partite',\n                    partitions=partitions,\n                    layout_scale=3,\n                    vertex_config={'radius': 0.20},\n                )\n                self.add(graph)\n\n    The custom tree layout can be used to show the graph\n    by distance from the root vertex. You must pass the root vertex\n    of the tree.\n\n    .. manim:: Tree\n\n        import networkx as nx\n\n        class Tree(Scene):\n            def construct(self):\n                G = nx.Graph()\n\n                G.add_node(\"ROOT\")\n\n                for i in range(5):\n                    G.add_node(\"Child_%i\" % i)\n                    G.add_node(\"Grandchild_%i\" % i)\n                    G.add_node(\"Greatgrandchild_%i\" % i)\n\n                    G.add_edge(\"ROOT\", \"Child_%i\" % i)\n                    G.add_edge(\"Child_%i\" % i, \"Grandchild_%i\" % i)\n                    G.add_edge(\"Grandchild_%i\" % i, \"Greatgrandchild_%i\" % i)\n\n                self.play(Create(\n                    Graph(list(G.nodes), list(G.edges), layout=\"tree\", root_vertex=\"ROOT\")))\n\n    The following code sample illustrates the use of the ``vertex_spacing``\n    layout parameter specific to the ``\"tree\"`` layout. As mentioned\n    above, setting ``vertex_spacing`` overrides the specified value\n    for ``layout_scale``, and as such it is harder to control the size\n    of the mobject. However, we can adjust the captured frame and\n    zoom out by using a :class:`.MovingCameraScene`::\n\n        class LargeTreeGeneration(MovingCameraScene):\n            DEPTH = 4\n            CHILDREN_PER_VERTEX = 3\n            LAYOUT_CONFIG = {\"vertex_spacing\": (0.5, 1)}\n            VERTEX_CONF = {\"radius\": 0.25, \"color\": BLUE_B, \"fill_opacity\": 1}\n\n            def expand_vertex(self, g, vertex_id: str, depth: int):\n                new_vertices = [\n                    f\"{vertex_id}/{i}\" for i in range(self.CHILDREN_PER_VERTEX)\n                ]\n                new_edges = [(vertex_id, child_id) for child_id in new_vertices]\n                g.add_edges(\n                    *new_edges,\n                    vertex_config=self.VERTEX_CONF,\n                    positions={\n                        k: g.vertices[vertex_id].get_center() + 0.1 * DOWN\n                        for k in new_vertices\n                    },\n                )\n                if depth < self.DEPTH:\n                    for child_id in new_vertices:\n                        self.expand_vertex(g, child_id, depth + 1)\n\n                return g\n\n            def construct(self):\n                g = Graph([\"ROOT\"], [], vertex_config=self.VERTEX_CONF)\n                g = self.expand_vertex(g, \"ROOT\", 1)\n                self.add(g)\n\n                self.play(\n                    g.animate.change_layout(\n                        \"tree\",\n                        root_vertex=\"ROOT\",\n                        layout_config=self.LAYOUT_CONFIG,\n                    )\n                )\n                self.play(self.camera.auto_zoom(g, margin=1), run_time=0.5)\n    \"\"\"\n\n\n[docs]\n    @staticmethod\n    def _empty_networkx_graph() -> nx.Graph:\n        return nx.Graph()\n\n\n\n[docs]\n    def _populate_edge_dict(\n        self, edges: list[tuple[Hashable, Hashable]], edge_type: type[Mobject]\n    ):\n        self.edges = {\n            (u, v): edge_type(\n                self[u].get_center(),\n                self[v].get_center(),\n                z_index=-1,\n                **self._edge_config[(u, v)],\n            )\n            for (u, v) in edges\n        }\n\n\n    def update_edges(self, graph):\n        for (u, v), edge in graph.edges.items():\n            # Undirected graph has a Line edge\n            edge.set_points_by_ends(\n                graph[u].get_center(),\n                graph[v].get_center(),\n                buff=self._edge_config.get(\"buff\", 0),\n                path_arc=self._edge_config.get(\"path_arc\", 0),\n            )\n\n    def __repr__(self: Graph) -> str:\n        return f\"Undirected graph on {len(self.vertices)} vertices and {len(self.edges)} edges\"\n\n\n\n\n[docs]\nclass DiGraph(GenericGraph):\n    \"\"\"A directed graph.\n\n    .. note::\n\n        In contrast to undirected graphs, the order in which vertices in a given\n        edge are specified is relevant here.\n\n    See also\n    --------\n\n    :class:`.GenericGraph`\n\n    Parameters\n    ----------\n\n    vertices\n        A list of vertices. Must be hashable elements.\n    edges\n        A list of edges, specified as tuples ``(u, v)`` where both ``u``\n        and ``v`` are vertices. The edge is directed from ``u`` to ``v``.\n    labels\n        Controls whether or not vertices are labeled. If ``False`` (the default),\n        the vertices are not labeled; if ``True`` they are labeled using their\n        names (as specified in ``vertices``) via :class:`~.MathTex`. Alternatively,\n        custom labels can be specified by passing a dictionary whose keys are\n        the vertices, and whose values are the corresponding vertex labels\n        (rendered via, e.g., :class:`~.Text` or :class:`~.Tex`).\n    label_fill_color\n        Sets the fill color of the default labels generated when ``labels``\n        is set to ``True``. Has no effect for other values of ``labels``.\n    layout\n        Either one of ``\"spring\"`` (the default), ``\"circular\"``, ``\"kamada_kawai\"``,\n        ``\"planar\"``, ``\"random\"``, ``\"shell\"``, ``\"spectral\"``, ``\"spiral\"``, ``\"tree\"``, and ``\"partite\"``\n        for automatic vertex positioning using ``networkx``\n        (see `their documentation <https://networkx.org/documentation/stable/reference/drawing.html#module-networkx.drawing.layout>`_\n        for more details), or a dictionary specifying a coordinate (value)\n        for each vertex (key) for manual positioning.\n    layout_config\n        Only for automatically generated layouts. A dictionary whose entries\n        are passed as keyword arguments to the automatic layout algorithm\n        specified via ``layout`` of ``networkx``.\n        The ``tree`` layout also accepts a special parameter ``vertex_spacing``\n        passed as a keyword argument inside the ``layout_config`` dictionary.\n        Passing a tuple ``(space_x, space_y)`` as this argument overrides\n        the value of ``layout_scale`` and ensures that vertices are arranged\n        in a way such that the centers of siblings in the same layer are\n        at least ``space_x`` units apart horizontally, and neighboring layers\n        are spaced ``space_y`` units vertically.\n    layout_scale\n        The scale of automatically generated layouts: the vertices will\n        be arranged such that the coordinates are located within the\n        interval ``[-scale, scale]``. Some layouts accept a tuple ``(scale_x, scale_y)``\n        causing the first coordinate to be in the interval ``[-scale_x, scale_x]``,\n        and the second in ``[-scale_y, scale_y]``. Default: 2.\n    vertex_type\n        The mobject class used for displaying vertices in the scene.\n    vertex_config\n        Either a dictionary containing keyword arguments to be passed to\n        the class specified via ``vertex_type``, or a dictionary whose keys\n        are the vertices, and whose values are dictionaries containing keyword\n        arguments for the mobject related to the corresponding vertex.\n    vertex_mobjects\n        A dictionary whose keys are the vertices, and whose values are\n        mobjects to be used as vertices. Passing vertices here overrides\n        all other configuration options for a vertex.\n    edge_type\n        The mobject class used for displaying edges in the scene.\n    edge_config\n        Either a dictionary containing keyword arguments to be passed\n        to the class specified via ``edge_type``, or a dictionary whose\n        keys are the edges, and whose values are dictionaries containing\n        keyword arguments for the mobject related to the corresponding edge.\n        You can further customize the tip by adding a ``tip_config`` dictionary\n        for global styling, or by adding the dict to a specific ``edge_config``.\n\n    Examples\n    --------\n\n    .. manim:: MovingDiGraph\n\n        class MovingDiGraph(Scene):\n            def construct(self):\n                vertices = [1, 2, 3, 4]\n                edges = [(1, 2), (2, 3), (3, 4), (1, 3), (1, 4)]\n\n                g = DiGraph(vertices, edges)\n\n                self.add(g)\n                self.play(\n                    g[1].animate.move_to([1, 1, 1]),\n                    g[2].animate.move_to([-1, 1, 2]),\n                    g[3].animate.move_to([1, -1, -1]),\n                    g[4].animate.move_to([-1, -1, 0]),\n                )\n                self.wait()\n\n    You can customize the edges and arrow tips globally or locally.\n\n    .. manim:: CustomDiGraph\n\n        class CustomDiGraph(Scene):\n            def construct(self):\n                vertices = [i for i in range(5)]\n                edges = [\n                    (0, 1),\n                    (1, 2),\n                    (3, 2),\n                    (3, 4),\n                ]\n\n                edge_config = {\n                    \"stroke_width\": 2,\n                    \"tip_config\": {\n                        \"tip_shape\": ArrowSquareTip,\n                        \"tip_length\": 0.15,\n                    },\n                    (3, 4): {\n                        \"color\": RED,\n                        \"tip_config\": {\"tip_length\": 0.25, \"tip_width\": 0.25}\n                    },\n                }\n\n                g = DiGraph(\n                    vertices,\n                    edges,\n                    labels=True,\n                    layout=\"circular\",\n                    edge_config=edge_config,\n                ).scale(1.4)\n\n                self.play(Create(g))\n                self.wait()\n\n    Since this implementation respects the labels boundary you can also use\n    it for an undirected moving graph with labels.\n\n    .. manim:: UndirectedMovingDiGraph\n\n        class UndirectedMovingDiGraph(Scene):\n            def construct(self):\n                vertices = [i for i in range(5)]\n                edges = [\n                    (0, 1),\n                    (1, 2),\n                    (3, 2),\n                    (3, 4),\n                ]\n\n                edge_config = {\n                    \"stroke_width\": 2,\n                    \"tip_config\": {\"tip_length\": 0, \"tip_width\": 0},\n                    (3, 4): {\"color\": RED},\n                }\n\n                g = DiGraph(\n                    vertices,\n                    edges,\n                    labels=True,\n                    layout=\"circular\",\n                    edge_config=edge_config,\n                ).scale(1.4)\n\n                self.play(Create(g))\n                self.wait()\n\n                self.play(\n                    g[1].animate.move_to([1, 1, 1]),\n                    g[2].animate.move_to([-1, 1, 2]),\n                    g[3].animate.move_to([-1.5, -1.5, -1]),\n                    g[4].animate.move_to([1, -2, -1]),\n                )\n                self.wait()\n\n    \"\"\"\n\n\n[docs]\n    @staticmethod\n    def _empty_networkx_graph() -> nx.DiGraph:\n        return nx.DiGraph()\n\n\n\n[docs]\n    def _populate_edge_dict(\n        self, edges: list[tuple[Hashable, Hashable]], edge_type: type[Mobject]\n    ):\n        self.edges = {\n            (u, v): edge_type(\n                self[u],\n                self[v],\n                z_index=-1,\n                **self._edge_config[(u, v)],\n            )\n            for (u, v) in edges\n        }\n\n        for (u, v), edge in self.edges.items():\n            edge.add_tip(**self._tip_config[(u, v)])\n\n\n\n[docs]\n    def update_edges(self, graph):\n        \"\"\"Updates the edges to stick at their corresponding vertices.\n\n        Arrow tips need to be repositioned since otherwise they can be\n        deformed.\n        \"\"\"\n        for (u, v), edge in graph.edges.items():\n            tip = edge.pop_tips()[0]\n            # Passing the Mobject instead of the vertex makes the tip\n            # stop on the bounding box of the vertex.\n            edge.set_points_by_ends(\n                graph[u],\n                graph[v],\n                buff=self._edge_config.get(\"buff\", 0),\n                path_arc=self._edge_config.get(\"path_arc\", 0),\n            )\n            edge.add_tip(tip)\n\n\n    def __repr__(self: DiGraph) -> str:\n        return f\"Directed graph on {len(self.vertices)} vertices and {len(self.edges)} edges\"", "code_sha1": "98b00caa8efc93a7a2fd6f8955669bd4397ea7d4"}
{"url": "https://docs.manim.community/en/stable/_modules/manim/mobject/graphing/coordinate_systems.html", "depth": 2, "instruction": "The code defines a coordinate system with axes and a polar plane, featuring customizable properties like ranges, lengths, and labels. It includes methods for plotting functions, generating lines, and adding coordinate labels. The visual result would be a grid of axes with labeled ticks, a polar plane, and the ability to plot various mathematical functions and shapes, all rendered in a 2D or 3D scene.", "code": "\"\"\"Mobjects that represent coordinate systems.\"\"\"\n\nfrom __future__ import annotations\n\n__all__ = [\n    \"CoordinateSystem\",\n    \"Axes\",\n    \"ThreeDAxes\",\n    \"NumberPlane\",\n    \"PolarPlane\",\n    \"ComplexPlane\",\n]\n\nimport fractions as fr\nimport numbers\nfrom collections.abc import Iterable, Sequence\nfrom typing import TYPE_CHECKING, Any, Callable, TypeVar, overload\n\nimport numpy as np\nfrom typing_extensions import Self\n\nfrom manim import config\nfrom manim.constants import *\nfrom manim.mobject.geometry.arc import Circle, Dot\nfrom manim.mobject.geometry.line import Arrow, DashedLine, Line\nfrom manim.mobject.geometry.polygram import Polygon, Rectangle, RegularPolygon\nfrom manim.mobject.graphing.functions import ImplicitFunction, ParametricFunction\nfrom manim.mobject.graphing.number_line import NumberLine\nfrom manim.mobject.graphing.scale import LinearBase\nfrom manim.mobject.mobject import Mobject\nfrom manim.mobject.opengl.opengl_compatibility import ConvertToOpenGL\nfrom manim.mobject.opengl.opengl_surface import OpenGLSurface\nfrom manim.mobject.text.tex_mobject import MathTex\nfrom manim.mobject.three_d.three_dimensions import Surface\nfrom manim.mobject.types.vectorized_mobject import (\n    VDict,\n    VectorizedPoint,\n    VGroup,\n    VMobject,\n)\nfrom manim.utils.color import (\n    BLACK,\n    BLUE,\n    BLUE_D,\n    GREEN,\n    WHITE,\n    YELLOW,\n    ManimColor,\n    ParsableManimColor,\n    color_gradient,\n    interpolate_color,\n    invert_color,\n)\nfrom manim.utils.config_ops import merge_dicts_recursively, update_dict_recursively\nfrom manim.utils.simple_functions import binary_search\nfrom manim.utils.space_ops import angle_of_vector\n\nif TYPE_CHECKING:\n    from manim.mobject.mobject import Mobject\n    from manim.typing import (\n        ManimFloat,\n        Point2D,\n        Point2DLike,\n        Point3D,\n        Point3DLike,\n        Vector3D,\n    )\n\n    LineType = TypeVar(\"LineType\", bound=Line)\n\n\n\n[docs]\nclass CoordinateSystem:\n    r\"\"\"Abstract base class for Axes and NumberPlane.\n\n    Examples\n    --------\n    .. manim:: CoordSysExample\n        :save_last_frame:\n\n        class CoordSysExample(Scene):\n            def construct(self):\n                # the location of the ticks depends on the x_range and y_range.\n                grid = Axes(\n                    x_range=[0, 1, 0.05],  # step size determines num_decimal_places.\n                    y_range=[0, 1, 0.05],\n                    x_length=9,\n                    y_length=5.5,\n                    axis_config={\n                        \"numbers_to_include\": np.arange(0, 1 + 0.1, 0.1),\n                        \"font_size\": 24,\n                    },\n                    tips=False,\n                )\n\n                # Labels for the x-axis and y-axis.\n                y_label = grid.get_y_axis_label(\"y\", edge=LEFT, direction=LEFT, buff=0.4)\n                x_label = grid.get_x_axis_label(\"x\")\n                grid_labels = VGroup(x_label, y_label)\n\n                graphs = VGroup()\n                for n in np.arange(1, 20 + 0.5, 0.5):\n                    graphs += grid.plot(lambda x: x ** n, color=WHITE)\n                    graphs += grid.plot(\n                        lambda x: x ** (1 / n), color=WHITE, use_smoothing=False\n                    )\n\n                # Extra lines and labels for point (1,1)\n                graphs += grid.get_horizontal_line(grid @ (1, 1, 0), color=BLUE)\n                graphs += grid.get_vertical_line(grid @ (1, 1, 0), color=BLUE)\n                graphs += Dot(point=grid @ (1, 1, 0), color=YELLOW)\n                graphs += Tex(\"(1,1)\").scale(0.75).next_to(grid @ (1, 1, 0))\n                title = Title(\n                    # spaces between braces to prevent SyntaxError\n                    r\"Graphs of $y=x^{ {1}\\over{n} }$ and $y=x^n (n=1,2,3,...,20)$\",\n                    include_underline=False,\n                    font_size=40,\n                )\n\n                self.add(title, graphs, grid, grid_labels)\n    \"\"\"\n\n    def __init__(\n        self,\n        x_range: Sequence[float] | None = None,\n        y_range: Sequence[float] | None = None,\n        x_length: float | None = None,\n        y_length: float | None = None,\n        dimension: int = 2,\n    ) -> None:\n        self.dimension = dimension\n\n        default_step = 1\n        if x_range is None:\n            x_range = [\n                round(-config[\"frame_x_radius\"]),\n                round(config[\"frame_x_radius\"]),\n                default_step,\n            ]\n        elif len(x_range) == 2:\n            x_range = [*x_range, default_step]\n\n        if y_range is None:\n            y_range = [\n                round(-config[\"frame_y_radius\"]),\n                round(config[\"frame_y_radius\"]),\n                default_step,\n            ]\n        elif len(y_range) == 2:\n            y_range = [*y_range, default_step]\n\n        self.x_range = x_range\n        self.y_range = y_range\n        self.x_length = x_length\n        self.y_length = y_length\n        self.num_sampled_graph_points_per_tick = 10\n\n    def coords_to_point(self, *coords: ManimFloat):\n        raise NotImplementedError()\n\n    def point_to_coords(self, point: Point3DLike):\n        raise NotImplementedError()\n\n\n[docs]\n    def polar_to_point(self, radius: float, azimuth: float) -> Point2D:\n        r\"\"\"Gets a point from polar coordinates.\n\n        Parameters\n        ----------\n        radius\n            The coordinate radius (:math:`r`).\n\n        azimuth\n            The coordinate azimuth (:math:`\\theta`).\n\n        Returns\n        -------\n        numpy.ndarray\n            The point.\n\n        Examples\n        --------\n        .. manim:: PolarToPointExample\n            :ref_classes: PolarPlane Vector\n            :save_last_frame:\n\n            class PolarToPointExample(Scene):\n                def construct(self):\n                    polarplane_pi = PolarPlane(azimuth_units=\"PI radians\", size=6)\n                    polartopoint_vector = Vector(polarplane_pi.polar_to_point(3, PI/4))\n                    self.add(polarplane_pi)\n                    self.add(polartopoint_vector)\n        \"\"\"\n        return self.coords_to_point(radius * np.cos(azimuth), radius * np.sin(azimuth))\n\n\n\n[docs]\n    def point_to_polar(self, point: Point2DLike) -> Point2D:\n        r\"\"\"Gets polar coordinates from a point.\n\n        Parameters\n        ----------\n        point\n            The point.\n\n        Returns\n        -------\n        Tuple[:class:`float`, :class:`float`]\n            The coordinate radius (:math:`r`) and the coordinate azimuth (:math:`\\theta`).\n        \"\"\"\n        x, y = self.point_to_coords(point)\n        return np.sqrt(x**2 + y**2), np.arctan2(y, x)\n\n\n\n[docs]\n    def c2p(\n        self, *coords: float | Sequence[float] | Sequence[Sequence[float]] | np.ndarray\n    ) -> np.ndarray:\n        \"\"\"Abbreviation for :meth:`coords_to_point`\"\"\"\n        return self.coords_to_point(*coords)\n\n\n\n[docs]\n    def p2c(self, point: Point3DLike):\n        \"\"\"Abbreviation for :meth:`point_to_coords`\"\"\"\n        return self.point_to_coords(point)\n\n\n\n[docs]\n    def pr2pt(self, radius: float, azimuth: float) -> np.ndarray:\n        \"\"\"Abbreviation for :meth:`polar_to_point`\"\"\"\n        return self.polar_to_point(radius, azimuth)\n\n\n\n[docs]\n    def pt2pr(self, point: np.ndarray) -> tuple[float, float]:\n        \"\"\"Abbreviation for :meth:`point_to_polar`\"\"\"\n        return self.point_to_polar(point)\n\n\n    def get_axes(self):\n        raise NotImplementedError()\n\n    def get_axis(self, index: int) -> Mobject:\n        return self.get_axes()[index]\n\n\n[docs]\n    def get_origin(self) -> np.ndarray:\n        \"\"\"Gets the origin of :class:`~.Axes`.\n\n        Returns\n        -------\n        np.ndarray\n            The center point.\n        \"\"\"\n        return self.coords_to_point(0, 0)\n\n\n    def get_x_axis(self) -> Mobject:\n        return self.get_axis(0)\n\n    def get_y_axis(self) -> Mobject:\n        return self.get_axis(1)\n\n    def get_z_axis(self) -> Mobject:\n        return self.get_axis(2)\n\n    def get_x_unit_size(self) -> float:\n        return self.get_x_axis().get_unit_size()\n\n    def get_y_unit_size(self) -> float:\n        return self.get_y_axis().get_unit_size()\n\n\n[docs]\n    def get_x_axis_label(\n        self,\n        label: float | str | Mobject,\n        edge: Sequence[float] = UR,\n        direction: Sequence[float] = UR,\n        buff: float = SMALL_BUFF,\n        **kwargs,\n    ) -> Mobject:\n        \"\"\"Generate an x-axis label.\n\n        Parameters\n        ----------\n        label\n            The label. Defaults to :class:`~.MathTex` for ``str`` and ``float`` inputs.\n        edge\n            The edge of the x-axis to which the label will be added, by default ``UR``.\n        direction\n            Allows for further positioning of the label from an edge, by default ``UR``.\n        buff\n            The distance of the label from the line.\n\n        Returns\n        -------\n        :class:`~.Mobject`\n            The positioned label.\n\n        Examples\n        --------\n        .. manim:: GetXAxisLabelExample\n            :save_last_frame:\n\n            class GetXAxisLabelExample(Scene):\n                def construct(self):\n                    ax = Axes(x_range=(0, 8), y_range=(0, 5), x_length=8, y_length=5)\n                    x_label = ax.get_x_axis_label(\n                        Tex(\"$x$-values\").scale(0.65), edge=DOWN, direction=DOWN, buff=0.5\n                    )\n                    self.add(ax, x_label)\n        \"\"\"\n        return self._get_axis_label(\n            label, self.get_x_axis(), edge, direction, buff=buff, **kwargs\n        )\n\n\n\n[docs]\n    def get_y_axis_label(\n        self,\n        label: float | str | Mobject,\n        edge: Sequence[float] = UR,\n        direction: Sequence[float] = UP * 0.5 + RIGHT,\n        buff: float = SMALL_BUFF,\n        **kwargs,\n    ) -> Mobject:\n        \"\"\"Generate a y-axis label.\n\n        Parameters\n        ----------\n        label\n            The label. Defaults to :class:`~.MathTex` for ``str`` and ``float`` inputs.\n        edge\n            The edge of the y-axis to which the label will be added, by default ``UR``.\n        direction\n            Allows for further positioning of the label from an edge, by default ``UR``\n        buff\n            The distance of the label from the line.\n\n        Returns\n        -------\n        :class:`~.Mobject`\n            The positioned label.\n\n        Examples\n        --------\n        .. manim:: GetYAxisLabelExample\n            :save_last_frame:\n\n            class GetYAxisLabelExample(Scene):\n                def construct(self):\n                    ax = Axes(x_range=(0, 8), y_range=(0, 5), x_length=8, y_length=5)\n                    y_label = ax.get_y_axis_label(\n                        Tex(\"$y$-values\").scale(0.65).rotate(90 * DEGREES),\n                        edge=LEFT,\n                        direction=LEFT,\n                        buff=0.3,\n                    )\n                    self.add(ax, y_label)\n        \"\"\"\n        return self._get_axis_label(\n            label, self.get_y_axis(), edge, direction, buff=buff, **kwargs\n        )\n\n\n\n[docs]\n    def _get_axis_label(\n        self,\n        label: float | str | Mobject,\n        axis: Mobject,\n        edge: Sequence[float],\n        direction: Sequence[float],\n        buff: float = SMALL_BUFF,\n    ) -> Mobject:\n        \"\"\"Gets the label for an axis.\n\n        Parameters\n        ----------\n        label\n            The label. Defaults to :class:`~.MathTex` for ``str`` and ``float`` inputs.\n        axis\n            The axis to which the label will be added.\n        edge\n            The edge of the axes to which the label will be added. ``RIGHT`` adds to the right side of the axis\n        direction\n            Allows for further positioning of the label.\n        buff\n            The distance of the label from the line.\n\n        Returns\n        -------\n        :class:`~.Mobject`\n            The positioned label along the given axis.\n        \"\"\"\n        label = self.x_axis._create_label_tex(label)\n        label.next_to(axis.get_edge_center(edge), direction=direction, buff=buff)\n        label.shift_onto_screen(buff=MED_SMALL_BUFF)\n        return label\n\n\n    def get_axis_labels(self):\n        raise NotImplementedError()\n\n\n[docs]\n    def add_coordinates(\n        self,\n        *axes_numbers: Iterable[float] | None | dict[float, str | float | Mobject],\n        **kwargs: Any,\n    ) -> Self:\n        \"\"\"Adds labels to the axes. Use ``Axes.coordinate_labels`` to\n        access the coordinates after creation.\n\n        Parameters\n        ----------\n        axes_numbers\n            The numbers to be added to the axes. Use ``None`` to represent an axis with default labels.\n\n        Examples\n        --------\n        .. code-block:: python\n\n            ax = ThreeDAxes()\n            x_labels = range(-4, 5)\n            z_labels = range(-4, 4, 2)\n            ax.add_coordinates(\n                x_labels, None, z_labels\n            )  # default y labels, custom x & z labels\n            ax.add_coordinates(x_labels)  # only x labels\n\n        You can also specifically control the position and value of the labels using a dict.\n\n        .. code-block:: python\n\n            ax = Axes(x_range=[0, 7])\n            x_pos = [x for x in range(1, 8)]\n\n            # strings are automatically converted into a Tex mobject.\n            x_vals = [\n                \"Monday\",\n                \"Tuesday\",\n                \"Wednesday\",\n                \"Thursday\",\n                \"Friday\",\n                \"Saturday\",\n                \"Sunday\",\n            ]\n            x_dict = dict(zip(x_pos, x_vals))\n            ax.add_coordinates(x_dict)\n        \"\"\"\n        self.coordinate_labels = VGroup()\n        # if nothing is passed to axes_numbers, produce axes with default labelling\n        if not axes_numbers:\n            axes_numbers = [None for _ in range(self.dimension)]\n\n        for axis, values in zip(self.axes, axes_numbers):\n            if isinstance(values, dict):\n                axis.add_labels(values, **kwargs)\n                labels = axis.labels\n            elif values is None and axis.scaling.custom_labels:\n                tick_range = axis.get_tick_range()\n                axis.add_labels(\n                    dict(zip(tick_range, axis.scaling.get_custom_labels(tick_range)))\n                )\n                labels = axis.labels\n            else:\n                axis.add_numbers(values, **kwargs)\n                labels = axis.numbers\n            self.coordinate_labels.add(labels)\n\n        return self\n\n\n    # overload necessary until https://github.com/python/mypy/issues/3737 is supported\n    @overload\n    def get_line_from_axis_to_point(\n        self,\n        index: int,\n        point: Sequence[float],\n        line_config: dict | None = ...,\n        color: ParsableManimColor | None = ...,\n        stroke_width: float = ...,\n    ) -> DashedLine: ...\n\n    @overload\n    def get_line_from_axis_to_point(\n        self,\n        index: int,\n        point: Sequence[float],\n        line_func: type[LineType],\n        line_config: dict | None = ...,\n        color: ParsableManimColor | None = ...,\n        stroke_width: float = ...,\n    ) -> LineType: ...\n\n\n[docs]\n    def get_line_from_axis_to_point(  # type: ignore[no-untyped-def]\n        self,\n        index,\n        point,\n        line_func=DashedLine,\n        line_config=None,\n        color=None,\n        stroke_width=2,\n    ):\n        \"\"\"Returns a straight line from a given axis to a point in the scene.\n\n        Parameters\n        ----------\n        index\n            Specifies the axis from which to draw the line. `0 = x_axis`, `1 = y_axis`\n        point\n            The point to which the line will be drawn.\n        line_func\n            The function of the :class:`~.Line` mobject used to construct the line.\n        line_config\n            Optional arguments to passed to :attr:`line_func`.\n        color\n            The color of the line.\n        stroke_width\n            The stroke width of the line.\n\n        Returns\n        -------\n        :class:`~.Line`\n            The line from an axis to a point.\n\n\n        .. seealso::\n            :meth:`~.CoordinateSystem.get_vertical_line`\n            :meth:`~.CoordinateSystem.get_horizontal_line`\n        \"\"\"\n        line_config = line_config if line_config is not None else {}\n\n        if color is None:\n            color = VMobject().color\n\n        line_config[\"color\"] = ManimColor.parse(color)\n        line_config[\"stroke_width\"] = stroke_width\n\n        axis = self.get_axis(index)\n        line = line_func(axis.get_projection(point), point, **line_config)\n        return line\n\n\n\n[docs]\n    def get_vertical_line(self, point: Sequence[float], **kwargs: Any) -> Line:\n        \"\"\"A vertical line from the x-axis to a given point in the scene.\n\n        Parameters\n        ----------\n        point\n            The point to which the vertical line will be drawn.\n        kwargs\n            Additional parameters to be passed to :class:`get_line_from_axis_to_point`.\n\n        Returns\n        -------\n        :class:`Line`\n            A vertical line from the x-axis to the point.\n\n        Examples\n        --------\n        .. manim:: GetVerticalLineExample\n            :save_last_frame:\n\n            class GetVerticalLineExample(Scene):\n                def construct(self):\n                    ax = Axes().add_coordinates()\n                    point = ax.coords_to_point(-3.5, 2)\n\n                    dot = Dot(point)\n                    line = ax.get_vertical_line(point, line_config={\"dashed_ratio\": 0.85})\n\n                    self.add(ax, line, dot)\n\n\n        \"\"\"\n        return self.get_line_from_axis_to_point(0, point, **kwargs)\n\n\n\n[docs]\n    def get_horizontal_line(self, point: Sequence[float], **kwargs) -> Line:\n        \"\"\"A horizontal line from the y-axis to a given point in the scene.\n\n        Parameters\n        ----------\n        point\n            The point to which the horizontal line will be drawn.\n        kwargs\n            Additional parameters to be passed to :class:`get_line_from_axis_to_point`.\n\n        Returns\n        -------\n        :class:`Line`\n            A horizontal line from the y-axis to the point.\n\n        Examples\n        --------\n        .. manim:: GetHorizontalLineExample\n            :save_last_frame:\n\n            class GetHorizontalLineExample(Scene):\n                def construct(self):\n                    ax = Axes().add_coordinates()\n                    point = ax @ (-4, 1.5)\n\n                    dot = Dot(point)\n                    line = ax.get_horizontal_line(point, line_func=Line)\n\n                    self.add(ax, line, dot)\n        \"\"\"\n        return self.get_line_from_axis_to_point(1, point, **kwargs)\n\n\n\n[docs]\n    def get_lines_to_point(self, point: Sequence[float], **kwargs) -> VGroup:\n        \"\"\"Generate both horizontal and vertical lines from the axis to a point.\n\n        Parameters\n        ----------\n        point\n            A point on the scene.\n        kwargs\n            Additional parameters to be passed to :meth:`get_line_from_axis_to_point`\n\n        Returns\n        -------\n        :class:`~.VGroup`\n            A :class:`~.VGroup` of the horizontal and vertical lines.\n\n\n        .. seealso::\n            :meth:`~.CoordinateSystem.get_vertical_line`\n            :meth:`~.CoordinateSystem.get_horizontal_line`\n\n        Examples\n        --------\n        .. manim:: GetLinesToPointExample\n            :save_last_frame:\n\n            class GetLinesToPointExample(Scene):\n                def construct(self):\n                    ax = Axes()\n                    circ = Circle(radius=0.5).move_to([-4, -1.5, 0])\n\n                    lines_1 = ax.get_lines_to_point(circ.get_right(), color=GREEN_B)\n                    lines_2 = ax.get_lines_to_point(circ.get_corner(DL), color=BLUE_B)\n                    self.add(ax, lines_1, lines_2, circ)\n        \"\"\"\n        return VGroup(\n            self.get_horizontal_line(point, **kwargs),\n            self.get_vertical_line(point, **kwargs),\n        )\n\n\n    # graphing\n\n\n[docs]\n    def plot(\n        self,\n        function: Callable[[float], float],\n        x_range: Sequence[float] | None = None,\n        use_vectorized: bool = False,\n        colorscale: Union[Iterable[Color], Iterable[Color, float]] | None = None,\n        colorscale_axis: int = 1,\n        **kwargs: Any,\n    ) -> ParametricFunction:\n        \"\"\"Generates a curve based on a function.\n\n        Parameters\n        ----------\n        function\n            The function used to construct the :class:`~.ParametricFunction`.\n        x_range\n            The range of the curve along the axes. ``x_range = [x_min, x_max, x_step]``.\n        use_vectorized\n            Whether to pass in the generated t value array to the function. Only use this if your function supports it.\n            Output should be a numpy array of shape ``[y_0, y_1, ...]``\n        colorscale\n            Colors of the function. Optional parameter used when coloring a function by values. Passing a list of colors\n            and a colorscale_axis will color the function by y-value. Passing a list of tuples in the form ``(color, pivot)``\n            allows user-defined pivots where the color transitions.\n        colorscale_axis\n            Defines the axis on which the colorscale is applied (0 = x, 1 = y), default is y-axis (1).\n        kwargs\n            Additional parameters to be passed to :class:`~.ParametricFunction`.\n\n        Returns\n        -------\n        :class:`~.ParametricFunction`\n            The plotted curve.\n\n\n        .. warning::\n            This method may not produce accurate graphs since Manim currently relies on interpolation between\n            evenly-spaced samples of the curve, instead of intelligent plotting.\n            See the example below for some solutions to this problem.\n\n        Examples\n        --------\n        .. manim:: PlotExample\n            :save_last_frame:\n\n            class PlotExample(Scene):\n                def construct(self):\n                    # construct the axes\n                    ax_1 = Axes(\n                        x_range=[0.001, 6],\n                        y_range=[-8, 2],\n                        x_length=5,\n                        y_length=3,\n                        tips=False,\n                    )\n                    ax_2 = ax_1.copy()\n                    ax_3 = ax_1.copy()\n\n                    # position the axes\n                    ax_1.to_corner(UL)\n                    ax_2.to_corner(UR)\n                    ax_3.to_edge(DOWN)\n                    axes = VGroup(ax_1, ax_2, ax_3)\n\n                    # create the logarithmic curves\n                    def log_func(x):\n                        return np.log(x)\n\n                    # a curve without adjustments; poor interpolation.\n                    curve_1 = ax_1.plot(log_func, color=PURE_RED)\n\n                    # disabling interpolation makes the graph look choppy as not enough\n                    # inputs are available\n                    curve_2 = ax_2.plot(log_func, use_smoothing=False, color=ORANGE)\n\n                    # taking more inputs of the curve by specifying a step for the\n                    # x_range yields expected results, but increases rendering time.\n                    curve_3 = ax_3.plot(\n                        log_func, x_range=(0.001, 6, 0.001), color=PURE_GREEN\n                    )\n\n                    curves = VGroup(curve_1, curve_2, curve_3)\n\n                    self.add(axes, curves)\n        \"\"\"\n        t_range = np.array(self.x_range, dtype=float)\n        if x_range is not None:\n            t_range[: len(x_range)] = x_range\n\n        if x_range is None or len(x_range) < 3:\n            # if t_range has a defined step size, increase the number of sample points per tick\n            t_range[2] /= self.num_sampled_graph_points_per_tick\n        # For axes, the third coordinate of x_range indicates\n        # tick frequency.  But for functions, it indicates a\n        # sample frequency\n\n        graph = ParametricFunction(\n            lambda t: self.coords_to_point(t, function(t)),\n            t_range=t_range,\n            scaling=self.x_axis.scaling,\n            use_vectorized=use_vectorized,\n            **kwargs,\n        )\n\n        graph.underlying_function = function\n\n        if colorscale:\n            if type(colorscale[0]) in (list, tuple):\n                new_colors, pivots = [\n                    [i for i, j in colorscale],\n                    [j for i, j in colorscale],\n                ]\n            else:\n                new_colors = colorscale\n\n                ranges = [self.x_range, self.y_range]\n                pivot_min = ranges[colorscale_axis][0]\n                pivot_max = ranges[colorscale_axis][1]\n                pivot_frequency = (pivot_max - pivot_min) / (len(new_colors) - 1)\n                pivots = np.arange(\n                    start=pivot_min,\n                    stop=pivot_max + pivot_frequency,\n                    step=pivot_frequency,\n                )\n\n            resolution = 0.01 if len(x_range) == 2 else x_range[2]\n            sample_points = np.arange(x_range[0], x_range[1] + resolution, resolution)\n            color_list = []\n            for samp_x in sample_points:\n                axis_value = (samp_x, function(samp_x))[colorscale_axis]\n                if axis_value <= pivots[0]:\n                    color_list.append(new_colors[0])\n                elif axis_value >= pivots[-1]:\n                    color_list.append(new_colors[-1])\n                else:\n                    for i, pivot in enumerate(pivots):\n                        if pivot > axis_value:\n                            color_index = (axis_value - pivots[i - 1]) / (\n                                pivots[i] - pivots[i - 1]\n                            )\n                            color_index = min(color_index, 1)\n                            mob_color = interpolate_color(\n                                new_colors[i - 1],\n                                new_colors[i],\n                                color_index,\n                            )\n                            color_list.append(mob_color)\n                            break\n            if config.renderer == RendererType.OPENGL:\n                graph.set_color(color_list)\n            else:\n                graph.set_stroke(color_list)\n                graph.set_sheen_direction(RIGHT)\n\n        return graph\n\n\n\n[docs]\n    def plot_implicit_curve(\n        self,\n        func: Callable[[float, float], float],\n        min_depth: int = 5,\n        max_quads: int = 1500,\n        **kwargs: Any,\n    ) -> ImplicitFunction:\n        \"\"\"Creates the curves of an implicit function.\n\n        Parameters\n        ----------\n        func\n            The function to graph, in the form of f(x, y) = 0.\n        min_depth\n            The minimum depth of the function to calculate.\n        max_quads\n            The maximum number of quads to use.\n        kwargs\n            Additional parameters to pass into :class:`ImplicitFunction`.\n\n        Examples\n        --------\n        .. manim:: ImplicitExample\n            :save_last_frame:\n\n            class ImplicitExample(Scene):\n                def construct(self):\n                    ax = Axes()\n                    a = ax.plot_implicit_curve(\n                        lambda x, y: y * (x - y) ** 2 - 4 * x - 8, color=BLUE\n                    )\n                    self.add(ax, a)\n        \"\"\"\n        x_scale = self.get_x_axis().scaling\n        y_scale = self.get_y_axis().scaling\n        graph = ImplicitFunction(\n            func=(lambda x, y: func(x_scale.function(x), y_scale.function(y))),\n            x_range=self.x_range[:2],\n            y_range=self.y_range[:2],\n            min_depth=min_depth,\n            max_quads=max_quads,\n            **kwargs,\n        )\n        (\n            graph.stretch(self.get_x_unit_size(), 0, about_point=ORIGIN)\n            .stretch(self.get_y_unit_size(), 1, about_point=ORIGIN)\n            .shift(self.get_origin())\n        )\n        return graph\n\n\n\n[docs]\n    def plot_parametric_curve(\n        self,\n        function: Callable[[float], np.ndarray],\n        use_vectorized: bool = False,\n        **kwargs: Any,\n    ) -> ParametricFunction:\n        \"\"\"A parametric curve.\n\n        Parameters\n        ----------\n        function\n            A parametric function mapping a number to a point in the\n            coordinate system.\n        use_vectorized\n            Whether to pass in the generated t value array to the function. Only use this if your function supports it.\n        kwargs\n            Any further keyword arguments are passed to :class:`.ParametricFunction`.\n\n        Example\n        -------\n        .. manim:: ParametricCurveExample\n            :save_last_frame:\n\n            class ParametricCurveExample(Scene):\n                def construct(self):\n                    ax = Axes()\n                    cardioid = ax.plot_parametric_curve(\n                        lambda t: np.array(\n                            [\n                                np.exp(1) * np.cos(t) * (1 - np.cos(t)),\n                                np.exp(1) * np.sin(t) * (1 - np.cos(t)),\n                                0,\n                            ]\n                        ),\n                        t_range=[0, 2 * PI],\n                        color=\"#0FF1CE\",\n                    )\n                    self.add(ax, cardioid)\n        \"\"\"\n        dim = self.dimension\n        graph = ParametricFunction(\n            lambda t: self.coords_to_point(*function(t)[:dim]),\n            use_vectorized=use_vectorized,\n            **kwargs,\n        )\n        graph.underlying_function = function\n        return graph\n\n\n\n[docs]\n    def plot_polar_graph(\n        self,\n        r_func: Callable[[float], float],\n        theta_range: Sequence[float] | None = None,\n        **kwargs: Any,\n    ) -> ParametricFunction:\n        \"\"\"A polar graph.\n\n        Parameters\n        ----------\n        r_func\n            The function r of theta.\n        theta_range\n            The range of theta as ``theta_range = [theta_min, theta_max, theta_step]``.\n        kwargs\n            Additional parameters passed to :class:`~.ParametricFunction`.\n\n        Examples\n        --------\n        .. manim:: PolarGraphExample\n            :ref_classes: PolarPlane\n            :save_last_frame:\n\n            class PolarGraphExample(Scene):\n                def construct(self):\n                    plane = PolarPlane()\n                    r = lambda theta: 2 * np.sin(theta * 5)\n                    graph = plane.plot_polar_graph(r, [0, 2 * PI], color=ORANGE)\n                    self.add(plane, graph)\n        \"\"\"\n        theta_range = theta_range if theta_range is not None else [0, 2 * PI]\n        graph = ParametricFunction(\n            function=lambda th: self.pr2pt(r_func(th), th),\n            t_range=theta_range,\n            **kwargs,\n        )\n        graph.underlying_function = r_func\n        return graph\n\n\n\n[docs]\n    def plot_surface(\n        self,\n        function: Callable[[float], float],\n        u_range: Sequence[float] | None = None,\n        v_range: Sequence[float] | None = None,\n        colorscale: (\n            Sequence[ParsableManimColor]\n            | Sequence[tuple[ParsableManimColor, float]]\n            | None\n        ) = None,\n        colorscale_axis: int = 2,\n        **kwargs: Any,\n    ) -> Surface | OpenGLSurface:\n        \"\"\"Generates a surface based on a function.\n\n        Parameters\n        ----------\n        function\n            The function used to construct the :class:`~.Surface`.\n        u_range\n            The range of the ``u`` variable: ``(u_min, u_max)``.\n        v_range\n            The range of the ``v`` variable: ``(v_min, v_max)``.\n        colorscale\n            Colors of the surface. Passing a list of colors will color the surface by z-value.\n            Passing a list of tuples in the form ``(color, pivot)`` allows user-defined pivots\n            where the color transitions.\n        colorscale_axis\n            Defines the axis on which the colorscale is applied (0 = x, 1 = y, 2 = z), default\n            is z-axis (2).\n        kwargs\n            Additional parameters to be passed to :class:`~.Surface`.\n\n        Returns\n        -------\n        :class:`~.Surface`\n            The plotted surface.\n\n        Examples\n        --------\n        .. manim:: PlotSurfaceExample\n            :save_last_frame:\n\n            class PlotSurfaceExample(ThreeDScene):\n                def construct(self):\n                    resolution_fa = 16\n                    self.set_camera_orientation(phi=75 * DEGREES, theta=-60 * DEGREES)\n                    axes = ThreeDAxes(x_range=(-3, 3, 1), y_range=(-3, 3, 1), z_range=(-5, 5, 1))\n                    def param_trig(u, v):\n                        x = u\n                        y = v\n                        z = 2 * np.sin(x) + 2 * np.cos(y)\n                        return z\n                    trig_plane = axes.plot_surface(\n                        param_trig,\n                        resolution=(resolution_fa, resolution_fa),\n                        u_range = (-3, 3),\n                        v_range = (-3, 3),\n                        colorscale = [BLUE, GREEN, YELLOW, ORANGE, RED],\n                        )\n                    self.add(axes, trig_plane)\n        \"\"\"\n        if config.renderer == RendererType.CAIRO:\n            surface = Surface(\n                lambda u, v: self.c2p(u, v, function(u, v)),\n                u_range=u_range,\n                v_range=v_range,\n                **kwargs,\n            )\n            if colorscale:\n                surface.set_fill_by_value(\n                    axes=self.copy(),\n                    colorscale=colorscale,\n                    axis=colorscale_axis,\n                )\n        elif config.renderer == RendererType.OPENGL:\n            surface = OpenGLSurface(\n                lambda u, v: self.c2p(u, v, function(u, v)),\n                u_range=u_range,\n                v_range=v_range,\n                axes=self.copy(),\n                colorscale=colorscale,\n                colorscale_axis=colorscale_axis,\n                **kwargs,\n            )\n\n        return surface\n\n\n\n[docs]\n    def input_to_graph_point(\n        self,\n        x: float,\n        graph: ParametricFunction | VMobject,\n    ) -> Point3D:\n        \"\"\"Returns the coordinates of the point on a ``graph`` corresponding to an ``x`` value.\n\n        Parameters\n        ----------\n        x\n            The x-value of a point on the ``graph``.\n        graph\n            The :class:`~.ParametricFunction` on which the point lies.\n\n        Returns\n        -------\n        :class:`np.ndarray`\n            The coordinates of the point on the :attr:`graph` corresponding to the :attr:`x` value.\n\n        Raises\n        ------\n        :exc:`ValueError`\n            When the target x is not in the range of the line graph.\n\n        Examples\n        --------\n        .. manim:: InputToGraphPointExample\n            :save_last_frame:\n\n            class InputToGraphPointExample(Scene):\n                def construct(self):\n                    ax = Axes()\n                    curve = ax.plot(lambda x : np.cos(x))\n\n                    # move a square to PI on the cosine curve.\n                    position = ax.input_to_graph_point(x=PI, graph=curve)\n                    sq = Square(side_length=1, color=YELLOW).move_to(position)\n\n                    self.add(ax, curve, sq)\n        \"\"\"\n        if hasattr(graph, \"underlying_function\"):\n            return graph.function(x)\n        else:\n            alpha = binary_search(\n                function=lambda a: self.point_to_coords(graph.point_from_proportion(a))[\n                    0\n                ],\n                target=x,\n                lower_bound=0,\n                upper_bound=1,\n            )\n            if alpha is not None:\n                return graph.point_from_proportion(alpha)\n            else:\n                raise ValueError(\n                    f\"x={x} not located in the range of the graph ([{self.p2c(graph.get_start())[0]}, {self.p2c(graph.get_end())[0]}])\",\n                )\n\n\n\n[docs]\n    def input_to_graph_coords(\n        self, x: float, graph: ParametricFunction\n    ) -> tuple[float, float]:\n        \"\"\"Returns a tuple of the axis relative coordinates of the point\n        on the graph based on the x-value given.\n\n        Examples\n        --------\n        .. code-block:: pycon\nfrom manim import Axes\nax = Axes()\nparabola = ax.plot(lambda x: x**2)\nax.input_to_graph_coords(x=3, graph=parabola)\n            (3, 9)\n        \"\"\"\n        return x, graph.underlying_function(x)\n\n\n\n[docs]\n    def i2gc(self, x: float, graph: ParametricFunction) -> tuple[float, float]:\n        \"\"\"Alias for :meth:`input_to_graph_coords`.\"\"\"\n        return self.input_to_graph_coords(x, graph)\n\n\n\n[docs]\n    def i2gp(self, x: float, graph: ParametricFunction) -> np.ndarray:\n        \"\"\"Alias for :meth:`input_to_graph_point`.\"\"\"\n        return self.input_to_graph_point(x, graph)\n\n\n\n[docs]\n    def get_graph_label(\n        self,\n        graph: ParametricFunction,\n        label: float | str | Mobject = \"f(x)\",\n        x_val: float | None = None,\n        direction: Sequence[float] = RIGHT,\n        buff: float = MED_SMALL_BUFF,\n        color: ParsableManimColor | None = None,\n        dot: bool = False,\n        dot_config: dict[str, Any] | None = None,\n    ) -> Mobject:\n        r\"\"\"Creates a properly positioned label for the passed graph, with an optional dot.\n\n        Parameters\n        ----------\n        graph\n            The curve.\n        label\n            The label for the function's curve. Defaults to :class:`~.MathTex` for ``str`` and ``float`` inputs.\n        x_val\n            The x_value along the curve that positions the label.\n        direction\n            The cartesian position, relative to the curve that the label will be at --> ``LEFT``, ``RIGHT``.\n        buff\n            The distance between the curve and the label.\n        color\n            The color of the label. Defaults to the color of the curve.\n        dot\n            Whether to add a dot at the point on the graph.\n        dot_config\n            Additional parameters to be passed to :class:`~.Dot`.\n\n        Returns\n        -------\n        :class:`Mobject`\n            The positioned label and :class:`~.Dot`, if applicable.\n\n        Examples\n        --------\n        .. manim:: GetGraphLabelExample\n            :save_last_frame:\n\n            class GetGraphLabelExample(Scene):\n                def construct(self):\n                    ax = Axes()\n                    sin = ax.plot(lambda x: np.sin(x), color=PURPLE_B)\n                    label = ax.get_graph_label(\n                        graph=sin,\n                        label= MathTex(r\"\\frac{\\pi}{2}\"),\n                        x_val=PI / 2,\n                        dot=True,\n                        direction=UR,\n                    )\n\n                    self.add(ax, sin, label)\n        \"\"\"\n        if dot_config is None:\n            dot_config = {}\n        if color is None:\n            color = graph.get_color()\n        label = self.x_axis._create_label_tex(label).set_color(color)\n\n        if x_val is None:\n            # Search from right to left\n            for x in np.linspace(self.x_range[1], self.x_range[0], 100):\n                point = self.input_to_graph_point(x, graph)\n                if point[1] < config[\"frame_y_radius\"]:\n                    break\n        else:\n            point = self.input_to_graph_point(x_val, graph)\n\n        label.next_to(point, direction, buff=buff)\n        label.shift_onto_screen()\n\n        if dot:\n            dot = Dot(point=point, **dot_config)\n            label.add(dot)\n            label.dot = dot\n        return label\n\n\n    # calculus\n\n\n[docs]\n    def get_riemann_rectangles(\n        self,\n        graph: ParametricFunction,\n        x_range: Sequence[float] | None = None,\n        dx: float | None = 0.1,\n        input_sample_type: str = \"left\",\n        stroke_width: float = 1,\n        stroke_color: ParsableManimColor = BLACK,\n        fill_opacity: float = 1,\n        color: Iterable[ParsableManimColor] | ParsableManimColor = (BLUE, GREEN),\n        show_signed_area: bool = True,\n        bounded_graph: ParametricFunction = None,\n        blend: bool = False,\n        width_scale_factor: float = 1.001,\n    ) -> VGroup:\n        \"\"\"Generates a :class:`~.VGroup` of the Riemann Rectangles for a given curve.\n\n        Parameters\n        ----------\n        graph\n            The graph whose area will be approximated by Riemann rectangles.\n        x_range\n            The minimum and maximum x-values of the rectangles. ``x_range = [x_min, x_max]``.\n        dx\n            The change in x-value that separates each rectangle.\n        input_sample_type\n            Can be any of ``\"left\"``, ``\"right\"`` or ``\"center\"``. Refers to where\n            the sample point for the height of each Riemann Rectangle\n            will be inside the segments of the partition.\n        stroke_width\n            The stroke_width of the border of the rectangles.\n        stroke_color\n            The color of the border of the rectangle.\n        fill_opacity\n            The opacity of the rectangles.\n        color\n            The colors of the rectangles. Creates a balanced gradient if multiple colors are passed.\n        show_signed_area\n            Indicates negative area when the curve dips below the x-axis by inverting its color.\n        blend\n            Sets the :attr:`stroke_color` to :attr:`fill_color`, blending the rectangles without clear separation.\n        bounded_graph\n            If a secondary graph is specified, encloses the area between the two curves.\n        width_scale_factor\n            The factor by which the width of the rectangles is scaled.\n\n        Returns\n        -------\n        :class:`~.VGroup`\n            A :class:`~.VGroup` containing the Riemann Rectangles.\n\n        Examples\n        --------\n        .. manim:: GetRiemannRectanglesExample\n            :save_last_frame:\n\n            class GetRiemannRectanglesExample(Scene):\n                def construct(self):\n                    ax = Axes(y_range=[-2, 10])\n                    quadratic = ax.plot(lambda x: 0.5 * x ** 2 - 0.5)\n\n                    # the rectangles are constructed from their top right corner.\n                    # passing an iterable to `color` produces a gradient\n                    rects_right = ax.get_riemann_rectangles(\n                        quadratic,\n                        x_range=[-4, -3],\n                        dx=0.25,\n                        color=(TEAL, BLUE_B, DARK_BLUE),\n                        input_sample_type=\"right\",\n                    )\n\n                    # the colour of rectangles below the x-axis is inverted\n                    # due to show_signed_area\n                    rects_left = ax.get_riemann_rectangles(\n                        quadratic, x_range=[-1.5, 1.5], dx=0.15, color=YELLOW\n                    )\n\n                    bounding_line = ax.plot(\n                        lambda x: 1.5 * x, color=BLUE_B, x_range=[3.3, 6]\n                    )\n                    bounded_rects = ax.get_riemann_rectangles(\n                        bounding_line,\n                        bounded_graph=quadratic,\n                        dx=0.15,\n                        x_range=[4, 5],\n                        show_signed_area=False,\n                        color=(MAROON_A, RED_B, PURPLE_D),\n                    )\n\n                    self.add(\n                        ax, bounding_line, quadratic, rects_right, rects_left, bounded_rects\n                    )\n        \"\"\"\n        # setting up x_range, overwrite user's third input\n        if x_range is None:\n            if bounded_graph is None:\n                x_range = [graph.t_min, graph.t_max]\n            else:\n                x_min = max(graph.t_min, bounded_graph.t_min)\n                x_max = min(graph.t_max, bounded_graph.t_max)\n                x_range = [x_min, x_max]\n\n        x_range = [*x_range[:2], dx]\n\n        rectangles = VGroup()\n        x_range = np.arange(*x_range)\n\n        if isinstance(color, (list, tuple)):\n            color = [ManimColor(c) for c in color]\n        else:\n            color = [ManimColor(color)]\n\n        colors = color_gradient(color, len(x_range))\n\n        for x, color in zip(x_range, colors):\n            if input_sample_type == \"left\":\n                sample_input = x\n            elif input_sample_type == \"right\":\n                sample_input = x + dx\n            elif input_sample_type == \"center\":\n                sample_input = x + 0.5 * dx\n            else:\n                raise ValueError(\"Invalid input sample type\")\n            graph_point = self.input_to_graph_point(sample_input, graph)\n\n            if bounded_graph is None:\n                y_point = self._origin_shift(self.y_range)\n            else:\n                y_point = bounded_graph.underlying_function(x)\n\n            points = VGroup(\n                *list(\n                    map(\n                        VectorizedPoint,\n                        [\n                            self.coords_to_point(x, y_point),\n                            self.coords_to_point(x + width_scale_factor * dx, y_point),\n                            graph_point,\n                        ],\n                    ),\n                )\n            )\n\n            rect = Rectangle().replace(points, stretch=True)\n            rectangles.add(rect)\n\n            # checks if the rectangle is under the x-axis\n            if self.p2c(graph_point)[1] < y_point and show_signed_area:\n                color = invert_color(color)\n\n            # blends rectangles smoothly\n            if blend:\n                stroke_color = color\n\n            rect.set_style(\n                fill_color=color,\n                fill_opacity=fill_opacity,\n                stroke_color=stroke_color,\n                stroke_width=stroke_width,\n            )\n\n        return rectangles\n\n\n\n[docs]\n    def get_area(\n        self,\n        graph: ParametricFunction,\n        x_range: tuple[float, float] | None = None,\n        color: ParsableManimColor | Iterable[ParsableManimColor] = (BLUE, GREEN),\n        opacity: float = 0.3,\n        bounded_graph: ParametricFunction = None,\n        **kwargs: Any,\n    ) -> Polygon:\n        \"\"\"Returns a :class:`~.Polygon` representing the area under the graph passed.\n\n        Parameters\n        ----------\n        graph\n            The graph/curve for which the area needs to be gotten.\n        x_range\n            The range of the minimum and maximum x-values of the area. ``x_range = [x_min, x_max]``.\n        color\n            The color of the area. Creates a gradient if a list of colors is provided.\n        opacity\n            The opacity of the area.\n        bounded_graph\n            If a secondary :attr:`graph` is specified, encloses the area between the two curves.\n        kwargs\n            Additional parameters passed to :class:`~.Polygon`.\n\n        Returns\n        -------\n        :class:`~.Polygon`\n            The :class:`~.Polygon` representing the area.\n\n        Raises\n        ------\n        :exc:`ValueError`\n            When x_ranges do not match (either area x_range, graph's x_range or bounded_graph's x_range).\n\n        Examples\n        --------\n        .. manim:: GetAreaExample\n            :save_last_frame:\n\n            class GetAreaExample(Scene):\n                def construct(self):\n                    ax = Axes().add_coordinates()\n                    curve = ax.plot(lambda x: 2 * np.sin(x), color=DARK_BLUE)\n                    area = ax.get_area(\n                        curve,\n                        x_range=(PI / 2, 3 * PI / 2),\n                        color=(GREEN_B, GREEN_D),\n                        opacity=1,\n                    )\n\n                    self.add(ax, curve, area)\n        \"\"\"\n        if x_range is None:\n            a = graph.t_min\n            b = graph.t_max\n        else:\n            a, b = x_range\n        if bounded_graph is not None:\n            if bounded_graph.t_min > b:\n                raise ValueError(\n                    f\"Ranges not matching: {bounded_graph.t_min} < {b}\",\n                )\n            if bounded_graph.t_max < a:\n                raise ValueError(\n                    f\"Ranges not matching: {bounded_graph.t_max} > {a}\",\n                )\n            a = max(a, bounded_graph.t_min)\n            b = min(b, bounded_graph.t_max)\n\n        if bounded_graph is None:\n            points = (\n                [self.c2p(a), graph.function(a)]\n                + [p for p in graph.points if a <= self.p2c(p)[0] <= b]\n                + [graph.function(b), self.c2p(b)]\n            )\n        else:\n            graph_points, bounded_graph_points = (\n                [g.function(a)]\n                + [p for p in g.points if a <= self.p2c(p)[0] <= b]\n                + [g.function(b)]\n                for g in (graph, bounded_graph)\n            )\n            points = graph_points + bounded_graph_points[::-1]\n        return Polygon(*points, **kwargs).set_opacity(opacity).set_color(color)\n\n\n\n[docs]\n    def angle_of_tangent(\n        self,\n        x: float,\n        graph: ParametricFunction,\n        dx: float = 1e-8,\n    ) -> float:\n        \"\"\"Returns the angle to the x-axis of the tangent\n        to the plotted curve at a particular x-value.\n\n        Parameters\n        ----------\n        x\n            The x-value at which the tangent must touch the curve.\n        graph\n            The :class:`~.ParametricFunction` for which to calculate the tangent.\n        dx\n            The change in `x` used to determine the angle of the tangent to the curve.\n\n        Returns\n        -------\n        :class:`float`\n            The angle of the tangent to the curve.\n\n        Examples\n        --------\n        .. code-block:: python\n\n            ax = Axes()\n            curve = ax.plot(lambda x: x**2)\n            ax.angle_of_tangent(x=3, graph=curve)\n            # 1.4056476493802699\n        \"\"\"\n        p0 = np.array([*self.input_to_graph_coords(x, graph)])\n        p1 = np.array([*self.input_to_graph_coords(x + dx, graph)])\n        return angle_of_vector(p1 - p0)\n\n\n\n[docs]\n    def slope_of_tangent(\n        self, x: float, graph: ParametricFunction, **kwargs: Any\n    ) -> float:\n        \"\"\"Returns the slope of the tangent to the plotted curve\n        at a particular x-value.\n\n        Parameters\n        ----------\n        x\n            The x-value at which the tangent must touch the curve.\n        graph\n            The :class:`~.ParametricFunction` for which to calculate the tangent.\n\n        Returns\n        -------\n        :class:`float`\n            The slope of the tangent with the x axis.\n\n        Examples\n        --------\n        .. code-block:: python\n\n            ax = Axes()\n            curve = ax.plot(lambda x: x**2)\n            ax.slope_of_tangent(x=-2, graph=curve)\n            # -3.5000000259052038\n        \"\"\"\n        return np.tan(self.angle_of_tangent(x, graph, **kwargs))\n\n\n\n[docs]\n    def plot_derivative_graph(\n        self, graph: ParametricFunction, color: ParsableManimColor = GREEN, **kwargs\n    ) -> ParametricFunction:\n        \"\"\"Returns the curve of the derivative of the passed graph.\n\n        Parameters\n        ----------\n        graph\n            The graph for which the derivative will be found.\n        color\n            The color of the derivative curve.\n        kwargs\n            Any valid keyword argument of :class:`~.ParametricFunction`.\n\n        Returns\n        -------\n        :class:`~.ParametricFunction`\n            The curve of the derivative.\n\n        Examples\n        --------\n        .. manim:: DerivativeGraphExample\n            :save_last_frame:\n\n            class DerivativeGraphExample(Scene):\n                def construct(self):\n                    ax = NumberPlane(y_range=[-1, 7], background_line_style={\"stroke_opacity\": 0.4})\n\n                    curve_1 = ax.plot(lambda x: x ** 2, color=PURPLE_B)\n                    curve_2 = ax.plot_derivative_graph(curve_1)\n                    curves = VGroup(curve_1, curve_2)\n\n                    label_1 = ax.get_graph_label(curve_1, \"x^2\", x_val=-2, direction=DL)\n                    label_2 = ax.get_graph_label(curve_2, \"2x\", x_val=3, direction=RIGHT)\n                    labels = VGroup(label_1, label_2)\n\n                    self.add(ax, curves, labels)\n        \"\"\"\n\n        def deriv(x):\n            return self.slope_of_tangent(x, graph)\n\n        return self.plot(deriv, color=color, **kwargs)\n\n\n\n[docs]\n    def plot_antiderivative_graph(\n        self,\n        graph: ParametricFunction,\n        y_intercept: float = 0,\n        samples: int = 50,\n        use_vectorized: bool = False,\n        **kwargs: Any,\n    ) -> ParametricFunction:\n        \"\"\"Plots an antiderivative graph.\n\n        Parameters\n        ----------\n        graph\n            The graph for which the antiderivative will be found.\n        y_intercept\n            The y-value at which the graph intercepts the y-axis.\n        samples\n            The number of points to take the area under the graph.\n        use_vectorized\n            Whether to use the vectorized version of the antiderivative. This means\n            to pass in the generated t value array to the function. Only use this if your function supports it.\n            Output should be a numpy array of shape ``[y_0, y_1, ...]``\n        kwargs\n            Any valid keyword argument of :class:`~.ParametricFunction`.\n\n        Returns\n        -------\n        :class:`~.ParametricFunction`\n            The curve of the antiderivative.\n\n\n        .. note::\n            This graph is plotted from the values of area under the reference graph.\n            The result might not be ideal if the reference graph contains uncalculatable\n            areas from x=0.\n\n        Examples\n        --------\n        .. manim:: AntiderivativeExample\n            :save_last_frame:\n\n            class AntiderivativeExample(Scene):\n                def construct(self):\n                    ax = Axes()\n                    graph1 = ax.plot(\n                        lambda x: (x ** 2 - 2) / 3,\n                        color=RED,\n                    )\n                    graph2 = ax.plot_antiderivative_graph(graph1, color=BLUE)\n                    self.add(ax, graph1, graph2)\n        \"\"\"\n\n        def antideriv(x):\n            x_vals = np.linspace(0, x, samples, axis=1 if use_vectorized else 0)\n            f_vec = np.vectorize(graph.underlying_function)\n            y_vals = f_vec(x_vals)\n            return np.trapz(y_vals, x_vals) + y_intercept\n\n        return self.plot(antideriv, use_vectorized=use_vectorized, **kwargs)\n\n\n\n[docs]\n    def get_secant_slope_group(\n        self,\n        x: float,\n        graph: ParametricFunction,\n        dx: float | None = None,\n        dx_line_color: ParsableManimColor = YELLOW,\n        dy_line_color: ParsableManimColor | None = None,\n        dx_label: float | str | None = None,\n        dy_label: float | str | None = None,\n        include_secant_line: bool = True,\n        secant_line_color: ParsableManimColor = GREEN,\n        secant_line_length: float = 10,\n    ) -> VGroup:\n        \"\"\"Creates two lines representing `dx` and `df`, the labels for `dx` and `df`, and\n         the secant to the curve at a particular x-value.\n\n        Parameters\n        ----------\n        x\n            The x-value at which the secant intersects the graph for the first time.\n        graph\n            The curve for which the secant will be found.\n        dx\n            The change in `x` after which the secant exits.\n        dx_line_color\n            The color of the line that indicates the change in `x`.\n        dy_line_color\n            The color of the line that indicates the change in `y`. Defaults to the color of :attr:`graph`.\n        dx_label\n            The label for the `dx` line. Defaults to :class:`~.MathTex` for ``str`` and ``float`` inputs.\n        dy_label\n            The label for the `dy` line. Defaults to :class:`~.MathTex` for ``str`` and ``float`` inputs.\n        include_secant_line\n            Whether to include the secant line in the graph,\n            or just the df/dx lines and labels.\n        secant_line_color\n            The color of the secant line.\n        secant_line_length\n            The length of the secant line.\n\n        Returns\n        -------\n        :class:`~.VGroup`\n            A group containing the elements: `dx_line`, `df_line`, and\n            if applicable also :attr:`dx_label`, :attr:`df_label`, `secant_line`.\n\n        Examples\n        --------\n         .. manim:: GetSecantSlopeGroupExample\n            :save_last_frame:\n\n            class GetSecantSlopeGroupExample(Scene):\n                def construct(self):\n                    ax = Axes(y_range=[-1, 7])\n                    graph = ax.plot(lambda x: 1 / 4 * x ** 2, color=BLUE)\n                    slopes = ax.get_secant_slope_group(\n                        x=2.0,\n                        graph=graph,\n                        dx=1.0,\n                        dx_label=Tex(\"dx = 1.0\"),\n                        dy_label=\"dy\",\n                        dx_line_color=GREEN_B,\n                        secant_line_length=4,\n                        secant_line_color=RED_D,\n                    )\n\n                    self.add(ax, graph, slopes)\n        \"\"\"\n        group = VGroup()\n\n        dx = dx or float(self.x_range[1] - self.x_range[0]) / 10\n        dy_line_color = dy_line_color or graph.get_color()\n\n        p1 = self.input_to_graph_point(x, graph)\n        p2 = self.input_to_graph_point(x + dx, graph)\n        interim_point = p2[0] * RIGHT + p1[1] * UP\n\n        group.dx_line = Line(p1, interim_point, color=dx_line_color)\n        group.df_line = Line(interim_point, p2, color=dy_line_color)\n        group.add(group.dx_line, group.df_line)\n\n        labels = VGroup()\n        if dx_label is not None:\n            group.dx_label = self.x_axis._create_label_tex(dx_label)\n            labels.add(group.dx_label)\n            group.add(group.dx_label)\n        if dy_label is not None:\n            group.df_label = self.x_axis._create_label_tex(dy_label)\n            labels.add(group.df_label)\n            group.add(group.df_label)\n\n        if len(labels) > 0:\n            max_width = 0.8 * group.dx_line.width\n            max_height = 0.8 * group.df_line.height\n            if labels.width > max_width:\n                labels.width = max_width\n            if labels.height > max_height:\n                labels.height = max_height\n\n        if dx_label is not None:\n            group.dx_label.next_to(\n                group.dx_line,\n                np.sign(dx) * DOWN,\n                buff=group.dx_label.height / 2,\n            )\n            group.dx_label.set_color(group.dx_line.get_color())\n\n        if dy_label is not None:\n            group.df_label.next_to(\n                group.df_line,\n                np.sign(dx) * RIGHT,\n                buff=group.df_label.height / 2,\n            )\n            group.df_label.set_color(group.df_line.get_color())\n\n        if include_secant_line:\n            group.secant_line = Line(p1, p2, color=secant_line_color)\n            group.secant_line.scale(\n                secant_line_length / group.secant_line.get_length(),\n            )\n            group.add(group.secant_line)\n        return group\n\n\n\n[docs]\n    def get_vertical_lines_to_graph(\n        self,\n        graph: ParametricFunction,\n        x_range: Sequence[float] | None = None,\n        num_lines: int = 20,\n        **kwargs: Any,\n    ) -> VGroup:\n        \"\"\"Obtains multiple lines from the x-axis to the curve.\n\n        Parameters\n        ----------\n        graph\n            The graph along which the lines are placed.\n        x_range\n            A list containing the lower and and upper bounds of the lines: ``x_range = [x_min, x_max]``.\n        num_lines\n            The number of evenly spaced lines.\n        kwargs\n            Additional arguments to be passed to :meth:`~.CoordinateSystem.get_vertical_line`.\n\n        Returns\n        -------\n        :class:`~.VGroup`\n            The :class:`~.VGroup` of the evenly spaced lines.\n\n        Examples\n        --------\n        .. manim:: GetVerticalLinesToGraph\n            :save_last_frame:\n\n            class GetVerticalLinesToGraph(Scene):\n                def construct(self):\n                    ax = Axes(\n                        x_range=[0, 8.0, 1],\n                        y_range=[-1, 1, 0.2],\n                        axis_config={\"font_size\": 24},\n                    ).add_coordinates()\n\n                    curve = ax.plot(lambda x: np.sin(x) / np.e ** 2 * x)\n\n                    lines = ax.get_vertical_lines_to_graph(\n                        curve, x_range=[0, 4], num_lines=30, color=BLUE\n                    )\n\n                    self.add(ax, curve, lines)\n        \"\"\"\n        x_range = x_range if x_range is not None else self.x_range\n\n        return VGroup(\n            *(\n                self.get_vertical_line(self.i2gp(x, graph), **kwargs)\n                for x in np.linspace(x_range[0], x_range[1], num_lines)\n            )\n        )\n\n\n\n[docs]\n    def get_T_label(\n        self,\n        x_val: float,\n        graph: ParametricFunction,\n        label: float | str | Mobject | None = None,\n        label_color: ParsableManimColor | None = None,\n        triangle_size: float = MED_SMALL_BUFF,\n        triangle_color: ParsableManimColor | None = WHITE,\n        line_func: type[Line] = Line,\n        line_color: ParsableManimColor = YELLOW,\n    ) -> VGroup:\n        \"\"\"Creates a labelled triangle marker with a vertical line from the x-axis\n        to a curve at a given x-value.\n\n        Parameters\n        ----------\n        x_val\n            The position along the curve at which the label, line and triangle will be constructed.\n        graph\n            The :class:`~.ParametricFunction` for which to construct the label.\n        label\n            The label of the vertical line and triangle.\n        label_color\n            The color of the label.\n        triangle_size\n            The size of the triangle.\n        triangle_color\n            The color of the triangle.\n        line_func\n            The function used to construct the vertical line.\n        line_color\n            The color of the vertical line.\n\n        Returns\n        -------\n        :class:`~.VGroup`\n            A :class:`~.VGroup` of the label, triangle and vertical line mobjects.\n\n        Examples\n        --------\n        .. manim:: TLabelExample\n            :save_last_frame:\n\n            class TLabelExample(Scene):\n                def construct(self):\n                    # defines the axes and linear function\n                    axes = Axes(x_range=[-1, 10], y_range=[-1, 10], x_length=9, y_length=6)\n                    func = axes.plot(lambda x: x, color=BLUE)\n                    # creates the T_label\n                    t_label = axes.get_T_label(x_val=4, graph=func, label=Tex(\"x-value\"))\n                    self.add(axes, func, t_label)\n        \"\"\"\n        T_label_group = VGroup()\n        triangle = RegularPolygon(n=3, start_angle=np.pi / 2, stroke_width=0).set_fill(\n            color=triangle_color,\n            opacity=1,\n        )\n        triangle.height = triangle_size\n        triangle.move_to(self.coords_to_point(x_val, 0), UP)\n        if label is not None:\n            t_label = self.x_axis._create_label_tex(label, color=label_color)\n            t_label.next_to(triangle, DOWN)\n            T_label_group.add(t_label)\n\n        v_line = self.get_vertical_line(\n            self.i2gp(x_val, graph),\n            color=line_color,\n            line_func=line_func,\n        )\n\n        T_label_group.add(triangle, v_line)\n\n        return T_label_group\n\n\n    def __matmul__(self, coord: Point3DLike | Mobject):\n        if isinstance(coord, Mobject):\n            coord = coord.get_center()\n        return self.coords_to_point(*coord)\n\n    def __rmatmul__(self, point: Point3DLike):\n        return self.point_to_coords(point)\n\n\n\n\n[docs]\nclass Axes(VGroup, CoordinateSystem, metaclass=ConvertToOpenGL):\n    \"\"\"Creates a set of axes.\n\n    Parameters\n    ----------\n    x_range\n        The ``(x_min, x_max, x_step)`` values of the x-axis.\n    y_range\n        The ``(y_min, y_max, y_step)`` values of the y-axis.\n    x_length\n        The length of the x-axis.\n    y_length\n        The length of the y-axis.\n    axis_config\n        Arguments to be passed to :class:`~.NumberLine` that influences both axes.\n    x_axis_config\n        Arguments to be passed to :class:`~.NumberLine` that influence the x-axis.\n    y_axis_config\n        Arguments to be passed to :class:`~.NumberLine` that influence the y-axis.\n    tips\n        Whether or not to include the tips on both axes.\n    kwargs\n        Additional arguments to be passed to :class:`CoordinateSystem` and :class:`~.VGroup`.\n\n    Examples\n    --------\n    .. manim:: LogScalingExample\n        :save_last_frame:\n\n        class LogScalingExample(Scene):\n            def construct(self):\n                ax = Axes(\n                    x_range=[0, 10, 1],\n                    y_range=[-2, 6, 1],\n                    tips=False,\n                    axis_config={\"include_numbers\": True},\n                    y_axis_config={\"scaling\": LogBase(custom_labels=True)},\n                )\n\n                # x_min must be > 0 because log is undefined at 0.\n                graph = ax.plot(lambda x: x ** 2, x_range=[0.001, 10], use_smoothing=False)\n                self.add(ax, graph)\n\n    Styling arguments can be passed to the underlying :class:`.NumberLine`\n    mobjects that represent the axes:\n\n    .. manim:: AxesWithDifferentTips\n        :save_last_frame:\n\n        class AxesWithDifferentTips(Scene):\n            def construct(self):\n                ax = Axes(axis_config={'tip_shape': StealthTip})\n                self.add(ax)\n    \"\"\"\n\n    def __init__(\n        self,\n        x_range: Sequence[float] | None = None,\n        y_range: Sequence[float] | None = None,\n        x_length: float | None = round(config.frame_width) - 2,\n        y_length: float | None = round(config.frame_height) - 2,\n        axis_config: dict | None = None,\n        x_axis_config: dict | None = None,\n        y_axis_config: dict | None = None,\n        tips: bool = True,\n        **kwargs: Any,\n    ) -> None:\n        VGroup.__init__(self, **kwargs)\n        CoordinateSystem.__init__(self, x_range, y_range, x_length, y_length)\n\n        self.axis_config = {\n            \"include_tip\": tips,\n            \"numbers_to_exclude\": [0],\n        }\n        self.x_axis_config = {}\n        self.y_axis_config = {\"rotation\": 90 * DEGREES, \"label_direction\": LEFT}\n\n        self._update_default_configs(\n            (self.axis_config, self.x_axis_config, self.y_axis_config),\n            (axis_config, x_axis_config, y_axis_config),\n        )\n\n        self.x_axis_config = merge_dicts_recursively(\n            self.axis_config,\n            self.x_axis_config,\n        )\n        self.y_axis_config = merge_dicts_recursively(\n            self.axis_config,\n            self.y_axis_config,\n        )\n\n        # excluding the origin tick removes a tick at the 0-point of the axis\n        # This is desired for LinearBase because the 0 point is always the x-axis\n        # For non-LinearBase, the \"0-point\" does not have this quality, so it must be included.\n\n        # i.e. with LogBase range [-2, 4]:\n        # it would remove the \"0\" tick, which is actually 10^0,\n        # not the lowest tick on the graph (which is 10^-2).\n\n        if self.x_axis_config.get(\"scaling\") is None or isinstance(\n            self.x_axis_config.get(\"scaling\"), LinearBase\n        ):\n            self.x_axis_config[\"exclude_origin_tick\"] = True\n        else:\n            self.x_axis_config[\"exclude_origin_tick\"] = False\n\n        if self.y_axis_config.get(\"scaling\") is None or isinstance(\n            self.y_axis_config.get(\"scaling\"), LinearBase\n        ):\n            self.y_axis_config[\"exclude_origin_tick\"] = True\n        else:\n            self.y_axis_config[\"exclude_origin_tick\"] = False\n\n        self.x_axis = self._create_axis(self.x_range, self.x_axis_config, self.x_length)\n        self.y_axis = self._create_axis(self.y_range, self.y_axis_config, self.y_length)\n\n        # Add as a separate group in case various other\n        # mobjects are added to self, as for example in\n        # NumberPlane below\n        self.axes = VGroup(self.x_axis, self.y_axis)\n        self.add(*self.axes)\n\n        # finds the middle-point on each axis\n        lines_center_point = [\n            axis.scaling.function((axis.x_range[1] + axis.x_range[0]) / 2)\n            for axis in self.axes\n        ]\n\n        self.shift(-self.coords_to_point(*lines_center_point))\n\n\n[docs]\n    @staticmethod\n    def _update_default_configs(\n        default_configs: tuple[dict[Any, Any]], passed_configs: tuple[dict[Any, Any]]\n    ) -> None:\n        \"\"\"Takes in two tuples of dicts and return modifies the first such that values from\n        ``passed_configs`` overwrite values in ``default_configs``. If a key does not exist\n        in default_configs, it is added to the dict.\n\n        This method is useful for having defaults in a class and being able to overwrite\n        them with user-defined input.\n\n        Parameters\n        ----------\n        default_configs\n            The dict that will be updated.\n        passed_configs\n            The dict that will be used to update.\n\n        Examples\n        --------\n        To create a tuple with one dictionary, add a comma after the element:\n\n        .. code-block:: python\n\n            self._update_default_configs(\n                (dict_1,)(\n                    dict_2,\n                )\n            )\n        \"\"\"\n        for default_config, passed_config in zip(default_configs, passed_configs):\n            if passed_config is not None:\n                update_dict_recursively(default_config, passed_config)\n\n\n\n[docs]\n    def _create_axis(\n        self,\n        range_terms: Sequence[float],\n        axis_config: dict[str, Any],\n        length: float,\n    ) -> NumberLine:\n        \"\"\"Creates an axis and dynamically adjusts its position depending on where 0 is located on the line.\n\n        Parameters\n        ----------\n        range_terms\n            The range of the the axis : ``(x_min, x_max, x_step)``.\n        axis_config\n            Additional parameters that are passed to :class:`~.NumberLine`.\n        length\n            The length of the axis.\n\n        Returns\n        -------\n        :class:`NumberLine`\n            Returns a number line based on ``range_terms``.\n        \"\"\"\n        axis_config[\"length\"] = length\n        axis = NumberLine(range_terms, **axis_config)\n\n        # without the call to _origin_shift, graph does not exist when min > 0 or max < 0\n        # shifts the axis so that 0 is centered\n        axis.shift(-axis.number_to_point(self._origin_shift([axis.x_min, axis.x_max])))\n        return axis\n\n\n\n[docs]\n    def coords_to_point(\n        self, *coords: float | Sequence[float] | Sequence[Sequence[float]] | np.ndarray\n    ) -> np.ndarray:\n        \"\"\"Accepts coordinates from the axes and returns a point with respect to the scene.\n        Equivalent to `ax @ (coord1)`\n\n        Parameters\n        ----------\n        coords\n            The coordinates. Each coord is passed as a separate argument: ``ax.coords_to_point(1, 2, 3)``.\n\n            Also accepts a list of coordinates\n\n            ``ax.coords_to_point( [x_0, x_1, ...], [y_0, y_1, ...], ... )``\n\n            ``ax.coords_to_point( [[x_0, y_0, z_0], [x_1, y_1, z_1]] )``\n\n        Returns\n        -------\n        np.ndarray\n            A point with respect to the scene's coordinate system.\n            The shape of the array will be similar to the shape of the input.\n\n        Examples\n        --------\n\n        .. code-block:: pycon\nfrom manim import Axes\nimport numpy as np\nax = Axes()\nnp.around(ax.coords_to_point(1, 0, 0), 2)\n            array([0.86, 0.  , 0.  ])\nnp.around(ax @ (1, 0, 0), 2)\n            array([0.86, 0.  , 0.  ])\nnp.around(ax.coords_to_point([[0, 1], [1, 1], [1, 0]]), 2)\n            array([[0.  , 0.75, 0.  ],\n                   [0.86, 0.75, 0.  ],\n                   [0.86, 0.  , 0.  ]])\nnp.around(\n    ax.coords_to_point([0, 1, 1], [1, 1, 0]), 2\n)  # Transposed version of the above\n            array([[0.  , 0.86, 0.86],\n                   [0.75, 0.75, 0.  ],\n                   [0.  , 0.  , 0.  ]])\n\n        .. manim:: CoordsToPointExample\n            :save_last_frame:\n\n            class CoordsToPointExample(Scene):\n                def construct(self):\n                    ax = Axes().add_coordinates()\n\n                    # a dot with respect to the axes\n                    dot_axes = Dot(ax.coords_to_point(2, 2), color=GREEN)\n                    lines = ax.get_lines_to_point(ax.c2p(2,2))\n\n                    # a dot with respect to the scene\n                    # the default plane corresponds to the coordinates of the scene.\n                    plane = NumberPlane()\n                    dot_scene = Dot((2,2,0), color=RED)\n\n                    self.add(plane, dot_scene, ax, dot_axes, lines)\n        \"\"\"\n        coords = np.asarray(coords)\n        origin = self.x_axis.number_to_point(\n            self._origin_shift([self.x_axis.x_min, self.x_axis.x_max]),\n        )\n\n        # Is coords in the format ([[x1 y1 z1] [x2 y2 z2] ...])? (True)\n        # Or is coords in the format (x, y, z) or ([x1 x2 ...], [y1 y2 ...], [z1 z2 ...])? (False)\n        # The latter is preferred.\n        are_coordinates_transposed = False\n\n        # If coords is in the format ([[x1 y1 z1] [x2 y2 z2] ...]):\n        if coords.ndim == 3:\n            # Extract from original tuple: now coords looks like [[x y z]] or [[x1 y1 z1] [x2 y2 z2] ...].\n            coords = coords[0]\n            # If there's a single coord (coords = [[x y z]]), extract it so that\n            # coords = [x y z] and coords_to_point returns a single point.\n            if coords.shape[0] == 1:\n                coords = coords[0]\n            # Else, if coords looks more like [[x1 y1 z1] [x2 y2 z2] ...], transform them (by\n            # transposing) into the format [[x1 x2 ...] [y1 y2 ...] [z1 z2 ...]] for later processing.\n            else:\n                coords = coords.T\n                are_coordinates_transposed = True\n        # Otherwise, coords already looked like (x, y, z) or ([x1 x2 ...], [y1 y2 ...], [z1 z2 ...]),\n        # so no further processing is needed.\n\n        # Now coords should either look like [x y z] or [[x1 x2 ...] [y1 y2 ...] [z1 z2 ...]],\n        # so it can be iterated directly. Each element is either a float representing a single\n        # coordinate, or a float ndarray of coordinates corresponding to a single axis.\n        # Although \"points\" and \"nums\" are in plural, there might be a single point or number.\n        points = self.x_axis.number_to_point(coords[0])\n        other_axes = self.axes.submobjects[1:]\n        for axis, nums in zip(other_axes, coords[1:]):\n            points += axis.number_to_point(nums) - origin\n\n        # Return points as is, except if coords originally looked like\n        # ([x1 x2 ...], [y1 y2 ...], [z1 z2 ...]), which is determined by the conditions below. In\n        # that case, the current implementation requires that the results have to be transposed.\n        if are_coordinates_transposed or points.ndim == 1:\n            return points\n        return points.T\n\n\n\n[docs]\n    def point_to_coords(self, point: Sequence[float]) -> np.ndarray:\n        \"\"\"Accepts a point from the scene and returns its coordinates with respect to the axes.\n\n        Parameters\n        ----------\n        point\n            The point, i.e. ``RIGHT`` or ``[0, 1, 0]``.\n            Also accepts a list of points as ``[RIGHT, [0, 1, 0]]``.\n\n        Returns\n        -------\n        np.ndarray[float]\n            The coordinates on the axes, i.e. ``[4.0, 7.0]``.\n            Or a list of coordinates if `point` is a list of points.\n\n        Examples\n        --------\n\n        .. code-block:: pycon\nfrom manim import Axes, RIGHT\nimport numpy as np\nax = Axes(x_range=[0, 10, 2])\nnp.around(ax.point_to_coords(RIGHT), 2)\n            array([5.83, 0.  ])\nnp.around(ax.point_to_coords([[0, 0, 1], [1, 0, 0]]), 2)\n            array([[5.  , 0.  ],\n                   [5.83, 0.  ]])\n\n\n        .. manim:: PointToCoordsExample\n            :save_last_frame:\n\n            class PointToCoordsExample(Scene):\n                def construct(self):\n                    ax = Axes(x_range=[0, 10, 2]).add_coordinates()\n                    circ = Circle(radius=0.5).shift(UR * 2)\n\n                    # get the coordinates of the circle with respect to the axes\n                    coords = np.around(ax.point_to_coords(circ.get_right()), decimals=2)\n\n                    label = (\n                        Matrix([[coords[0]], [coords[1]]]).scale(0.75).next_to(circ, RIGHT)\n                    )\n\n                    self.add(ax, circ, label, Dot(circ.get_right()))\n        \"\"\"\n        point = np.asarray(point)\n        result = np.asarray([axis.point_to_number(point) for axis in self.get_axes()])\n        if point.ndim == 2:\n            return result.T\n        return result\n\n\n\n[docs]\n    def get_axes(self) -> VGroup:\n        \"\"\"Gets the axes.\n\n        Returns\n        -------\n        :class:`~.VGroup`\n            A pair of axes.\n        \"\"\"\n        return self.axes\n\n\n\n[docs]\n    def get_axis_labels(\n        self,\n        x_label: float | str | Mobject = \"x\",\n        y_label: float | str | Mobject = \"y\",\n    ) -> VGroup:\n        \"\"\"Defines labels for the x-axis and y-axis of the graph.\n\n        For increased control over the position of the labels,\n        use :meth:`~.CoordinateSystem.get_x_axis_label` and\n        :meth:`~.CoordinateSystem.get_y_axis_label`.\n\n        Parameters\n        ----------\n        x_label\n            The label for the x_axis. Defaults to :class:`~.MathTex` for ``str`` and ``float`` inputs.\n        y_label\n            The label for the y_axis. Defaults to :class:`~.MathTex` for ``str`` and ``float`` inputs.\n\n        Returns\n        -------\n        :class:`~.VGroup`\n            A :class:`~.VGroup` of the labels for the x_axis and y_axis.\n\n\n        .. seealso::\n            :meth:`~.CoordinateSystem.get_x_axis_label`\n            :meth:`~.CoordinateSystem.get_y_axis_label`\n\n        Examples\n        --------\n        .. manim:: GetAxisLabelsExample\n            :save_last_frame:\n\n            class GetAxisLabelsExample(Scene):\n                def construct(self):\n                    ax = Axes()\n                    labels = ax.get_axis_labels(\n                        Tex(\"x-axis\").scale(0.7), Text(\"y-axis\").scale(0.45)\n                    )\n                    self.add(ax, labels)\n        \"\"\"\n        self.axis_labels = VGroup(\n            self.get_x_axis_label(x_label),\n            self.get_y_axis_label(y_label),\n        )\n        return self.axis_labels\n\n\n\n[docs]\n    def plot_line_graph(\n        self,\n        x_values: Iterable[float],\n        y_values: Iterable[float],\n        z_values: Iterable[float] | None = None,\n        line_color: ParsableManimColor = YELLOW,\n        add_vertex_dots: bool = True,\n        vertex_dot_radius: float = DEFAULT_DOT_RADIUS,\n        vertex_dot_style: dict[str, Any] | None = None,\n        **kwargs: Any,\n    ) -> VDict:\n        \"\"\"Draws a line graph.\n\n        The graph connects the vertices formed from zipping\n        ``x_values``, ``y_values`` and ``z_values``. Also adds :class:`Dots <.Dot>` at the\n        vertices if ``add_vertex_dots`` is set to ``True``.\n\n        Parameters\n        ----------\n        x_values\n            Iterable of values along the x-axis.\n        y_values\n            Iterable of values along the y-axis.\n        z_values\n            Iterable of values (zeros if z_values is None) along the z-axis.\n        line_color\n            Color for the line graph.\n        add_vertex_dots\n            Whether or not to add :class:`~.Dot` at each vertex.\n        vertex_dot_radius\n            Radius for the :class:`~.Dot` at each vertex.\n        vertex_dot_style\n            Style arguments to be passed into :class:`~.Dot` at each vertex.\n        kwargs\n            Additional arguments to be passed into :class:`~.VMobject`.\n\n        Returns\n        -------\n        :class:`~.VDict`\n            A VDict containing both the line and dots (if specified). The line can be accessed with: ``line_graph[\"line_graph\"]``.\n            The dots can be accessed with: ``line_graph[\"vertex_dots\"]``.\n\n        Examples\n        --------\n        .. manim:: LineGraphExample\n            :save_last_frame:\n\n            class LineGraphExample(Scene):\n                def construct(self):\n                    plane = NumberPlane(\n                        x_range = (0, 7),\n                        y_range = (0, 5),\n                        x_length = 7,\n                        axis_config={\"include_numbers\": True},\n                    )\n                    plane.center()\n                    line_graph = plane.plot_line_graph(\n                        x_values = [0, 1.5, 2, 2.8, 4, 6.25],\n                        y_values = [1, 3, 2.25, 4, 2.5, 1.75],\n                        line_color=GOLD_E,\n                        vertex_dot_style=dict(stroke_width=3,  fill_color=PURPLE),\n                        stroke_width = 4,\n                    )\n                    self.add(plane, line_graph)\n        \"\"\"\n        x_values, y_values = map(np.array, (x_values, y_values))\n        if z_values is None:\n            z_values = np.zeros(x_values.shape)\n\n        line_graph = VDict()\n        graph = VGroup(color=line_color, **kwargs)\n\n        vertices = [\n            self.coords_to_point(x, y, z)\n            for x, y, z in zip(x_values, y_values, z_values)\n        ]\n        graph.set_points_as_corners(vertices)\n        line_graph[\"line_graph\"] = graph\n\n        if add_vertex_dots:\n            vertex_dot_style = vertex_dot_style or {}\n            vertex_dots = VGroup(\n                *(\n                    Dot(point=vertex, radius=vertex_dot_radius, **vertex_dot_style)\n                    for vertex in vertices\n                )\n            )\n            line_graph[\"vertex_dots\"] = vertex_dots\n\n        return line_graph\n\n\n\n[docs]\n    @staticmethod\n    def _origin_shift(axis_range: Sequence[float]) -> float:\n        \"\"\"Determines how to shift graph mobjects to compensate when 0 is not on the axis.\n\n        Parameters\n        ----------\n        axis_range\n            The range of the axis : ``(x_min, x_max, x_step)``.\n        \"\"\"\n        if axis_range[0] > 0:\n            # min greater than 0\n            return axis_range[0]\n        if axis_range[1] < 0:\n            # max less than 0\n            return axis_range[1]\n        else:\n            return 0\n\n\n\n\n\n[docs]\nclass ThreeDAxes(Axes):\n    \"\"\"A 3-dimensional set of axes.\n\n    Parameters\n    ----------\n    x_range\n        The ``[x_min, x_max, x_step]`` values of the x-axis.\n    y_range\n        The ``[y_min, y_max, y_step]`` values of the y-axis.\n    z_range\n        The ``[z_min, z_max, z_step]`` values of the z-axis.\n    x_length\n        The length of the x-axis.\n    y_length\n        The length of the y-axis.\n    z_length\n        The length of the z-axis.\n    z_axis_config\n        Arguments to be passed to :class:`~.NumberLine` that influence the z-axis.\n    z_normal\n        The direction of the normal.\n    num_axis_pieces\n        The number of pieces used to construct the axes.\n    light_source\n        The direction of the light source.\n    depth\n        Currently non-functional.\n    gloss\n        Currently non-functional.\n    kwargs\n        Additional arguments to be passed to :class:`Axes`.\n    \"\"\"\n\n    def __init__(\n        self,\n        x_range: Sequence[float] | None = (-6, 6, 1),\n        y_range: Sequence[float] | None = (-5, 5, 1),\n        z_range: Sequence[float] | None = (-4, 4, 1),\n        x_length: float | None = config.frame_height + 2.5,\n        y_length: float | None = config.frame_height + 2.5,\n        z_length: float | None = config.frame_height - 1.5,\n        z_axis_config: dict[str, Any] | None = None,\n        z_normal: Vector3D = DOWN,\n        num_axis_pieces: int = 20,\n        light_source: Sequence[float] = 9 * DOWN + 7 * LEFT + 10 * OUT,\n        # opengl stuff (?)\n        depth=None,\n        gloss=0.5,\n        **kwargs: dict[str, Any],\n    ) -> None:\n        super().__init__(\n            x_range=x_range,\n            x_length=x_length,\n            y_range=y_range,\n            y_length=y_length,\n            **kwargs,\n        )\n\n        self.z_range = z_range\n        self.z_length = z_length\n\n        self.z_axis_config = {}\n        self._update_default_configs((self.z_axis_config,), (z_axis_config,))\n        self.z_axis_config = merge_dicts_recursively(\n            self.axis_config,\n            self.z_axis_config,\n        )\n\n        self.z_normal = z_normal\n        self.num_axis_pieces = num_axis_pieces\n\n        self.light_source = light_source\n\n        self.dimension = 3\n\n        if self.z_axis_config.get(\"scaling\") is None or isinstance(\n            self.z_axis_config.get(\"scaling\"), LinearBase\n        ):\n            self.z_axis_config[\"exclude_origin_tick\"] = True\n        else:\n            self.z_axis_config[\"exclude_origin_tick\"] = False\n\n        z_axis = self._create_axis(self.z_range, self.z_axis_config, self.z_length)\n\n        # [ax.x_min, ax.x_max] used to account for LogBase() scaling\n        # where ax.x_range[0] != ax.x_min\n        z_origin = self._origin_shift([z_axis.x_min, z_axis.x_max])\n\n        z_axis.rotate_about_number(z_origin, -PI / 2, UP)\n        z_axis.rotate_about_number(z_origin, angle_of_vector(self.z_normal))\n        z_axis.shift(-z_axis.number_to_point(z_origin))\n        z_axis.shift(\n            self.x_axis.number_to_point(\n                self._origin_shift([self.x_axis.x_min, self.x_axis.x_max]),\n            ),\n        )\n\n        self.axes.add(z_axis)\n        self.add(z_axis)\n        self.z_axis = z_axis\n\n        if config.renderer == RendererType.CAIRO:\n            self._add_3d_pieces()\n            self._set_axis_shading()\n\n    def _add_3d_pieces(self) -> None:\n        for axis in self.axes:\n            axis.pieces = VGroup(*axis.get_pieces(self.num_axis_pieces))\n            axis.add(axis.pieces)\n            axis.set_stroke(width=0, family=False)\n            axis.set_shade_in_3d(True)\n\n    def _set_axis_shading(self) -> None:\n        def make_func(axis):\n            vect = self.light_source\n            return lambda: (\n                axis.get_edge_center(-vect),\n                axis.get_edge_center(vect),\n            )\n\n        for axis in self:\n            for submob in axis.family_members_with_points():\n                submob.get_gradient_start_and_end_points = make_func(axis)\n                submob.get_unit_normal = lambda a: np.ones(3)\n                submob.set_sheen(0.2)\n\n\n[docs]\n    def get_y_axis_label(\n        self,\n        label: float | str | Mobject,\n        edge: Sequence[float] = UR,\n        direction: Sequence[float] = UR,\n        buff: float = SMALL_BUFF,\n        rotation: float = PI / 2,\n        rotation_axis: Vector3D = OUT,\n        **kwargs,\n    ) -> Mobject:\n        \"\"\"Generate a y-axis label.\n\n        Parameters\n        ----------\n        label\n            The label. Defaults to :class:`~.MathTex` for ``str`` and ``float`` inputs.\n        edge\n            The edge of the y-axis to which the label will be added, by default ``UR``.\n        direction\n            Allows for further positioning of the label from an edge, by default ``UR``.\n        buff\n            The distance of the label from the line, by default ``SMALL_BUFF``.\n        rotation\n            The angle at which to rotate the label, by default ``PI/2``.\n        rotation_axis\n            The axis about which to rotate the label, by default ``OUT``.\n\n        Returns\n        -------\n        :class:`~.Mobject`\n            The positioned label.\n\n        Examples\n        --------\n        .. manim:: GetYAxisLabelExample\n            :save_last_frame:\n\n            class GetYAxisLabelExample(ThreeDScene):\n                def construct(self):\n                    ax = ThreeDAxes()\n                    lab = ax.get_y_axis_label(Tex(\"$y$-label\"))\n                    self.set_camera_orientation(phi=2*PI/5, theta=PI/5)\n                    self.add(ax, lab)\n        \"\"\"\n        positioned_label = self._get_axis_label(\n            label, self.get_y_axis(), edge, direction, buff=buff, **kwargs\n        )\n        positioned_label.rotate(rotation, axis=rotation_axis)\n        return positioned_label\n\n\n\n[docs]\n    def get_z_axis_label(\n        self,\n        label: float | str | Mobject,\n        edge: Vector3D = OUT,\n        direction: Vector3D = RIGHT,\n        buff: float = SMALL_BUFF,\n        rotation: float = PI / 2,\n        rotation_axis: Vector3D = RIGHT,\n        **kwargs: Any,\n    ) -> Mobject:\n        \"\"\"Generate a z-axis label.\n\n        Parameters\n        ----------\n        label\n            The label. Defaults to :class:`~.MathTex` for ``str`` and ``float`` inputs.\n        edge\n            The edge of the z-axis to which the label will be added, by default ``OUT``.\n        direction\n            Allows for further positioning of the label from an edge, by default ``RIGHT``.\n        buff\n            The distance of the label from the line, by default ``SMALL_BUFF``.\n        rotation\n            The angle at which to rotate the label, by default ``PI/2``.\n        rotation_axis\n            The axis about which to rotate the label, by default ``RIGHT``.\n\n        Returns\n        -------\n        :class:`~.Mobject`\n            The positioned label.\n\n        Examples\n        --------\n        .. manim:: GetZAxisLabelExample\n            :save_last_frame:\n\n            class GetZAxisLabelExample(ThreeDScene):\n                def construct(self):\n                    ax = ThreeDAxes()\n                    lab = ax.get_z_axis_label(Tex(\"$z$-label\"))\n                    self.set_camera_orientation(phi=2*PI/5, theta=PI/5)\n                    self.add(ax, lab)\n        \"\"\"\n        positioned_label = self._get_axis_label(\n            label, self.get_z_axis(), edge, direction, buff=buff, **kwargs\n        )\n        positioned_label.rotate(rotation, axis=rotation_axis)\n        return positioned_label\n\n\n\n[docs]\n    def get_axis_labels(\n        self,\n        x_label: float | str | Mobject = \"x\",\n        y_label: float | str | Mobject = \"y\",\n        z_label: float | str | Mobject = \"z\",\n    ) -> VGroup:\n        \"\"\"Defines labels for the x_axis and y_axis of the graph.\n\n        For increased control over the position of the labels,\n        use :meth:`~.CoordinateSystem.get_x_axis_label`,\n        :meth:`~.ThreeDAxes.get_y_axis_label`, and\n        :meth:`~.ThreeDAxes.get_z_axis_label`.\n\n        Parameters\n        ----------\n        x_label\n            The label for the x_axis. Defaults to :class:`~.MathTex` for ``str`` and ``float`` inputs.\n        y_label\n            The label for the y_axis. Defaults to :class:`~.MathTex` for ``str`` and ``float`` inputs.\n        z_label\n            The label for the z_axis. Defaults to :class:`~.MathTex` for ``str`` and ``float`` inputs.\n\n        Returns\n        -------\n        :class:`~.VGroup`\n            A :class:`~.VGroup` of the labels for the x_axis, y_axis, and z_axis.\n\n\n        .. seealso::\n            :meth:`~.CoordinateSystem.get_x_axis_label`\n            :meth:`~.ThreeDAxes.get_y_axis_label`\n            :meth:`~.ThreeDAxes.get_z_axis_label`\n\n        Examples\n        --------\n        .. manim:: GetAxisLabelsExample\n            :save_last_frame:\n\n            class GetAxisLabelsExample(ThreeDScene):\n                def construct(self):\n                    self.set_camera_orientation(phi=2*PI/5, theta=PI/5)\n                    axes = ThreeDAxes()\n                    labels = axes.get_axis_labels(\n                        Text(\"x-axis\").scale(0.7), Text(\"y-axis\").scale(0.45), Text(\"z-axis\").scale(0.45)\n                    )\n                    self.add(axes, labels)\n        \"\"\"\n        self.axis_labels = VGroup(\n            self.get_x_axis_label(x_label),\n            self.get_y_axis_label(y_label),\n            self.get_z_axis_label(z_label),\n        )\n        return self.axis_labels\n\n\n\n\n\n[docs]\nclass NumberPlane(Axes):\n    \"\"\"Creates a cartesian plane with background lines.\n\n    Parameters\n    ----------\n    x_range\n        The ``[x_min, x_max, x_step]`` values of the plane in the horizontal direction.\n    y_range\n        The ``[y_min, y_max, y_step]`` values of the plane in the vertical direction.\n    x_length\n        The width of the plane.\n    y_length\n        The height of the plane.\n    background_line_style\n        Arguments that influence the construction of the background lines of the plane.\n    faded_line_style\n        Similar to :attr:`background_line_style`, affects the construction of the scene's background lines.\n    faded_line_ratio\n        Determines the number of boxes within the background lines: :code:`2` = 4 boxes, :code:`3` = 9 boxes.\n    make_smooth_after_applying_functions\n        Currently non-functional.\n    kwargs\n        Additional arguments to be passed to :class:`Axes`.\n\n\n    .. note::\n        If :attr:`x_length` or :attr:`y_length` are not defined, they are automatically calculated such that\n        one unit on each axis is one Manim unit long.\n\n    Examples\n    --------\n    .. manim:: NumberPlaneExample\n        :save_last_frame:\n\n        class NumberPlaneExample(Scene):\n            def construct(self):\n                number_plane = NumberPlane(\n                    background_line_style={\n                        \"stroke_color\": TEAL,\n                        \"stroke_width\": 4,\n                        \"stroke_opacity\": 0.6\n                    }\n                )\n                self.add(number_plane)\n\n    .. manim:: NumberPlaneScaled\n        :save_last_frame:\n\n        class NumberPlaneScaled(Scene):\n            def construct(self):\n                number_plane = NumberPlane(\n                    x_range=(-4, 11, 1),\n                    y_range=(-3, 3, 1),\n                    x_length=5,\n                    y_length=2,\n                ).move_to(LEFT*3)\n\n                number_plane_scaled_y = NumberPlane(\n                    x_range=(-4, 11, 1),\n                    x_length=5,\n                    y_length=4,\n                ).move_to(RIGHT*3)\n\n                self.add(number_plane)\n                self.add(number_plane_scaled_y)\n    \"\"\"\n\n    def __init__(\n        self,\n        x_range: Sequence[float] | None = (\n            -config[\"frame_x_radius\"],\n            config[\"frame_x_radius\"],\n            1,\n        ),\n        y_range: Sequence[float] | None = (\n            -config[\"frame_y_radius\"],\n            config[\"frame_y_radius\"],\n            1,\n        ),\n        x_length: float | None = None,\n        y_length: float | None = None,\n        background_line_style: dict[str, Any] | None = None,\n        faded_line_style: dict[str, Any] | None = None,\n        faded_line_ratio: int = 1,\n        make_smooth_after_applying_functions: bool = True,\n        **kwargs: dict[str, Any],\n    ):\n        # configs\n        self.axis_config = {\n            \"stroke_width\": 2,\n            \"include_ticks\": False,\n            \"include_tip\": False,\n            \"line_to_number_buff\": SMALL_BUFF,\n            \"label_direction\": DR,\n            \"font_size\": 24,\n        }\n        self.y_axis_config = {\"label_direction\": DR}\n        self.background_line_style = {\n            \"stroke_color\": BLUE_D,\n            \"stroke_width\": 2,\n            \"stroke_opacity\": 1,\n        }\n\n        self._update_default_configs(\n            (self.axis_config, self.y_axis_config, self.background_line_style),\n            (\n                kwargs.pop(\"axis_config\", None),\n                kwargs.pop(\"y_axis_config\", None),\n                background_line_style,\n            ),\n        )\n\n        # Defaults to a faded version of line_config\n        self.faded_line_style = faded_line_style\n        self.faded_line_ratio = faded_line_ratio\n        self.make_smooth_after_applying_functions = make_smooth_after_applying_functions\n\n        # init\n        super().__init__(\n            x_range=x_range,\n            y_range=y_range,\n            x_length=x_length,\n            y_length=y_length,\n            axis_config=self.axis_config,\n            y_axis_config=self.y_axis_config,\n            **kwargs,\n        )\n\n        self._init_background_lines()\n\n\n[docs]\n    def _init_background_lines(self) -> None:\n        \"\"\"Will init all the lines of NumberPlanes (faded or not)\"\"\"\n        if self.faded_line_style is None:\n            style = dict(self.background_line_style)\n            # For anything numerical, like stroke_width\n            # and stroke_opacity, chop it in half\n            for key in style:\n                if isinstance(style[key], numbers.Number):\n                    style[key] *= 0.5\n            self.faded_line_style = style\n\n        self.background_lines, self.faded_lines = self._get_lines()\n\n        self.background_lines.set_style(\n            **self.background_line_style,\n        )\n        self.faded_lines.set_style(\n            **self.faded_line_style,\n        )\n        self.add_to_back(\n            self.faded_lines,\n            self.background_lines,\n        )\n\n\n\n[docs]\n    def _get_lines(self) -> tuple[VGroup, VGroup]:\n        \"\"\"Generate all the lines, faded and not faded.\n         Two sets of lines are generated: one parallel to the X-axis, and parallel to the Y-axis.\n\n        Returns\n        -------\n        Tuple[:class:`~.VGroup`, :class:`~.VGroup`]\n            The first (i.e the non faded lines) and second (i.e the faded lines) sets of lines, respectively.\n        \"\"\"\n        x_axis = self.get_x_axis()\n        y_axis = self.get_y_axis()\n\n        x_lines1, x_lines2 = self._get_lines_parallel_to_axis(\n            x_axis,\n            y_axis,\n            self.y_axis.x_range[2],\n            self.faded_line_ratio,\n        )\n\n        y_lines1, y_lines2 = self._get_lines_parallel_to_axis(\n            y_axis,\n            x_axis,\n            self.x_axis.x_range[2],\n            self.faded_line_ratio,\n        )\n\n        # TODO this was added so that we can run tests on NumberPlane\n        # In the future these attributes will be tacked onto self.background_lines\n        self.x_lines = x_lines1\n        self.y_lines = y_lines1\n        lines1 = VGroup(*x_lines1, *y_lines1)\n        lines2 = VGroup(*x_lines2, *y_lines2)\n\n        return lines1, lines2\n\n\n\n[docs]\n    def _get_lines_parallel_to_axis(\n        self,\n        axis_parallel_to: NumberLine,\n        axis_perpendicular_to: NumberLine,\n        freq: float,\n        ratio_faded_lines: int,\n    ) -> tuple[VGroup, VGroup]:\n        \"\"\"Generate a set of lines parallel to an axis.\n\n        Parameters\n        ----------\n        axis_parallel_to\n            The axis with which the lines will be parallel.\n        axis_perpendicular_to\n            The axis with which the lines will be perpendicular.\n        ratio_faded_lines\n            The ratio between the space between faded lines and the space between non-faded lines.\n        freq\n            Frequency of non-faded lines (number of non-faded lines per graph unit).\n\n        Returns\n        -------\n        Tuple[:class:`~.VGroup`, :class:`~.VGroup`]\n            The first (i.e the non-faded lines parallel to `axis_parallel_to`) and second\n             (i.e the faded lines parallel to `axis_parallel_to`) sets of lines, respectively.\n        \"\"\"\n        line = Line(axis_parallel_to.get_start(), axis_parallel_to.get_end())\n        if ratio_faded_lines == 0:  # don't show faded lines\n            ratio_faded_lines = 1  # i.e. set ratio to 1\n        step = (1 / ratio_faded_lines) * freq\n        lines1 = VGroup()\n        lines2 = VGroup()\n        unit_vector_axis_perp_to = axis_perpendicular_to.get_unit_vector()\n\n        # need to unpack all three values\n        x_min, x_max, _ = axis_perpendicular_to.x_range\n\n        # account for different axis scalings (logarithmic), where\n        # negative values do not exist and [-2 , 4] should output lines\n        # similar to [0, 6]\n        if axis_perpendicular_to.x_min > 0 and x_min < 0:\n            x_min, x_max = (0, np.abs(x_min) + np.abs(x_max))\n\n        # min/max used in case range does not include 0. i.e. if (2,6):\n        # the range becomes (0,4), not (0,6).\n        ranges = (\n            [0],\n            np.arange(step, min(x_max - x_min, x_max), step),\n            np.arange(-step, max(x_min - x_max, x_min), -step),\n        )\n\n        for inputs in ranges:\n            for k, x in enumerate(inputs):\n                new_line = line.copy()\n                new_line.shift(unit_vector_axis_perp_to * x)\n                if (k + 1) % ratio_faded_lines == 0:\n                    lines1.add(new_line)\n                else:\n                    lines2.add(new_line)\n        return lines1, lines2\n\n\n    def get_vector(self, coords: Sequence[ManimFloat], **kwargs: Any) -> Arrow:\n        kwargs[\"buff\"] = 0\n        return Arrow(\n            self.coords_to_point(0, 0), self.coords_to_point(*coords), **kwargs\n        )\n\n    def prepare_for_nonlinear_transform(self, num_inserted_curves: int = 50) -> Self:\n        for mob in self.family_members_with_points():\n            num_curves = mob.get_num_curves()\n            if num_inserted_curves > num_curves:\n                mob.insert_n_curves(num_inserted_curves - num_curves)\n        return self\n\n\n\n\n[docs]\nclass PolarPlane(Axes):\n    r\"\"\"Creates a polar plane with background lines.\n\n    Parameters\n    ----------\n    azimuth_step\n        The number of divisions in the azimuth (also known as the `angular coordinate` or `polar angle`). If ``None`` is specified then it will use the default\n        specified by ``azimuth_units``:\n\n        - ``\"PI radians\"`` or ``\"TAU radians\"``: 20\n        - ``\"degrees\"``: 36\n        - ``\"gradians\"``: 40\n        - ``None``: 1\n\n        A non-integer value will result in a partial division at the end of the circle.\n\n    size\n        The diameter of the plane.\n\n    radius_step\n        The distance between faded radius lines.\n\n    radius_max\n        The maximum value of the radius.\n\n    azimuth_units\n        Specifies a default labelling system for the azimuth. Choices are:\n\n        - ``\"PI radians\"``: Fractional labels in the interval :math:`\\left[0, 2\\pi\\right]` with :math:`\\pi` as a constant.\n        - ``\"TAU radians\"``: Fractional labels in the interval :math:`\\left[0, \\tau\\right]` (where :math:`\\tau = 2\\pi`) with :math:`\\tau` as a constant.\n        - ``\"degrees\"``: Decimal labels in the interval :math:`\\left[0, 360\\right]` with a degree (:math:`^{\\circ}`) symbol.\n        - ``\"gradians\"``: Decimal labels in the interval :math:`\\left[0, 400\\right]` with a superscript \"g\" (:math:`^{g}`).\n        - ``None``: Decimal labels in the interval :math:`\\left[0, 1\\right]`.\n\n    azimuth_compact_fraction\n        If the ``azimuth_units`` choice has fractional labels, choose whether to\n        combine the constant in a compact form :math:`\\tfrac{xu}{y}` as opposed to\n        :math:`\\tfrac{x}{y}u`, where :math:`u` is the constant.\n\n    azimuth_offset\n        The angle offset of the azimuth, expressed in radians.\n\n    azimuth_direction\n        The direction of the azimuth.\n\n        - ``\"CW\"``: Clockwise.\n        - ``\"CCW\"``: Anti-clockwise.\n\n    azimuth_label_buff\n        The buffer for the azimuth labels.\n\n    azimuth_label_font_size\n        The font size of the azimuth labels.\n\n    radius_config\n        The axis config for the radius.\n\n    Examples\n    --------\n    .. manim:: PolarPlaneExample\n        :ref_classes: PolarPlane\n        :save_last_frame:\n\n        class PolarPlaneExample(Scene):\n            def construct(self):\n                polarplane_pi = PolarPlane(\n                    azimuth_units=\"PI radians\",\n                    size=6,\n                    azimuth_label_font_size=33.6,\n                    radius_config={\"font_size\": 33.6},\n                ).add_coordinates()\n                self.add(polarplane_pi)\n    \"\"\"\n\n    def __init__(\n        self,\n        radius_max: float = config[\"frame_y_radius\"],\n        size: float | None = None,\n        radius_step: float = 1,\n        azimuth_step: float | None = None,\n        azimuth_units: str | None = \"PI radians\",\n        azimuth_compact_fraction: bool = True,\n        azimuth_offset: float = 0,\n        azimuth_direction: str = \"CCW\",\n        azimuth_label_buff: float = SMALL_BUFF,\n        azimuth_label_font_size: float = 24,\n        radius_config: dict[str, Any] | None = None,\n        background_line_style: dict[str, Any] | None = None,\n        faded_line_style: dict[str, Any] | None = None,\n        faded_line_ratio: int = 1,\n        make_smooth_after_applying_functions: bool = True,\n        **kwargs: Any,\n    ) -> None:\n        # error catching\n        if azimuth_units in [\"PI radians\", \"TAU radians\", \"degrees\", \"gradians\", None]:\n            self.azimuth_units = azimuth_units\n        else:\n            raise ValueError(\n                \"Invalid azimuth units. Expected one of: PI radians, TAU radians, degrees, gradians or None.\",\n            )\n\n        if azimuth_direction in [\"CW\", \"CCW\"]:\n            self.azimuth_direction = azimuth_direction\n        else:\n            raise ValueError(\"Invalid azimuth units. Expected one of: CW, CCW.\")\n\n        # configs\n        self.radius_config = {\n            \"stroke_width\": 2,\n            \"include_ticks\": False,\n            \"include_tip\": False,\n            \"line_to_number_buff\": SMALL_BUFF,\n            \"label_direction\": DL,\n            \"font_size\": 24,\n        }\n\n        self.background_line_style = {\n            \"stroke_color\": BLUE_D,\n            \"stroke_width\": 2,\n            \"stroke_opacity\": 1,\n        }\n\n        self.azimuth_step = (\n            (\n                {\n                    \"PI radians\": 20,\n                    \"TAU radians\": 20,\n                    \"degrees\": 36,\n                    \"gradians\": 40,\n                    None: 1,\n                }[azimuth_units]\n            )\n            if azimuth_step is None\n            else azimuth_step\n        )\n\n        self._update_default_configs(\n            (self.radius_config, self.background_line_style),\n            (radius_config, background_line_style),\n        )\n\n        # Defaults to a faded version of line_config\n        self.faded_line_style = faded_line_style\n        self.faded_line_ratio = faded_line_ratio\n        self.make_smooth_after_applying_functions = make_smooth_after_applying_functions\n        self.azimuth_offset = azimuth_offset\n        self.azimuth_label_buff = azimuth_label_buff\n        self.azimuth_label_font_size = azimuth_label_font_size\n        self.azimuth_compact_fraction = azimuth_compact_fraction\n\n        # init\n\n        super().__init__(\n            x_range=np.array((-radius_max, radius_max, radius_step)),\n            y_range=np.array((-radius_max, radius_max, radius_step)),\n            x_length=size,\n            y_length=size,\n            axis_config=self.radius_config,\n            **kwargs,\n        )\n\n        self._init_background_lines()\n\n\n[docs]\n    def _init_background_lines(self) -> None:\n        \"\"\"Will init all the lines of NumberPlanes (faded or not)\"\"\"\n        if self.faded_line_style is None:\n            style = dict(self.background_line_style)\n            # For anything numerical, like stroke_width\n            # and stroke_opacity, chop it in half\n            for key in style:\n                if isinstance(style[key], numbers.Number):\n                    style[key] *= 0.5\n            self.faded_line_style = style\n\n        self.background_lines, self.faded_lines = self._get_lines()\n        self.background_lines.set_style(\n            **self.background_line_style,\n        )\n        self.faded_lines.set_style(\n            **self.faded_line_style,\n        )\n        self.add_to_back(\n            self.faded_lines,\n            self.background_lines,\n        )\n\n\n\n[docs]\n    def _get_lines(self) -> tuple[VGroup, VGroup]:\n        \"\"\"Generate all the lines and circles, faded and not faded.\n\n        Returns\n        -------\n        Tuple[:class:`~.VGroup`, :class:`~.VGroup`]\n            The first (i.e the non faded lines and circles) and second (i.e the faded lines and circles) sets of lines and circles, respectively.\n        \"\"\"\n        center = self.get_origin()\n        ratio_faded_lines = self.faded_line_ratio\n        offset = self.azimuth_offset\n\n        if ratio_faded_lines == 0:  # don't show faded lines\n            ratio_faded_lines = 1  # i.e. set ratio to 1\n        rstep = (1 / ratio_faded_lines) * self.x_axis.x_range[2]\n        astep = (1 / ratio_faded_lines) * (TAU * (1 / self.azimuth_step))\n        rlines1 = VGroup()\n        rlines2 = VGroup()\n        alines1 = VGroup()\n        alines2 = VGroup()\n\n        rinput = np.arange(0, self.x_axis.x_range[1] + rstep, rstep)\n        ainput = np.arange(0, TAU, astep)\n\n        unit_vector = self.x_axis.get_unit_vector()[0]\n\n        for k, x in enumerate(rinput):\n            new_line = Circle(radius=x * unit_vector)\n            if k % ratio_faded_lines == 0:\n                alines1.add(new_line)\n            else:\n                alines2.add(new_line)\n\n        line = Line(center, self.get_x_axis().get_end())\n\n        for k, x in enumerate(ainput):\n            new_line = line.copy()\n            new_line.rotate(x + offset, about_point=center)\n            if k % ratio_faded_lines == 0:\n                rlines1.add(new_line)\n            else:\n                rlines2.add(new_line)\n\n        lines1 = VGroup(*rlines1, *alines1)\n        lines2 = VGroup(*rlines2, *alines2)\n        return lines1, lines2\n\n\n\n[docs]\n    def get_axes(self) -> VGroup:\n        \"\"\"Gets the axes.\n\n        Returns\n        -------\n        :class:`~.VGroup`\n            A pair of axes.\n        \"\"\"\n        return self.axes\n\n\n    def get_vector(self, coords: Sequence[ManimFloat], **kwargs: Any) -> Arrow:\n        kwargs[\"buff\"] = 0\n        return Arrow(\n            self.coords_to_point(0, 0), self.coords_to_point(*coords), **kwargs\n        )\n\n    def prepare_for_nonlinear_transform(self, num_inserted_curves: int = 50) -> Self:\n        for mob in self.family_members_with_points():\n            num_curves = mob.get_num_curves()\n            if num_inserted_curves > num_curves:\n                mob.insert_n_curves(num_inserted_curves - num_curves)\n        return self\n\n\n[docs]\n    def get_coordinate_labels(\n        self,\n        r_values: Iterable[float] | None = None,\n        a_values: Iterable[float] | None = None,\n        **kwargs: Any,\n    ) -> VDict:\n        \"\"\"Gets labels for the coordinates\n\n        Parameters\n        ----------\n        r_values\n            Iterable of values along the radius, by default None.\n        a_values\n            Iterable of values along the azimuth, by default None.\n\n        Returns\n        -------\n        VDict\n            Labels for the radius and azimuth values.\n        \"\"\"\n        if r_values is None:\n            r_values = [r for r in self.get_x_axis().get_tick_range() if r >= 0]\n        if a_values is None:\n            a_values = np.arange(0, 1, 1 / self.azimuth_step)\n        r_mobs = self.get_x_axis().add_numbers(r_values)\n        if self.azimuth_direction == \"CCW\":\n            d = 1\n        elif self.azimuth_direction == \"CW\":\n            d = -1\n        else:\n            raise ValueError(\"Invalid azimuth direction. Expected one of: CW, CCW\")\n        a_points = [\n            {\n                \"label\": i,\n                \"point\": np.array(\n                    [\n                        self.get_right()[0]\n                        * np.cos(d * (i * TAU) + self.azimuth_offset),\n                        self.get_right()[0]\n                        * np.sin(d * (i * TAU) + self.azimuth_offset),\n                        0,\n                    ],\n                ),\n            }\n            for i in a_values\n        ]\n        if self.azimuth_units == \"PI radians\" or self.azimuth_units == \"TAU radians\":\n            a_tex = [\n                self.get_radian_label(\n                    i[\"label\"],\n                    font_size=self.azimuth_label_font_size,\n                ).next_to(\n                    i[\"point\"],\n                    direction=i[\"point\"],\n                    aligned_edge=i[\"point\"],\n                    buff=self.azimuth_label_buff,\n                )\n                for i in a_points\n            ]\n        elif self.azimuth_units == \"degrees\":\n            a_tex = [\n                MathTex(\n                    f\"{360 * i['label']:g}\" + r\"^{\\circ}\",\n                    font_size=self.azimuth_label_font_size,\n                ).next_to(\n                    i[\"point\"],\n                    direction=i[\"point\"],\n                    aligned_edge=i[\"point\"],\n                    buff=self.azimuth_label_buff,\n                )\n                for i in a_points\n            ]\n        elif self.azimuth_units == \"gradians\":\n            a_tex = [\n                MathTex(\n                    f\"{400 * i['label']:g}\" + r\"^{g}\",\n                    font_size=self.azimuth_label_font_size,\n                ).next_to(\n                    i[\"point\"],\n                    direction=i[\"point\"],\n                    aligned_edge=i[\"point\"],\n                    buff=self.azimuth_label_buff,\n                )\n                for i in a_points\n            ]\n        elif self.azimuth_units is None:\n            a_tex = [\n                MathTex(\n                    f\"{i['label']:g}\",\n                    font_size=self.azimuth_label_font_size,\n                ).next_to(\n                    i[\"point\"],\n                    direction=i[\"point\"],\n                    aligned_edge=i[\"point\"],\n                    buff=self.azimuth_label_buff,\n                )\n                for i in a_points\n            ]\n        a_mobs = VGroup(*a_tex)\n        self.coordinate_labels = VGroup(r_mobs, a_mobs)\n        return self.coordinate_labels\n\n\n\n[docs]\n    def add_coordinates(\n        self,\n        r_values: Iterable[float] | None = None,\n        a_values: Iterable[float] | None = None,\n    ) -> Self:\n        \"\"\"Adds the coordinates.\n\n        Parameters\n        ----------\n        r_values\n            Iterable of values along the radius, by default None.\n        a_values\n            Iterable of values along the azimuth, by default None.\n        \"\"\"\n        self.add(self.get_coordinate_labels(r_values, a_values))\n        return self\n\n\n    def get_radian_label(self, number, font_size: float = 24, **kwargs: Any) -> MathTex:\n        constant_label = {\"PI radians\": r\"\\pi\", \"TAU radians\": r\"\\tau\"}[\n            self.azimuth_units\n        ]\n        division = number * {\"PI radians\": 2, \"TAU radians\": 1}[self.azimuth_units]\n        frac = fr.Fraction(division).limit_denominator(max_denominator=100)\n        if frac.numerator == 0 & frac.denominator == 0:\n            string = r\"0\"\n        elif frac.numerator == 1 and frac.denominator == 1:\n            string = constant_label\n        elif frac.numerator == 1:\n            if self.azimuth_compact_fraction:\n                string = (\n                    r\"\\tfrac{\" + constant_label + r\"}{\" + str(frac.denominator) + \"}\"\n                )\n            else:\n                string = r\"\\tfrac{1}{\" + str(frac.denominator) + \"}\" + constant_label\n        elif frac.denominator == 1:\n            string = str(frac.numerator) + constant_label\n\n        else:\n            if self.azimuth_compact_fraction:\n                string = (\n                    r\"\\tfrac{\"\n                    + str(frac.numerator)\n                    + constant_label\n                    + r\"}{\"\n                    + str(frac.denominator)\n                    + r\"}\"\n                )\n            else:\n                string = (\n                    r\"\\tfrac{\"\n                    + str(frac.numerator)\n                    + r\"}{\"\n                    + str(frac.denominator)\n                    + r\"}\"\n                    + constant_label\n                )\n\n        return MathTex(string, font_size=font_size, **kwargs)\n\n\n\n\n[docs]\nclass ComplexPlane(NumberPlane):\n    \"\"\"A :class:`~.NumberPlane` specialized for use with complex numbers.\n\n    Examples\n    --------\n    .. manim:: ComplexPlaneExample\n        :save_last_frame:\n        :ref_classes: Dot MathTex\n\n        class ComplexPlaneExample(Scene):\n            def construct(self):\n                plane = ComplexPlane().add_coordinates()\n                self.add(plane)\n                d1 = Dot(plane.n2p(2 + 1j), color=YELLOW)\n                d2 = Dot(plane.n2p(-3 - 2j), color=YELLOW)\n                label1 = MathTex(\"2+i\").next_to(d1, UR, 0.1)\n                label2 = MathTex(\"-3-2i\").next_to(d2, UR, 0.1)\n                self.add(\n                    d1,\n                    label1,\n                    d2,\n                    label2,\n                )\n\n    \"\"\"\n\n    def __init__(self, **kwargs: Any) -> None:\n        super().__init__(\n            **kwargs,\n        )\n\n\n[docs]\n    def number_to_point(self, number: float | complex) -> np.ndarray:\n        \"\"\"Accepts a float/complex number and returns the equivalent point on the plane.\n\n        Parameters\n        ----------\n        number\n            The number. Can be a float or a complex number.\n\n        Returns\n        -------\n        np.ndarray\n            The point on the plane.\n        \"\"\"\n        number = complex(number)\n        return self.coords_to_point(number.real, number.imag)\n\n\n\n[docs]\n    def n2p(self, number: float | complex) -> np.ndarray:\n        \"\"\"Abbreviation for :meth:`number_to_point`.\"\"\"\n        return self.number_to_point(number)\n\n\n\n[docs]\n    def point_to_number(self, point: Point3DLike) -> complex:\n        \"\"\"Accepts a point and returns a complex number equivalent to that point on the plane.\n\n        Parameters\n        ----------\n        point\n            The point in manim's coordinate-system\n\n        Returns\n        -------\n        complex\n            A complex number consisting of real and imaginary components.\n        \"\"\"\n        x, y = self.point_to_coords(point)\n        return complex(x, y)\n\n\n\n[docs]\n    def p2n(self, point: Point3DLike) -> complex:\n        \"\"\"Abbreviation for :meth:`point_to_number`.\"\"\"\n        return self.point_to_number(point)\n\n\n\n[docs]\n    def _get_default_coordinate_values(self) -> list[float | complex]:\n        \"\"\"Generate a list containing the numerical values of the plane's labels.\n\n        Returns\n        -------\n        List[float | complex]\n            A list of floats representing the x-axis and complex numbers representing the y-axis.\n        \"\"\"\n        x_numbers = self.get_x_axis().get_tick_range()\n        y_numbers = self.get_y_axis().get_tick_range()\n        y_numbers = [complex(0, y) for y in y_numbers if y != 0]\n        return [*x_numbers, *y_numbers]\n\n\n\n[docs]\n    def get_coordinate_labels(\n        self, *numbers: Iterable[float | complex], **kwargs: Any\n    ) -> VGroup:\n        \"\"\"Generates the :class:`~.DecimalNumber` mobjects for the coordinates of the plane.\n\n        Parameters\n        ----------\n        numbers\n            An iterable of floats/complex numbers. Floats are positioned along the x-axis, complex numbers along the y-axis.\n        kwargs\n            Additional arguments to be passed to :meth:`~.NumberLine.get_number_mobject`, i.e. :class:`~.DecimalNumber`.\n\n        Returns\n        -------\n        :class:`~.VGroup`\n            A :class:`~.VGroup` containing the positioned label mobjects.\n        \"\"\"\n        # TODO: Make this work the same as coord_sys.add_coordinates()\n        if len(numbers) == 0:\n            numbers = self._get_default_coordinate_values()\n\n        self.coordinate_labels = VGroup()\n        for number in numbers:\n            z = complex(number)\n            if abs(z.imag) > abs(z.real):\n                axis = self.get_y_axis()\n                value = z.imag\n                kwargs[\"unit\"] = \"i\"\n            else:\n                axis = self.get_x_axis()\n                value = z.real\n            number_mob = axis.get_number_mobject(value, **kwargs)\n            self.coordinate_labels.add(number_mob)\n        return self.coordinate_labels\n\n\n\n[docs]\n    def add_coordinates(\n        self, *numbers: Iterable[float | complex], **kwargs: Any\n    ) -> Self:\n        \"\"\"Adds the labels produced from :meth:`~.NumberPlane.get_coordinate_labels` to the plane.\n\n        Parameters\n        ----------\n        numbers\n            An iterable of floats/complex numbers. Floats are positioned along the x-axis, complex numbers along the y-axis.\n        kwargs\n            Additional arguments to be passed to :meth:`~.NumberLine.get_number_mobject`, i.e. :class:`~.DecimalNumber`.\n        \"\"\"\n        self.add(self.get_coordinate_labels(*numbers, **kwargs))\n        return self", "code_sha1": "2ad7aa94c1de6971733495d30b154c0e46deb9e8"}
{"url": "https://docs.manim.community/en/stable/_modules/manim/mobject/graphing/functions.html", "depth": 2, "instruction": "The code defines three classes for visualizing mathematical functions in Manim: `ParametricFunction`, `FunctionGraph`, and `ImplicitFunction`. Each class generates curves based on specified mathematical functions, with customizable properties like color, range, and smoothing. The visual output includes colorful, smooth curves plotted in a 2D or 3D space, with potential animations for dynamic presentations.", "code": "\"\"\"Mobjects representing function graphs.\"\"\"\n\nfrom __future__ import annotations\n\n__all__ = [\"ParametricFunction\", \"FunctionGraph\", \"ImplicitFunction\"]\n\n\nfrom collections.abc import Iterable, Sequence\nfrom typing import TYPE_CHECKING, Callable\n\nimport numpy as np\nfrom isosurfaces import plot_isoline\n\nfrom manim import config\nfrom manim.mobject.graphing.scale import LinearBase, _ScaleBase\nfrom manim.mobject.opengl.opengl_compatibility import ConvertToOpenGL\nfrom manim.mobject.types.vectorized_mobject import VMobject\n\nif TYPE_CHECKING:\n    from typing_extensions import Self\n\n    from manim.typing import Point3D, Point3DLike\n\nfrom manim.utils.color import YELLOW\n\n\n\n[docs]\nclass ParametricFunction(VMobject, metaclass=ConvertToOpenGL):\n    \"\"\"A parametric curve.\n\n    Parameters\n    ----------\n    function\n        The function to be plotted in the form of ``(lambda t: (x(t), y(t), z(t)))``\n    t_range\n        Determines the length that the function spans in the form of (t_min, t_max, step=0.01). By default ``[0, 1]``\n    scaling\n        Scaling class applied to the points of the function. Default of :class:`~.LinearBase`.\n    use_smoothing\n        Whether to interpolate between the points of the function after they have been created.\n        (Will have odd behaviour with a low number of points)\n    use_vectorized\n        Whether to pass in the generated t value array to the function as ``[t_0, t_1, ...]``.\n        Only use this if your function supports it. Output should be a numpy array\n        of shape ``[[x_0, x_1, ...], [y_0, y_1, ...], [z_0, z_1, ...]]`` but ``z`` can\n        also be 0 if the Axes is 2D\n    discontinuities\n        Values of t at which the function experiences discontinuity.\n    dt\n        The left and right tolerance for the discontinuities.\n\n\n    Examples\n    --------\n    .. manim:: PlotParametricFunction\n        :save_last_frame:\n\n        class PlotParametricFunction(Scene):\n            def func(self, t):\n                return (np.sin(2 * t), np.sin(3 * t), 0)\n\n            def construct(self):\n                func = ParametricFunction(self.func, t_range = (0, TAU), fill_opacity=0).set_color(RED)\n                self.add(func.scale(3))\n\n    .. manim:: ThreeDParametricSpring\n        :save_last_frame:\n\n        class ThreeDParametricSpring(ThreeDScene):\n            def construct(self):\n                curve1 = ParametricFunction(\n                    lambda u: (\n                        1.2 * np.cos(u),\n                        1.2 * np.sin(u),\n                        u * 0.05\n                    ), color=RED, t_range = (-3*TAU, 5*TAU, 0.01)\n                ).set_shade_in_3d(True)\n                axes = ThreeDAxes()\n                self.add(axes, curve1)\n                self.set_camera_orientation(phi=80 * DEGREES, theta=-60 * DEGREES)\n                self.wait()\n\n    .. attention::\n        If your function has discontinuities, you'll have to specify the location\n        of the discontinuities manually. See the following example for guidance.\n\n    .. manim:: DiscontinuousExample\n        :save_last_frame:\n\n        class DiscontinuousExample(Scene):\n            def construct(self):\n                ax1 = NumberPlane((-3, 3), (-4, 4))\n                ax2 = NumberPlane((-3, 3), (-4, 4))\n                VGroup(ax1, ax2).arrange()\n                discontinuous_function = lambda x: (x ** 2 - 2) / (x ** 2 - 4)\n                incorrect = ax1.plot(discontinuous_function, color=RED)\n                correct = ax2.plot(\n                    discontinuous_function,\n                    discontinuities=[-2, 2],  # discontinuous points\n                    dt=0.1,  # left and right tolerance of discontinuity\n                    color=GREEN,\n                )\n                self.add(ax1, ax2, incorrect, correct)\n    \"\"\"\n\n    def __init__(\n        self,\n        function: Callable[[float], Point3DLike],\n        t_range: tuple[float, float] | tuple[float, float, float] = (0, 1),\n        scaling: _ScaleBase = LinearBase(),\n        dt: float = 1e-8,\n        discontinuities: Iterable[float] | None = None,\n        use_smoothing: bool = True,\n        use_vectorized: bool = False,\n        **kwargs,\n    ):\n        def internal_parametric_function(t: float) -> Point3D:\n            \"\"\"Wrap ``function``'s output inside a NumPy array.\"\"\"\n            return np.asarray(function(t))\n\n        self.function = internal_parametric_function\n        if len(t_range) == 2:\n            t_range = (*t_range, 0.01)\n\n        self.scaling = scaling\n\n        self.dt = dt\n        self.discontinuities = discontinuities\n        self.use_smoothing = use_smoothing\n        self.use_vectorized = use_vectorized\n        self.t_min, self.t_max, self.t_step = t_range\n\n        super().__init__(**kwargs)\n\n    def get_function(self) -> Callable[[float], Point3D]:\n        return self.function\n\n    def get_point_from_function(self, t: float) -> Point3D:\n        return self.function(t)\n\n\n[docs]\n    def generate_points(self) -> Self:\n        if self.discontinuities is not None:\n            discontinuities = filter(\n                lambda t: self.t_min <= t <= self.t_max,\n                self.discontinuities,\n            )\n            discontinuities = np.array(list(discontinuities))\n            boundary_times = np.array(\n                [\n                    self.t_min,\n                    self.t_max,\n                    *(discontinuities - self.dt),\n                    *(discontinuities + self.dt),\n                ],\n            )\n            boundary_times.sort()\n        else:\n            boundary_times = [self.t_min, self.t_max]\n\n        for t1, t2 in zip(boundary_times[0::2], boundary_times[1::2]):\n            t_range = np.array(\n                [\n                    *self.scaling.function(np.arange(t1, t2, self.t_step)),\n                    self.scaling.function(t2),\n                ],\n            )\n\n            if self.use_vectorized:\n                x, y, z = self.function(t_range)\n                if not isinstance(z, np.ndarray):\n                    z = np.zeros_like(x)\n                points = np.stack([x, y, z], axis=1)\n            else:\n                points = np.array([self.function(t) for t in t_range])\n\n            self.start_new_path(points[0])\n            self.add_points_as_corners(points[1:])\n        if self.use_smoothing:\n            # TODO: not in line with upstream, approx_smooth does not exist\n            self.make_smooth()\n        return self\n\n\n    init_points = generate_points\n\n\n\n\n[docs]\nclass FunctionGraph(ParametricFunction):\n    \"\"\"A :class:`ParametricFunction` that spans the length of the scene by default.\n\n    Examples\n    --------\n    .. manim:: ExampleFunctionGraph\n        :save_last_frame:\n\n        class ExampleFunctionGraph(Scene):\n            def construct(self):\n                cos_func = FunctionGraph(\n                    lambda t: np.cos(t) + 0.5 * np.cos(7 * t) + (1 / 7) * np.cos(14 * t),\n                    color=RED,\n                )\n\n                sin_func_1 = FunctionGraph(\n                    lambda t: np.sin(t) + 0.5 * np.sin(7 * t) + (1 / 7) * np.sin(14 * t),\n                    color=BLUE,\n                )\n\n                sin_func_2 = FunctionGraph(\n                    lambda t: np.sin(t) + 0.5 * np.sin(7 * t) + (1 / 7) * np.sin(14 * t),\n                    x_range=[-4, 4],\n                    color=GREEN,\n                ).move_to([0, 1, 0])\n\n                self.add(cos_func, sin_func_1, sin_func_2)\n    \"\"\"\n\n    def __init__(self, function, x_range=None, color=YELLOW, **kwargs):\n        if x_range is None:\n            x_range = np.array([-config[\"frame_x_radius\"], config[\"frame_x_radius\"]])\n\n        self.x_range = x_range\n        self.parametric_function = lambda t: np.array([t, function(t), 0])\n        self.function = function\n        super().__init__(self.parametric_function, self.x_range, color=color, **kwargs)\n\n    def get_function(self):\n        return self.function\n\n    def get_point_from_function(self, x):\n        return self.parametric_function(x)\n\n\n\n\n[docs]\nclass ImplicitFunction(VMobject, metaclass=ConvertToOpenGL):\n    def __init__(\n        self,\n        func: Callable[[float, float], float],\n        x_range: Sequence[float] | None = None,\n        y_range: Sequence[float] | None = None,\n        min_depth: int = 5,\n        max_quads: int = 1500,\n        use_smoothing: bool = True,\n        **kwargs,\n    ):\n        \"\"\"An implicit function.\n\n        Parameters\n        ----------\n        func\n            The implicit function in the form ``f(x, y) = 0``.\n        x_range\n            The x min and max of the function.\n        y_range\n            The y min and max of the function.\n        min_depth\n            The minimum depth of the function to calculate.\n        max_quads\n            The maximum number of quads to use.\n        use_smoothing\n            Whether or not to smoothen the curves.\n        kwargs\n            Additional parameters to pass into :class:`VMobject`\n\n\n        .. note::\n            A small ``min_depth`` :math:`d` means that some small details might\n            be ignored if they don't cross an edge of one of the\n            :math:`4^d` uniform quads.\n\n            The value of ``max_quads`` strongly corresponds to the\n            quality of the curve, but a higher number of quads\n            may take longer to render.\n\n        Examples\n        --------\n        .. manim:: ImplicitFunctionExample\n            :save_last_frame:\n\n            class ImplicitFunctionExample(Scene):\n                def construct(self):\n                    graph = ImplicitFunction(\n                        lambda x, y: x * y ** 2 - x ** 2 * y - 2,\n                        color=YELLOW\n                    )\n                    self.add(NumberPlane(), graph)\n        \"\"\"\n        self.function = func\n        self.min_depth = min_depth\n        self.max_quads = max_quads\n        self.use_smoothing = use_smoothing\n        self.x_range = x_range or [\n            -config.frame_width / 2,\n            config.frame_width / 2,\n        ]\n        self.y_range = y_range or [\n            -config.frame_height / 2,\n            config.frame_height / 2,\n        ]\n\n        super().__init__(**kwargs)\n\n\n[docs]\n    def generate_points(self):\n        p_min, p_max = (\n            np.array([self.x_range[0], self.y_range[0]]),\n            np.array([self.x_range[1], self.y_range[1]]),\n        )\n        curves = plot_isoline(\n            fn=lambda u: self.function(u[0], u[1]),\n            pmin=p_min,\n            pmax=p_max,\n            min_depth=self.min_depth,\n            max_quads=self.max_quads,\n        )  # returns a list of lists of 2D points\n        curves = [\n            np.pad(curve, [(0, 0), (0, 1)]) for curve in curves if curve != []\n        ]  # add z coord as 0\n        for curve in curves:\n            self.start_new_path(curve[0])\n            self.add_points_as_corners(curve[1:])\n        if self.use_smoothing:\n            self.make_smooth()\n        return self\n\n\n    init_points = generate_points", "code_sha1": "98889092b00ab8497b80ff8d62ecfa1fc3b8f8f7"}
{"url": "https://docs.manim.community/en/stable/_modules/manim/mobject/graphing/number_line.html", "depth": 2, "instruction": "The code creates a number line with four instances, each displaying tick marks and labels at specified intervals. The first line is blue, the second has a red label, the third shows decimal numbers, and the fourth is rotated at 10 degrees. All lines are arranged vertically with equal spacing.", "code": "\"\"\"Mobject representing a number line.\"\"\"\n\nfrom __future__ import annotations\n\nfrom manim.mobject.mobject import Mobject\nfrom manim.mobject.opengl.opengl_vectorized_mobject import OpenGLVMobject\n\n__all__ = [\"NumberLine\", \"UnitInterval\"]\n\n\nfrom collections.abc import Iterable, Sequence\nfrom typing import TYPE_CHECKING, Callable\n\nif TYPE_CHECKING:\n    from manim.mobject.geometry.tips import ArrowTip\n    from manim.typing import Point3DLike\n\nimport numpy as np\n\nfrom manim import config\nfrom manim.constants import *\nfrom manim.mobject.geometry.line import Line\nfrom manim.mobject.graphing.scale import LinearBase, _ScaleBase\nfrom manim.mobject.text.numbers import DecimalNumber\nfrom manim.mobject.text.tex_mobject import MathTex, Tex\nfrom manim.mobject.types.vectorized_mobject import VGroup, VMobject\nfrom manim.utils.bezier import interpolate\nfrom manim.utils.config_ops import merge_dicts_recursively\nfrom manim.utils.space_ops import normalize\n\n\n\n[docs]\nclass NumberLine(Line):\n    \"\"\"Creates a number line with tick marks.\n\n    Parameters\n    ----------\n    x_range\n        The ``[x_min, x_max, x_step]`` values to create the line.\n    length\n        The length of the number line.\n    unit_size\n        The distance between each tick of the line. Overwritten by :attr:`length`, if specified.\n    include_ticks\n        Whether to include ticks on the number line.\n    tick_size\n        The length of each tick mark.\n    numbers_with_elongated_ticks\n        An iterable of specific values with elongated ticks.\n    longer_tick_multiple\n        Influences how many times larger elongated ticks are than regular ticks (2 = 2x).\n    rotation\n        The angle (in radians) at which the line is rotated.\n    stroke_width\n        The thickness of the line.\n    include_tip\n        Whether to add a tip to the end of the line.\n    tip_width\n        The width of the tip.\n    tip_height\n        The height of the tip.\n    tip_shape\n        The mobject class used to construct the tip, or ``None`` (the\n        default) for the default arrow tip. Passed classes have to inherit\n        from :class:`.ArrowTip`.\n    include_numbers\n        Whether to add numbers to the tick marks. The number of decimal places is determined\n        by the step size, this default can be overridden by ``decimal_number_config``.\n    scaling\n        The way the ``x_range`` is value is scaled, i.e. :class:`~.LogBase` for a logarithmic numberline. Defaults to :class:`~.LinearBase`.\n    font_size\n        The size of the label mobjects. Defaults to 36.\n    label_direction\n        The specific position to which label mobjects are added on the line.\n    label_constructor\n        Determines the mobject class that will be used to construct the labels of the number line.\n    line_to_number_buff\n        The distance between the line and the label mobject.\n    decimal_number_config\n        Arguments that can be passed to :class:`~.numbers.DecimalNumber` to influence number mobjects.\n    numbers_to_exclude\n        An explicit iterable of numbers to not be added to the number line.\n    numbers_to_include\n        An explicit iterable of numbers to add to the number line\n    kwargs\n        Additional arguments to be passed to :class:`~.Line`.\n\n\n    .. note::\n\n        Number ranges that include both negative and positive values will be generated\n        from the 0 point, and may not include a tick at the min / max\n        values as the tick locations are dependent on the step size.\n\n    Examples\n    --------\n    .. manim:: NumberLineExample\n        :save_last_frame:\n\n        class NumberLineExample(Scene):\n            def construct(self):\n                l0 = NumberLine(\n                    x_range=[-10, 10, 2],\n                    length=10,\n                    color=BLUE,\n                    include_numbers=True,\n                    label_direction=UP,\n                )\n\n                l1 = NumberLine(\n                    x_range=[-10, 10, 2],\n                    unit_size=0.5,\n                    numbers_with_elongated_ticks=[-2, 4],\n                    include_numbers=True,\n                    font_size=24,\n                )\n                num6 = l1.numbers[8]\n                num6.set_color(RED)\n\n                l2 = NumberLine(\n                    x_range=[-2.5, 2.5 + 0.5, 0.5],\n                    length=12,\n                    decimal_number_config={\"num_decimal_places\": 2},\n                    include_numbers=True,\n                )\n\n                l3 = NumberLine(\n                    x_range=[-5, 5 + 1, 1],\n                    length=6,\n                    include_tip=True,\n                    include_numbers=True,\n                    rotation=10 * DEGREES,\n                )\n\n                line_group = VGroup(l0, l1, l2, l3).arrange(DOWN, buff=1)\n                self.add(line_group)\n    \"\"\"\n\n    def __init__(\n        self,\n        x_range: Sequence[float] | None = None,  # must be first\n        length: float | None = None,\n        unit_size: float = 1,\n        # ticks\n        include_ticks: bool = True,\n        tick_size: float = 0.1,\n        numbers_with_elongated_ticks: Iterable[float] | None = None,\n        longer_tick_multiple: int = 2,\n        exclude_origin_tick: bool = False,\n        # visuals\n        rotation: float = 0,\n        stroke_width: float = 2.0,\n        # tip\n        include_tip: bool = False,\n        tip_width: float = DEFAULT_ARROW_TIP_LENGTH,\n        tip_height: float = DEFAULT_ARROW_TIP_LENGTH,\n        tip_shape: type[ArrowTip] | None = None,\n        # numbers/labels\n        include_numbers: bool = False,\n        font_size: float = 36,\n        label_direction: Sequence[float] = DOWN,\n        label_constructor: VMobject = MathTex,\n        scaling: _ScaleBase = LinearBase(),\n        line_to_number_buff: float = MED_SMALL_BUFF,\n        decimal_number_config: dict | None = None,\n        numbers_to_exclude: Iterable[float] | None = None,\n        numbers_to_include: Iterable[float] | None = None,\n        **kwargs,\n    ):\n        # avoid mutable arguments in defaults\n        if numbers_to_exclude is None:\n            numbers_to_exclude = []\n        if numbers_with_elongated_ticks is None:\n            numbers_with_elongated_ticks = []\n\n        if x_range is None:\n            x_range = [\n                round(-config[\"frame_x_radius\"]),\n                round(config[\"frame_x_radius\"]),\n                1,\n            ]\n        elif len(x_range) == 2:\n            # adds x_step if not specified. not sure how to feel about this. a user can't know default without peeking at source code\n            x_range = [*x_range, 1]\n\n        if decimal_number_config is None:\n            decimal_number_config = {\n                \"num_decimal_places\": self._decimal_places_from_step(x_range[2]),\n            }\n\n        # turn into a NumPy array to scale by just applying the function\n        self.x_range = np.array(x_range, dtype=float)\n        self.x_min, self.x_max, self.x_step = scaling.function(self.x_range)\n        self.length = length\n        self.unit_size = unit_size\n        # ticks\n        self.include_ticks = include_ticks\n        self.tick_size = tick_size\n        self.numbers_with_elongated_ticks = numbers_with_elongated_ticks\n        self.longer_tick_multiple = longer_tick_multiple\n        self.exclude_origin_tick = exclude_origin_tick\n        # visuals\n        self.rotation = rotation\n        # tip\n        self.include_tip = include_tip\n        self.tip_width = tip_width\n        self.tip_height = tip_height\n        # numbers\n        self.font_size = font_size\n        self.include_numbers = include_numbers\n        self.label_direction = label_direction\n        self.label_constructor = label_constructor\n        self.line_to_number_buff = line_to_number_buff\n        self.decimal_number_config = decimal_number_config\n        self.numbers_to_exclude = numbers_to_exclude\n        self.numbers_to_include = numbers_to_include\n\n        self.scaling = scaling\n        super().__init__(\n            self.x_range[0] * RIGHT,\n            self.x_range[1] * RIGHT,\n            stroke_width=stroke_width,\n            **kwargs,\n        )\n\n        if self.length:\n            self.set_length(self.length)\n            self.unit_size = self.get_unit_size()\n        else:\n            self.scale(self.unit_size)\n\n        self.center()\n\n        if self.include_tip:\n            self.add_tip(\n                tip_length=self.tip_height,\n                tip_width=self.tip_width,\n                tip_shape=tip_shape,\n            )\n            self.tip.set_stroke(self.stroke_color, self.stroke_width)\n\n        if self.include_ticks:\n            self.add_ticks()\n\n        self.rotate(self.rotation)\n        if self.include_numbers or self.numbers_to_include is not None:\n            if self.scaling.custom_labels:\n                tick_range = self.get_tick_range()\n\n                self.add_labels(\n                    dict(\n                        zip(\n                            tick_range,\n                            self.scaling.get_custom_labels(\n                                tick_range,\n                                unit_decimal_places=decimal_number_config[\n                                    \"num_decimal_places\"\n                                ],\n                            ),\n                        )\n                    ),\n                )\n\n            else:\n                self.add_numbers(\n                    x_values=self.numbers_to_include,\n                    excluding=self.numbers_to_exclude,\n                    font_size=self.font_size,\n                )\n\n    def rotate_about_zero(self, angle: float, axis: Sequence[float] = OUT, **kwargs):\n        return self.rotate_about_number(0, angle, axis, **kwargs)\n\n    def rotate_about_number(\n        self, number: float, angle: float, axis: Sequence[float] = OUT, **kwargs\n    ):\n        return self.rotate(angle, axis, about_point=self.n2p(number), **kwargs)\n\n\n[docs]\n    def add_ticks(self):\n        \"\"\"Adds ticks to the number line. Ticks can be accessed after creation\n        via ``self.ticks``.\n        \"\"\"\n        ticks = VGroup()\n        elongated_tick_size = self.tick_size * self.longer_tick_multiple\n        elongated_tick_offsets = self.numbers_with_elongated_ticks - self.x_min\n        for x in self.get_tick_range():\n            size = self.tick_size\n            if np.any(np.isclose(x - self.x_min, elongated_tick_offsets)):\n                size = elongated_tick_size\n            ticks.add(self.get_tick(x, size))\n        self.add(ticks)\n        self.ticks = ticks\n\n\n\n[docs]\n    def get_tick(self, x: float, size: float | None = None) -> Line:\n        \"\"\"Generates a tick and positions it along the number line.\n\n        Parameters\n        ----------\n        x\n            The position of the tick.\n        size\n            The factor by which the tick is scaled.\n\n        Returns\n        -------\n        :class:`~.Line`\n            A positioned tick.\n        \"\"\"\n        if size is None:\n            size = self.tick_size\n        result = Line(size * DOWN, size * UP)\n        result.rotate(self.get_angle())\n        result.move_to(self.number_to_point(x))\n        result.match_style(self)\n        return result\n\n\n    def get_tick_marks(self) -> VGroup:\n        return self.ticks\n\n\n[docs]\n    def get_tick_range(self) -> np.ndarray:\n        \"\"\"Generates the range of values on which labels are plotted based on the\n        ``x_range`` attribute of the number line.\n\n        Returns\n        -------\n        np.ndarray\n            A numpy array of floats represnting values along the number line.\n        \"\"\"\n        x_min, x_max, x_step = self.x_range\n        if not self.include_tip:\n            x_max += 1e-6\n\n        # Handle cases where min and max are both positive or both negative\n        if x_min < x_max < 0 or x_max > x_min > 0:\n            tick_range = np.arange(x_min, x_max, x_step)\n        else:\n            start_point = 0\n            if self.exclude_origin_tick:\n                start_point += x_step\n\n            x_min_segment = np.arange(start_point, np.abs(x_min) + 1e-6, x_step) * -1\n            x_max_segment = np.arange(start_point, x_max, x_step)\n\n            tick_range = np.unique(np.concatenate((x_min_segment, x_max_segment)))\n\n        return self.scaling.function(tick_range)\n\n\n\n[docs]\n    def number_to_point(self, number: float | np.ndarray) -> np.ndarray:\n        \"\"\"Accepts a value along the number line and returns a point with\n        respect to the scene.\n        Equivalent to `NumberLine @ number`\n\n        Parameters\n        ----------\n        number\n            The value to be transformed into a coordinate. Or a list of values.\n\n        Returns\n        -------\n        np.ndarray\n            A point with respect to the scene's coordinate system. Or a list of points.\n\n        Examples\n        --------\nfrom manim import NumberLine\nnumber_line = NumberLine()\nnumber_line.number_to_point(0)\n            array([0., 0., 0.])\nnumber_line.number_to_point(1)\n            array([1., 0., 0.])\nnumber_line @ 1\n            array([1., 0., 0.])\nnumber_line.number_to_point([1, 2, 3])\n            array([[1., 0., 0.],\n                   [2., 0., 0.],\n                   [3., 0., 0.]])\n        \"\"\"\n        number = np.asarray(number)\n        scalar = number.ndim == 0\n        number = self.scaling.inverse_function(number)\n        alphas = (number - self.x_range[0]) / (self.x_range[1] - self.x_range[0])\n        alphas = float(alphas) if scalar else np.vstack(alphas)\n        val = interpolate(self.get_start(), self.get_end(), alphas)\n        return val\n\n\n\n[docs]\n    def point_to_number(self, point: Sequence[float]) -> float:\n        \"\"\"Accepts a point with respect to the scene and returns\n        a float along the number line.\n\n        Parameters\n        ----------\n        point\n            A sequence of values consisting of ``(x_coord, y_coord, z_coord)``.\n\n        Returns\n        -------\n        float\n            A float representing a value along the number line.\n\n        Examples\n        --------\nfrom manim import NumberLine\nnumber_line = NumberLine()\nnumber_line.point_to_number((0, 0, 0))\n            np.float64(0.0)\nnumber_line.point_to_number((1, 0, 0))\n            np.float64(1.0)\nnumber_line.point_to_number([[0.5, 0, 0], [1, 0, 0], [1.5, 0, 0]])\n            array([0.5, 1. , 1.5])\n\n        \"\"\"\n        point = np.asarray(point)\n        start, end = self.get_start_and_end()\n        unit_vect = normalize(end - start)\n        proportion = np.dot(point - start, unit_vect) / np.dot(end - start, unit_vect)\n        return interpolate(self.x_min, self.x_max, proportion)\n\n\n\n[docs]\n    def n2p(self, number: float | np.ndarray) -> np.ndarray:\n        \"\"\"Abbreviation for :meth:`~.NumberLine.number_to_point`.\"\"\"\n        return self.number_to_point(number)\n\n\n\n[docs]\n    def p2n(self, point: Sequence[float]) -> float:\n        \"\"\"Abbreviation for :meth:`~.NumberLine.point_to_number`.\"\"\"\n        return self.point_to_number(point)\n\n\n    def get_unit_size(self) -> float:\n        return self.get_length() / (self.x_range[1] - self.x_range[0])\n\n    def get_unit_vector(self) -> np.ndarray:\n        return super().get_unit_vector() * self.unit_size\n\n\n[docs]\n    def get_number_mobject(\n        self,\n        x: float,\n        direction: Sequence[float] | None = None,\n        buff: float | None = None,\n        font_size: float | None = None,\n        label_constructor: VMobject | None = None,\n        **number_config,\n    ) -> VMobject:\n        \"\"\"Generates a positioned :class:`~.DecimalNumber` mobject\n        generated according to ``label_constructor``.\n\n        Parameters\n        ----------\n        x\n            The x-value at which the mobject should be positioned.\n        direction\n            Determines the direction at which the label is positioned next to the line.\n        buff\n            The distance of the label from the line.\n        font_size\n            The font size of the label mobject.\n        label_constructor\n            The :class:`~.VMobject` class that will be used to construct the label.\n            Defaults to the ``label_constructor`` attribute of the number line\n            if not specified.\n\n        Returns\n        -------\n        :class:`~.DecimalNumber`\n            The positioned mobject.\n        \"\"\"\n        number_config = merge_dicts_recursively(\n            self.decimal_number_config,\n            number_config,\n        )\n        if direction is None:\n            direction = self.label_direction\n        if buff is None:\n            buff = self.line_to_number_buff\n        if font_size is None:\n            font_size = self.font_size\n        if label_constructor is None:\n            label_constructor = self.label_constructor\n\n        num_mob = DecimalNumber(\n            x, font_size=font_size, mob_class=label_constructor, **number_config\n        )\n\n        num_mob.next_to(self.number_to_point(x), direction=direction, buff=buff)\n        if x < 0 and self.label_direction[0] == 0:\n            # Align without the minus sign\n            num_mob.shift(num_mob[0].width * LEFT / 2)\n        return num_mob\n\n\n    def get_number_mobjects(self, *numbers, **kwargs) -> VGroup:\n        if len(numbers) == 0:\n            numbers = self.default_numbers_to_display()\n        return VGroup([self.get_number_mobject(number, **kwargs) for number in numbers])\n\n    def get_labels(self) -> VGroup:\n        return self.get_number_mobjects()\n\n\n[docs]\n    def add_numbers(\n        self,\n        x_values: Iterable[float] | None = None,\n        excluding: Iterable[float] | None = None,\n        font_size: float | None = None,\n        label_constructor: VMobject | None = None,\n        **kwargs,\n    ):\n        \"\"\"Adds :class:`~.DecimalNumber` mobjects representing their position\n        at each tick of the number line. The numbers can be accessed after creation\n        via ``self.numbers``.\n\n        Parameters\n        ----------\n        x_values\n            An iterable of the values used to position and create the labels.\n            Defaults to the output produced by :meth:`~.NumberLine.get_tick_range`\n        excluding\n            A list of values to exclude from :attr:`x_values`.\n        font_size\n            The font size of the labels. Defaults to the ``font_size`` attribute\n            of the number line.\n        label_constructor\n            The :class:`~.VMobject` class that will be used to construct the label.\n            Defaults to the ``label_constructor`` attribute of the number line\n            if not specified.\n        \"\"\"\n        if x_values is None:\n            x_values = self.get_tick_range()\n\n        if excluding is None:\n            excluding = self.numbers_to_exclude\n\n        if font_size is None:\n            font_size = self.font_size\n\n        if label_constructor is None:\n            label_constructor = self.label_constructor\n\n        numbers = VGroup()\n        for x in x_values:\n            if x in excluding:\n                continue\n            numbers.add(\n                self.get_number_mobject(\n                    x,\n                    font_size=font_size,\n                    label_constructor=label_constructor,\n                    **kwargs,\n                )\n            )\n        self.add(numbers)\n        self.numbers = numbers\n        return self\n\n\n\n[docs]\n    def add_labels(\n        self,\n        dict_values: dict[float, str | float | VMobject],\n        direction: Sequence[float] = None,\n        buff: float | None = None,\n        font_size: float | None = None,\n        label_constructor: VMobject | None = None,\n    ):\n        \"\"\"Adds specifically positioned labels to the :class:`~.NumberLine` using a ``dict``.\n        The labels can be accessed after creation via ``self.labels``.\n\n        Parameters\n        ----------\n        dict_values\n            A dictionary consisting of the position along the number line and the mobject to be added:\n            ``{1: Tex(\"Monday\"), 3: Tex(\"Tuesday\")}``. :attr:`label_constructor` will be used\n            to construct the labels if the value is not a mobject (``str`` or ``float``).\n        direction\n            Determines the direction at which the label is positioned next to the line.\n        buff\n            The distance of the label from the line.\n        font_size\n            The font size of the mobject to be positioned.\n        label_constructor\n            The :class:`~.VMobject` class that will be used to construct the label.\n            Defaults to the ``label_constructor`` attribute of the number line\n            if not specified.\n\n        Raises\n        ------\n        AttributeError\n            If the label does not have a ``font_size`` attribute, an ``AttributeError`` is raised.\n        \"\"\"\n        direction = self.label_direction if direction is None else direction\n        buff = self.line_to_number_buff if buff is None else buff\n        font_size = self.font_size if font_size is None else font_size\n        if label_constructor is None:\n            label_constructor = self.label_constructor\n\n        labels = VGroup()\n        for x, label in dict_values.items():\n            # TODO: remove this check and ability to call\n            # this method via CoordinateSystem.add_coordinates()\n            # must be explicitly called\n            if isinstance(label, str) and label_constructor is MathTex:\n                label = Tex(label)\n            else:\n                label = self._create_label_tex(label, label_constructor)\n\n            if hasattr(label, \"font_size\"):\n                label.font_size = font_size\n            else:\n                raise AttributeError(f\"{label} is not compatible with add_labels.\")\n            label.next_to(self.number_to_point(x), direction=direction, buff=buff)\n            labels.add(label)\n\n        self.labels = labels\n        self.add(labels)\n        return self\n\n\n\n[docs]\n    def _create_label_tex(\n        self,\n        label_tex: str | float | VMobject,\n        label_constructor: Callable | None = None,\n        **kwargs,\n    ) -> VMobject:\n        \"\"\"Checks if the label is a :class:`~.VMobject`, otherwise, creates a\n        label by passing ``label_tex`` to ``label_constructor``.\n\n        Parameters\n        ----------\n        label_tex\n            The label for which a mobject should be created. If the label already\n            is a mobject, no new mobject is created.\n        label_constructor\n            Optional. A class or function returning a mobject when\n            passing ``label_tex`` as an argument. If ``None`` is passed\n            (the default), the label constructor from the :attr:`.label_constructor`\n            attribute is used.\n\n        Returns\n        -------\n        :class:`~.VMobject`\n            The label.\n        \"\"\"\n        if label_constructor is None:\n            label_constructor = self.label_constructor\n        if isinstance(label_tex, (VMobject, OpenGLVMobject)):\n            return label_tex\n        else:\n            return label_constructor(label_tex, **kwargs)\n\n\n    @staticmethod\n    def _decimal_places_from_step(step) -> int:\n        step = str(step)\n        if \".\" not in step:\n            return 0\n        return len(step.split(\".\")[-1])\n\n    def __matmul__(self, other: float):\n        return self.n2p(other)\n\n    def __rmatmul__(self, other: Point3DLike | Mobject):\n        if isinstance(other, Mobject):\n            other = other.get_center()\n        return self.p2n(other)\n\n\n\n\n[docs]\nclass UnitInterval(NumberLine):\n    def __init__(\n        self,\n        unit_size=10,\n        numbers_with_elongated_ticks=None,\n        decimal_number_config=None,\n        **kwargs,\n    ):\n        numbers_with_elongated_ticks = (\n            [0, 1]\n            if numbers_with_elongated_ticks is None\n            else numbers_with_elongated_ticks\n        )\n\n        decimal_number_config = (\n            {\n                \"num_decimal_places\": 1,\n            }\n            if decimal_number_config is None\n            else decimal_number_config\n        )\n\n        super().__init__(\n            x_range=(0, 1, 0.1),\n            unit_size=unit_size,\n            numbers_with_elongated_ticks=numbers_with_elongated_ticks,\n            decimal_number_config=decimal_number_config,\n            **kwargs,\n        )", "code_sha1": "36ec2dd5dd710e0f9c58609b99e96f46b9b85564"}
{"url": "https://docs.manim.community/en/stable/_modules/manim/mobject/graphing/probability.html", "depth": 2, "instruction": "The code creates a scene with a bar chart displaying five bars of varying heights, colored in a gradient from dark blue to orange. Each bar is labeled with its corresponding value above or below, depending on whether the value is positive or negative. The chart is centered, with axes labeled appropriately.", "code": "\"\"\"Mobjects representing objects from probability theory and statistics.\"\"\"\n\nfrom __future__ import annotations\n\n__all__ = [\"SampleSpace\", \"BarChart\"]\n\n\nfrom collections.abc import Iterable, MutableSequence, Sequence\n\nimport numpy as np\n\nfrom manim import config, logger\nfrom manim.constants import *\nfrom manim.mobject.geometry.polygram import Rectangle\nfrom manim.mobject.graphing.coordinate_systems import Axes\nfrom manim.mobject.mobject import Mobject\nfrom manim.mobject.opengl.opengl_mobject import OpenGLMobject\nfrom manim.mobject.svg.brace import Brace\nfrom manim.mobject.text.tex_mobject import MathTex, Tex\nfrom manim.mobject.types.vectorized_mobject import VGroup, VMobject\nfrom manim.utils.color import (\n    BLUE_E,\n    DARK_GREY,\n    GREEN_E,\n    LIGHT_GREY,\n    MAROON_B,\n    YELLOW,\n    ParsableManimColor,\n    color_gradient,\n)\nfrom manim.utils.iterables import tuplify\n\nEPSILON = 0.0001\n\n\n\n[docs]\nclass SampleSpace(Rectangle):\n    \"\"\"A mobject representing a twodimensional rectangular\n    sampling space.\n\n    Examples\n    --------\n    .. manim:: ExampleSampleSpace\n        :save_last_frame:\n\n        class ExampleSampleSpace(Scene):\n            def construct(self):\n                poly1 = SampleSpace(stroke_width=15, fill_opacity=1)\n                poly2 = SampleSpace(width=5, height=3, stroke_width=5, fill_opacity=0.5)\n                poly3 = SampleSpace(width=2, height=2, stroke_width=5, fill_opacity=0.1)\n                poly3.divide_vertically(p_list=np.array([0.37, 0.13, 0.5]), colors=[BLACK, WHITE, GRAY], vect=RIGHT)\n                poly_group = VGroup(poly1, poly2, poly3).arrange()\n                self.add(poly_group)\n    \"\"\"\n\n    def __init__(\n        self,\n        height=3,\n        width=3,\n        fill_color=DARK_GREY,\n        fill_opacity=1,\n        stroke_width=0.5,\n        stroke_color=LIGHT_GREY,\n        default_label_scale_val=1,\n    ):\n        super().__init__(\n            height=height,\n            width=width,\n            fill_color=fill_color,\n            fill_opacity=fill_opacity,\n            stroke_width=stroke_width,\n            stroke_color=stroke_color,\n        )\n        self.default_label_scale_val = default_label_scale_val\n\n    def add_title(self, title=\"Sample space\", buff=MED_SMALL_BUFF):\n        # TODO, should this really exist in SampleSpaceScene\n        title_mob = Tex(title)\n        if title_mob.width > self.width:\n            title_mob.width = self.width\n        title_mob.next_to(self, UP, buff=buff)\n        self.title = title_mob\n        self.add(title_mob)\n\n    def add_label(self, label):\n        self.label = label\n\n    def complete_p_list(self, p_list):\n        new_p_list = list(tuplify(p_list))\n        remainder = 1.0 - sum(new_p_list)\n        if abs(remainder) > EPSILON:\n            new_p_list.append(remainder)\n        return new_p_list\n\n    def get_division_along_dimension(self, p_list, dim, colors, vect):\n        p_list = self.complete_p_list(p_list)\n        colors = color_gradient(colors, len(p_list))\n\n        last_point = self.get_edge_center(-vect)\n        parts = VGroup()\n        for factor, color in zip(p_list, colors):\n            part = SampleSpace()\n            part.set_fill(color, 1)\n            part.replace(self, stretch=True)\n            part.stretch(factor, dim)\n            part.move_to(last_point, -vect)\n            last_point = part.get_edge_center(vect)\n            parts.add(part)\n        return parts\n\n    def get_horizontal_division(self, p_list, colors=[GREEN_E, BLUE_E], vect=DOWN):\n        return self.get_division_along_dimension(p_list, 1, colors, vect)\n\n    def get_vertical_division(self, p_list, colors=[MAROON_B, YELLOW], vect=RIGHT):\n        return self.get_division_along_dimension(p_list, 0, colors, vect)\n\n    def divide_horizontally(self, *args, **kwargs):\n        self.horizontal_parts = self.get_horizontal_division(*args, **kwargs)\n        self.add(self.horizontal_parts)\n\n    def divide_vertically(self, *args, **kwargs):\n        self.vertical_parts = self.get_vertical_division(*args, **kwargs)\n        self.add(self.vertical_parts)\n\n    def get_subdivision_braces_and_labels(\n        self,\n        parts,\n        labels,\n        direction,\n        buff=SMALL_BUFF,\n        min_num_quads=1,\n    ):\n        label_mobs = VGroup()\n        braces = VGroup()\n        for label, part in zip(labels, parts):\n            brace = Brace(part, direction, min_num_quads=min_num_quads, buff=buff)\n            if isinstance(label, (Mobject, OpenGLMobject)):\n                label_mob = label\n            else:\n                label_mob = MathTex(label)\n                label_mob.scale(self.default_label_scale_val)\n            label_mob.next_to(brace, direction, buff)\n\n            braces.add(brace)\n            label_mobs.add(label_mob)\n        parts.braces = braces\n        parts.labels = label_mobs\n        parts.label_kwargs = {\n            \"labels\": label_mobs.copy(),\n            \"direction\": direction,\n            \"buff\": buff,\n        }\n        return VGroup(parts.braces, parts.labels)\n\n    def get_side_braces_and_labels(self, labels, direction=LEFT, **kwargs):\n        assert hasattr(self, \"horizontal_parts\")\n        parts = self.horizontal_parts\n        return self.get_subdivision_braces_and_labels(\n            parts, labels, direction, **kwargs\n        )\n\n    def get_top_braces_and_labels(self, labels, **kwargs):\n        assert hasattr(self, \"vertical_parts\")\n        parts = self.vertical_parts\n        return self.get_subdivision_braces_and_labels(parts, labels, UP, **kwargs)\n\n    def get_bottom_braces_and_labels(self, labels, **kwargs):\n        assert hasattr(self, \"vertical_parts\")\n        parts = self.vertical_parts\n        return self.get_subdivision_braces_and_labels(parts, labels, DOWN, **kwargs)\n\n    def add_braces_and_labels(self):\n        for attr in \"horizontal_parts\", \"vertical_parts\":\n            if not hasattr(self, attr):\n                continue\n            parts = getattr(self, attr)\n            for subattr in \"braces\", \"labels\":\n                if hasattr(parts, subattr):\n                    self.add(getattr(parts, subattr))\n\n    def __getitem__(self, index):\n        if hasattr(self, \"horizontal_parts\"):\n            return self.horizontal_parts[index]\n        elif hasattr(self, \"vertical_parts\"):\n            return self.vertical_parts[index]\n        return self.split()[index]\n\n\n\n\n[docs]\nclass BarChart(Axes):\n    \"\"\"Creates a bar chart. Inherits from :class:`~.Axes`, so it shares its methods\n    and attributes. Each axis inherits from :class:`~.NumberLine`, so pass in ``x_axis_config``/``y_axis_config``\n    to control their attributes.\n\n    Parameters\n    ----------\n    values\n        A sequence of values that determines the height of each bar. Accepts negative values.\n    bar_names\n        A sequence of names for each bar. Does not have to match the length of ``values``.\n    y_range\n        The y_axis range of values. If ``None``, the range will be calculated based on the\n        min/max of ``values`` and the step will be calculated based on ``y_length``.\n    x_length\n        The length of the x-axis. If ``None``, it is automatically calculated based on\n        the number of values and the width of the screen.\n    y_length\n        The length of the y-axis.\n    bar_colors\n        The color for the bars. Accepts a sequence of colors (can contain just one item).\n        If the length of``bar_colors`` does not match that of ``values``,\n        intermediate colors will be automatically determined.\n    bar_width\n        The length of a bar. Must be between 0 and 1.\n    bar_fill_opacity\n        The fill opacity of the bars.\n    bar_stroke_width\n        The stroke width of the bars.\n\n    Examples\n    --------\n    .. manim:: BarChartExample\n        :save_last_frame:\n\n        class BarChartExample(Scene):\n            def construct(self):\n                chart = BarChart(\n                    values=[-5, 40, -10, 20, -3],\n                    bar_names=[\"one\", \"two\", \"three\", \"four\", \"five\"],\n                    y_range=[-20, 50, 10],\n                    y_length=6,\n                    x_length=10,\n                    x_axis_config={\"font_size\": 36},\n                )\n\n                c_bar_lbls = chart.get_bar_labels(font_size=48)\n\n                self.add(chart, c_bar_lbls)\n    \"\"\"\n\n    def __init__(\n        self,\n        values: MutableSequence[float],\n        bar_names: Sequence[str] | None = None,\n        y_range: Sequence[float] | None = None,\n        x_length: float | None = None,\n        y_length: float | None = None,\n        bar_colors: Iterable[str] = [\n            \"#003f5c\",\n            \"#58508d\",\n            \"#bc5090\",\n            \"#ff6361\",\n            \"#ffa600\",\n        ],\n        bar_width: float = 0.6,\n        bar_fill_opacity: float = 0.7,\n        bar_stroke_width: float = 3,\n        **kwargs,\n    ):\n        if isinstance(bar_colors, str):\n            logger.warning(\n                \"Passing a string to `bar_colors` has been deprecated since v0.15.2 and will be removed after v0.17.0, the parameter must be a list.  \"\n            )\n            bar_colors = list(bar_colors)\n\n        y_length = y_length if y_length is not None else config.frame_height - 4\n\n        self.values = values\n        self.bar_names = bar_names\n        self.bar_colors = bar_colors\n        self.bar_width = bar_width\n        self.bar_fill_opacity = bar_fill_opacity\n        self.bar_stroke_width = bar_stroke_width\n\n        x_range = [0, len(self.values), 1]\n\n        if y_range is None:\n            y_range = [\n                min(0, min(self.values)),\n                max(0, max(self.values)),\n                round(max(self.values) / y_length, 2),\n            ]\n\n        elif len(y_range) == 2:\n            y_range = [*y_range, round(max(self.values) / y_length, 2)]\n\n        if x_length is None:\n            x_length = min(len(self.values), config.frame_width - 2)\n\n        x_axis_config = {\"font_size\": 24, \"label_constructor\": Tex}\n        self._update_default_configs(\n            (x_axis_config,), (kwargs.pop(\"x_axis_config\", None),)\n        )\n\n        self.bars: VGroup = VGroup()\n        self.x_labels: VGroup | None = None\n        self.bar_labels: VGroup | None = None\n\n        super().__init__(\n            x_range=x_range,\n            y_range=y_range,\n            x_length=x_length,\n            y_length=y_length,\n            x_axis_config=x_axis_config,\n            tips=kwargs.pop(\"tips\", False),\n            **kwargs,\n        )\n\n        self._add_bars()\n\n        if self.bar_names is not None:\n            self._add_x_axis_labels()\n\n        self.y_axis.add_numbers()\n\n\n[docs]\n    def _update_colors(self):\n        \"\"\"Initialize the colors of the bars of the chart.\n\n        Sets the color of ``self.bars`` via ``self.bar_colors``.\n\n        Primarily used when the bars are initialized with ``self._add_bars``\n        or updated via ``self.change_bar_values``.\n        \"\"\"\n        self.bars.set_color_by_gradient(*self.bar_colors)\n\n\n\n[docs]\n    def _add_x_axis_labels(self):\n        \"\"\"Essentially :meth`:~.NumberLine.add_labels`, but differs in that\n        the direction of the label with respect to the x_axis changes to UP or DOWN\n        depending on the value.\n\n        UP for negative values and DOWN for positive values.\n        \"\"\"\n        val_range = np.arange(\n            0.5, len(self.bar_names), 1\n        )  # 0.5 shifted so that labels are centered, not on ticks\n\n        labels = VGroup()\n\n        for i, (value, bar_name) in enumerate(zip(val_range, self.bar_names)):\n            # to accommodate negative bars, the label may need to be\n            # below or above the x_axis depending on the value of the bar\n            direction = UP if self.values[i] < 0 else DOWN\n            bar_name_label = self.x_axis.label_constructor(bar_name)\n\n            bar_name_label.font_size = self.x_axis.font_size\n            bar_name_label.next_to(\n                self.x_axis.number_to_point(value),\n                direction=direction,\n                buff=self.x_axis.line_to_number_buff,\n            )\n\n            labels.add(bar_name_label)\n\n        self.x_axis.labels = labels\n        self.x_axis.add(labels)\n\n\n\n[docs]\n    def _create_bar(self, bar_number: int, value: float) -> Rectangle:\n        \"\"\"Creates a positioned bar on the chart.\n\n        Parameters\n        ----------\n        bar_number\n            Determines the x-position of the bar.\n        value\n            The value that determines the height of the bar.\n\n        Returns\n        -------\n        Rectangle\n            A positioned rectangle representing a bar on the chart.\n        \"\"\"\n        # bar measurements relative to the axis\n\n        # distance from between the y-axis and the top of the bar\n        bar_h = abs(self.c2p(0, value)[1] - self.c2p(0, 0)[1])\n        # width of the bar\n        bar_w = self.c2p(self.bar_width, 0)[0] - self.c2p(0, 0)[0]\n\n        bar = Rectangle(\n            height=bar_h,\n            width=bar_w,\n            stroke_width=self.bar_stroke_width,\n            fill_opacity=self.bar_fill_opacity,\n        )\n\n        pos = UP if (value >= 0) else DOWN\n        bar.next_to(self.c2p(bar_number + 0.5, 0), pos, buff=0)\n        return bar\n\n\n    def _add_bars(self) -> None:\n        for i, value in enumerate(self.values):\n            tmp_bar = self._create_bar(bar_number=i, value=value)\n            self.bars.add(tmp_bar)\n\n        self._update_colors()\n        self.add_to_back(self.bars)\n\n\n[docs]\n    def get_bar_labels(\n        self,\n        color: ParsableManimColor | None = None,\n        font_size: float = 24,\n        buff: float = MED_SMALL_BUFF,\n        label_constructor: type[VMobject] = Tex,\n    ):\n        \"\"\"Annotates each bar with its corresponding value. Use ``self.bar_labels`` to access the\n        labels after creation.\n\n        Parameters\n        ----------\n        color\n            The color of each label. By default ``None`` and is based on the parent's bar color.\n        font_size\n            The font size of each label.\n        buff\n            The distance from each label to its bar. By default 0.4.\n        label_constructor\n            The Mobject class to construct the labels, by default :class:`~.Tex`.\n\n        Examples\n        --------\n        .. manim:: GetBarLabelsExample\n            :save_last_frame:\n\n            class GetBarLabelsExample(Scene):\n                def construct(self):\n                    chart = BarChart(values=[10, 9, 8, 7, 6, 5, 4, 3, 2, 1], y_range=[0, 10, 1])\n\n                    c_bar_lbls = chart.get_bar_labels(\n                        color=WHITE, label_constructor=MathTex, font_size=36\n                    )\n\n                    self.add(chart, c_bar_lbls)\n        \"\"\"\n        bar_labels = VGroup()\n        for bar, value in zip(self.bars, self.values):\n            bar_lbl = label_constructor(str(value))\n\n            if color is None:\n                bar_lbl.set_color(bar.get_fill_color())\n            else:\n                bar_lbl.set_color(color)\n\n            bar_lbl.font_size = font_size\n\n            pos = UP if (value >= 0) else DOWN\n            bar_lbl.next_to(bar, pos, buff=buff)\n            bar_labels.add(bar_lbl)\n\n        return bar_labels\n\n\n\n[docs]\n    def change_bar_values(self, values: Iterable[float], update_colors: bool = True):\n        \"\"\"Updates the height of the bars of the chart.\n\n        Parameters\n        ----------\n        values\n            The values that will be used to update the height of the bars.\n            Does not have to match the number of bars.\n        update_colors\n            Whether to re-initalize the colors of the bars based on ``self.bar_colors``.\n\n        Examples\n        --------\n        .. manim:: ChangeBarValuesExample\n            :save_last_frame:\n\n            class ChangeBarValuesExample(Scene):\n                def construct(self):\n                    values=[-10, -8, -6, -4, -2, 0, 2, 4, 6, 8, 10]\n\n                    chart = BarChart(\n                        values,\n                        y_range=[-10, 10, 2],\n                        y_axis_config={\"font_size\": 24},\n                    )\n                    self.add(chart)\n\n                    chart.change_bar_values(list(reversed(values)))\n                    self.add(chart.get_bar_labels(font_size=24))\n        \"\"\"\n        for i, (bar, value) in enumerate(zip(self.bars, values)):\n            chart_val = self.values[i]\n\n            if chart_val > 0:\n                bar_lim = bar.get_bottom()\n                aligned_edge = DOWN\n            else:\n                bar_lim = bar.get_top()\n                aligned_edge = UP\n\n            # check if the bar has height\n            if chart_val != 0:\n                quotient = value / chart_val\n                if quotient < 0:\n                    aligned_edge = UP if chart_val > 0 else DOWN\n\n                    # if the bar is already positive, then we now want to move it\n                    # so that it is negative. So, we move the top edge of the bar\n                    # to the location of the previous bottom\n\n                    # if already negative, then we move the bottom edge of the bar\n                    # to the location of the previous top\n\n                bar.stretch_to_fit_height(abs(quotient) * bar.height)\n\n            else:\n                # create a new bar since the current one has a height of zero (doesn't exist)\n                temp_bar = self._create_bar(i, value)\n                self.bars.remove(bar)\n                self.bars.insert(i, temp_bar)\n\n            bar.move_to(bar_lim, aligned_edge)\n\n        if update_colors:\n            self._update_colors()\n\n        self.values[: len(values)] = values", "code_sha1": "453b2ff9b6b8a063761ac56ac4e79b90986ac330"}
{"url": "https://docs.manim.community/en/stable/_modules/manim/mobject/logo.html", "depth": 2, "instruction": "The code creates a Manim banner featuring a stylized \"M\" logo and geometric shapes (circle, square, triangle) in a specified color scheme. The banner animates with a spiral-in effect for the shapes and a fade-in for the \"M\", followed by an expansion animation revealing the full logo text. The background color changes based on the theme (dark or light).", "code": "\"\"\"Utilities for Manim's logo and banner.\"\"\"\n\nfrom __future__ import annotations\n\n__all__ = [\"ManimBanner\"]\n\nimport svgelements as se\n\nfrom manim.animation.updaters.update import UpdateFromAlphaFunc\nfrom manim.mobject.geometry.arc import Circle\nfrom manim.mobject.geometry.polygram import Square, Triangle\n\nfrom .. import constants as cst\nfrom ..animation.animation import override_animation\nfrom ..animation.composition import AnimationGroup, Succession\nfrom ..animation.creation import Create, SpiralIn\nfrom ..animation.fading import FadeIn\nfrom ..mobject.svg.svg_mobject import VMobjectFromSVGPath\nfrom ..mobject.types.vectorized_mobject import VGroup\nfrom ..utils.rate_functions import ease_in_out_cubic, smooth\n\nMANIM_SVG_PATHS: list[se.Path] = [\n    se.Path(  # double stroke letter M\n        \"M4.64259-2.092154L2.739726-6.625156C2.660025-6.824408 2.650062-6.824408 \"\n        \"2.381071-6.824408H.52802C.348692-6.824408 .199253-6.824408 .199253-6.645\"\n        \"081C.199253-6.475716 .37858-6.475716 .428394-6.475716C.547945-6.475716 .\"\n        \"816936-6.455791 1.036115-6.37609V-1.05604C1.036115-.846824 1.036115-.408\"\n        \"468 .358655-.348692C.169365-.328767 .169365-.18929 .169365-.179328C.1693\"\n        \"65 0 .328767 0 .508095 0H2.052304C2.231631 0 2.381071 0 2.381071-.179328\"\n        \"C2.381071-.268991 2.30137-.33873 2.221669-.348692C1.454545-.408468 1.454\"\n        \"545-.826899 1.454545-1.05604V-6.017435L1.464508-6.027397L3.895392-.20921\"\n        \"5C3.975093-.029888 4.044832 0 4.104608 0C4.224159 0 4.254047-.079701 4.3\"\n        \"03861-.199253L6.744707-6.027397L6.75467-6.017435V-1.05604C6.75467-.84682\"\n        \"4 6.75467-.408468 6.07721-.348692C5.88792-.328767 5.88792-.18929 5.88792\"\n        \"-.179328C5.88792 0 6.047323 0 6.22665 0H8.886675C9.066002 0 9.215442 0 9\"\n        \".215442-.179328C9.215442-.268991 9.135741-.33873 9.05604-.348692C8.28891\"\n        \"7-.408468 8.288917-.826899 8.288917-1.05604V-5.768369C8.288917-5.977584 \"\n        \"8.288917-6.41594 8.966376-6.475716C9.066002-6.485679 9.155666-6.535492 9\"\n        \".155666-6.645081C9.155666-6.824408 9.006227-6.824408 8.826899-6.824408H6\"\n        \".90411C6.645081-6.824408 6.625156-6.824408 6.535492-6.615193L4.64259-2.0\"\n        \"92154ZM4.343711-1.912827C4.423412-1.743462 4.433375-1.733499 4.552927-1.\"\n        \"693649L4.11457-.637609H4.094645L1.823163-6.057285C1.77335-6.1868 1.69364\"\n        \"9-6.356164 1.554172-6.475716H2.420922L4.343711-1.912827ZM1.334994-.34869\"\n        \"2H1.165629C1.185554-.37858 1.205479-.408468 1.225405-.428394C1.235367-.4\"\n        \"38356 1.235367-.448319 1.24533-.458281L1.334994-.348692ZM7.103362-6.4757\"\n        \"16H8.159402C7.940224-6.22665 7.940224-5.967621 7.940224-5.788294V-1.0361\"\n        \"15C7.940224-.856787 7.940224-.597758 8.169365-.348692H6.884184C7.103362-\"\n        \".597758 7.103362-.856787 7.103362-1.036115V-6.475716Z\"\n    ),\n    se.Path(  # letter a\n        \"M1.464508-4.024907C1.464508-4.234122 1.743462-4.393524 2.092154-4.393524\"\n        \"C2.669988-4.393524 2.929016-4.124533 2.929016-3.516812V-2.789539C1.77335\"\n        \"-2.440847 .249066-2.042341 .249066-.916563C.249066-.308842 .71731 .13947\"\n        \"7 1.354919 .139477C1.92279 .139477 2.381071-.059776 2.929016-.557908C3.0\"\n        \"38605-.049813 3.257783 .139477 3.745953 .139477C4.174346 .139477 4.48318\"\n        \"8-.019925 4.861768-.428394L4.712329-.637609L4.612702-.537983C4.582814-.5\"\n        \"08095 4.552927-.498132 4.503113-.498132C4.363636-.498132 4.293898-.58779\"\n        \"6 4.293898-.747198V-3.347447C4.293898-4.184309 3.536737-4.712329 2.32129\"\n        \"5-4.712329C1.195517-4.712329 .438356-4.204234 .438356-3.457036C.438356-3\"\n        \".048568 .67746-2.799502 1.085928-2.799502C1.484433-2.799502 1.763387-3.0\"\n        \"38605 1.763387-3.377335C1.763387-3.676214 1.464508-3.88543 1.464508-4.02\"\n        \"4907ZM2.919054-.996264C2.650062-.687422 2.450809-.56787 2.211706-.56787C\"\n        \"1.912827-.56787 1.703611-.836862 1.703611-1.235367C1.703611-1.8132 2.122\"\n        \"042-2.231631 2.919054-2.440847V-.996264Z\"\n    ),\n    se.Path(  # letter n\n        \"M2.948941-4.044832C3.297634-4.044832 3.466999-3.775841 3.466999-3.217933\"\n        \"V-.806974C3.466999-.438356 3.337484-.278954 2.998755-.239103V0H5.339975V\"\n        \"-.239103C4.951432-.268991 4.851806-.388543 4.851806-.806974V-3.307597C4.\"\n        \"851806-4.164384 4.323786-4.712329 3.506849-4.712329C2.909091-4.712329 2.\"\n        \"450809-4.433375 2.082192-3.845579V-4.592777H.179328V-4.353674C.617684-4.\"\n        \"283935 .707347-4.184309 .707347-3.765878V-.836862C.707347-.418431 .62764\"\n        \"6-.328767 .179328-.239103V0H2.580324V-.239103C2.211706-.288917 2.092154-\"\n        \".438356 2.092154-.806974V-3.466999C2.092154-3.576588 2.530511-4.044832 2\"\n        \".948941-4.044832Z\"\n    ),\n    se.Path(  # letter i\n        \"M2.15193-4.592777H.239103V-4.353674C.67746-4.26401 .767123-4.174346 .767\"\n        \"123-3.765878V-.836862C.767123-.428394 .697385-.348692 .239103-.239103V0H\"\n        \"2.6401V-.239103C2.291407-.288917 2.15193-.428394 2.15193-.806974V-4.5927\"\n        \"77ZM1.454545-6.884184C1.026152-6.884184 .67746-6.535492 .67746-6.117061C\"\n        \".67746-5.668742 1.006227-5.339975 1.444583-5.339975S2.221669-5.668742 2.\"\n        \"221669-6.107098C2.221669-6.535492 1.882939-6.884184 1.454545-6.884184Z\"\n    ),\n    se.Path(  # letter m\n        \"M2.929016-4.044832C3.317559-4.044832 3.466999-3.815691 3.466999-3.217933\"\n        \"V-.806974C3.466999-.398506 3.35741-.268991 2.988792-.239103V0H5.32005V-.\"\n        \"239103C4.971357-.278954 4.851806-.428394 4.851806-.806974V-3.466999C4.85\"\n        \"1806-3.576588 5.310087-4.044832 5.69863-4.044832C6.07721-4.044832 6.2266\"\n        \"5-3.805729 6.22665-3.217933V-.806974C6.22665-.388543 6.117061-.268991 5.\"\n        \"738481-.239103V0H8.109589V-.239103C7.721046-.259029 7.611457-.37858 7.61\"\n        \"1457-.806974V-3.307597C7.611457-4.164384 7.083437-4.712329 6.266501-4.71\"\n        \"2329C5.69863-4.712329 5.32005-4.483188 4.801993-3.845579C4.503113-4.4732\"\n        \"25 4.154421-4.712329 3.526775-4.712329S2.440847-4.443337 2.062267-3.8455\"\n        \"79V-4.592777H.179328V-4.353674C.617684-4.293898 .707347-4.174346 .707347\"\n        \"-3.765878V-.836862C.707347-.428394 .617684-.318804 .179328-.239103V0H2.5\"\n        \"50436V-.239103C2.201743-.288917 2.092154-.428394 2.092154-.806974V-3.466\"\n        \"999C2.092154-3.58655 2.530511-4.044832 2.929016-4.044832Z\"\n    ),\n]\n\n\n\n[docs]\nclass ManimBanner(VGroup):\n    r\"\"\"Convenience class representing Manim's banner.\n\n    Can be animated using custom methods.\n\n    Parameters\n    ----------\n    dark_theme\n        If ``True`` (the default), the dark theme version of the logo\n        (with light text font) will be rendered. Otherwise, if ``False``,\n        the light theme version (with dark text font) is used.\n\n    Examples\n    --------\n    .. manim:: DarkThemeBanner\n\n        class DarkThemeBanner(Scene):\n            def construct(self):\n                banner = ManimBanner()\n                self.play(banner.create())\n                self.play(banner.expand())\n                self.wait()\n                self.play(Unwrite(banner))\n\n    .. manim:: LightThemeBanner\n\n        class LightThemeBanner(Scene):\n            def construct(self):\n                self.camera.background_color = \"#ece6e2\"\n                banner = ManimBanner(dark_theme=False)\n                self.play(banner.create())\n                self.play(banner.expand())\n                self.wait()\n                self.play(Unwrite(banner))\n\n    \"\"\"\n\n    def __init__(self, dark_theme: bool = True):\n        super().__init__()\n\n        logo_green = \"#81b29a\"\n        logo_blue = \"#454866\"\n        logo_red = \"#e07a5f\"\n        m_height_over_anim_height = 0.75748\n\n        self.font_color = \"#ece6e2\" if dark_theme else \"#343434\"\n        self.scale_factor = 1\n\n        self.M = VMobjectFromSVGPath(MANIM_SVG_PATHS[0]).flip(cst.RIGHT).center()\n        self.M.set(stroke_width=0).scale(\n            7 * cst.DEFAULT_FONT_SIZE * cst.SCALE_FACTOR_PER_FONT_POINT\n        )\n        self.M.set_fill(color=self.font_color, opacity=1).shift(\n            2.25 * cst.LEFT + 1.5 * cst.UP\n        )\n\n        self.circle = Circle(color=logo_green, fill_opacity=1).shift(cst.LEFT)\n        self.square = Square(color=logo_blue, fill_opacity=1).shift(cst.UP)\n        self.triangle = Triangle(color=logo_red, fill_opacity=1).shift(cst.RIGHT)\n        self.shapes = VGroup(self.triangle, self.square, self.circle)\n        self.add(self.shapes, self.M)\n        self.move_to(cst.ORIGIN)\n\n        anim = VGroup()\n        for ind, path in enumerate(MANIM_SVG_PATHS[1:]):\n            tex = VMobjectFromSVGPath(path).flip(cst.RIGHT).center()\n            tex.set(stroke_width=0).scale(\n                cst.DEFAULT_FONT_SIZE * cst.SCALE_FACTOR_PER_FONT_POINT\n            )\n            if ind > 0:\n                tex.next_to(anim, buff=0.01)\n            tex.align_to(self.M, cst.DOWN)\n            anim.add(tex)\n        anim.set_fill(color=self.font_color, opacity=1)\n        anim.height = m_height_over_anim_height * self.M.height\n\n        # Note: \"anim\" is only shown in the expanded state\n        # and thus not yet added to the submobjects of self.\n        self.anim = anim\n\n\n[docs]\n    def scale(self, scale_factor: float, **kwargs) -> ManimBanner:\n        \"\"\"Scale the banner by the specified scale factor.\n\n        Parameters\n        ----------\n        scale_factor\n            The factor used for scaling the banner.\n\n        Returns\n        -------\n        :class:`~.ManimBanner`\n            The scaled banner.\n        \"\"\"\n        self.scale_factor *= scale_factor\n        # Note: self.anim is only added to self after expand()\n        if self.anim not in self.submobjects:\n            self.anim.scale(scale_factor, **kwargs)\n        return super().scale(scale_factor, **kwargs)\n\n\n\n[docs]\n    @override_animation(Create)\n    def create(self, run_time: float = 2) -> AnimationGroup:\n        \"\"\"The creation animation for Manim's logo.\n\n        Parameters\n        ----------\n        run_time\n            The run time of the animation.\n\n        Returns\n        -------\n        :class:`~.AnimationGroup`\n            An animation to be used in a :meth:`.Scene.play` call.\n        \"\"\"\n        return AnimationGroup(\n            SpiralIn(self.shapes, run_time=run_time),\n            FadeIn(self.M, run_time=run_time / 2),\n            lag_ratio=0.1,\n        )\n\n\n\n[docs]\n    def expand(self, run_time: float = 1.5, direction=\"center\") -> Succession:\n        \"\"\"An animation that expands Manim's logo into its banner.\n\n        The returned animation transforms the banner from its initial\n        state (representing Manim's logo with just the icons) to its\n        expanded state (showing the full name together with the icons).\n\n        See the class documentation for how to use this.\n\n        .. note::\n\n            Before calling this method, the text \"anim\" is not a\n            submobject of the banner object. After the expansion,\n            it is added as a submobject so subsequent animations\n            to the banner object apply to the text \"anim\" as well.\n\n        Parameters\n        ----------\n        run_time\n            The run time of the animation.\n        direction\n            The direction in which the logo is expanded.\n\n        Returns\n        -------\n        :class:`~.Succession`\n            An animation to be used in a :meth:`.Scene.play` call.\n\n        Examples\n        --------\n        .. manim:: ExpandDirections\n\n            class ExpandDirections(Scene):\n                def construct(self):\n                    banners = [ManimBanner().scale(0.5).shift(UP*x) for x in [-2, 0, 2]]\n                    self.play(\n                        banners[0].expand(direction=\"right\"),\n                        banners[1].expand(direction=\"center\"),\n                        banners[2].expand(direction=\"left\"),\n                    )\n\n        \"\"\"\n        if direction not in [\"left\", \"right\", \"center\"]:\n            raise ValueError(\"direction must be 'left', 'right' or 'center'.\")\n\n        m_shape_offset = 6.25 * self.scale_factor\n        shape_sliding_overshoot = self.scale_factor * 0.8\n        m_anim_buff = 0.06\n        self.anim.next_to(self.M, buff=m_anim_buff).align_to(self.M, cst.DOWN)\n        self.anim.set_opacity(0)\n        self.shapes.save_state()\n        m_clone = self.anim[-1].copy()\n        self.add(m_clone)\n        m_clone.move_to(self.shapes)\n\n        self.M.save_state()\n        left_group = VGroup(self.M, self.anim, m_clone)\n\n        def shift(vector):\n            self.shapes.restore()\n            left_group.align_to(self.M.saved_state, cst.LEFT)\n            if direction == \"right\":\n                self.shapes.shift(vector)\n            elif direction == \"center\":\n                self.shapes.shift(vector / 2)\n                left_group.shift(-vector / 2)\n            elif direction == \"left\":\n                left_group.shift(-vector)\n\n        def slide_and_uncover(mob, alpha):\n            shift(alpha * (m_shape_offset + shape_sliding_overshoot) * cst.RIGHT)\n\n            # Add letters when they are covered\n            for letter in mob.anim:\n                if mob.square.get_center()[0] > letter.get_center()[0]:\n                    letter.set_opacity(1)\n                    self.add_to_back(letter)\n\n            # Finish animation\n            if alpha == 1:\n                self.remove(*[self.anim])\n                self.add_to_back(self.anim)\n                mob.shapes.set_z_index(0)\n                mob.shapes.save_state()\n                mob.M.save_state()\n\n        def slide_back(mob, alpha):\n            if alpha == 0:\n                m_clone.set_opacity(1)\n                m_clone.move_to(mob.anim[-1])\n                mob.anim.set_opacity(1)\n\n            shift(alpha * shape_sliding_overshoot * cst.LEFT)\n\n            if alpha == 1:\n                mob.remove(m_clone)\n                mob.add_to_back(mob.shapes)\n\n        return Succession(\n            UpdateFromAlphaFunc(\n                self,\n                slide_and_uncover,\n                run_time=run_time * 2 / 3,\n                rate_func=ease_in_out_cubic,\n            ),\n            UpdateFromAlphaFunc(\n                self,\n                slide_back,\n                run_time=run_time * 1 / 3,\n                rate_func=smooth,\n            ),\n        )", "code_sha1": "2af0302a253b48c321244d9a27aae2148e0adf9e"}
{"url": "https://docs.manim.community/en/stable/_modules/manim/mobject/matrix.html", "depth": 2, "instruction": "The code creates a scene displaying four types of matrices arranged in a grid: a standard matrix with LaTeX symbols, an integer matrix with parentheses, a decimal matrix with curly brackets, and a matrix of geometric shapes (circle, square, pi symbol, star). Each matrix is visually distinct, with appropriate brackets and spacing.", "code": "r\"\"\"Mobjects representing matrices.\n\nExamples\n--------\n\n.. manim:: MatrixExamples\n    :save_last_frame:\n\n    class MatrixExamples(Scene):\n        def construct(self):\n            m0 = Matrix([[\"\\\\pi\", 0], [-1, 1]])\n            m1 = IntegerMatrix([[1.5, 0.], [12, -1.3]],\n                left_bracket=\"(\",\n                right_bracket=\")\")\n            m2 = DecimalMatrix(\n                [[3.456, 2.122], [33.2244, 12.33]],\n                element_to_mobject_config={\"num_decimal_places\": 2},\n                left_bracket=r\"\\{\",\n                right_bracket=r\"\\}\")\n            m3 = MobjectMatrix(\n                [[Circle().scale(0.3), Square().scale(0.3)],\n                [MathTex(\"\\\\pi\").scale(2), Star().scale(0.3)]],\n                left_bracket=\"\\\\langle\",\n                right_bracket=\"\\\\rangle\")\n            g = Group(m0, m1, m2, m3).arrange_in_grid(buff=2)\n            self.add(g)\n\"\"\"\n\nfrom __future__ import annotations\n\n__all__ = [\n    \"Matrix\",\n    \"DecimalMatrix\",\n    \"IntegerMatrix\",\n    \"MobjectMatrix\",\n    \"matrix_to_tex_string\",\n    \"matrix_to_mobject\",\n    \"get_det_text\",\n]\n\n\nimport itertools as it\nfrom collections.abc import Iterable, Sequence\n\nimport numpy as np\n\nfrom manim.mobject.mobject import Mobject\nfrom manim.mobject.opengl.opengl_compatibility import ConvertToOpenGL\nfrom manim.mobject.text.numbers import DecimalNumber, Integer\nfrom manim.mobject.text.tex_mobject import MathTex, Tex\n\nfrom ..constants import *\nfrom ..mobject.types.vectorized_mobject import VGroup, VMobject\n\n# TO DO : The following two functions are not used in this file.\n#         Not sure if we should keep it or not.\n\n\n\n[docs]\ndef matrix_to_tex_string(matrix):\n    matrix = np.array(matrix).astype(\"str\")\n    if matrix.ndim == 1:\n        matrix = matrix.reshape((matrix.size, 1))\n    n_rows, n_cols = matrix.shape\n    prefix = \"\\\\left[ \\\\begin{array}{%s}\" % (\"c\" * n_cols)\n    suffix = \"\\\\end{array} \\\\right]\"\n    rows = [\" & \".join(row) for row in matrix]\n    return prefix + \" \\\\\\\\ \".join(rows) + suffix\n\n\n\n\n[docs]\ndef matrix_to_mobject(matrix):\n    return MathTex(matrix_to_tex_string(matrix))\n\n\n\n\n[docs]\nclass Matrix(VMobject, metaclass=ConvertToOpenGL):\n    r\"\"\"A mobject that displays a matrix on the screen.\n\n    Parameters\n    ----------\n    matrix\n        A numpy 2d array or list of lists.\n    v_buff\n        Vertical distance between elements, by default 0.8.\n    h_buff\n        Horizontal distance between elements, by default 1.3.\n    bracket_h_buff\n        Distance of the brackets from the matrix, by default ``MED_SMALL_BUFF``.\n    bracket_v_buff\n        Height of the brackets, by default ``MED_SMALL_BUFF``.\n    add_background_rectangles_to_entries\n        ``True`` if should add backgraound rectangles to entries, by default ``False``.\n    include_background_rectangle\n        ``True`` if should include background rectangle, by default ``False``.\n    element_to_mobject\n        The mobject class used to construct the elements, by default :class:`~.MathTex`.\n    element_to_mobject_config\n        Additional arguments to be passed to the constructor in ``element_to_mobject``,\n        by default ``{}``.\n    element_alignment_corner\n        The corner to which elements are aligned, by default ``DR``.\n    left_bracket\n        The left bracket type, by default ``\"[\"``.\n    right_bracket\n        The right bracket type, by default ``\"]\"``.\n    stretch_brackets\n        ``True`` if should stretch the brackets to fit the height of matrix contents, by default ``True``.\n    bracket_config\n        Additional arguments to be passed to :class:`~.MathTex` when constructing\n        the brackets.\n\n    Examples\n    --------\n    The first example shows a variety of uses of this module while the second example\n    exlpains the use of the options `add_background_rectangles_to_entries` and\n    `include_background_rectangle`.\n\n    .. manim:: MatrixExamples\n        :save_last_frame:\n\n        class MatrixExamples(Scene):\n            def construct(self):\n                m0 = Matrix([[2, r\"\\pi\"], [-1, 1]])\n                m1 = Matrix([[2, 0, 4], [-1, 1, 5]],\n                    v_buff=1.3,\n                    h_buff=0.8,\n                    bracket_h_buff=SMALL_BUFF,\n                    bracket_v_buff=SMALL_BUFF,\n                    left_bracket=r\"\\{\",\n                    right_bracket=r\"\\}\")\n                m1.add(SurroundingRectangle(m1.get_columns()[1]))\n                m2 = Matrix([[2, 1], [-1, 3]],\n                    element_alignment_corner=UL,\n                    left_bracket=\"(\",\n                    right_bracket=\")\")\n                m3 = Matrix([[2, 1], [-1, 3]],\n                    left_bracket=r\"\\langle\",\n                    right_bracket=r\"\\rangle\")\n                m4 = Matrix([[2, 1], [-1, 3]],\n                ).set_column_colors(RED, GREEN)\n                m5 = Matrix([[2, 1], [-1, 3]],\n                ).set_row_colors(RED, GREEN)\n                g = Group(\n                    m0,m1,m2,m3,m4,m5\n                ).arrange_in_grid(buff=2)\n                self.add(g)\n\n    .. manim:: BackgroundRectanglesExample\n        :save_last_frame:\n\n        class BackgroundRectanglesExample(Scene):\n            def construct(self):\n                background= Rectangle().scale(3.2)\n                background.set_fill(opacity=.5)\n                background.set_color([TEAL, RED, YELLOW])\n                self.add(background)\n                m0 = Matrix([[12, -30], [-1, 15]],\n                    add_background_rectangles_to_entries=True)\n                m1 = Matrix([[2, 0], [-1, 1]],\n                    include_background_rectangle=True)\n                m2 = Matrix([[12, -30], [-1, 15]])\n                g = Group(m0, m1, m2).arrange(buff=2)\n                self.add(g)\n    \"\"\"\n\n    def __init__(\n        self,\n        matrix: Iterable,\n        v_buff: float = 0.8,\n        h_buff: float = 1.3,\n        bracket_h_buff: float = MED_SMALL_BUFF,\n        bracket_v_buff: float = MED_SMALL_BUFF,\n        add_background_rectangles_to_entries: bool = False,\n        include_background_rectangle: bool = False,\n        element_to_mobject: type[MathTex] = MathTex,\n        element_to_mobject_config: dict = {},\n        element_alignment_corner: Sequence[float] = DR,\n        left_bracket: str = \"[\",\n        right_bracket: str = \"]\",\n        stretch_brackets: bool = True,\n        bracket_config: dict = {},\n        **kwargs,\n    ):\n        self.v_buff = v_buff\n        self.h_buff = h_buff\n        self.bracket_h_buff = bracket_h_buff\n        self.bracket_v_buff = bracket_v_buff\n        self.add_background_rectangles_to_entries = add_background_rectangles_to_entries\n        self.include_background_rectangle = include_background_rectangle\n        self.element_to_mobject = element_to_mobject\n        self.element_to_mobject_config = element_to_mobject_config\n        self.element_alignment_corner = element_alignment_corner\n        self.left_bracket = left_bracket\n        self.right_bracket = right_bracket\n        self.stretch_brackets = stretch_brackets\n        super().__init__(**kwargs)\n        mob_matrix = self._matrix_to_mob_matrix(matrix)\n        self._organize_mob_matrix(mob_matrix)\n        self.elements = VGroup(*it.chain(*mob_matrix))\n        self.add(self.elements)\n        self._add_brackets(self.left_bracket, self.right_bracket, **bracket_config)\n        self.center()\n        self.mob_matrix = mob_matrix\n        if self.add_background_rectangles_to_entries:\n            for mob in self.elements:\n                mob.add_background_rectangle()\n        if self.include_background_rectangle:\n            self.add_background_rectangle()\n\n    def _matrix_to_mob_matrix(self, matrix):\n        return [\n            [\n                self.element_to_mobject(item, **self.element_to_mobject_config)\n                for item in row\n            ]\n            for row in matrix\n        ]\n\n    def _organize_mob_matrix(self, matrix):\n        for i, row in enumerate(matrix):\n            for j, _ in enumerate(row):\n                mob = matrix[i][j]\n                mob.move_to(\n                    i * self.v_buff * DOWN + j * self.h_buff * RIGHT,\n                    self.element_alignment_corner,\n                )\n        return self\n\n\n[docs]\n    def _add_brackets(self, left: str = \"[\", right: str = \"]\", **kwargs):\n        \"\"\"Adds the brackets to the Matrix mobject.\n\n        See Latex document for various bracket types.\n\n        Parameters\n        ----------\n        left\n            the left bracket, by default \"[\"\n        right\n            the right bracket, by default \"]\"\n\n        Returns\n        -------\n        :class:`Matrix`\n            The current matrix object (self).\n        \"\"\"\n        # Height per row of LaTeX array with default settings\n        BRACKET_HEIGHT = 0.5977\n\n        n = int((self.height) / BRACKET_HEIGHT) + 1\n        empty_tex_array = \"\".join(\n            [\n                r\"\\begin{array}{c}\",\n                *n * [r\"\\quad \\\\\"],\n                r\"\\end{array}\",\n            ]\n        )\n        tex_left = \"\".join(\n            [\n                r\"\\left\" + left,\n                empty_tex_array,\n                r\"\\right.\",\n            ]\n        )\n        tex_right = \"\".join(\n            [\n                r\"\\left.\",\n                empty_tex_array,\n                r\"\\right\" + right,\n            ]\n        )\n        l_bracket = MathTex(tex_left, **kwargs)\n        r_bracket = MathTex(tex_right, **kwargs)\n\n        bracket_pair = VGroup(l_bracket, r_bracket)\n        if self.stretch_brackets:\n            bracket_pair.stretch_to_fit_height(self.height + 2 * self.bracket_v_buff)\n        l_bracket.next_to(self, LEFT, self.bracket_h_buff)\n        r_bracket.next_to(self, RIGHT, self.bracket_h_buff)\n        self.brackets = bracket_pair\n        self.add(l_bracket, r_bracket)\n        return self\n\n\n\n[docs]\n    def get_columns(self):\n        r\"\"\"Return columns of the matrix as VGroups.\n\n        Returns\n        --------\n        List[:class:`~.VGroup`]\n            Each VGroup contains a column of the matrix.\n\n        Examples\n        --------\n\n        .. manim:: GetColumnsExample\n            :save_last_frame:\n\n            class GetColumnsExample(Scene):\n                def construct(self):\n                    m0 = Matrix([[r\"\\pi\", 3], [1, 5]])\n                    m0.add(SurroundingRectangle(m0.get_columns()[1]))\n                    self.add(m0)\n        \"\"\"\n        return VGroup(\n            *(\n                VGroup(*(row[i] for row in self.mob_matrix))\n                for i in range(len(self.mob_matrix[0]))\n            )\n        )\n\n\n\n[docs]\n    def set_column_colors(self, *colors: str):\n        r\"\"\"Set individual colors for each columns of the matrix.\n\n        Parameters\n        ----------\n        colors\n            The list of colors; each color specified corresponds to a column.\n\n        Returns\n        -------\n        :class:`Matrix`\n            The current matrix object (self).\n\n        Examples\n        --------\n\n        .. manim:: SetColumnColorsExample\n            :save_last_frame:\n\n            class SetColumnColorsExample(Scene):\n                def construct(self):\n                    m0 = Matrix([[\"\\\\pi\", 1], [-1, 3]],\n                    ).set_column_colors([RED,BLUE], GREEN)\n                    self.add(m0)\n        \"\"\"\n        columns = self.get_columns()\n        for color, column in zip(colors, columns):\n            column.set_color(color)\n        return self\n\n\n\n[docs]\n    def get_rows(self):\n        r\"\"\"Return rows of the matrix as VGroups.\n\n        Returns\n        --------\n        List[:class:`~.VGroup`]\n            Each VGroup contains a row of the matrix.\n\n        Examples\n        --------\n\n        .. manim:: GetRowsExample\n            :save_last_frame:\n\n            class GetRowsExample(Scene):\n                def construct(self):\n                    m0 = Matrix([[\"\\\\pi\", 3], [1, 5]])\n                    m0.add(SurroundingRectangle(m0.get_rows()[1]))\n                    self.add(m0)\n        \"\"\"\n        return VGroup(*(VGroup(*row) for row in self.mob_matrix))\n\n\n\n[docs]\n    def set_row_colors(self, *colors: str):\n        r\"\"\"Set individual colors for each row of the matrix.\n\n        Parameters\n        ----------\n        colors\n            The list of colors; each color specified corresponds to a row.\n\n        Returns\n        -------\n        :class:`Matrix`\n            The current matrix object (self).\n\n        Examples\n        --------\n\n        .. manim:: SetRowColorsExample\n            :save_last_frame:\n\n            class SetRowColorsExample(Scene):\n                def construct(self):\n                    m0 = Matrix([[\"\\\\pi\", 1], [-1, 3]],\n                    ).set_row_colors([RED,BLUE], GREEN)\n                    self.add(m0)\n        \"\"\"\n        rows = self.get_rows()\n        for color, row in zip(colors, rows):\n            row.set_color(color)\n        return self\n\n\n\n[docs]\n    def add_background_to_entries(self):\n        \"\"\"Add a black background rectangle to the matrix,\n        see above for an example.\n\n        Returns\n        -------\n        :class:`Matrix`\n            The current matrix object (self).\n        \"\"\"\n        for mob in self.get_entries():\n            mob.add_background_rectangle()\n        return self\n\n\n\n[docs]\n    def get_mob_matrix(self):\n        \"\"\"Return the underlying mob matrix mobjects.\n\n        Returns\n        --------\n        List[:class:`~.VGroup`]\n            Each VGroup contains a row of the matrix.\n        \"\"\"\n        return self.mob_matrix\n\n\n\n[docs]\n    def get_entries(self):\n        \"\"\"Return the individual entries of the matrix.\n\n        Returns\n        --------\n        :class:`~.VGroup`\n            VGroup containing entries of the matrix.\n\n        Examples\n        --------\n\n        .. manim:: GetEntriesExample\n            :save_last_frame:\n\n            class GetEntriesExample(Scene):\n                def construct(self):\n                    m0 = Matrix([[2, 3], [1, 5]])\n                    ent = m0.get_entries()\n                    colors = [BLUE, GREEN, YELLOW, RED]\n                    for k in range(len(colors)):\n                        ent[k].set_color(colors[k])\n                    self.add(m0)\n        \"\"\"\n        return self.elements\n\n\n\n[docs]\n    def get_brackets(self):\n        r\"\"\"Return the bracket mobjects.\n\n        Returns\n        --------\n        List[:class:`~.VGroup`]\n            Each VGroup contains a bracket\n\n        Examples\n        --------\n\n        .. manim:: GetBracketsExample\n            :save_last_frame:\n\n            class GetBracketsExample(Scene):\n                def construct(self):\n                    m0 = Matrix([[\"\\\\pi\", 3], [1, 5]])\n                    bra = m0.get_brackets()\n                    colors = [BLUE, GREEN]\n                    for k in range(len(colors)):\n                        bra[k].set_color(colors[k])\n                    self.add(m0)\n        \"\"\"\n        return self.brackets\n\n\n\n\n\n[docs]\nclass DecimalMatrix(Matrix):\n    r\"\"\"A mobject that displays a matrix with decimal entries on the screen.\n\n    Examples\n    --------\n\n    .. manim:: DecimalMatrixExample\n        :save_last_frame:\n\n        class DecimalMatrixExample(Scene):\n            def construct(self):\n                m0 = DecimalMatrix(\n                    [[3.456, 2.122], [33.2244, 12]],\n                    element_to_mobject_config={\"num_decimal_places\": 2},\n                    left_bracket=\"\\\\{\",\n                    right_bracket=\"\\\\}\")\n                self.add(m0)\n    \"\"\"\n\n    def __init__(\n        self,\n        matrix: Iterable,\n        element_to_mobject: Mobject = DecimalNumber,\n        element_to_mobject_config: dict[str, Mobject] = {\"num_decimal_places\": 1},\n        **kwargs,\n    ):\n        \"\"\"\n        Will round/truncate the decimal places as per the provided config.\n\n        Parameters\n        ----------\n        matrix\n            A numpy 2d array or list of lists\n        element_to_mobject\n            Mobject to use, by default DecimalNumber\n        element_to_mobject_config\n            Config for the desired mobject, by default {\"num_decimal_places\": 1}\n        \"\"\"\n        super().__init__(\n            matrix,\n            element_to_mobject=element_to_mobject,\n            element_to_mobject_config=element_to_mobject_config,\n            **kwargs,\n        )\n\n\n\n\n[docs]\nclass IntegerMatrix(Matrix):\n    \"\"\"A mobject that displays a matrix with integer entries on the screen.\n\n    Examples\n    --------\n\n    .. manim:: IntegerMatrixExample\n        :save_last_frame:\n\n        class IntegerMatrixExample(Scene):\n            def construct(self):\n                m0 = IntegerMatrix(\n                    [[3.7, 2], [42.2, 12]],\n                    left_bracket=\"(\",\n                    right_bracket=\")\")\n                self.add(m0)\n    \"\"\"\n\n    def __init__(\n        self, matrix: Iterable, element_to_mobject: Mobject = Integer, **kwargs\n    ):\n        \"\"\"\n        Will round if there are decimal entries in the matrix.\n\n        Parameters\n        ----------\n        matrix\n            A numpy 2d array or list of lists\n        element_to_mobject\n            Mobject to use, by default Integer\n        \"\"\"\n        super().__init__(matrix, element_to_mobject=element_to_mobject, **kwargs)\n\n\n\n\n[docs]\nclass MobjectMatrix(Matrix):\n    r\"\"\"A mobject that displays a matrix of mobject entries on the screen.\n\n    Examples\n    --------\n\n    .. manim:: MobjectMatrixExample\n        :save_last_frame:\n\n        class MobjectMatrixExample(Scene):\n            def construct(self):\n                a = Circle().scale(0.3)\n                b = Square().scale(0.3)\n                c = MathTex(\"\\\\pi\").scale(2)\n                d = Star().scale(0.3)\n                m0 = MobjectMatrix([[a, b], [c, d]])\n                self.add(m0)\n    \"\"\"\n\n    def __init__(self, matrix, element_to_mobject=lambda m: m, **kwargs):\n        super().__init__(matrix, element_to_mobject=element_to_mobject, **kwargs)\n\n\n\n\n[docs]\ndef get_det_text(\n    matrix: Matrix,\n    determinant: int | str | None = None,\n    background_rect: bool = False,\n    initial_scale_factor: float = 2,\n):\n    r\"\"\"Helper function to create determinant.\n\n    Parameters\n    ----------\n    matrix\n        The matrix whose determinant is to be created\n\n    determinant\n        The value of the determinant of the matrix\n\n    background_rect\n        The background rectangle\n\n    initial_scale_factor\n        The scale of the text `det` w.r.t the matrix\n\n    Returns\n    --------\n    :class:`~.VGroup`\n        A VGroup containing the determinant\n\n    Examples\n    --------\n\n    .. manim:: DeterminantOfAMatrix\n        :save_last_frame:\n\n        class DeterminantOfAMatrix(Scene):\n            def construct(self):\n                matrix = Matrix([\n                    [2, 0],\n                    [-1, 1]\n                ])\n\n                # scaling down the `det` string\n                det = get_det_text(matrix,\n                            determinant=3,\n                            initial_scale_factor=1)\n\n                # must add the matrix\n                self.add(matrix)\n                self.add(det)\n    \"\"\"\n    parens = MathTex(\"(\", \")\")\n    parens.scale(initial_scale_factor)\n    parens.stretch_to_fit_height(matrix.height)\n    l_paren, r_paren = parens.split()\n    l_paren.next_to(matrix, LEFT, buff=0.1)\n    r_paren.next_to(matrix, RIGHT, buff=0.1)\n    det = Tex(\"det\")\n    det.scale(initial_scale_factor)\n    det.next_to(l_paren, LEFT, buff=0.1)\n    if background_rect:\n        det.add_background_rectangle()\n    det_text = VGroup(det, l_paren, r_paren)\n    if determinant is not None:\n        eq = MathTex(\"=\")\n        eq.next_to(r_paren, RIGHT, buff=0.1)\n        result = MathTex(str(determinant))\n        result.next_to(eq, RIGHT, buff=0.2)\n        det_text.add(eq, result)\n    return det_text", "code_sha1": "68936d928e38a2749289c9127e0be674bc6ba935"}
{"url": "https://docs.manim.community/en/stable/_modules/manim/mobject/mobject.html", "depth": 2, "instruction": "The code defines a base class `Mobject` for displayable objects in Manim, featuring attributes for color, dimensions, and submobjects. It includes methods for animations, transformations, and positioning, allowing for complex visual manipulations. The `Group` class extends `Mobject` to manage collections of submobjects, facilitating organized scene construction.", "code": "\"\"\"Base classes for objects that can be displayed.\"\"\"\n\nfrom __future__ import annotations\n\n__all__ = [\"Mobject\", \"Group\", \"override_animate\"]\n\n\nimport copy\nimport inspect\nimport itertools as it\nimport math\nimport operator as op\nimport random\nimport sys\nimport types\nimport warnings\nfrom collections.abc import Iterable\nfrom functools import partialmethod, reduce\nfrom pathlib import Path\nfrom typing import TYPE_CHECKING\n\nimport numpy as np\n\nfrom manim.mobject.opengl.opengl_compatibility import ConvertToOpenGL\n\nfrom .. import config, logger\nfrom ..constants import *\nfrom ..utils.color import (\n    BLACK,\n    WHITE,\n    YELLOW_C,\n    ManimColor,\n    ParsableManimColor,\n    color_gradient,\n    interpolate_color,\n)\nfrom ..utils.exceptions import MultiAnimationOverrideException\nfrom ..utils.iterables import list_update, remove_list_redundancies\nfrom ..utils.paths import straight_path\nfrom ..utils.space_ops import angle_between_vectors, normalize, rotation_matrix\n\nif TYPE_CHECKING:\n    from typing import Any, Callable, Literal\n\n    from typing_extensions import Self, TypeAlias\n\n    from manim.typing import (\n        FunctionOverride,\n        MappingFunction,\n        MultiMappingFunction,\n        PathFuncType,\n        PixelArray,\n        Point3D,\n        Point3DLike,\n        Point3DLike_Array,\n        Vector3D,\n    )\n\n    from ..animation.animation import Animation\n\n    TimeBasedUpdater: TypeAlias = Callable[[\"Mobject\", float], object]\n    NonTimeBasedUpdater: TypeAlias = Callable[[\"Mobject\"], object]\n    Updater: TypeAlias = NonTimeBasedUpdater | TimeBasedUpdater\n\n\n\n[docs]\nclass Mobject:\n    \"\"\"Mathematical Object: base class for objects that can be displayed on screen.\n\n    There is a compatibility layer that allows for\n    getting and setting generic attributes with ``get_*``\n    and ``set_*`` methods. See :meth:`set` for more details.\n\n    Attributes\n    ----------\n    submobjects : List[:class:`Mobject`]\n        The contained objects.\n    points : :class:`numpy.ndarray`\n        The points of the objects.\n\n        .. seealso::\n\n            :class:`~.VMobject`\n\n    \"\"\"\n\n    animation_overrides = {}\n\n    @classmethod\n    def __init_subclass__(cls, **kwargs) -> None:\n        super().__init_subclass__(**kwargs)\n\n        cls.animation_overrides: dict[\n            type[Animation],\n            FunctionOverride,\n        ] = {}\n        cls._add_intrinsic_animation_overrides()\n        cls._original__init__ = cls.__init__\n\n    def __init__(\n        self,\n        color: ParsableManimColor | list[ParsableManimColor] = WHITE,\n        name: str | None = None,\n        dim: int = 3,\n        target=None,\n        z_index: float = 0,\n    ) -> None:\n        self.name = self.__class__.__name__ if name is None else name\n        self.dim = dim\n        self.target = target\n        self.z_index = z_index\n        self.point_hash = None\n        self.submobjects = []\n        self.updaters: list[Updater] = []\n        self.updating_suspended = False\n        self.color = ManimColor.parse(color)\n\n        self.reset_points()\n        self.generate_points()\n        self.init_colors()\n\n\n[docs]\n    def _assert_valid_submobjects(self, submobjects: Iterable[Mobject]) -> Self:\n        \"\"\"Check that all submobjects are actually instances of\n        :class:`Mobject`, and that none of them is ``self`` (a\n        :class:`Mobject` cannot contain itself).\n\n        This is an auxiliary function called when adding Mobjects to the\n        :attr:`submobjects` list.\n\n        This function is intended to be overridden by subclasses such as\n        :class:`VMobject`, which should assert that only other VMobjects\n        may be added into it.\n\n        Parameters\n        ----------\n        submobjects\n            The list containing values to validate.\n\n        Returns\n        -------\n        :class:`Mobject`\n            The Mobject itself.\n\n        Raises\n        ------\n        TypeError\n            If any of the values in `submobjects` is not a :class:`Mobject`.\n        ValueError\n            If there was an attempt to add a :class:`Mobject` as its own\n            submobject.\n        \"\"\"\n        return self._assert_valid_submobjects_internal(submobjects, Mobject)\n\n\n    def _assert_valid_submobjects_internal(\n        self, submobjects: list[Mobject], mob_class: type[Mobject]\n    ) -> Self:\n        for i, submob in enumerate(submobjects):\n            if not isinstance(submob, mob_class):\n                error_message = (\n                    f\"Only values of type {mob_class.__name__} can be added \"\n                    f\"as submobjects of {type(self).__name__}, but the value \"\n                    f\"{submob} (at index {i}) is of type \"\n                    f\"{type(submob).__name__}.\"\n                )\n                # Intended for subclasses such as VMobject, which\n                # cannot have regular Mobjects as submobjects\n                if isinstance(submob, Mobject):\n                    error_message += (\n                        \" You can try adding this value into a Group instead.\"\n                    )\n                raise TypeError(error_message)\n            if submob is self:\n                raise ValueError(\n                    f\"Cannot add {type(self).__name__} as a submobject of \"\n                    f\"itself (at index {i}).\"\n                )\n        return self\n\n\n[docs]\n    @classmethod\n    def animation_override_for(\n        cls,\n        animation_class: type[Animation],\n    ) -> FunctionOverride | None:\n        \"\"\"Returns the function defining a specific animation override for this class.\n\n        Parameters\n        ----------\n        animation_class\n            The animation class for which the override function should be returned.\n\n        Returns\n        -------\n        Optional[Callable[[Mobject, ...], Animation]]\n            The function returning the override animation or ``None`` if no such animation\n            override is defined.\n        \"\"\"\n        if animation_class in cls.animation_overrides:\n            return cls.animation_overrides[animation_class]\n\n        return None\n\n\n\n[docs]\n    @classmethod\n    def _add_intrinsic_animation_overrides(cls) -> None:\n        \"\"\"Initializes animation overrides marked with the :func:`~.override_animation`\n        decorator.\n        \"\"\"\n        for method_name in dir(cls):\n            # Ignore dunder methods\n            if method_name.startswith(\"__\"):\n                continue\n\n            method = getattr(cls, method_name)\n            if hasattr(method, \"_override_animation\"):\n                animation_class = method._override_animation\n                cls.add_animation_override(animation_class, method)\n\n\n\n[docs]\n    @classmethod\n    def add_animation_override(\n        cls,\n        animation_class: type[Animation],\n        override_func: FunctionOverride,\n    ) -> None:\n        \"\"\"Add an animation override.\n\n        This does not apply to subclasses.\n\n        Parameters\n        ----------\n        animation_class\n            The animation type to be overridden\n        override_func\n            The function returning an animation replacing the default animation. It gets\n            passed the parameters given to the animation constructor.\n\n        Raises\n        ------\n        MultiAnimationOverrideException\n            If the overridden animation was already overridden.\n        \"\"\"\n        if animation_class not in cls.animation_overrides:\n            cls.animation_overrides[animation_class] = override_func\n        else:\n            raise MultiAnimationOverrideException(\n                f\"The animation {animation_class.__name__} for \"\n                f\"{cls.__name__} is overridden by more than one method: \"\n                f\"{cls.animation_overrides[animation_class].__qualname__} and \"\n                f\"{override_func.__qualname__}.\",\n            )\n\n\n\n[docs]\n    @classmethod\n    def set_default(cls, **kwargs) -> None:\n        \"\"\"Sets the default values of keyword arguments.\n\n        If this method is called without any additional keyword\n        arguments, the original default values of the initialization\n        method of this class are restored.\n\n        Parameters\n        ----------\n\n        kwargs\n            Passing any keyword argument will update the default\n            values of the keyword arguments of the initialization\n            function of this class.\n\n        Examples\n        --------\n\n        ::\nfrom manim import Square, GREEN\nSquare.set_default(color=GREEN, fill_opacity=0.25)\ns = Square(); s.color, s.fill_opacity\n            (ManimColor('#83C167'), 0.25)\nSquare.set_default()\ns = Square(); s.color, s.fill_opacity\n            (ManimColor('#FFFFFF'), 0.0)\n\n        .. manim:: ChangedDefaultTextcolor\n            :save_last_frame:\n\n            config.background_color = WHITE\n\n            class ChangedDefaultTextcolor(Scene):\n                def construct(self):\n                    Text.set_default(color=BLACK)\n                    self.add(Text(\"Changing default values is easy!\"))\n\n                    # we revert the colour back to the default to prevent a bug in the docs.\n                    Text.set_default(color=WHITE)\n\n        \"\"\"\n        if kwargs:\n            cls.__init__ = partialmethod(cls.__init__, **kwargs)\n        else:\n            cls.__init__ = cls._original__init__\n\n\n    @property\n    def animate(self) -> _AnimationBuilder | Self:\n        \"\"\"Used to animate the application of any method of :code:`self`.\n\n        Any method called on :code:`animate` is converted to an animation of applying\n        that method on the mobject itself.\n\n        For example, :code:`square.set_fill(WHITE)` sets the fill color of a square,\n        while :code:`square.animate.set_fill(WHITE)` animates this action.\n\n        Multiple methods can be put in a single animation once via chaining:\n\n        ::\n\n            self.play(my_mobject.animate.shift(RIGHT).rotate(PI))\n\n        .. warning::\n\n            Passing multiple animations for the same :class:`Mobject` in one\n            call to :meth:`~.Scene.play` is discouraged and will most likely\n            not work properly. Instead of writing an animation like\n\n            ::\n\n                self.play(\n                    my_mobject.animate.shift(RIGHT), my_mobject.animate.rotate(PI)\n                )\n\n            make use of method chaining.\n\n        Keyword arguments that can be passed to :meth:`.Scene.play` can be passed\n        directly after accessing ``.animate``, like so::\n\n            self.play(my_mobject.animate(rate_func=linear).shift(RIGHT))\n\n        This is especially useful when animating simultaneous ``.animate`` calls that\n        you want to behave differently::\n\n            self.play(\n                mobject1.animate(run_time=2).rotate(PI),\n                mobject2.animate(rate_func=there_and_back).shift(RIGHT),\n            )\n\n        .. seealso::\n\n            :func:`override_animate`\n\n\n        Examples\n        --------\n\n        .. manim:: AnimateExample\n\n            class AnimateExample(Scene):\n                def construct(self):\n                    s = Square()\n                    self.play(Create(s))\n                    self.play(s.animate.shift(RIGHT))\n                    self.play(s.animate.scale(2))\n                    self.play(s.animate.rotate(PI / 2))\n                    self.play(Uncreate(s))\n\n\n        .. manim:: AnimateChainExample\n\n            class AnimateChainExample(Scene):\n                def construct(self):\n                    s = Square()\n                    self.play(Create(s))\n                    self.play(s.animate.shift(RIGHT).scale(2).rotate(PI / 2))\n                    self.play(Uncreate(s))\n\n        .. manim:: AnimateWithArgsExample\n\n            class AnimateWithArgsExample(Scene):\n                def construct(self):\n                    s = Square()\n                    c = Circle()\n\n                    VGroup(s, c).arrange(RIGHT, buff=2)\n                    self.add(s, c)\n\n                    self.play(\n                        s.animate(run_time=2).rotate(PI / 2),\n                        c.animate(rate_func=there_and_back).shift(RIGHT),\n                    )\n\n        .. warning::\n\n            ``.animate``\n             will interpolate the :class:`~.Mobject` between its points prior to\n             ``.animate`` and its points after applying ``.animate`` to it. This may\n             result in unexpected behavior when attempting to interpolate along paths,\n             or rotations.\n             If you want animations to consider the points between, consider using\n             :class:`~.ValueTracker` with updaters instead.\n\n        \"\"\"\n        return _AnimationBuilder(self)\n\n    def __deepcopy__(self, clone_from_id) -> Self:\n        cls = self.__class__\n        result = cls.__new__(cls)\n        clone_from_id[id(self)] = result\n        for k, v in self.__dict__.items():\n            setattr(result, k, copy.deepcopy(v, clone_from_id))\n        result.original_id = str(id(self))\n        return result\n\n    def __repr__(self) -> str:\n        return str(self.name)\n\n\n[docs]\n    def reset_points(self) -> None:\n        \"\"\"Sets :attr:`points` to be an empty array.\"\"\"\n        self.points = np.zeros((0, self.dim))\n\n\n\n[docs]\n    def init_colors(self) -> object:\n        \"\"\"Initializes the colors.\n\n        Gets called upon creation. This is an empty method that can be implemented by\n        subclasses.\n        \"\"\"\n\n\n\n[docs]\n    def generate_points(self) -> object:\n        \"\"\"Initializes :attr:`points` and therefore the shape.\n\n        Gets called upon creation. This is an empty method that can be implemented by\n        subclasses.\n        \"\"\"\n\n\n\n[docs]\n    def add(self, *mobjects: Mobject) -> Self:\n        \"\"\"Add mobjects as submobjects.\n\n        The mobjects are added to :attr:`submobjects`.\n\n        Subclasses of mobject may implement ``+`` and ``+=`` dunder methods.\n\n        Parameters\n        ----------\n        mobjects\n            The mobjects to add.\n\n        Returns\n        -------\n        :class:`Mobject`\n            ``self``\n\n        Raises\n        ------\n        :class:`ValueError`\n            When a mobject tries to add itself.\n        :class:`TypeError`\n            When trying to add an object that is not an instance of :class:`Mobject`.\n\n\n        Notes\n        -----\n        A mobject cannot contain itself, and it cannot contain a submobject\n        more than once.  If the parent mobject is displayed, the newly-added\n        submobjects will also be displayed (i.e. they are automatically added\n        to the parent Scene).\n\n        See Also\n        --------\n        :meth:`remove`\n        :meth:`add_to_back`\n\n        Examples\n        --------\n        ::\nouter = Mobject()\ninner = Mobject()\nouter = outer.add(inner)\n\n        Duplicates are not added again::\nouter = outer.add(inner)\nlen(outer.submobjects)\n            1\n\n        Only Mobjects can be added::\nouter.add(3)\n            Traceback (most recent call last):\n\n            TypeError: Only values of type Mobject can be added as submobjects of Mobject, but the value 3 (at index 0) is of type int.\n\n        Adding an object to itself raises an error::\nouter.add(outer)\n            Traceback (most recent call last):\n\n            ValueError: Cannot add Mobject as a submobject of itself (at index 0).\n\n        A given mobject cannot be added as a submobject\n        twice to some parent::\nparent = Mobject(name=\"parent\")\nchild = Mobject(name=\"child\")\nparent.add(child, child)\n            [...] WARNING  ...\n            parent\nparent.submobjects\n            [child]\n\n        \"\"\"\n        self._assert_valid_submobjects(mobjects)\n        unique_mobjects = remove_list_redundancies(mobjects)\n        if len(mobjects) != len(unique_mobjects):\n            logger.warning(\n                \"Attempted adding some Mobject as a child more than once, \"\n                \"this is not possible. Repetitions are ignored.\",\n            )\n\n        self.submobjects = list_update(self.submobjects, unique_mobjects)\n        return self\n\n\n\n[docs]\n    def insert(self, index: int, mobject: Mobject) -> None:\n        \"\"\"Inserts a mobject at a specific position into self.submobjects\n\n        Effectively just calls  ``self.submobjects.insert(index, mobject)``,\n        where ``self.submobjects`` is a list.\n\n        Highly adapted from ``Mobject.add``.\n\n        Parameters\n        ----------\n        index\n            The index at which\n        mobject\n            The mobject to be inserted.\n        \"\"\"\n        self._assert_valid_submobjects([mobject])\n        self.submobjects.insert(index, mobject)\n\n\n    def __add__(self, mobject: Mobject):\n        raise NotImplementedError\n\n    def __iadd__(self, mobject: Mobject):\n        raise NotImplementedError\n\n\n[docs]\n    def add_to_back(self, *mobjects: Mobject) -> Self:\n        \"\"\"Add all passed mobjects to the back of the submobjects.\n\n        If :attr:`submobjects` already contains the given mobjects, they just get moved\n        to the back instead.\n\n        Parameters\n        ----------\n        mobjects\n            The mobjects to add.\n\n        Returns\n        -------\n        :class:`Mobject`\n            ``self``\n\n\n        .. note::\n\n            Technically, this is done by adding (or moving) the mobjects to\n            the head of :attr:`submobjects`. The head of this list is rendered\n            first, which places the corresponding mobjects behind the\n            subsequent list members.\n\n        Raises\n        ------\n        :class:`ValueError`\n            When a mobject tries to add itself.\n        :class:`TypeError`\n            When trying to add an object that is not an instance of :class:`Mobject`.\n\n        Notes\n        -----\n        A mobject cannot contain itself, and it cannot contain a submobject\n        more than once.  If the parent mobject is displayed, the newly-added\n        submobjects will also be displayed (i.e. they are automatically added\n        to the parent Scene).\n\n        See Also\n        --------\n        :meth:`remove`\n        :meth:`add`\n\n        \"\"\"\n        self._assert_valid_submobjects(mobjects)\n        self.remove(*mobjects)\n        # dict.fromkeys() removes duplicates while maintaining order\n        self.submobjects = list(dict.fromkeys(mobjects)) + self.submobjects\n        return self\n\n\n\n[docs]\n    def remove(self, *mobjects: Mobject) -> Self:\n        \"\"\"Remove :attr:`submobjects`.\n\n        The mobjects are removed from :attr:`submobjects`, if they exist.\n\n        Subclasses of mobject may implement ``-`` and ``-=`` dunder methods.\n\n        Parameters\n        ----------\n        mobjects\n            The mobjects to remove.\n\n        Returns\n        -------\n        :class:`Mobject`\n            ``self``\n\n        See Also\n        --------\n        :meth:`add`\n\n        \"\"\"\n        for mobject in mobjects:\n            if mobject in self.submobjects:\n                self.submobjects.remove(mobject)\n        return self\n\n\n    def __sub__(self, other):\n        raise NotImplementedError\n\n    def __isub__(self, other):\n        raise NotImplementedError\n\n\n[docs]\n    def set(self, **kwargs) -> Self:\n        \"\"\"Sets attributes.\n\n        I.e. ``my_mobject.set(foo=1)`` applies ``my_mobject.foo = 1``.\n\n        This is a convenience to be used along with :attr:`animate` to\n        animate setting attributes.\n\n        In addition to this method, there is a compatibility\n        layer that allows ``get_*`` and ``set_*`` methods to\n        get and set generic attributes. For instance::\nmob = Mobject()\nmob.set_foo(0)\n            Mobject\nmob.get_foo()\n            0\nmob.foo\n            0\n\n        This compatibility layer does not interfere with any\n        ``get_*`` or ``set_*`` methods that are explicitly\n        defined.\n\n        .. warning::\n\n            This compatibility layer is for backwards compatibility\n            and is not guaranteed to stay around. Where applicable,\n            please prefer getting/setting attributes normally or with\n            the :meth:`set` method.\n\n        Parameters\n        ----------\n        **kwargs\n            The attributes and corresponding values to set.\n\n        Returns\n        -------\n        :class:`Mobject`\n            ``self``\n\n        Examples\n        --------\n        ::\nmob = Mobject()\nmob.set(foo=0)\n            Mobject\nmob.foo\n            0\n        \"\"\"\n        for attr, value in kwargs.items():\n            setattr(self, attr, value)\n\n        return self\n\n\n    def __getattr__(self, attr: str) -> types.MethodType:\n        # Add automatic compatibility layer\n        # between properties and get_* and set_*\n        # methods.\n        #\n        # In python 3.9+ we could change this\n        # logic to use str.remove_prefix instead.\n\n        if attr.startswith(\"get_\"):\n            # Remove the \"get_\" prefix\n            to_get = attr[4:]\n\n            def getter(self):\n                warnings.warn(\n                    \"This method is not guaranteed to stay around. Please prefer \"\n                    \"getting the attribute normally.\",\n                    DeprecationWarning,\n                    stacklevel=2,\n                )\n\n                return getattr(self, to_get)\n\n            # Return a bound method\n            return types.MethodType(getter, self)\n\n        if attr.startswith(\"set_\"):\n            # Remove the \"set_\" prefix\n            to_set = attr[4:]\n\n            def setter(self, value):\n                warnings.warn(\n                    \"This method is not guaranteed to stay around. Please prefer \"\n                    \"setting the attribute normally or with Mobject.set().\",\n                    DeprecationWarning,\n                    stacklevel=2,\n                )\n\n                setattr(self, to_set, value)\n\n                return self\n\n            # Return a bound method\n            return types.MethodType(setter, self)\n\n        # Unhandled attribute, therefore error\n        raise AttributeError(f\"{type(self).__name__} object has no attribute '{attr}'\")\n\n    @property\n    def width(self) -> float:\n        \"\"\"The width of the mobject.\n\n        Returns\n        -------\n        :class:`float`\n\n        Examples\n        --------\n        .. manim:: WidthExample\n\n            class WidthExample(Scene):\n                def construct(self):\n                    decimal = DecimalNumber().to_edge(UP)\n                    rect = Rectangle(color=BLUE)\n                    rect_copy = rect.copy().set_stroke(GRAY, opacity=0.5)\n\n                    decimal.add_updater(lambda d: d.set_value(rect.width))\n\n                    self.add(rect_copy, rect, decimal)\n                    self.play(rect.animate.set(width=7))\n                    self.wait()\n\n        See also\n        --------\n        :meth:`length_over_dim`\n\n        \"\"\"\n        # Get the length across the X dimension\n        return self.length_over_dim(0)\n\n    @width.setter\n    def width(self, value: float):\n        self.scale_to_fit_width(value)\n\n    @property\n    def height(self) -> float:\n        \"\"\"The height of the mobject.\n\n        Returns\n        -------\n        :class:`float`\n\n        Examples\n        --------\n        .. manim:: HeightExample\n\n            class HeightExample(Scene):\n                def construct(self):\n                    decimal = DecimalNumber().to_edge(UP)\n                    rect = Rectangle(color=BLUE)\n                    rect_copy = rect.copy().set_stroke(GRAY, opacity=0.5)\n\n                    decimal.add_updater(lambda d: d.set_value(rect.height))\n\n                    self.add(rect_copy, rect, decimal)\n                    self.play(rect.animate.set(height=5))\n                    self.wait()\n\n        See also\n        --------\n        :meth:`length_over_dim`\n\n        \"\"\"\n        # Get the length across the Y dimension\n        return self.length_over_dim(1)\n\n    @height.setter\n    def height(self, value: float):\n        self.scale_to_fit_height(value)\n\n    @property\n    def depth(self) -> float:\n        \"\"\"The depth of the mobject.\n\n        Returns\n        -------\n        :class:`float`\n\n        See also\n        --------\n        :meth:`length_over_dim`\n\n        \"\"\"\n        # Get the length across the Z dimension\n        return self.length_over_dim(2)\n\n    @depth.setter\n    def depth(self, value: float):\n        self.scale_to_fit_depth(value)\n\n    # Can't be staticmethod because of point_cloud_mobject.py\n    def get_array_attrs(self) -> list[Literal[\"points\"]]:\n        return [\"points\"]\n\n    def apply_over_attr_arrays(self, func: MultiMappingFunction) -> Self:\n        for attr in self.get_array_attrs():\n            setattr(self, attr, func(getattr(self, attr)))\n        return self\n\n    # Displaying\n\n    def get_image(self, camera=None) -> PixelArray:\n        if camera is None:\n            from ..camera.camera import Camera\n\n            camera = Camera()\n        camera.capture_mobject(self)\n        return camera.get_image()\n\n    def show(self, camera=None) -> None:\n        self.get_image(camera=camera).show()\n\n\n[docs]\n    def save_image(self, name: str | None = None) -> None:\n        \"\"\"Saves an image of only this :class:`Mobject` at its position to a png\n        file.\n        \"\"\"\n        self.get_image().save(\n            Path(config.get_dir(\"video_dir\")).joinpath((name or str(self)) + \".png\"),\n        )\n\n\n\n[docs]\n    def copy(self) -> Self:\n        \"\"\"Create and return an identical copy of the :class:`Mobject` including all\n        :attr:`submobjects`.\n\n        Returns\n        -------\n        :class:`Mobject`\n            The copy.\n\n        Note\n        ----\n        The clone is initially not visible in the Scene, even if the original was.\n        \"\"\"\n        return copy.deepcopy(self)\n\n\n    def generate_target(self, use_deepcopy: bool = False) -> Self:\n        self.target = None  # Prevent unbounded linear recursion\n        if use_deepcopy:\n            self.target = copy.deepcopy(self)\n        else:\n            self.target = self.copy()\n        return self.target\n\n    # Updating\n\n\n[docs]\n    def update(self, dt: float = 0, recursive: bool = True) -> Self:\n        \"\"\"Apply all updaters.\n\n        Does nothing if updating is suspended.\n\n        Parameters\n        ----------\n        dt\n            The parameter ``dt`` to pass to the update functions. Usually this is the\n            time in seconds since the last call of ``update``.\n        recursive\n            Whether to recursively update all submobjects.\n\n        Returns\n        -------\n        :class:`Mobject`\n            ``self``\n\n        See Also\n        --------\n        :meth:`add_updater`\n        :meth:`get_updaters`\n\n        \"\"\"\n        if self.updating_suspended:\n            return self\n        for updater in self.updaters:\n            if \"dt\" in inspect.signature(updater).parameters:\n                updater(self, dt)\n            else:\n                updater(self)\n        if recursive:\n            for submob in self.submobjects:\n                submob.update(dt, recursive)\n        return self\n\n\n\n[docs]\n    def get_time_based_updaters(self) -> list[TimeBasedUpdater]:\n        \"\"\"Return all updaters using the ``dt`` parameter.\n\n        The updaters use this parameter as the input for difference in time.\n\n        Returns\n        -------\n        List[:class:`Callable`]\n            The list of time based updaters.\n\n        See Also\n        --------\n        :meth:`get_updaters`\n        :meth:`has_time_based_updater`\n\n        \"\"\"\n        return [\n            updater\n            for updater in self.updaters\n            if \"dt\" in inspect.signature(updater).parameters\n        ]\n\n\n\n[docs]\n    def has_time_based_updater(self) -> bool:\n        \"\"\"Test if ``self`` has a time based updater.\n\n        Returns\n        -------\n        :class:`bool`\n            ``True`` if at least one updater uses the ``dt`` parameter, ``False``\n            otherwise.\n\n        See Also\n        --------\n        :meth:`get_time_based_updaters`\n\n        \"\"\"\n        return any(\n            \"dt\" in inspect.signature(updater).parameters for updater in self.updaters\n        )\n\n\n\n[docs]\n    def get_updaters(self) -> list[Updater]:\n        \"\"\"Return all updaters.\n\n        Returns\n        -------\n        List[:class:`Callable`]\n            The list of updaters.\n\n        See Also\n        --------\n        :meth:`add_updater`\n        :meth:`get_time_based_updaters`\n\n        \"\"\"\n        return self.updaters\n\n\n    def get_family_updaters(self) -> list[Updater]:\n        return list(it.chain(*(sm.get_updaters() for sm in self.get_family())))\n\n\n[docs]\n    def add_updater(\n        self,\n        update_function: Updater,\n        index: int | None = None,\n        call_updater: bool = False,\n    ) -> Self:\n        \"\"\"Add an update function to this mobject.\n\n        Update functions, or updaters in short, are functions that are applied to the\n        Mobject in every frame.\n\n        Parameters\n        ----------\n        update_function\n            The update function to be added.\n            Whenever :meth:`update` is called, this update function gets called using\n            ``self`` as the first parameter.\n            The updater can have a second parameter ``dt``. If it uses this parameter,\n            it gets called using a second value ``dt``, usually representing the time\n            in seconds since the last call of :meth:`update`.\n        index\n            The index at which the new updater should be added in ``self.updaters``.\n            In case ``index`` is ``None`` the updater will be added at the end.\n        call_updater\n            Whether or not to call the updater initially. If ``True``, the updater will\n            be called using ``dt=0``.\n\n        Returns\n        -------\n        :class:`Mobject`\n            ``self``\n\n        Examples\n        --------\n        .. manim:: NextToUpdater\n\n            class NextToUpdater(Scene):\n                def construct(self):\n                    def dot_position(mobject):\n                        mobject.set_value(dot.get_center()[0])\n                        mobject.next_to(dot)\n\n                    dot = Dot(RIGHT*3)\n                    label = DecimalNumber()\n                    label.add_updater(dot_position)\n                    self.add(dot, label)\n\n                    self.play(Rotating(dot, about_point=ORIGIN, angle=TAU, run_time=TAU, rate_func=linear))\n\n        .. manim:: DtUpdater\n\n            class DtUpdater(Scene):\n                def construct(self):\n                    square = Square()\n\n                    #Let the square rotate 90° per second\n                    square.add_updater(lambda mobject, dt: mobject.rotate(dt*90*DEGREES))\n                    self.add(square)\n                    self.wait(2)\n\n        See also\n        --------\n        :meth:`get_updaters`\n        :meth:`remove_updater`\n        :class:`~.UpdateFromFunc`\n        \"\"\"\n        if index is None:\n            self.updaters.append(update_function)\n        else:\n            self.updaters.insert(index, update_function)\n        if call_updater:\n            parameters = inspect.signature(update_function).parameters\n            if \"dt\" in parameters:\n                update_function(self, 0)\n            else:\n                update_function(self)\n        return self\n\n\n\n[docs]\n    def remove_updater(self, update_function: Updater) -> Self:\n        \"\"\"Remove an updater.\n\n        If the same updater is applied multiple times, every instance gets removed.\n\n        Parameters\n        ----------\n        update_function\n            The update function to be removed.\n\n\n        Returns\n        -------\n        :class:`Mobject`\n            ``self``\n\n        See also\n        --------\n        :meth:`clear_updaters`\n        :meth:`add_updater`\n        :meth:`get_updaters`\n\n        \"\"\"\n        while update_function in self.updaters:\n            self.updaters.remove(update_function)\n        return self\n\n\n\n[docs]\n    def clear_updaters(self, recursive: bool = True) -> Self:\n        \"\"\"Remove every updater.\n\n        Parameters\n        ----------\n        recursive\n            Whether to recursively call ``clear_updaters`` on all submobjects.\n\n        Returns\n        -------\n        :class:`Mobject`\n            ``self``\n\n        See also\n        --------\n        :meth:`remove_updater`\n        :meth:`add_updater`\n        :meth:`get_updaters`\n\n        \"\"\"\n        self.updaters = []\n        if recursive:\n            for submob in self.submobjects:\n                submob.clear_updaters()\n        return self\n\n\n\n[docs]\n    def match_updaters(self, mobject: Mobject) -> Self:\n        \"\"\"Match the updaters of the given mobject.\n\n        Parameters\n        ----------\n        mobject\n            The mobject whose updaters get matched.\n\n        Returns\n        -------\n        :class:`Mobject`\n            ``self``\n\n        Note\n        ----\n        All updaters from submobjects are removed, but only updaters of the given\n        mobject are matched, not those of it's submobjects.\n\n        See also\n        --------\n        :meth:`add_updater`\n        :meth:`clear_updaters`\n\n        \"\"\"\n        self.clear_updaters()\n        for updater in mobject.get_updaters():\n            self.add_updater(updater)\n        return self\n\n\n\n[docs]\n    def suspend_updating(self, recursive: bool = True) -> Self:\n        \"\"\"Disable updating from updaters and animations.\n\n\n        Parameters\n        ----------\n        recursive\n            Whether to recursively suspend updating on all submobjects.\n\n        Returns\n        -------\n        :class:`Mobject`\n            ``self``\n\n        See also\n        --------\n        :meth:`resume_updating`\n        :meth:`add_updater`\n\n        \"\"\"\n        self.updating_suspended = True\n        if recursive:\n            for submob in self.submobjects:\n                submob.suspend_updating(recursive)\n        return self\n\n\n\n[docs]\n    def resume_updating(self, recursive: bool = True) -> Self:\n        \"\"\"Enable updating from updaters and animations.\n\n        Parameters\n        ----------\n        recursive\n            Whether to recursively enable updating on all submobjects.\n\n        Returns\n        -------\n        :class:`Mobject`\n            ``self``\n\n        See also\n        --------\n        :meth:`suspend_updating`\n        :meth:`add_updater`\n\n        \"\"\"\n        self.updating_suspended = False\n        if recursive:\n            for submob in self.submobjects:\n                submob.resume_updating(recursive)\n        self.update(dt=0, recursive=recursive)\n        return self\n\n\n    # Transforming operations\n\n\n[docs]\n    def apply_to_family(self, func: Callable[[Mobject], None]) -> None:\n        \"\"\"Apply a function to ``self`` and every submobject with points recursively.\n\n        Parameters\n        ----------\n        func\n            The function to apply to each mobject. ``func`` gets passed the respective\n            (sub)mobject as parameter.\n\n        Returns\n        -------\n        :class:`Mobject`\n            ``self``\n\n        See also\n        --------\n        :meth:`family_members_with_points`\n\n        \"\"\"\n        for mob in self.family_members_with_points():\n            func(mob)\n\n\n\n[docs]\n    def shift(self, *vectors: Vector3D) -> Self:\n        \"\"\"Shift by the given vectors.\n\n        Parameters\n        ----------\n        vectors\n            Vectors to shift by. If multiple vectors are given, they are added\n            together.\n\n        Returns\n        -------\n        :class:`Mobject`\n            ``self``\n\n        See also\n        --------\n        :meth:`move_to`\n        \"\"\"\n        total_vector = reduce(op.add, vectors)\n        for mob in self.family_members_with_points():\n            mob.points = mob.points.astype(\"float\")\n            mob.points += total_vector\n\n        return self\n\n\n\n[docs]\n    def scale(self, scale_factor: float, **kwargs) -> Self:\n        r\"\"\"Scale the size by a factor.\n\n        Default behavior is to scale about the center of the mobject.\n\n        Parameters\n        ----------\n        scale_factor\n            The scaling factor :math:`\\alpha`. If :math:`0 < |\\alpha| < 1`, the mobject\n            will shrink, and for :math:`|\\alpha| > 1` it will grow. Furthermore,\n            if :math:`\\alpha < 0`, the mobject is also flipped.\n        kwargs\n            Additional keyword arguments passed to\n            :meth:`apply_points_function_about_point`.\n\n        Returns\n        -------\n        :class:`Mobject`\n            ``self``\n\n        Examples\n        --------\n\n        .. manim:: MobjectScaleExample\n            :save_last_frame:\n\n            class MobjectScaleExample(Scene):\n                def construct(self):\n                    f1 = Text(\"F\")\n                    f2 = Text(\"F\").scale(2)\n                    f3 = Text(\"F\").scale(0.5)\n                    f4 = Text(\"F\").scale(-1)\n\n                    vgroup = VGroup(f1, f2, f3, f4).arrange(6 * RIGHT)\n                    self.add(vgroup)\n\n        See also\n        --------\n        :meth:`move_to`\n\n        \"\"\"\n        self.apply_points_function_about_point(\n            lambda points: scale_factor * points, **kwargs\n        )\n        return self\n\n\n\n[docs]\n    def rotate_about_origin(self, angle: float, axis: Vector3D = OUT, axes=[]) -> Self:\n        \"\"\"Rotates the :class:`~.Mobject` about the ORIGIN, which is at [0,0,0].\"\"\"\n        return self.rotate(angle, axis, about_point=ORIGIN)\n\n\n\n[docs]\n    def rotate(\n        self,\n        angle: float,\n        axis: Vector3D = OUT,\n        about_point: Point3DLike | None = None,\n        **kwargs,\n    ) -> Self:\n        \"\"\"Rotates the :class:`~.Mobject` about a certain point.\"\"\"\n        rot_matrix = rotation_matrix(angle, axis)\n        self.apply_points_function_about_point(\n            lambda points: np.dot(points, rot_matrix.T), about_point, **kwargs\n        )\n        return self\n\n\n\n[docs]\n    def flip(self, axis: Vector3D = UP, **kwargs) -> Self:\n        \"\"\"Flips/Mirrors an mobject about its center.\n\n        Examples\n        --------\n\n        .. manim:: FlipExample\n            :save_last_frame:\n\n            class FlipExample(Scene):\n                def construct(self):\n                    s= Line(LEFT, RIGHT+UP).shift(4*LEFT)\n                    self.add(s)\n                    s2= s.copy().flip()\n                    self.add(s2)\n\n        \"\"\"\n        return self.rotate(TAU / 2, axis, **kwargs)\n\n\n    def stretch(self, factor: float, dim: int, **kwargs) -> Self:\n        def func(points: Point3D_Array) -> Point3D_Array:\n            points[:, dim] *= factor\n            return points\n\n        self.apply_points_function_about_point(func, **kwargs)\n        return self\n\n    def apply_function(self, function: MappingFunction, **kwargs) -> Self:\n        # Default to applying matrix about the origin, not mobjects center\n        if len(kwargs) == 0:\n            kwargs[\"about_point\"] = ORIGIN\n\n        def multi_mapping_function(points: Point3D_Array) -> Point3D_Array:\n            result: Point3D_Array = np.apply_along_axis(function, 1, points)\n            return result\n\n        self.apply_points_function_about_point(multi_mapping_function, **kwargs)\n        return self\n\n    def apply_function_to_position(self, function: MappingFunction) -> Self:\n        self.move_to(function(self.get_center()))\n        return self\n\n    def apply_function_to_submobject_positions(self, function: MappingFunction) -> Self:\n        for submob in self.submobjects:\n            submob.apply_function_to_position(function)\n        return self\n\n    def apply_matrix(self, matrix, **kwargs) -> Self:\n        # Default to applying matrix about the origin, not mobjects center\n        if (\"about_point\" not in kwargs) and (\"about_edge\" not in kwargs):\n            kwargs[\"about_point\"] = ORIGIN\n        full_matrix = np.identity(self.dim)\n        matrix = np.array(matrix)\n        full_matrix[: matrix.shape[0], : matrix.shape[1]] = matrix\n        self.apply_points_function_about_point(\n            lambda points: np.dot(points, full_matrix.T), **kwargs\n        )\n        return self\n\n\n[docs]\n    def apply_complex_function(\n        self, function: Callable[[complex], complex], **kwargs\n    ) -> Self:\n        \"\"\"Applies a complex function to a :class:`Mobject`.\n        The x and y Point3Ds correspond to the real and imaginary parts respectively.\n\n        Example\n        -------\n\n        .. manim:: ApplyFuncExample\n\n            class ApplyFuncExample(Scene):\n                def construct(self):\n                    circ = Circle().scale(1.5)\n                    circ_ref = circ.copy()\n                    circ.apply_complex_function(\n                        lambda x: np.exp(x*1j)\n                    )\n                    t = ValueTracker(0)\n                    circ.add_updater(\n                        lambda x: x.become(circ_ref.copy().apply_complex_function(\n                            lambda x: np.exp(x+t.get_value()*1j)\n                        )).set_color(BLUE)\n                    )\n                    self.add(circ_ref)\n                    self.play(TransformFromCopy(circ_ref, circ))\n                    self.play(t.animate.set_value(TAU), run_time=3)\n        \"\"\"\n\n        def R3_func(point):\n            x, y, z = point\n            xy_complex = function(complex(x, y))\n            return [xy_complex.real, xy_complex.imag, z]\n\n        return self.apply_function(R3_func)\n\n\n    def reverse_points(self) -> Self:\n        for mob in self.family_members_with_points():\n            mob.apply_over_attr_arrays(lambda arr: np.array(list(reversed(arr))))\n        return self\n\n\n[docs]\n    def repeat(self, count: int) -> Self:\n        \"\"\"This can make transition animations nicer\"\"\"\n\n        def repeat_array(array):\n            return reduce(lambda a1, a2: np.append(a1, a2, axis=0), [array] * count)\n\n        for mob in self.family_members_with_points():\n            mob.apply_over_attr_arrays(repeat_array)\n        return self\n\n\n    # In place operations.\n    # Note, much of these are now redundant with default behavior of\n    # above methods\n\n    # TODO: name is inconsistent with OpenGLMobject.apply_points_function()\n    def apply_points_function_about_point(\n        self,\n        func: MultiMappingFunction,\n        about_point: Point3DLike | None = None,\n        about_edge: Vector3D | None = None,\n    ) -> Self:\n        if about_point is None:\n            if about_edge is None:\n                about_edge = ORIGIN\n            about_point = self.get_critical_point(about_edge)\n        for mob in self.family_members_with_points():\n            mob.points -= about_point\n            mob.points = func(mob.points)\n            mob.points += about_point\n        return self\n\n    def pose_at_angle(self, **kwargs):\n        self.rotate(TAU / 14, RIGHT + UP, **kwargs)\n        return self\n\n    # Positioning methods\n\n\n[docs]\n    def center(self) -> Self:\n        \"\"\"Moves the center of the mobject to the center of the scene.\n\n        Returns\n        -------\n        :class:`.Mobject`\n            The centered mobject.\n        \"\"\"\n        self.shift(-self.get_center())\n        return self\n\n\n\n[docs]\n    def align_on_border(\n        self, direction: Vector3D, buff: float = DEFAULT_MOBJECT_TO_EDGE_BUFFER\n    ) -> Self:\n        \"\"\"Direction just needs to be a vector pointing towards side or\n        corner in the 2d plane.\n        \"\"\"\n        target_point = np.sign(direction) * (\n            config[\"frame_x_radius\"],\n            config[\"frame_y_radius\"],\n            0,\n        )\n        point_to_align = self.get_critical_point(direction)\n        shift_val = target_point - point_to_align - buff * np.array(direction)\n        shift_val = shift_val * abs(np.sign(direction))\n        self.shift(shift_val)\n        return self\n\n\n\n[docs]\n    def to_corner(\n        self, corner: Vector3D = DL, buff: float = DEFAULT_MOBJECT_TO_EDGE_BUFFER\n    ) -> Self:\n        \"\"\"Moves this :class:`~.Mobject` to the given corner of the screen.\n\n        Returns\n        -------\n        :class:`.Mobject`\n            The newly positioned mobject.\n\n        Examples\n        --------\n\n        .. manim:: ToCornerExample\n            :save_last_frame:\n\n            class ToCornerExample(Scene):\n                def construct(self):\n                    c = Circle()\n                    c.to_corner(UR)\n                    t = Tex(\"To the corner!\")\n                    t2 = MathTex(\"x^3\").shift(DOWN)\n                    self.add(c,t,t2)\n                    t.to_corner(DL, buff=0)\n                    t2.to_corner(UL, buff=1.5)\n        \"\"\"\n        return self.align_on_border(corner, buff)\n\n\n\n[docs]\n    def to_edge(\n        self, edge: Vector3D = LEFT, buff: float = DEFAULT_MOBJECT_TO_EDGE_BUFFER\n    ) -> Self:\n        \"\"\"Moves this :class:`~.Mobject` to the given edge of the screen,\n        without affecting its position in the other dimension.\n\n        Returns\n        -------\n        :class:`.Mobject`\n            The newly positioned mobject.\n\n        Examples\n        --------\n\n        .. manim:: ToEdgeExample\n            :save_last_frame:\n\n            class ToEdgeExample(Scene):\n                def construct(self):\n                    tex_top = Tex(\"I am at the top!\")\n                    tex_top.to_edge(UP)\n                    tex_side = Tex(\"I am moving to the side!\")\n                    c = Circle().shift(2*DOWN)\n                    self.add(tex_top, tex_side, c)\n                    tex_side.to_edge(LEFT)\n                    c.to_edge(RIGHT, buff=0)\n\n        \"\"\"\n        return self.align_on_border(edge, buff)\n\n\n\n[docs]\n    def next_to(\n        self,\n        mobject_or_point: Mobject | Point3DLike,\n        direction: Vector3D = RIGHT,\n        buff: float = DEFAULT_MOBJECT_TO_MOBJECT_BUFFER,\n        aligned_edge: Vector3D = ORIGIN,\n        submobject_to_align: Mobject | None = None,\n        index_of_submobject_to_align: int | None = None,\n        coor_mask: Vector3D = np.array([1, 1, 1]),\n    ) -> Self:\n        \"\"\"Move this :class:`~.Mobject` next to another's :class:`~.Mobject` or Point3D.\n\n        Examples\n        --------\n\n        .. manim:: GeometricShapes\n            :save_last_frame:\n\n            class GeometricShapes(Scene):\n                def construct(self):\n                    d = Dot()\n                    c = Circle()\n                    s = Square()\n                    t = Triangle()\n                    d.next_to(c, RIGHT)\n                    s.next_to(c, LEFT)\n                    t.next_to(c, DOWN)\n                    self.add(d, c, s, t)\n\n        \"\"\"\n        if isinstance(mobject_or_point, Mobject):\n            mob = mobject_or_point\n            if index_of_submobject_to_align is not None:\n                target_aligner = mob[index_of_submobject_to_align]\n            else:\n                target_aligner = mob\n            target_point = target_aligner.get_critical_point(aligned_edge + direction)\n        else:\n            target_point = mobject_or_point\n        if submobject_to_align is not None:\n            aligner = submobject_to_align\n        elif index_of_submobject_to_align is not None:\n            aligner = self[index_of_submobject_to_align]\n        else:\n            aligner = self\n        point_to_align = aligner.get_critical_point(aligned_edge - direction)\n        self.shift((target_point - point_to_align + buff * direction) * coor_mask)\n        return self\n\n\n    def shift_onto_screen(self, **kwargs) -> Self:\n        space_lengths = [config[\"frame_x_radius\"], config[\"frame_y_radius\"]]\n        for vect in UP, DOWN, LEFT, RIGHT:\n            dim = np.argmax(np.abs(vect))\n            buff = kwargs.get(\"buff\", DEFAULT_MOBJECT_TO_EDGE_BUFFER)\n            max_val = space_lengths[dim] - buff\n            edge_center = self.get_edge_center(vect)\n            if np.dot(edge_center, vect) > max_val:\n                self.to_edge(vect, **kwargs)\n        return self\n\n    def is_off_screen(self):\n        if self.get_left()[0] > config[\"frame_x_radius\"]:\n            return True\n        if self.get_right()[0] < -config[\"frame_x_radius\"]:\n            return True\n        if self.get_bottom()[1] > config[\"frame_y_radius\"]:\n            return True\n        return self.get_top()[1] < -config[\"frame_y_radius\"]\n\n    def stretch_about_point(self, factor: float, dim: int, point: Point3DLike) -> Self:\n        return self.stretch(factor, dim, about_point=point)\n\n    def rescale_to_fit(\n        self, length: float, dim: int, stretch: bool = False, **kwargs\n    ) -> Self:\n        old_length = self.length_over_dim(dim)\n        if old_length == 0:\n            return self\n        if stretch:\n            self.stretch(length / old_length, dim, **kwargs)\n        else:\n            self.scale(length / old_length, **kwargs)\n        return self\n\n\n[docs]\n    def scale_to_fit_width(self, width: float, **kwargs) -> Self:\n        \"\"\"Scales the :class:`~.Mobject` to fit a width while keeping height/depth proportional.\n\n        Returns\n        -------\n        :class:`Mobject`\n            ``self``\n\n        Examples\n        --------\n        ::\nfrom manim import *\nsq = Square()\nsq.height\n            np.float64(2.0)\nsq.scale_to_fit_width(5)\n            Square\nsq.width\n            np.float64(5.0)\nsq.height\n            np.float64(5.0)\n        \"\"\"\n        return self.rescale_to_fit(width, 0, stretch=False, **kwargs)\n\n\n\n[docs]\n    def stretch_to_fit_width(self, width: float, **kwargs) -> Self:\n        \"\"\"Stretches the :class:`~.Mobject` to fit a width, not keeping height/depth proportional.\n\n        Returns\n        -------\n        :class:`Mobject`\n            ``self``\n\n        Examples\n        --------\n        ::\nfrom manim import *\nsq = Square()\nsq.height\n            np.float64(2.0)\nsq.stretch_to_fit_width(5)\n            Square\nsq.width\n            np.float64(5.0)\nsq.height\n            np.float64(2.0)\n        \"\"\"\n        return self.rescale_to_fit(width, 0, stretch=True, **kwargs)\n\n\n\n[docs]\n    def scale_to_fit_height(self, height: float, **kwargs) -> Self:\n        \"\"\"Scales the :class:`~.Mobject` to fit a height while keeping width/depth proportional.\n\n        Returns\n        -------\n        :class:`Mobject`\n            ``self``\n\n        Examples\n        --------\n        ::\nfrom manim import *\nsq = Square()\nsq.width\n            np.float64(2.0)\nsq.scale_to_fit_height(5)\n            Square\nsq.height\n            np.float64(5.0)\nsq.width\n            np.float64(5.0)\n        \"\"\"\n        return self.rescale_to_fit(height, 1, stretch=False, **kwargs)\n\n\n\n[docs]\n    def stretch_to_fit_height(self, height: float, **kwargs) -> Self:\n        \"\"\"Stretches the :class:`~.Mobject` to fit a height, not keeping width/depth proportional.\n\n        Returns\n        -------\n        :class:`Mobject`\n            ``self``\n\n        Examples\n        --------\n        ::\nfrom manim import *\nsq = Square()\nsq.width\n            np.float64(2.0)\nsq.stretch_to_fit_height(5)\n            Square\nsq.height\n            np.float64(5.0)\nsq.width\n            np.float64(2.0)\n        \"\"\"\n        return self.rescale_to_fit(height, 1, stretch=True, **kwargs)\n\n\n\n[docs]\n    def scale_to_fit_depth(self, depth: float, **kwargs) -> Self:\n        \"\"\"Scales the :class:`~.Mobject` to fit a depth while keeping width/height proportional.\"\"\"\n        return self.rescale_to_fit(depth, 2, stretch=False, **kwargs)\n\n\n\n[docs]\n    def stretch_to_fit_depth(self, depth: float, **kwargs) -> Self:\n        \"\"\"Stretches the :class:`~.Mobject` to fit a depth, not keeping width/height proportional.\"\"\"\n        return self.rescale_to_fit(depth, 2, stretch=True, **kwargs)\n\n\n    def set_coord(self, value, dim: int, direction: Vector3D = ORIGIN) -> Self:\n        curr = self.get_coord(dim, direction)\n        shift_vect = np.zeros(self.dim)\n        shift_vect[dim] = value - curr\n        self.shift(shift_vect)\n        return self\n\n\n[docs]\n    def set_x(self, x: float, direction: Vector3D = ORIGIN) -> Self:\n        \"\"\"Set x value of the center of the :class:`~.Mobject` (``int`` or ``float``)\"\"\"\n        return self.set_coord(x, 0, direction)\n\n\n\n[docs]\n    def set_y(self, y: float, direction: Vector3D = ORIGIN) -> Self:\n        \"\"\"Set y value of the center of the :class:`~.Mobject` (``int`` or ``float``)\"\"\"\n        return self.set_coord(y, 1, direction)\n\n\n\n[docs]\n    def set_z(self, z: float, direction: Vector3D = ORIGIN) -> Self:\n        \"\"\"Set z value of the center of the :class:`~.Mobject` (``int`` or ``float``)\"\"\"\n        return self.set_coord(z, 2, direction)\n\n\n    def space_out_submobjects(self, factor: float = 1.5, **kwargs) -> Self:\n        self.scale(factor, **kwargs)\n        for submob in self.submobjects:\n            submob.scale(1.0 / factor)\n        return self\n\n\n[docs]\n    def move_to(\n        self,\n        point_or_mobject: Point3DLike | Mobject,\n        aligned_edge: Vector3D = ORIGIN,\n        coor_mask: Vector3D = np.array([1, 1, 1]),\n    ) -> Self:\n        \"\"\"Move center of the :class:`~.Mobject` to certain Point3D.\"\"\"\n        if isinstance(point_or_mobject, Mobject):\n            target = point_or_mobject.get_critical_point(aligned_edge)\n        else:\n            target = point_or_mobject\n        point_to_align = self.get_critical_point(aligned_edge)\n        self.shift((target - point_to_align) * coor_mask)\n        return self\n\n\n    def replace(\n        self, mobject: Mobject, dim_to_match: int = 0, stretch: bool = False\n    ) -> Self:\n        if not mobject.get_num_points() and not mobject.submobjects:\n            raise Warning(\"Attempting to replace mobject with no points\")\n        if stretch:\n            self.stretch_to_fit_width(mobject.width)\n            self.stretch_to_fit_height(mobject.height)\n        else:\n            self.rescale_to_fit(\n                mobject.length_over_dim(dim_to_match),\n                dim_to_match,\n                stretch=False,\n            )\n        self.shift(mobject.get_center() - self.get_center())\n        return self\n\n    def surround(\n        self,\n        mobject: Mobject,\n        dim_to_match: int = 0,\n        stretch: bool = False,\n        buff: float = MED_SMALL_BUFF,\n    ) -> Self:\n        self.replace(mobject, dim_to_match, stretch)\n        length = mobject.length_over_dim(dim_to_match)\n        self.scale((length + buff) / length)\n        return self\n\n    def put_start_and_end_on(self, start: Point3DLike, end: Point3DLike) -> Self:\n        curr_start, curr_end = self.get_start_and_end()\n        curr_vect = curr_end - curr_start\n        if np.all(curr_vect == 0):\n            # TODO: this looks broken. It makes self.points a Point3D instead\n            # of a Point3D_Array. However, modifying this breaks some tests\n            # where this is currently expected.\n            self.points = np.array(start)\n            return self\n        target_vect = np.asarray(end) - np.asarray(start)\n        axis = (\n            normalize(np.cross(curr_vect, target_vect))\n            if np.linalg.norm(np.cross(curr_vect, target_vect)) != 0\n            else OUT\n        )\n        self.scale(\n            np.linalg.norm(target_vect) / np.linalg.norm(curr_vect),\n            about_point=curr_start,\n        )\n        self.rotate(\n            angle_between_vectors(curr_vect, target_vect),\n            about_point=curr_start,\n            axis=axis,\n        )\n        self.shift(start - curr_start)\n        return self\n\n    # Background rectangle\n\n[docs]\n    def add_background_rectangle(\n        self, color: ParsableManimColor | None = None, opacity: float = 0.75, **kwargs\n    ) -> Self:\n        \"\"\"Add a BackgroundRectangle as submobject.\n\n        The BackgroundRectangle is added behind other submobjects.\n\n        This can be used to increase the mobjects visibility in front of a noisy background.\n\n        Parameters\n        ----------\n        color\n            The color of the BackgroundRectangle\n        opacity\n            The opacity of the BackgroundRectangle\n        kwargs\n            Additional keyword arguments passed to the BackgroundRectangle constructor\n\n\n        Returns\n        -------\n        :class:`Mobject`\n            ``self``\n\n        See Also\n        --------\n        :meth:`add_to_back`\n        :class:`~.BackgroundRectangle`\n\n        \"\"\"\n        # TODO, this does not behave well when the mobject has points,\n        # since it gets displayed on top\n        from manim.mobject.geometry.shape_matchers import BackgroundRectangle\n\n        self.background_rectangle = BackgroundRectangle(\n            self, color=color, fill_opacity=opacity, **kwargs\n        )\n        self.add_to_back(self.background_rectangle)\n        return self\n\n\n    def add_background_rectangle_to_submobjects(self, **kwargs) -> Self:\n        for submobject in self.submobjects:\n            submobject.add_background_rectangle(**kwargs)\n        return self\n\n    def add_background_rectangle_to_family_members_with_points(self, **kwargs) -> Self:\n        for mob in self.family_members_with_points():\n            mob.add_background_rectangle(**kwargs)\n        return self\n\n    # Color functions\n\n\n[docs]\n    def set_color(\n        self, color: ParsableManimColor = YELLOW_C, family: bool = True\n    ) -> Self:\n        \"\"\"Condition is function which takes in one arguments, (x, y, z).\n        Here it just recurses to submobjects, but in subclasses this\n        should be further implemented based on the the inner workings\n        of color\n        \"\"\"\n        if family:\n            for submob in self.submobjects:\n                submob.set_color(color, family=family)\n\n        self.color = ManimColor.parse(color)\n        return self\n\n\n\n[docs]\n    def set_color_by_gradient(self, *colors: ParsableManimColor) -> Self:\n        \"\"\"\n        Parameters\n        ----------\n        colors\n            The colors to use for the gradient. Use like `set_color_by_gradient(RED, BLUE, GREEN)`.\n\n        self.color = ManimColor.parse(color)\n        return self\n        \"\"\"\n        self.set_submobject_colors_by_gradient(*colors)\n        return self\n\n\n    def set_colors_by_radial_gradient(\n        self,\n        center: Point3DLike | None = None,\n        radius: float = 1,\n        inner_color: ParsableManimColor = WHITE,\n        outer_color: ParsableManimColor = BLACK,\n    ) -> Self:\n        self.set_submobject_colors_by_radial_gradient(\n            center,\n            radius,\n            inner_color,\n            outer_color,\n        )\n        return self\n\n    def set_submobject_colors_by_gradient(self, *colors: Iterable[ParsableManimColor]):\n        if len(colors) == 0:\n            raise ValueError(\"Need at least one color\")\n        elif len(colors) == 1:\n            return self.set_color(*colors)\n\n        mobs = self.family_members_with_points()\n        new_colors = color_gradient(colors, len(mobs))\n\n        for mob, color in zip(mobs, new_colors):\n            mob.set_color(color, family=False)\n        return self\n\n    def set_submobject_colors_by_radial_gradient(\n        self,\n        center: Point3DLike | None = None,\n        radius: float = 1,\n        inner_color: ParsableManimColor = WHITE,\n        outer_color: ParsableManimColor = BLACK,\n    ) -> Self:\n        if center is None:\n            center = self.get_center()\n\n        for mob in self.family_members_with_points():\n            t = np.linalg.norm(mob.get_center() - center) / radius\n            t = min(t, 1)\n            mob_color = interpolate_color(inner_color, outer_color, t)\n            mob.set_color(mob_color, family=False)\n\n        return self\n\n    def to_original_color(self) -> Self:\n        self.set_color(self.color)\n        return self\n\n    def fade_to(\n        self, color: ParsableManimColor, alpha: float, family: bool = True\n    ) -> Self:\n        if self.get_num_points() > 0:\n            new_color = interpolate_color(self.get_color(), color, alpha)\n            self.set_color(new_color, family=False)\n        if family:\n            for submob in self.submobjects:\n                submob.fade_to(color, alpha)\n        return self\n\n    def fade(self, darkness: float = 0.5, family: bool = True) -> Self:\n        if family:\n            for submob in self.submobjects:\n                submob.fade(darkness, family)\n        return self\n\n\n[docs]\n    def get_color(self) -> ManimColor:\n        \"\"\"Returns the color of the :class:`~.Mobject`\n\n        Examples\n        --------\n        ::\nfrom manim import Square, RED\nSquare(color=RED).get_color() == RED\n            True\n\n        \"\"\"\n        return self.color\n\n\n    ##\n\n\n[docs]\n    def save_state(self) -> Self:\n        \"\"\"Save the current state (position, color & size). Can be restored with :meth:`~.Mobject.restore`.\"\"\"\n        if hasattr(self, \"saved_state\"):\n            # Prevent exponential growth of data\n            self.saved_state = None\n        self.saved_state = self.copy()\n\n        return self\n\n\n\n[docs]\n    def restore(self) -> Self:\n        \"\"\"Restores the state that was previously saved with :meth:`~.Mobject.save_state`.\"\"\"\n        if not hasattr(self, \"saved_state\") or self.save_state is None:\n            raise Exception(\"Trying to restore without having saved\")\n        self.become(self.saved_state)\n        return self\n\n\n\n[docs]\n    def reduce_across_dimension(self, reduce_func: Callable, dim: int):\n        \"\"\"Find the min or max value from a dimension across all points in this and submobjects.\"\"\"\n        assert dim >= 0\n        assert dim <= 2\n        if len(self.submobjects) == 0 and len(self.points) == 0:\n            # If we have no points and no submobjects, return 0 (e.g. center)\n            return 0\n\n        # If we do not have points (but do have submobjects)\n        # use only the points from those.\n        if len(self.points) == 0:  # noqa: SIM108\n            rv = None\n        else:\n            # Otherwise, be sure to include our own points\n            rv = reduce_func(self.points[:, dim])\n        # Recursively ask submobjects (if any) for the biggest/\n        # smallest dimension they have and compare it to the return value.\n        for mobj in self.submobjects:\n            value = mobj.reduce_across_dimension(reduce_func, dim)\n            rv = value if rv is None else reduce_func([value, rv])\n        return rv\n\n\n    def nonempty_submobjects(self) -> list[Self]:\n        return [\n            submob\n            for submob in self.submobjects\n            if len(submob.submobjects) != 0 or len(submob.points) != 0\n        ]\n\n\n[docs]\n    def get_merged_array(self, array_attr: str) -> np.ndarray:\n        \"\"\"Return all of a given attribute from this mobject and all submobjects.\n\n        May contain duplicates; the order is in a depth-first (pre-order)\n        traversal of the submobjects.\n        \"\"\"\n        result = getattr(self, array_attr)\n        for submob in self.submobjects:\n            result = np.append(result, submob.get_merged_array(array_attr), axis=0)\n        return result\n\n\n\n[docs]\n    def get_all_points(self) -> Point3D_Array:\n        \"\"\"Return all points from this mobject and all submobjects.\n\n        May contain duplicates; the order is in a depth-first (pre-order)\n        traversal of the submobjects.\n        \"\"\"\n        return self.get_merged_array(\"points\")\n\n\n    # Getters\n\n    def get_points_defining_boundary(self) -> Point3D_Array:\n        return self.get_all_points()\n\n    def get_num_points(self) -> int:\n        return len(self.points)\n\n    def get_extremum_along_dim(\n        self, points: Point3DLike_Array | None = None, dim: int = 0, key: int = 0\n    ) -> float:\n        np_points: Point3D_Array = (\n            self.get_points_defining_boundary()\n            if points is None\n            else np.asarray(points)\n        )\n        values = np_points[:, dim]\n        if key < 0:\n            return np.min(values)\n        elif key == 0:\n            return (np.min(values) + np.max(values)) / 2\n        else:\n            return np.max(values)\n\n\n[docs]\n    def get_critical_point(self, direction: Vector3D) -> Point3D:\n        \"\"\"Picture a box bounding the :class:`~.Mobject`.  Such a box has\n        9 'critical points': 4 corners, 4 edge center, the\n        center. This returns one of them, along the given direction.\n\n        ::\n\n            sample = Arc(start_angle=PI / 7, angle=PI / 5)\n\n            # These are all equivalent\n            max_y_1 = sample.get_top()[1]\n            max_y_2 = sample.get_critical_point(UP)[1]\n            max_y_3 = sample.get_extremum_along_dim(dim=1, key=1)\n\n        \"\"\"\n        result = np.zeros(self.dim)\n        all_points = self.get_points_defining_boundary()\n        if len(all_points) == 0:\n            return result\n        for dim in range(self.dim):\n            result[dim] = self.get_extremum_along_dim(\n                all_points,\n                dim=dim,\n                key=direction[dim],\n            )\n        return result\n\n\n    # Pseudonyms for more general get_critical_point method\n\n\n[docs]\n    def get_edge_center(self, direction: Vector3D) -> Point3D:\n        \"\"\"Get edge Point3Ds for certain direction.\"\"\"\n        return self.get_critical_point(direction)\n\n\n\n[docs]\n    def get_corner(self, direction: Vector3D) -> Point3D:\n        \"\"\"Get corner Point3Ds for certain direction.\"\"\"\n        return self.get_critical_point(direction)\n\n\n\n[docs]\n    def get_center(self) -> Point3D:\n        \"\"\"Get center Point3Ds\"\"\"\n        return self.get_critical_point(np.zeros(self.dim))\n\n\n    def get_center_of_mass(self) -> Point3D:\n        return np.apply_along_axis(np.mean, 0, self.get_all_points())\n\n    def get_boundary_point(self, direction: Vector3D) -> Point3D:\n        all_points = self.get_points_defining_boundary()\n        index = np.argmax(np.dot(all_points, np.array(direction).T))\n        return all_points[index]\n\n\n[docs]\n    def get_midpoint(self) -> Point3D:\n        \"\"\"Get Point3Ds of the middle of the path that forms the  :class:`~.Mobject`.\n\n        Examples\n        --------\n\n        .. manim:: AngleMidPoint\n            :save_last_frame:\n\n            class AngleMidPoint(Scene):\n                def construct(self):\n                    line1 = Line(ORIGIN, 2*RIGHT)\n                    line2 = Line(ORIGIN, 2*RIGHT).rotate_about_origin(80*DEGREES)\n\n                    a = Angle(line1, line2, radius=1.5, other_angle=False)\n                    d = Dot(a.get_midpoint()).set_color(RED)\n\n                    self.add(line1, line2, a, d)\n                    self.wait()\n\n        \"\"\"\n        return self.point_from_proportion(0.5)\n\n\n\n[docs]\n    def get_top(self) -> Point3D:\n        \"\"\"Get top Point3Ds of a box bounding the :class:`~.Mobject`\"\"\"\n        return self.get_edge_center(UP)\n\n\n\n[docs]\n    def get_bottom(self) -> Point3D:\n        \"\"\"Get bottom Point3Ds of a box bounding the :class:`~.Mobject`\"\"\"\n        return self.get_edge_center(DOWN)\n\n\n\n[docs]\n    def get_right(self) -> Point3D:\n        \"\"\"Get right Point3Ds of a box bounding the :class:`~.Mobject`\"\"\"\n        return self.get_edge_center(RIGHT)\n\n\n\n[docs]\n    def get_left(self) -> Point3D:\n        \"\"\"Get left Point3Ds of a box bounding the :class:`~.Mobject`\"\"\"\n        return self.get_edge_center(LEFT)\n\n\n\n[docs]\n    def get_zenith(self) -> Point3D:\n        \"\"\"Get zenith Point3Ds of a box bounding a 3D :class:`~.Mobject`.\"\"\"\n        return self.get_edge_center(OUT)\n\n\n\n[docs]\n    def get_nadir(self) -> Point3D:\n        \"\"\"Get nadir (opposite the zenith) Point3Ds of a box bounding a 3D :class:`~.Mobject`.\"\"\"\n        return self.get_edge_center(IN)\n\n\n\n[docs]\n    def length_over_dim(self, dim: int) -> float:\n        \"\"\"Measure the length of an :class:`~.Mobject` in a certain direction.\"\"\"\n        return self.reduce_across_dimension(\n            max,\n            dim,\n        ) - self.reduce_across_dimension(min, dim)\n\n\n\n[docs]\n    def get_coord(self, dim: int, direction: Vector3D = ORIGIN):\n        \"\"\"Meant to generalize ``get_x``, ``get_y`` and ``get_z``\"\"\"\n        return self.get_extremum_along_dim(dim=dim, key=direction[dim])\n\n\n\n[docs]\n    def get_x(self, direction: Vector3D = ORIGIN) -> float:\n        \"\"\"Returns x Point3D of the center of the :class:`~.Mobject` as ``float``\"\"\"\n        return self.get_coord(0, direction)\n\n\n\n[docs]\n    def get_y(self, direction: Vector3D = ORIGIN) -> float:\n        \"\"\"Returns y Point3D of the center of the :class:`~.Mobject` as ``float``\"\"\"\n        return self.get_coord(1, direction)\n\n\n\n[docs]\n    def get_z(self, direction: Vector3D = ORIGIN) -> float:\n        \"\"\"Returns z Point3D of the center of the :class:`~.Mobject` as ``float``\"\"\"\n        return self.get_coord(2, direction)\n\n\n\n[docs]\n    def get_start(self) -> Point3D:\n        \"\"\"Returns the point, where the stroke that surrounds the :class:`~.Mobject` starts.\"\"\"\n        self.throw_error_if_no_points()\n        return np.array(self.points[0])\n\n\n\n[docs]\n    def get_end(self) -> Point3D:\n        \"\"\"Returns the point, where the stroke that surrounds the :class:`~.Mobject` ends.\"\"\"\n        self.throw_error_if_no_points()\n        return np.array(self.points[-1])\n\n\n\n[docs]\n    def get_start_and_end(self) -> tuple[Point3D, Point3D]:\n        \"\"\"Returns starting and ending point of a stroke as a ``tuple``.\"\"\"\n        return self.get_start(), self.get_end()\n\n\n    def point_from_proportion(self, alpha: float) -> Point3D:\n        raise NotImplementedError(\"Please override in a child class.\")\n\n    def proportion_from_point(self, point: Point3DLike) -> float:\n        raise NotImplementedError(\"Please override in a child class.\")\n\n    def get_pieces(self, n_pieces: float) -> Group:\n        template = self.copy()\n        template.submobjects = []\n        alphas = np.linspace(0, 1, n_pieces + 1)\n        return Group(\n            *(\n                template.copy().pointwise_become_partial(self, a1, a2)\n                for a1, a2 in zip(alphas[:-1], alphas[1:])\n            )\n        )\n\n    def get_z_index_reference_point(self) -> Point3D:\n        # TODO, better place to define default z_index_group?\n        z_index_group = getattr(self, \"z_index_group\", self)\n        return z_index_group.get_center()\n\n\n[docs]\n    def has_points(self) -> bool:\n        \"\"\"Check if :class:`~.Mobject` contains points.\"\"\"\n        return len(self.points) > 0\n\n\n\n[docs]\n    def has_no_points(self) -> bool:\n        \"\"\"Check if :class:`~.Mobject` *does not* contains points.\"\"\"\n        return not self.has_points()\n\n\n    # Match other mobject properties\n\n\n[docs]\n    def match_color(self, mobject: Mobject) -> Self:\n        \"\"\"Match the color with the color of another :class:`~.Mobject`.\"\"\"\n        return self.set_color(mobject.get_color())\n\n\n\n[docs]\n    def match_dim_size(self, mobject: Mobject, dim: int, **kwargs) -> Self:\n        \"\"\"Match the specified dimension with the dimension of another :class:`~.Mobject`.\"\"\"\n        return self.rescale_to_fit(mobject.length_over_dim(dim), dim, **kwargs)\n\n\n\n[docs]\n    def match_width(self, mobject: Mobject, **kwargs) -> Self:\n        \"\"\"Match the width with the width of another :class:`~.Mobject`.\"\"\"\n        return self.match_dim_size(mobject, 0, **kwargs)\n\n\n\n[docs]\n    def match_height(self, mobject: Mobject, **kwargs) -> Self:\n        \"\"\"Match the height with the height of another :class:`~.Mobject`.\"\"\"\n        return self.match_dim_size(mobject, 1, **kwargs)\n\n\n\n[docs]\n    def match_depth(self, mobject: Mobject, **kwargs) -> Self:\n        \"\"\"Match the depth with the depth of another :class:`~.Mobject`.\"\"\"\n        return self.match_dim_size(mobject, 2, **kwargs)\n\n\n\n[docs]\n    def match_coord(\n        self, mobject: Mobject, dim: int, direction: Vector3D = ORIGIN\n    ) -> Self:\n        \"\"\"Match the Point3Ds with the Point3Ds of another :class:`~.Mobject`.\"\"\"\n        return self.set_coord(\n            mobject.get_coord(dim, direction),\n            dim=dim,\n            direction=direction,\n        )\n\n\n\n[docs]\n    def match_x(self, mobject: Mobject, direction=ORIGIN) -> Self:\n        \"\"\"Match x coord. to the x coord. of another :class:`~.Mobject`.\"\"\"\n        return self.match_coord(mobject, 0, direction)\n\n\n\n[docs]\n    def match_y(self, mobject: Mobject, direction=ORIGIN) -> Self:\n        \"\"\"Match y coord. to the x coord. of another :class:`~.Mobject`.\"\"\"\n        return self.match_coord(mobject, 1, direction)\n\n\n\n[docs]\n    def match_z(self, mobject: Mobject, direction=ORIGIN) -> Self:\n        \"\"\"Match z coord. to the x coord. of another :class:`~.Mobject`.\"\"\"\n        return self.match_coord(mobject, 2, direction)\n\n\n\n[docs]\n    def align_to(\n        self,\n        mobject_or_point: Mobject | Point3DLike,\n        direction: Vector3D = ORIGIN,\n    ) -> Self:\n        \"\"\"Aligns mobject to another :class:`~.Mobject` in a certain direction.\n\n        Examples:\n        mob1.align_to(mob2, UP) moves mob1 vertically so that its\n        top edge lines ups with mob2's top edge.\n        \"\"\"\n        if isinstance(mobject_or_point, Mobject):\n            point = mobject_or_point.get_critical_point(direction)\n        else:\n            point = mobject_or_point\n\n        for dim in range(self.dim):\n            if direction[dim] != 0:\n                self.set_coord(point[dim], dim, direction)\n        return self\n\n\n    # Family matters\n\n    def __getitem__(self, value):\n        self_list = self.split()\n        if isinstance(value, slice):\n            GroupClass = self.get_group_class()\n            return GroupClass(*self_list.__getitem__(value))\n        return self_list.__getitem__(value)\n\n    def __iter__(self):\n        return iter(self.split())\n\n    def __len__(self):\n        return len(self.split())\n\n    def get_group_class(self) -> type[Group]:\n        return Group\n\n\n[docs]\n    @staticmethod\n    def get_mobject_type_class() -> type[Mobject]:\n        \"\"\"Return the base class of this mobject type.\"\"\"\n        return Mobject\n\n\n    def split(self) -> list[Self]:\n        result = [self] if len(self.points) > 0 else []\n        return result + self.submobjects\n\n    def get_family(self, recurse: bool = True) -> list[Self]:\n        sub_families = [x.get_family() for x in self.submobjects]\n        all_mobjects = [self] + list(it.chain(*sub_families))\n        return remove_list_redundancies(all_mobjects)\n\n    def family_members_with_points(self) -> list[Self]:\n        return [m for m in self.get_family() if m.get_num_points() > 0]\n\n\n[docs]\n    def arrange(\n        self,\n        direction: Vector3D = RIGHT,\n        buff: float = DEFAULT_MOBJECT_TO_MOBJECT_BUFFER,\n        center: bool = True,\n        **kwargs,\n    ) -> Self:\n        \"\"\"Sorts :class:`~.Mobject` next to each other on screen.\n\n        Examples\n        --------\n\n        .. manim:: Example\n            :save_last_frame:\n\n            class Example(Scene):\n                def construct(self):\n                    s1 = Square()\n                    s2 = Square()\n                    s3 = Square()\n                    s4 = Square()\n                    x = VGroup(s1, s2, s3, s4).set_x(0).arrange(buff=1.0)\n                    self.add(x)\n        \"\"\"\n        for m1, m2 in zip(self.submobjects, self.submobjects[1:]):\n            m2.next_to(m1, direction, buff, **kwargs)\n        if center:\n            self.center()\n        return self\n\n\n\n[docs]\n    def arrange_in_grid(\n        self,\n        rows: int | None = None,\n        cols: int | None = None,\n        buff: float | tuple[float, float] = MED_SMALL_BUFF,\n        cell_alignment: Vector3D = ORIGIN,\n        row_alignments: str | None = None,  # \"ucd\"\n        col_alignments: str | None = None,  # \"lcr\"\n        row_heights: Iterable[float | None] | None = None,\n        col_widths: Iterable[float | None] | None = None,\n        flow_order: str = \"rd\",\n        **kwargs,\n    ) -> Self:\n        \"\"\"Arrange submobjects in a grid.\n\n        Parameters\n        ----------\n        rows\n            The number of rows in the grid.\n        cols\n            The number of columns in the grid.\n        buff\n            The gap between grid cells. To specify a different buffer in the horizontal and\n            vertical directions, a tuple of two values can be given - ``(row, col)``.\n        cell_alignment\n            The way each submobject is aligned in its grid cell.\n        row_alignments\n            The vertical alignment for each row (top to bottom). Accepts the following characters: ``\"u\"`` -\n            up, ``\"c\"`` - center, ``\"d\"`` - down.\n        col_alignments\n            The horizontal alignment for each column (left to right). Accepts the following characters ``\"l\"`` - left,\n            ``\"c\"`` - center, ``\"r\"`` - right.\n        row_heights\n            Defines a list of heights for certain rows (top to bottom). If the list contains\n            ``None``, the corresponding row will fit its height automatically based\n            on the highest element in that row.\n        col_widths\n            Defines a list of widths for certain columns (left to right). If the list contains ``None``, the\n            corresponding column will fit its width automatically based on the widest element in that column.\n        flow_order\n            The order in which submobjects fill the grid. Can be one of the following values:\n            \"rd\", \"dr\", \"ld\", \"dl\", \"ru\", \"ur\", \"lu\", \"ul\". (\"rd\" -> fill rightwards then downwards)\n\n        Returns\n        -------\n        :class:`Mobject`\n            ``self``\n\n        Raises\n        ------\n        ValueError\n            If ``rows`` and ``cols`` are too small to fit all submobjects.\n        ValueError\n            If :code:`cols`, :code:`col_alignments` and :code:`col_widths` or :code:`rows`,\n            :code:`row_alignments` and :code:`row_heights` have mismatching sizes.\n\n        Notes\n        -----\n        If only one of ``cols`` and ``rows`` is set implicitly, the other one will be chosen big\n        enough to fit all submobjects. If neither is set, they will be chosen to be about the same,\n        tending towards ``cols`` > ``rows`` (simply because videos are wider than they are high).\n\n        If both ``cell_alignment`` and ``row_alignments`` / ``col_alignments`` are\n        defined, the latter has higher priority.\n\n        Examples\n        --------\n        .. manim:: ExampleBoxes\n            :save_last_frame:\n\n            class ExampleBoxes(Scene):\n                def construct(self):\n                    boxes=VGroup(*[Square() for s in range(0,6)])\n                    boxes.arrange_in_grid(rows=2, buff=0.1)\n                    self.add(boxes)\n\n\n        .. manim:: ArrangeInGrid\n            :save_last_frame:\n\n            class ArrangeInGrid(Scene):\n                def construct(self):\n                    boxes = VGroup(*[\n                        Rectangle(WHITE, 0.5, 0.5).add(Text(str(i+1)).scale(0.5))\n                        for i in range(24)\n                    ])\n                    self.add(boxes)\n\n                    boxes.arrange_in_grid(\n                        buff=(0.25,0.5),\n                        col_alignments=\"lccccr\",\n                        row_alignments=\"uccd\",\n                        col_widths=[1, *[None]*4, 1],\n                        row_heights=[1, None, None, 1],\n                        flow_order=\"dr\"\n                    )\n\n\n        \"\"\"\n        from manim.mobject.geometry.line import Line\n\n        mobs = self.submobjects.copy()\n        start_pos = self.get_center()\n\n        # get cols / rows values if given (implicitly)\n        def init_size(num, alignments, sizes):\n            if num is not None:\n                return num\n            if alignments is not None:\n                return len(alignments)\n            if sizes is not None:\n                return len(sizes)\n\n        cols = init_size(cols, col_alignments, col_widths)\n        rows = init_size(rows, row_alignments, row_heights)\n\n        # calculate rows cols\n        if rows is None and cols is None:\n            cols = math.ceil(math.sqrt(len(mobs)))\n            # make the grid as close to quadratic as possible.\n            # choosing cols first can results in cols>rows.\n            # This is favored over rows>cols since in general\n            # the sceene is wider than high.\n        if rows is None:\n            rows = math.ceil(len(mobs) / cols)\n        if cols is None:\n            cols = math.ceil(len(mobs) / rows)\n        if rows * cols < len(mobs):\n            raise ValueError(\"Too few rows and columns to fit all submobjetcs.\")\n        # rows and cols are now finally valid.\n\n        if isinstance(buff, tuple):\n            buff_x = buff[0]\n            buff_y = buff[1]\n        else:\n            buff_x = buff_y = buff\n\n        # Initialize alignments correctly\n        def init_alignments(alignments, num, mapping, name, dir_):\n            if alignments is None:\n                # Use cell_alignment as fallback\n                return [cell_alignment * dir_] * num\n            if len(alignments) != num:\n                raise ValueError(f\"{name}_alignments has a mismatching size.\")\n            alignments = list(alignments)\n            for i in range(num):\n                alignments[i] = mapping[alignments[i]]\n            return alignments\n\n        row_alignments = init_alignments(\n            row_alignments,\n            rows,\n            {\"u\": UP, \"c\": ORIGIN, \"d\": DOWN},\n            \"row\",\n            RIGHT,\n        )\n        col_alignments = init_alignments(\n            col_alignments,\n            cols,\n            {\"l\": LEFT, \"c\": ORIGIN, \"r\": RIGHT},\n            \"col\",\n            UP,\n        )\n        # Now row_alignment[r] + col_alignment[c] is the alignment in cell [r][c]\n\n        mapper = {\n            \"dr\": lambda r, c: (rows - r - 1) + c * rows,\n            \"dl\": lambda r, c: (rows - r - 1) + (cols - c - 1) * rows,\n            \"ur\": lambda r, c: r + c * rows,\n            \"ul\": lambda r, c: r + (cols - c - 1) * rows,\n            \"rd\": lambda r, c: (rows - r - 1) * cols + c,\n            \"ld\": lambda r, c: (rows - r - 1) * cols + (cols - c - 1),\n            \"ru\": lambda r, c: r * cols + c,\n            \"lu\": lambda r, c: r * cols + (cols - c - 1),\n        }\n        if flow_order not in mapper:\n            raise ValueError(\n                'flow_order must be one of the following values: \"dr\", \"rd\", \"ld\" \"dl\", \"ru\", \"ur\", \"lu\", \"ul\".',\n            )\n        flow_order = mapper[flow_order]\n\n        # Reverse row_alignments and row_heights. Necessary since the\n        # grid filling is handled bottom up for simplicity reasons.\n        def reverse(maybe_list):\n            if maybe_list is not None:\n                maybe_list = list(maybe_list)\n                maybe_list.reverse()\n                return maybe_list\n\n        row_alignments = reverse(row_alignments)\n        row_heights = reverse(row_heights)\n\n        placeholder = Mobject()\n        # Used to fill up the grid temporarily, doesn't get added to the scene.\n        # In this case a Mobject is better than None since it has width and height\n        # properties of 0.\n\n        mobs.extend([placeholder] * (rows * cols - len(mobs)))\n        grid = [[mobs[flow_order(r, c)] for c in range(cols)] for r in range(rows)]\n\n        measured_heigths = [\n            max(grid[r][c].height for c in range(cols)) for r in range(rows)\n        ]\n        measured_widths = [\n            max(grid[r][c].width for r in range(rows)) for c in range(cols)\n        ]\n\n        # Initialize row_heights / col_widths correctly using measurements as fallback\n        def init_sizes(sizes, num, measures, name):\n            if sizes is None:\n                sizes = [None] * num\n            if len(sizes) != num:\n                raise ValueError(f\"{name} has a mismatching size.\")\n            return [\n                sizes[i] if sizes[i] is not None else measures[i] for i in range(num)\n            ]\n\n        heights = init_sizes(row_heights, rows, measured_heigths, \"row_heights\")\n        widths = init_sizes(col_widths, cols, measured_widths, \"col_widths\")\n\n        x, y = 0, 0\n        for r in range(rows):\n            x = 0\n            for c in range(cols):\n                if grid[r][c] is not placeholder:\n                    alignment = row_alignments[r] + col_alignments[c]\n                    line = Line(\n                        x * RIGHT + y * UP,\n                        (x + widths[c]) * RIGHT + (y + heights[r]) * UP,\n                    )\n                    # Use a mobject to avoid rewriting align inside\n                    # box code that Mobject.move_to(Mobject) already\n                    # includes.\n\n                    grid[r][c].move_to(line, alignment)\n                x += widths[c] + buff_x\n            y += heights[r] + buff_y\n\n        self.move_to(start_pos)\n        return self\n\n\n\n[docs]\n    def sort(\n        self,\n        point_to_num_func: Callable[[Point3DLike], float] = lambda p: p[0],\n        submob_func: Callable[[Mobject], Any] | None = None,\n    ) -> Self:\n        \"\"\"Sorts the list of :attr:`submobjects` by a function defined by ``submob_func``.\"\"\"\n        if submob_func is None:\n\n            def submob_func(m: Mobject) -> float:\n                return point_to_num_func(m.get_center())\n\n        self.submobjects.sort(key=submob_func)\n        return self\n\n\n\n[docs]\n    def shuffle(self, recursive: bool = False) -> None:\n        \"\"\"Shuffles the list of :attr:`submobjects`.\"\"\"\n        if recursive:\n            for submob in self.submobjects:\n                submob.shuffle(recursive=True)\n        random.shuffle(self.submobjects)\n\n\n\n[docs]\n    def invert(self, recursive: bool = False) -> None:\n        \"\"\"Inverts the list of :attr:`submobjects`.\n\n        Parameters\n        ----------\n        recursive\n            If ``True``, all submobject lists of this mobject's family are inverted.\n\n        Examples\n        --------\n\n        .. manim:: InvertSumobjectsExample\n\n            class InvertSumobjectsExample(Scene):\n                def construct(self):\n                    s = VGroup(*[Dot().shift(i*0.1*RIGHT) for i in range(-20,20)])\n                    s2 = s.copy()\n                    s2.invert()\n                    s2.shift(DOWN)\n                    self.play(Write(s), Write(s2))\n        \"\"\"\n        if recursive:\n            for submob in self.submobjects:\n                submob.invert(recursive=True)\n        self.submobjects.reverse()\n\n\n    # Just here to keep from breaking old scenes.\n\n[docs]\n    def arrange_submobjects(self, *args, **kwargs) -> Self:\n        \"\"\"Arrange the position of :attr:`submobjects` with a small buffer.\n\n        Examples\n        --------\n\n        .. manim:: ArrangeSumobjectsExample\n            :save_last_frame:\n\n            class ArrangeSumobjectsExample(Scene):\n                def construct(self):\n                    s= VGroup(*[Dot().shift(i*0.1*RIGHT*np.random.uniform(-1,1)+UP*np.random.uniform(-1,1)) for i in range(0,15)])\n                    s.shift(UP).set_color(BLUE)\n                    s2= s.copy().set_color(RED)\n                    s2.arrange_submobjects()\n                    s2.shift(DOWN)\n                    self.add(s,s2)\n\n        \"\"\"\n        return self.arrange(*args, **kwargs)\n\n\n\n[docs]\n    def sort_submobjects(self, *args, **kwargs) -> Self:\n        \"\"\"Sort the :attr:`submobjects`\"\"\"\n        return self.sort(*args, **kwargs)\n\n\n\n[docs]\n    def shuffle_submobjects(self, *args, **kwargs) -> None:\n        \"\"\"Shuffles the order of :attr:`submobjects`\n\n        Examples\n        --------\n\n        .. manim:: ShuffleSubmobjectsExample\n\n            class ShuffleSubmobjectsExample(Scene):\n                def construct(self):\n                    s= VGroup(*[Dot().shift(i*0.1*RIGHT) for i in range(-20,20)])\n                    s2= s.copy()\n                    s2.shuffle_submobjects()\n                    s2.shift(DOWN)\n                    self.play(Write(s), Write(s2))\n        \"\"\"\n        return self.shuffle(*args, **kwargs)\n\n\n    # Alignment\n\n[docs]\n    def align_data(self, mobject: Mobject, skip_point_alignment: bool = False) -> None:\n        \"\"\"Aligns the data of this mobject with another mobject.\n\n        Afterwards, the two mobjects will have the same number of submobjects\n        (see :meth:`.align_submobjects`), the same parent structure (see\n        :meth:`.null_point_align`). If ``skip_point_alignment`` is false,\n        they will also have the same number of points (see :meth:`.align_points`).\n\n        Parameters\n        ----------\n        mobject\n            The other mobject this mobject should be aligned to.\n        skip_point_alignment\n            Controls whether or not the computationally expensive\n            point alignment is skipped (default: False).\n        \"\"\"\n        self.null_point_align(mobject)\n        self.align_submobjects(mobject)\n        if not skip_point_alignment:\n            self.align_points(mobject)\n        # Recurse\n        for m1, m2 in zip(self.submobjects, mobject.submobjects):\n            m1.align_data(m2)\n\n\n\n[docs]\n    def get_point_mobject(self, center=None):\n        \"\"\"The simplest :class:`~.Mobject` to be transformed to or from self.\n        Should by a point of the appropriate type\n        \"\"\"\n        msg = f\"get_point_mobject not implemented for {self.__class__.__name__}\"\n        raise NotImplementedError(msg)\n\n\n    def align_points(self, mobject: Mobject) -> Self:\n        count1 = self.get_num_points()\n        count2 = mobject.get_num_points()\n        if count1 < count2:\n            self.align_points_with_larger(mobject)\n        elif count2 < count1:\n            mobject.align_points_with_larger(self)\n        return self\n\n    def align_points_with_larger(self, larger_mobject: Mobject):\n        raise NotImplementedError(\"Please override in a child class.\")\n\n    def align_submobjects(self, mobject: Mobject) -> Self:\n        mob1 = self\n        mob2 = mobject\n        n1 = len(mob1.submobjects)\n        n2 = len(mob2.submobjects)\n        mob1.add_n_more_submobjects(max(0, n2 - n1))\n        mob2.add_n_more_submobjects(max(0, n1 - n2))\n        return self\n\n\n[docs]\n    def null_point_align(self, mobject: Mobject):\n        \"\"\"If a :class:`~.Mobject` with points is being aligned to\n        one without, treat both as groups, and push\n        the one with points into its own submobjects\n        list.\n\n        Returns\n        -------\n        :class:`Mobject`\n            ``self``\n        \"\"\"\n        for m1, m2 in (self, mobject), (mobject, self):\n            if m1.has_no_points() and m2.has_points():\n                m2.push_self_into_submobjects()\n        return self\n\n\n    def push_self_into_submobjects(self) -> Self:\n        copy = self.copy()\n        copy.submobjects = []\n        self.reset_points()\n        self.add(copy)\n        return self\n\n    def add_n_more_submobjects(self, n: int) -> Self | None:\n        if n == 0:\n            return None\n\n        curr = len(self.submobjects)\n        if curr == 0:\n            # If empty, simply add n point mobjects\n            self.submobjects = [self.get_point_mobject() for k in range(n)]\n            return None\n\n        target = curr + n\n        # TODO, factor this out to utils so as to reuse\n        # with VMobject.insert_n_curves\n        repeat_indices = (np.arange(target) * curr) // target\n        split_factors = [sum(repeat_indices == i) for i in range(curr)]\n        new_submobs = []\n        for submob, sf in zip(self.submobjects, split_factors):\n            new_submobs.append(submob)\n            for _ in range(1, sf):\n                new_submobs.append(submob.copy().fade(1))\n        self.submobjects = new_submobs\n        return self\n\n    def repeat_submobject(self, submob: Mobject) -> Self:\n        return submob.copy()\n\n\n[docs]\n    def interpolate(\n        self,\n        mobject1: Mobject,\n        mobject2: Mobject,\n        alpha: float,\n        path_func: PathFuncType = straight_path(),\n    ) -> Self:\n        \"\"\"Turns this :class:`~.Mobject` into an interpolation between ``mobject1``\n        and ``mobject2``.\n\n        Examples\n        --------\n\n        .. manim:: DotInterpolation\n            :save_last_frame:\n\n            class DotInterpolation(Scene):\n                def construct(self):\n                    dotR = Dot(color=DARK_GREY)\n                    dotR.shift(2 * RIGHT)\n                    dotL = Dot(color=WHITE)\n                    dotL.shift(2 * LEFT)\n\n                    dotMiddle = VMobject().interpolate(dotL, dotR, alpha=0.3)\n\n                    self.add(dotL, dotR, dotMiddle)\n        \"\"\"\n        self.points = path_func(mobject1.points, mobject2.points, alpha)\n        self.interpolate_color(mobject1, mobject2, alpha)\n        return self\n\n\n    def interpolate_color(self, mobject1: Mobject, mobject2: Mobject, alpha: float):\n        raise NotImplementedError(\"Please override in a child class.\")\n\n\n[docs]\n    def become(\n        self,\n        mobject: Mobject,\n        match_height: bool = False,\n        match_width: bool = False,\n        match_depth: bool = False,\n        match_center: bool = False,\n        stretch: bool = False,\n    ) -> Self:\n        \"\"\"Edit points, colors and submobjects to be identical\n        to another :class:`~.Mobject`\n\n        .. note::\n\n            If both match_height and match_width are ``True`` then the transformed :class:`~.Mobject`\n            will match the height first and then the width.\n\n        Parameters\n        ----------\n        match_height\n            Whether or not to preserve the height of the original\n            :class:`~.Mobject`.\n        match_width\n            Whether or not to preserve the width of the original\n            :class:`~.Mobject`.\n        match_depth\n            Whether or not to preserve the depth of the original\n            :class:`~.Mobject`.\n        match_center\n            Whether or not to preserve the center of the original\n            :class:`~.Mobject`.\n        stretch\n            Whether or not to stretch the target mobject to match the\n            the proportions of the original :class:`~.Mobject`.\n\n        Examples\n        --------\n        .. manim:: BecomeScene\n\n            class BecomeScene(Scene):\n                def construct(self):\n                    circ = Circle(fill_color=RED, fill_opacity=0.8)\n                    square = Square(fill_color=BLUE, fill_opacity=0.2)\n                    self.add(circ)\n                    self.wait(0.5)\n                    circ.become(square)\n                    self.wait(0.5)\n\n\n        The following examples illustrate how mobject measurements\n        change when using the ``match_...`` and ``stretch`` arguments.\n        We start with a rectangle that is 2 units high and 4 units wide,\n        which we want to turn into a circle of radius 3::\nfrom manim import Rectangle, Circle\nimport numpy as np\nrect = Rectangle(height=2, width=4)\ncirc = Circle(radius=3)\n\n        With ``stretch=True``, the target circle is deformed to match\n        the proportions of the rectangle, which results in the target\n        mobject being an ellipse with height 2 and width 4. We can\n        check that the resulting points satisfy the ellipse equation\n        :math:`x^2/a^2 + y^2/b^2 = 1` with :math:`a = 4/2` and :math:`b = 2/2`\n        being the semi-axes::\nresult = rect.copy().become(circ, stretch=True)\nresult.height, result.width\n            (np.float64(2.0), np.float64(4.0))\nellipse_points = np.array(result.get_anchors())\nellipse_eq = np.sum(ellipse_points**2 * [1/4, 1, 0], axis=1)\nnp.allclose(ellipse_eq, 1)\n            True\n\n        With ``match_height=True`` and ``match_width=True`` the circle is\n        scaled such that the height or the width of the rectangle will\n        be preserved, respectively.\n        The points of the resulting mobject satisfy the circle equation\n        :math:`x^2 + y^2 = r^2` for the corresponding radius :math:`r`::\nresult = rect.copy().become(circ, match_height=True)\nresult.height, result.width\n            (np.float64(2.0), np.float64(2.0))\ncircle_points = np.array(result.get_anchors())\ncircle_eq = np.sum(circle_points**2, axis=1)\nnp.allclose(circle_eq, 1)\n            True\nresult = rect.copy().become(circ, match_width=True)\nresult.height, result.width\n            (np.float64(4.0), np.float64(4.0))\ncircle_points = np.array(result.get_anchors())\ncircle_eq = np.sum(circle_points**2, axis=1)\nnp.allclose(circle_eq, 2**2)\n            True\n\n        With ``match_center=True``, the resulting mobject is moved such that\n        its center is the same as the center of the original mobject::\nrect = rect.shift(np.array([0, 1, 0]))\nnp.allclose(rect.get_center(), circ.get_center())\n            False\nresult = rect.copy().become(circ, match_center=True)\nnp.allclose(rect.get_center(), result.get_center())\n            True\n        \"\"\"\n        mobject = mobject.copy()\n        if stretch:\n            mobject.stretch_to_fit_height(self.height)\n            mobject.stretch_to_fit_width(self.width)\n            mobject.stretch_to_fit_depth(self.depth)\n        else:\n            if match_height:\n                mobject.match_height(self)\n            if match_width:\n                mobject.match_width(self)\n            if match_depth:\n                mobject.match_depth(self)\n\n        if match_center:\n            mobject.move_to(self.get_center())\n\n        self.align_data(mobject, skip_point_alignment=True)\n        for sm1, sm2 in zip(self.get_family(), mobject.get_family()):\n            sm1.points = np.array(sm2.points)\n            sm1.interpolate_color(sm1, sm2, 1)\n        return self\n\n\n\n[docs]\n    def match_points(self, mobject: Mobject, copy_submobjects: bool = True) -> Self:\n        \"\"\"Edit points, positions, and submobjects to be identical\n        to another :class:`~.Mobject`, while keeping the style unchanged.\n\n        Examples\n        --------\n        .. manim:: MatchPointsScene\n\n            class MatchPointsScene(Scene):\n                def construct(self):\n                    circ = Circle(fill_color=RED, fill_opacity=0.8)\n                    square = Square(fill_color=BLUE, fill_opacity=0.2)\n                    self.add(circ)\n                    self.wait(0.5)\n                    self.play(circ.animate.match_points(square))\n                    self.wait(0.5)\n        \"\"\"\n        for sm1, sm2 in zip(self.get_family(), mobject.get_family()):\n            sm1.points = np.array(sm2.points)\n        return self\n\n\n    # Errors\n    def throw_error_if_no_points(self) -> None:\n        if self.has_no_points():\n            caller_name = sys._getframe(1).f_code.co_name\n            raise Exception(\n                f\"Cannot call Mobject.{caller_name} for a Mobject with no points\",\n            )\n\n    # About z-index\n\n[docs]\n    def set_z_index(\n        self,\n        z_index_value: float,\n        family: bool = True,\n    ) -> Self:\n        \"\"\"Sets the :class:`~.Mobject`'s :attr:`z_index` to the value specified in `z_index_value`.\n\n        Parameters\n        ----------\n        z_index_value\n            The new value of :attr:`z_index` set.\n        family\n            If ``True``, the :attr:`z_index` value of all submobjects is also set.\n\n        Returns\n        -------\n        :class:`Mobject`\n            The Mobject itself, after :attr:`z_index` is set. For chaining purposes. (Returns `self`.)\n\n        Examples\n        --------\n        .. manim:: SetZIndex\n            :save_last_frame:\n\n            class SetZIndex(Scene):\n                def construct(self):\n                    text = Text('z_index = 3', color = PURE_RED).shift(UP).set_z_index(3)\n                    square = Square(2, fill_opacity=1).set_z_index(2)\n                    tex = Tex(r'zIndex = 1', color = PURE_BLUE).shift(DOWN).set_z_index(1)\n                    circle = Circle(radius = 1.7, color = GREEN, fill_opacity = 1) # z_index = 0\n\n                    # Displaying order is now defined by z_index values\n                    self.add(text)\n                    self.add(square)\n                    self.add(tex)\n                    self.add(circle)\n        \"\"\"\n        if family:\n            for submob in self.submobjects:\n                submob.set_z_index(z_index_value, family=family)\n        self.z_index = z_index_value\n        return self\n\n\n\n[docs]\n    def set_z_index_by_z_Point3D(self) -> Self:\n        \"\"\"Sets the :class:`~.Mobject`'s z Point3D to the value of :attr:`z_index`.\n\n        Returns\n        -------\n        :class:`Mobject`\n            The Mobject itself, after :attr:`z_index` is set. (Returns `self`.)\n        \"\"\"\n        z_coord = self.get_center()[-1]\n        self.set_z_index(z_coord)\n        return self\n\n\n\n\n\n[docs]\nclass Group(Mobject, metaclass=ConvertToOpenGL):\n    \"\"\"Groups together multiple :class:`Mobjects <.Mobject>`.\n\n    Notes\n    -----\n    When adding the same mobject more than once, repetitions are ignored.\n    Use :meth:`.Mobject.copy` to create a separate copy which can then\n    be added to the group.\n    \"\"\"\n\n    def __init__(self, *mobjects, **kwargs) -> None:\n        super().__init__(**kwargs)\n        self.add(*mobjects)\n\n\n\nclass _AnimationBuilder:\n    def __init__(self, mobject) -> None:\n        self.mobject = mobject\n        self.mobject.generate_target()\n\n        self.overridden_animation = None\n        self.is_chaining = False\n        self.methods = []\n\n        # Whether animation args can be passed\n        self.cannot_pass_args = False\n        self.anim_args = {}\n\n    def __call__(self, **kwargs) -> Self:\n        if self.cannot_pass_args:\n            raise ValueError(\n                \"Animation arguments must be passed before accessing methods and can only be passed once\",\n            )\n\n        self.anim_args = kwargs\n        self.cannot_pass_args = True\n\n        return self\n\n    def __getattr__(self, method_name) -> types.MethodType:\n        method = getattr(self.mobject.target, method_name)\n        has_overridden_animation = hasattr(method, \"_override_animate\")\n\n        if (self.is_chaining and has_overridden_animation) or self.overridden_animation:\n            raise NotImplementedError(\n                \"Method chaining is currently not supported for overridden animations\",\n            )\n\n        def update_target(*method_args, **method_kwargs):\n            if has_overridden_animation:\n                self.overridden_animation = method._override_animate(\n                    self.mobject,\n                    *method_args,\n                    anim_args=self.anim_args,\n                    **method_kwargs,\n                )\n            else:\n                self.methods.append([method, method_args, method_kwargs])\n                method(*method_args, **method_kwargs)\n            return self\n\n        self.is_chaining = True\n        self.cannot_pass_args = True\n\n        return update_target\n\n    def build(self) -> Animation:\n        from ..animation.transform import (  # is this to prevent circular import?\n            _MethodAnimation,\n        )\n\n        if self.overridden_animation:\n            anim = self.overridden_animation\n        else:\n            anim = _MethodAnimation(self.mobject, self.methods)\n\n        for attr, value in self.anim_args.items():\n            setattr(anim, attr, value)\n\n        return anim\n\n\n\n[docs]\ndef override_animate(method) -> types.FunctionType:\n    r\"\"\"Decorator for overriding method animations.\n\n    This allows to specify a method (returning an :class:`~.Animation`)\n    which is called when the decorated method is used with the ``.animate`` syntax\n    for animating the application of a method.\n\n    .. seealso::\n\n        :attr:`Mobject.animate`\n\n    .. note::\n\n        Overridden methods cannot be combined with normal or other overridden\n        methods using method chaining with the ``.animate`` syntax.\n\n\n    Examples\n    --------\n\n    .. manim:: AnimationOverrideExample\n\n        class CircleWithContent(VGroup):\n            def __init__(self, content):\n                super().__init__()\n                self.circle = Circle()\n                self.content = content\n                self.add(self.circle, content)\n                content.move_to(self.circle.get_center())\n\n            def clear_content(self):\n                self.remove(self.content)\n                self.content = None\n\n            @override_animate(clear_content)\n            def _clear_content_animation(self, anim_args=None):\n                if anim_args is None:\n                    anim_args = {}\n                anim = Uncreate(self.content, **anim_args)\n                self.clear_content()\n                return anim\n\n        class AnimationOverrideExample(Scene):\n            def construct(self):\n                t = Text(\"hello!\")\n                my_mobject = CircleWithContent(t)\n                self.play(Create(my_mobject))\n                self.play(my_mobject.animate.clear_content())\n                self.wait()\n\n    \"\"\"\n\n    def decorator(animation_method):\n        method._override_animate = animation_method\n        return animation_method\n\n    return decorator", "code_sha1": "ee6a5e8631177ef517488fc9e0f0667b923049f4"}
{"url": "https://docs.manim.community/en/stable/_modules/manim/mobject/svg/brace.html", "depth": 2, "instruction": "The code defines a `Brace` mobject that visually represents a brace adjacent to another mobject, with customizable properties like direction, sharpness, and color. It includes animations for creating the brace and its label, which can be positioned at the brace tip. The brace can be animated to grow from the center, enhancing its visual appeal.", "code": "\"\"\"Mobject representing curly braces.\"\"\"\n\nfrom __future__ import annotations\n\n__all__ = [\"Brace\", \"BraceLabel\", \"ArcBrace\", \"BraceText\", \"BraceBetweenPoints\"]\n\nfrom collections.abc import Sequence\nfrom typing import TYPE_CHECKING\n\nimport numpy as np\nimport svgelements as se\n\nfrom manim._config import config\nfrom manim.mobject.geometry.arc import Arc\nfrom manim.mobject.geometry.line import Line\nfrom manim.mobject.mobject import Mobject\nfrom manim.mobject.opengl.opengl_compatibility import ConvertToOpenGL\nfrom manim.mobject.text.tex_mobject import MathTex, Tex\n\nfrom ...animation.composition import AnimationGroup\nfrom ...animation.fading import FadeIn\nfrom ...animation.growing import GrowFromCenter\nfrom ...constants import *\nfrom ...mobject.types.vectorized_mobject import VMobject\nfrom ...utils.color import BLACK\nfrom ..svg.svg_mobject import VMobjectFromSVGPath\n\nif TYPE_CHECKING:\n    from manim.typing import Point3DLike, Vector3D\n    from manim.utils.color.core import ParsableManimColor\n\n__all__ = [\"Brace\", \"BraceBetweenPoints\", \"BraceLabel\", \"ArcBrace\"]\n\n\n\n[docs]\nclass Brace(VMobjectFromSVGPath):\n    \"\"\"Takes a mobject and draws a brace adjacent to it.\n\n    Passing a direction vector determines the direction from which the\n    brace is drawn. By default it is drawn from below.\n\n    Parameters\n    ----------\n    mobject\n        The mobject adjacent to which the brace is placed.\n    direction :\n        The direction from which the brace faces the mobject.\n\n    See Also\n    --------\n    :class:`BraceBetweenPoints`\n\n    Examples\n    --------\n    .. manim:: BraceExample\n        :save_last_frame:\n\n        class BraceExample(Scene):\n            def construct(self):\n                s = Square()\n                self.add(s)\n                for i in np.linspace(0.1,1.0,4):\n                    br = Brace(s, sharpness=i)\n                    t = Text(f\"sharpness= {i}\").next_to(br, RIGHT)\n                    self.add(t)\n                    self.add(br)\n                VGroup(*self.mobjects).arrange(DOWN, buff=0.2)\n\n    \"\"\"\n\n    def __init__(\n        self,\n        mobject: Mobject,\n        direction: Vector3D | None = DOWN,\n        buff: float = 0.2,\n        sharpness: float = 2,\n        stroke_width: float = 0,\n        fill_opacity: float = 1.0,\n        background_stroke_width: float = 0,\n        background_stroke_color: ParsableManimColor = BLACK,\n        **kwargs,\n    ):\n        path_string_template = (\n            \"m0.01216 0c-0.01152 0-0.01216 6.103e-4 -0.01216 0.01311v0.007762c0.06776 \"\n            \"0.122 0.1799 0.1455 0.2307 0.1455h{0}c0.03046 3.899e-4 0.07964 0.00449 \"\n            \"0.1246 0.02636 0.0537 0.02695 0.07418 0.05816 0.08648 0.07769 0.001562 \"\n            \"0.002538 0.004539 0.002563 0.01098 0.002563 0.006444-2e-8 0.009421-2.47e-\"\n            \"5 0.01098-0.002563 0.0123-0.01953 0.03278-0.05074 0.08648-0.07769 0.04491\"\n            \"-0.02187 0.09409-0.02597 0.1246-0.02636h{0}c0.05077 0 0.1629-0.02346 \"\n            \"0.2307-0.1455v-0.007762c-1.78e-6 -0.0125-6.365e-4 -0.01311-0.01216-0.0131\"\n            \"1-0.006444-3.919e-8 -0.009348 2.448e-5 -0.01091 0.002563-0.0123 0.01953-\"\n            \"0.03278 0.05074-0.08648 0.07769-0.04491 0.02187-0.09416 0.02597-0.1246 \"\n            \"0.02636h{1}c-0.04786 0-0.1502 0.02094-0.2185 0.1256-0.06833-0.1046-0.1706\"\n            \"-0.1256-0.2185-0.1256h{1}c-0.03046-3.899e-4 -0.07972-0.004491-0.1246-0.02\"\n            \"636-0.0537-0.02695-0.07418-0.05816-0.08648-0.07769-0.001562-0.002538-\"\n            \"0.004467-0.002563-0.01091-0.002563z\"\n        )\n        default_min_width = 0.90552\n\n        self.buff = buff\n\n        angle = -np.arctan2(*direction[:2]) + np.pi\n        mobject.rotate(-angle, about_point=ORIGIN)\n        left = mobject.get_corner(DOWN + LEFT)\n        right = mobject.get_corner(DOWN + RIGHT)\n        target_width = right[0] - left[0]\n        linear_section_length = max(\n            0,\n            (target_width * sharpness - default_min_width) / 2,\n        )\n\n        path = se.Path(\n            path_string_template.format(\n                linear_section_length,\n                -linear_section_length,\n            )\n        )\n\n        super().__init__(\n            path_obj=path,\n            stroke_width=stroke_width,\n            fill_opacity=fill_opacity,\n            background_stroke_width=background_stroke_width,\n            background_stroke_color=background_stroke_color,\n            **kwargs,\n        )\n        self.flip(RIGHT)\n        self.stretch_to_fit_width(target_width)\n        self.shift(left - self.get_corner(UP + LEFT) + self.buff * DOWN)\n\n        for mob in mobject, self:\n            mob.rotate(angle, about_point=ORIGIN)\n\n\n[docs]\n    def put_at_tip(self, mob: Mobject, use_next_to: bool = True, **kwargs):\n        \"\"\"Puts the given mobject at the brace tip.\n\n        Parameters\n        ----------\n        mob\n            The mobject to be placed at the tip.\n        use_next_to\n            If true, then :meth:`next_to` is used to place the mobject at the\n            tip.\n        kwargs\n            Any additional keyword arguments are passed to :meth:`next_to` which\n            is used to put the mobject next to the brace tip.\n        \"\"\"\n        if use_next_to:\n            mob.next_to(self.get_tip(), np.round(self.get_direction()), **kwargs)\n        else:\n            mob.move_to(self.get_tip())\n            buff = kwargs.get(\"buff\", DEFAULT_MOBJECT_TO_MOBJECT_BUFFER)\n            shift_distance = mob.width / 2.0 + buff\n            mob.shift(self.get_direction() * shift_distance)\n        return self\n\n\n\n[docs]\n    def get_text(self, *text, **kwargs):\n        \"\"\"Places the text at the brace tip.\n\n        Parameters\n        ----------\n        text\n            The text to be placed at the brace tip.\n        kwargs\n            Any additional keyword arguments are passed to :meth:`.put_at_tip` which\n            is used to position the text at the brace tip.\n\n        Returns\n        -------\n        :class:`~.Tex`\n        \"\"\"\n        text_mob = Tex(*text)\n        self.put_at_tip(text_mob, **kwargs)\n        return text_mob\n\n\n\n[docs]\n    def get_tex(self, *tex, **kwargs):\n        \"\"\"Places the tex at the brace tip.\n\n        Parameters\n        ----------\n        tex\n            The tex to be placed at the brace tip.\n        kwargs\n            Any further keyword arguments are passed to :meth:`.put_at_tip` which\n            is used to position the tex at the brace tip.\n\n        Returns\n        -------\n        :class:`~.MathTex`\n        \"\"\"\n        tex_mob = MathTex(*tex)\n        self.put_at_tip(tex_mob, **kwargs)\n        return tex_mob\n\n\n\n[docs]\n    def get_tip(self):\n        \"\"\"Returns the point at the brace tip.\"\"\"\n        # Returns the position of the seventh point in the path, which is the tip.\n        if config[\"renderer\"] == \"opengl\":\n            return self.points[34]\n\n        return self.points[28]  # = 7*4\n\n\n\n[docs]\n    def get_direction(self):\n        \"\"\"Returns the direction from the center to the brace tip.\"\"\"\n        vect = self.get_tip() - self.get_center()\n        return vect / np.linalg.norm(vect)\n\n\n\n\n\n[docs]\nclass BraceLabel(VMobject, metaclass=ConvertToOpenGL):\n    \"\"\"Create a brace with a label attached.\n\n    Parameters\n    ----------\n    obj\n        The mobject adjacent to which the brace is placed.\n    text\n        The label text.\n    brace_direction\n        The direction of the brace. By default ``DOWN``.\n    label_constructor\n        A class or function used to construct a mobject representing\n        the label. By default :class:`~.MathTex`.\n    font_size\n        The font size of the label, passed to the ``label_constructor``.\n    buff\n        The buffer between the mobject and the brace.\n    brace_config\n        Arguments to be passed to :class:`.Brace`.\n    kwargs\n        Additional arguments to be passed to :class:`~.VMobject`.\n    \"\"\"\n\n    def __init__(\n        self,\n        obj: Mobject,\n        text: str,\n        brace_direction: np.ndarray = DOWN,\n        label_constructor: type = MathTex,\n        font_size: float = DEFAULT_FONT_SIZE,\n        buff: float = 0.2,\n        brace_config: dict | None = None,\n        **kwargs,\n    ):\n        self.label_constructor = label_constructor\n        super().__init__(**kwargs)\n\n        self.brace_direction = brace_direction\n        if brace_config is None:\n            brace_config = {}\n        self.brace = Brace(obj, brace_direction, buff, **brace_config)\n\n        if isinstance(text, (tuple, list)):\n            self.label = self.label_constructor(*text, font_size=font_size, **kwargs)\n        else:\n            self.label = self.label_constructor(str(text), font_size=font_size)\n\n        self.brace.put_at_tip(self.label)\n        self.add(self.brace, self.label)\n\n    def creation_anim(self, label_anim=FadeIn, brace_anim=GrowFromCenter):\n        return AnimationGroup(brace_anim(self.brace), label_anim(self.label))\n\n    def shift_brace(self, obj, **kwargs):\n        if isinstance(obj, list):\n            obj = self.get_group_class()(*obj)\n        self.brace = Brace(obj, self.brace_direction, **kwargs)\n        self.brace.put_at_tip(self.label)\n        return self\n\n    def change_label(self, *text, **kwargs):\n        self.label = self.label_constructor(*text, **kwargs)\n\n        self.brace.put_at_tip(self.label)\n        return self\n\n    def change_brace_label(self, obj, *text, **kwargs):\n        self.shift_brace(obj)\n        self.change_label(*text, **kwargs)\n        return self\n\n\n\n\n[docs]\nclass BraceText(BraceLabel):\n    def __init__(self, obj, text, label_constructor=Tex, **kwargs):\n        super().__init__(obj, text, label_constructor=label_constructor, **kwargs)\n\n\n\n\n[docs]\nclass BraceBetweenPoints(Brace):\n    \"\"\"Similar to Brace, but instead of taking a mobject it uses 2\n    points to place the brace.\n\n    A fitting direction for the brace is\n    computed, but it still can be manually overridden.\n    If the points go from left to right, the brace is drawn from below.\n    Swapping the points places the brace on the opposite side.\n\n    Parameters\n    ----------\n    point_1 :\n        The first point.\n    point_2 :\n        The second point.\n    direction :\n        The direction from which the brace faces towards the points.\n\n    Examples\n    --------\n        .. manim:: BraceBPExample\n\n            class BraceBPExample(Scene):\n                def construct(self):\n                    p1 = [0,0,0]\n                    p2 = [1,2,0]\n                    brace = BraceBetweenPoints(p1,p2)\n                    self.play(Create(NumberPlane()))\n                    self.play(Create(brace))\n                    self.wait(2)\n    \"\"\"\n\n    def __init__(\n        self,\n        point_1: Point3DLike | None,\n        point_2: Point3DLike | None,\n        direction: Vector3D | None = ORIGIN,\n        **kwargs,\n    ):\n        if all(direction == ORIGIN):\n            line_vector = np.array(point_2) - np.array(point_1)\n            direction = np.array([line_vector[1], -line_vector[0], 0])\n        super().__init__(Line(point_1, point_2), direction=direction, **kwargs)\n\n\n\n\n[docs]\nclass ArcBrace(Brace):\n    \"\"\"Creates a :class:`~Brace` that wraps around an :class:`~.Arc`.\n\n    The direction parameter allows the brace to be applied\n    from outside or inside the arc.\n\n    .. warning::\n        The :class:`ArcBrace` is smaller for arcs with smaller radii.\n\n    .. note::\n        The :class:`ArcBrace` is initially a vertical :class:`Brace` defined by the\n        length of the :class:`~.Arc`, but is scaled down to match the start and end\n        angles. An exponential function is then applied after it is shifted based on\n        the radius of the arc.\n\n        The scaling effect is not applied for arcs with radii smaller than 1 to prevent\n        over-scaling.\n\n    Parameters\n    ----------\n    arc\n        The :class:`~.Arc` that wraps around the :class:`Brace` mobject.\n    direction\n        The direction from which the brace faces the arc.\n        ``LEFT`` for inside the arc, and ``RIGHT`` for the outside.\n\n    Example\n    -------\n        .. manim:: ArcBraceExample\n            :save_last_frame:\n            :ref_classes: Arc\n\n            class ArcBraceExample(Scene):\n                def construct(self):\n                    arc_1 = Arc(radius=1.5,start_angle=0,angle=2*PI/3).set_color(RED)\n                    brace_1 = ArcBrace(arc_1,LEFT)\n                    group_1 = VGroup(arc_1,brace_1)\n\n                    arc_2 = Arc(radius=3,start_angle=0,angle=5*PI/6).set_color(YELLOW)\n                    brace_2 = ArcBrace(arc_2)\n                    group_2 = VGroup(arc_2,brace_2)\n\n                    arc_3 = Arc(radius=0.5,start_angle=-0,angle=PI).set_color(BLUE)\n                    brace_3 = ArcBrace(arc_3)\n                    group_3 = VGroup(arc_3,brace_3)\n\n                    arc_4 = Arc(radius=0.2,start_angle=0,angle=3*PI/2).set_color(GREEN)\n                    brace_4 = ArcBrace(arc_4)\n                    group_4 = VGroup(arc_4,brace_4)\n\n                    arc_group = VGroup(group_1, group_2, group_3, group_4).arrange_in_grid(buff=1.5)\n                    self.add(arc_group.center())\n\n    \"\"\"\n\n    def __init__(\n        self,\n        arc: Arc | None = None,\n        direction: Sequence[float] = RIGHT,\n        **kwargs,\n    ):\n        if arc is None:\n            arc = Arc(start_angle=-1, angle=2, radius=1)\n        arc_end_angle = arc.start_angle + arc.angle\n        line = Line(UP * arc.start_angle, UP * arc_end_angle)\n        scale_shift = RIGHT * np.log(arc.radius)\n\n        if arc.radius >= 1:\n            line.scale(arc.radius, about_point=ORIGIN)\n            super().__init__(line, direction=direction, **kwargs)\n            self.scale(1 / (arc.radius), about_point=ORIGIN)\n        else:\n            super().__init__(line, direction=direction, **kwargs)\n\n        if arc.radius >= 0.3:\n            self.shift(scale_shift)\n        else:\n            self.shift(RIGHT * np.log(0.3))\n\n        self.apply_complex_function(np.exp)\n        self.shift(arc.get_arc_center())", "code_sha1": "690f55861547fd21b140690f3768032a4222554a"}
{"url": "https://docs.manim.community/en/stable/_modules/manim/mobject/svg/svg_mobject.html", "depth": 2, "instruction": "The code defines an `SVGMobject` class that imports and visualizes SVG files as vectorized mobjects in Manim, allowing customization of properties like color, opacity, and size. It includes methods for parsing SVG elements, applying styles, and transforming shapes, resulting in a scalable, animated representation of SVG graphics in a 3D space.", "code": "\"\"\"Mobjects generated from an SVG file.\"\"\"\n\nfrom __future__ import annotations\n\nimport os\nfrom pathlib import Path\nfrom xml.etree import ElementTree as ET\n\nimport numpy as np\nimport svgelements as se\n\nfrom manim import config, logger\n\nfrom ...constants import RIGHT\nfrom ...utils.bezier import get_quadratic_approximation_of_cubic\nfrom ...utils.images import get_full_vector_image_path\nfrom ...utils.iterables import hash_obj\nfrom ..geometry.arc import Circle\nfrom ..geometry.line import Line\nfrom ..geometry.polygram import Polygon, Rectangle, RoundedRectangle\nfrom ..opengl.opengl_compatibility import ConvertToOpenGL\nfrom ..types.vectorized_mobject import VMobject\n\n__all__ = [\"SVGMobject\", \"VMobjectFromSVGPath\"]\n\n\nSVG_HASH_TO_MOB_MAP: dict[int, VMobject] = {}\n\n\ndef _convert_point_to_3d(x: float, y: float) -> np.ndarray:\n    return np.array([x, y, 0.0])\n\n\n\n[docs]\nclass SVGMobject(VMobject, metaclass=ConvertToOpenGL):\n    \"\"\"A vectorized mobject created from importing an SVG file.\n\n    Parameters\n    ----------\n    file_name\n        The path to the SVG file.\n    should_center\n        Whether or not the mobject should be centered after\n        being imported.\n    height\n        The target height of the mobject, set to 2 Manim units by default.\n        If the height and width are both set to ``None``, the mobject\n        is imported without being scaled.\n    width\n        The target width of the mobject, set to ``None`` by default. If\n        the height and the width are both set to ``None``, the mobject\n        is imported without being scaled.\n    color\n        The color (both fill and stroke color) of the mobject. If\n        ``None`` (the default), the colors set in the SVG file\n        are used.\n    opacity\n        The opacity (both fill and stroke opacity) of the mobject.\n        If ``None`` (the default), the opacity set in the SVG file\n        is used.\n    fill_color\n        The fill color of the mobject. If ``None`` (the default),\n        the fill colors set in the SVG file are used.\n    fill_opacity\n        The fill opacity of the mobject. If ``None`` (the default),\n        the fill opacities set in the SVG file are used.\n    stroke_color\n        The stroke color of the mobject. If ``None`` (the default),\n        the stroke colors set in the SVG file are used.\n    stroke_opacity\n        The stroke opacity of the mobject. If ``None`` (the default),\n        the stroke opacities set in the SVG file are used.\n    stroke_width\n        The stroke width of the mobject. If ``None`` (the default),\n        the stroke width values set in the SVG file are used.\n    svg_default\n        A dictionary in which fallback values for unspecified\n        properties of elements in the SVG file are defined. If\n        ``None`` (the default), ``color``, ``opacity``, ``fill_color``\n        ``fill_opacity``, ``stroke_color``, and ``stroke_opacity``\n        are set to ``None``, and ``stroke_width`` is set to 0.\n    path_string_config\n        A dictionary with keyword arguments passed to\n        :class:`.VMobjectFromSVGPath` used for importing path elements.\n        If ``None`` (the default), no additional arguments are passed.\n    use_svg_cache\n        If True (default), the svg inputs (e.g. file_name, settings)\n        will be used as a key and a copy of the created mobject will\n        be saved using that key to be quickly retrieved if the same\n        inputs need be processed later. For large SVGs which are used\n        only once, this can be omitted to improve performance.\n    kwargs\n        Further arguments passed to the parent class.\n    \"\"\"\n\n    def __init__(\n        self,\n        file_name: str | os.PathLike | None = None,\n        should_center: bool = True,\n        height: float | None = 2,\n        width: float | None = None,\n        color: str | None = None,\n        opacity: float | None = None,\n        fill_color: str | None = None,\n        fill_opacity: float | None = None,\n        stroke_color: str | None = None,\n        stroke_opacity: float | None = None,\n        stroke_width: float | None = None,\n        svg_default: dict | None = None,\n        path_string_config: dict | None = None,\n        use_svg_cache: bool = True,\n        **kwargs,\n    ):\n        super().__init__(color=None, stroke_color=None, fill_color=None, **kwargs)\n\n        # process keyword arguments\n        self.file_name = Path(file_name) if file_name is not None else None\n\n        self.should_center = should_center\n        self.svg_height = height\n        self.svg_width = width\n        self.color = color\n        self.opacity = opacity\n        self.fill_color = fill_color\n        self.fill_opacity = fill_opacity\n        self.stroke_color = stroke_color\n        self.stroke_opacity = stroke_opacity\n        self.stroke_width = stroke_width\n\n        if svg_default is None:\n            svg_default = {\n                \"color\": None,\n                \"opacity\": None,\n                \"fill_color\": None,\n                \"fill_opacity\": None,\n                \"stroke_width\": 0,\n                \"stroke_color\": None,\n                \"stroke_opacity\": None,\n            }\n        self.svg_default = svg_default\n\n        if path_string_config is None:\n            path_string_config = {}\n        self.path_string_config = path_string_config\n\n        self.init_svg_mobject(use_svg_cache=use_svg_cache)\n\n        self.set_style(\n            fill_color=fill_color,\n            fill_opacity=fill_opacity,\n            stroke_color=stroke_color,\n            stroke_opacity=stroke_opacity,\n            stroke_width=stroke_width,\n        )\n        self.move_into_position()\n\n\n[docs]\n    def init_svg_mobject(self, use_svg_cache: bool) -> None:\n        \"\"\"Checks whether the SVG has already been imported and\n        generates it if not.\n\n        See also\n        --------\n        :meth:`.SVGMobject.generate_mobject`\n        \"\"\"\n        if use_svg_cache:\n            hash_val = hash_obj(self.hash_seed)\n            if hash_val in SVG_HASH_TO_MOB_MAP:\n                mob = SVG_HASH_TO_MOB_MAP[hash_val].copy()\n                self.add(*mob)\n                return\n\n        self.generate_mobject()\n        if use_svg_cache:\n            SVG_HASH_TO_MOB_MAP[hash_val] = self.copy()\n\n\n    @property\n    def hash_seed(self) -> tuple:\n        \"\"\"A unique hash representing the result of the generated\n        mobject points.\n\n        Used as keys in the ``SVG_HASH_TO_MOB_MAP`` caching dictionary.\n        \"\"\"\n        return (\n            self.__class__.__name__,\n            self.svg_default,\n            self.path_string_config,\n            self.file_name,\n            config.renderer,\n        )\n\n\n[docs]\n    def generate_mobject(self) -> None:\n        \"\"\"Parse the SVG and translate its elements to submobjects.\"\"\"\n        file_path = self.get_file_path()\n        element_tree = ET.parse(file_path)\n        new_tree = self.modify_xml_tree(element_tree)\n        # Create a temporary svg file to dump modified svg to be parsed\n        modified_file_path = file_path.with_name(f\"{file_path.stem}_{file_path.suffix}\")\n        new_tree.write(modified_file_path)\n\n        svg = se.SVG.parse(modified_file_path)\n        modified_file_path.unlink()\n\n        mobjects = self.get_mobjects_from(svg)\n        self.add(*mobjects)\n        self.flip(RIGHT)  # Flip y\n\n\n\n[docs]\n    def get_file_path(self) -> Path:\n        \"\"\"Search for an existing file based on the specified file name.\"\"\"\n        if self.file_name is None:\n            raise ValueError(\"Must specify file for SVGMobject\")\n        return get_full_vector_image_path(self.file_name)\n\n\n\n[docs]\n    def modify_xml_tree(self, element_tree: ET.ElementTree) -> ET.ElementTree:\n        \"\"\"Modifies the SVG element tree to include default\n        style information.\n\n        Parameters\n        ----------\n        element_tree\n            The parsed element tree from the SVG file.\n        \"\"\"\n        config_style_dict = self.generate_config_style_dict()\n        style_keys = (\n            \"fill\",\n            \"fill-opacity\",\n            \"stroke\",\n            \"stroke-opacity\",\n            \"stroke-width\",\n            \"style\",\n        )\n        root = element_tree.getroot()\n        root_style_dict = {k: v for k, v in root.attrib.items() if k in style_keys}\n\n        new_root = ET.Element(\"svg\", {})\n        config_style_node = ET.SubElement(new_root, \"g\", config_style_dict)\n        root_style_node = ET.SubElement(config_style_node, \"g\", root_style_dict)\n        root_style_node.extend(root)\n        return ET.ElementTree(new_root)\n\n\n\n[docs]\n    def generate_config_style_dict(self) -> dict[str, str]:\n        \"\"\"Generate a dictionary holding the default style information.\"\"\"\n        keys_converting_dict = {\n            \"fill\": (\"color\", \"fill_color\"),\n            \"fill-opacity\": (\"opacity\", \"fill_opacity\"),\n            \"stroke\": (\"color\", \"stroke_color\"),\n            \"stroke-opacity\": (\"opacity\", \"stroke_opacity\"),\n            \"stroke-width\": (\"stroke_width\",),\n        }\n        svg_default_dict = self.svg_default\n        result = {}\n        for svg_key, style_keys in keys_converting_dict.items():\n            for style_key in style_keys:\n                if svg_default_dict[style_key] is None:\n                    continue\n                result[svg_key] = str(svg_default_dict[style_key])\n        return result\n\n\n\n[docs]\n    def get_mobjects_from(self, svg: se.SVG) -> list[VMobject]:\n        \"\"\"Convert the elements of the SVG to a list of mobjects.\n\n        Parameters\n        ----------\n        svg\n            The parsed SVG file.\n        \"\"\"\n        result = []\n        for shape in svg.elements():\n            # can we combine the two continue cases into one?\n            if isinstance(shape, se.Group):  # noqa: SIM114\n                continue\n            elif isinstance(shape, se.Path):\n                mob = self.path_to_mobject(shape)\n            elif isinstance(shape, se.SimpleLine):\n                mob = self.line_to_mobject(shape)\n            elif isinstance(shape, se.Rect):\n                mob = self.rect_to_mobject(shape)\n            elif isinstance(shape, (se.Circle, se.Ellipse)):\n                mob = self.ellipse_to_mobject(shape)\n            elif isinstance(shape, se.Polygon):\n                mob = self.polygon_to_mobject(shape)\n            elif isinstance(shape, se.Polyline):\n                mob = self.polyline_to_mobject(shape)\n            elif isinstance(shape, se.Text):\n                mob = self.text_to_mobject(shape)\n            elif isinstance(shape, se.Use) or type(shape) is se.SVGElement:\n                continue\n            else:\n                logger.warning(f\"Unsupported element type: {type(shape)}\")\n                continue\n            if mob is None or not mob.has_points():\n                continue\n            self.apply_style_to_mobject(mob, shape)\n            if isinstance(shape, se.Transformable) and shape.apply:\n                self.handle_transform(mob, shape.transform)\n            result.append(mob)\n        return result\n\n\n\n[docs]\n    @staticmethod\n    def handle_transform(mob: VMobject, matrix: se.Matrix) -> VMobject:\n        \"\"\"Apply SVG transformations to the converted mobject.\n\n        Parameters\n        ----------\n        mob\n            The converted mobject.\n        matrix\n            The transformation matrix determined from the SVG\n            transformation.\n        \"\"\"\n        mat = np.array([[matrix.a, matrix.c], [matrix.b, matrix.d]])\n        vec = np.array([matrix.e, matrix.f, 0.0])\n        mob.apply_matrix(mat)\n        mob.shift(vec)\n        return mob\n\n\n\n[docs]\n    @staticmethod\n    def apply_style_to_mobject(mob: VMobject, shape: se.GraphicObject) -> VMobject:\n        \"\"\"Apply SVG style information to the converted mobject.\n\n        Parameters\n        ----------\n        mob\n            The converted mobject.\n        shape\n            The parsed SVG element.\n        \"\"\"\n        mob.set_style(\n            stroke_width=shape.stroke_width,\n            stroke_color=shape.stroke.hexrgb,\n            stroke_opacity=shape.stroke.opacity,\n            fill_color=shape.fill.hexrgb,\n            fill_opacity=shape.fill.opacity,\n        )\n        return mob\n\n\n\n[docs]\n    def path_to_mobject(self, path: se.Path) -> VMobjectFromSVGPath:\n        \"\"\"Convert a path element to a vectorized mobject.\n\n        Parameters\n        ----------\n        path\n            The parsed SVG path.\n        \"\"\"\n        return VMobjectFromSVGPath(path, **self.path_string_config)\n\n\n\n[docs]\n    @staticmethod\n    def line_to_mobject(line: se.Line) -> Line:\n        \"\"\"Convert a line element to a vectorized mobject.\n\n        Parameters\n        ----------\n        line\n            The parsed SVG line.\n        \"\"\"\n        return Line(\n            start=_convert_point_to_3d(line.x1, line.y1),\n            end=_convert_point_to_3d(line.x2, line.y2),\n        )\n\n\n\n[docs]\n    @staticmethod\n    def rect_to_mobject(rect: se.Rect) -> Rectangle:\n        \"\"\"Convert a rectangle element to a vectorized mobject.\n\n        Parameters\n        ----------\n        rect\n            The parsed SVG rectangle.\n        \"\"\"\n        if rect.rx == 0 or rect.ry == 0:\n            mob = Rectangle(\n                width=rect.width,\n                height=rect.height,\n            )\n        else:\n            mob = RoundedRectangle(\n                width=rect.width,\n                height=rect.height * rect.rx / rect.ry,\n                corner_radius=rect.rx,\n            )\n            mob.stretch_to_fit_height(rect.height)\n        mob.shift(\n            _convert_point_to_3d(rect.x + rect.width / 2, rect.y + rect.height / 2)\n        )\n        return mob\n\n\n\n[docs]\n    @staticmethod\n    def ellipse_to_mobject(ellipse: se.Ellipse | se.Circle) -> Circle:\n        \"\"\"Convert an ellipse or circle element to a vectorized mobject.\n\n        Parameters\n        ----------\n        ellipse\n            The parsed SVG ellipse or circle.\n        \"\"\"\n        mob = Circle(radius=ellipse.rx)\n        if ellipse.rx != ellipse.ry:\n            mob.stretch_to_fit_height(2 * ellipse.ry)\n        mob.shift(_convert_point_to_3d(ellipse.cx, ellipse.cy))\n        return mob\n\n\n\n[docs]\n    @staticmethod\n    def polygon_to_mobject(polygon: se.Polygon) -> Polygon:\n        \"\"\"Convert a polygon element to a vectorized mobject.\n\n        Parameters\n        ----------\n        polygon\n            The parsed SVG polygon.\n        \"\"\"\n        points = [_convert_point_to_3d(*point) for point in polygon]\n        return Polygon(*points)\n\n\n\n[docs]\n    def polyline_to_mobject(self, polyline: se.Polyline) -> VMobject:\n        \"\"\"Convert a polyline element to a vectorized mobject.\n\n        Parameters\n        ----------\n        polyline\n            The parsed SVG polyline.\n        \"\"\"\n        points = [_convert_point_to_3d(*point) for point in polyline]\n        vmobject_class = self.get_mobject_type_class()\n        return vmobject_class().set_points_as_corners(points)\n\n\n\n[docs]\n    @staticmethod\n    def text_to_mobject(text: se.Text):\n        \"\"\"Convert a text element to a vectorized mobject.\n\n        .. warning::\n\n            Not yet implemented.\n\n        Parameters\n        ----------\n        text\n            The parsed SVG text.\n        \"\"\"\n        logger.warning(f\"Unsupported element type: {type(text)}\")\n        return\n\n\n\n[docs]\n    def move_into_position(self) -> None:\n        \"\"\"Scale and move the generated mobject into position.\"\"\"\n        if self.should_center:\n            self.center()\n        if self.svg_height is not None:\n            self.set(height=self.svg_height)\n        if self.svg_width is not None:\n            self.set(width=self.svg_width)\n\n\n\n\n\n[docs]\nclass VMobjectFromSVGPath(VMobject, metaclass=ConvertToOpenGL):\n    \"\"\"A vectorized mobject representing an SVG path.\n\n    .. note::\n\n        The ``long_lines``, ``should_subdivide_sharp_curves``,\n        and ``should_remove_null_curves`` keyword arguments are\n        only respected with the OpenGL renderer.\n\n    Parameters\n    ----------\n    path_obj\n        A parsed SVG path object.\n    long_lines\n        Whether or not straight lines in the vectorized mobject\n        are drawn in one or two segments.\n    should_subdivide_sharp_curves\n        Whether or not to subdivide subcurves further in case\n        two segments meet at an angle that is sharper than a\n        given threshold.\n    should_remove_null_curves\n        Whether or not to remove subcurves of length 0.\n    kwargs\n        Further keyword arguments are passed to the parent\n        class.\n    \"\"\"\n\n    def __init__(\n        self,\n        path_obj: se.Path,\n        long_lines: bool = False,\n        should_subdivide_sharp_curves: bool = False,\n        should_remove_null_curves: bool = False,\n        **kwargs,\n    ):\n        # Get rid of arcs\n        path_obj.approximate_arcs_with_quads()\n        self.path_obj = path_obj\n\n        self.long_lines = long_lines\n        self.should_subdivide_sharp_curves = should_subdivide_sharp_curves\n        self.should_remove_null_curves = should_remove_null_curves\n\n        super().__init__(**kwargs)\n\n    def init_points(self) -> None:\n        # TODO: cache mobject in a re-importable way\n\n        self.handle_commands()\n\n        if config.renderer == \"opengl\":\n            if self.should_subdivide_sharp_curves:\n                # For a healthy triangulation later\n                self.subdivide_sharp_curves()\n            if self.should_remove_null_curves:\n                # Get rid of any null curves\n                self.set_points(self.get_points_without_null_curves())\n\n    generate_points = init_points\n\n    def handle_commands(self) -> None:\n        all_points: list[np.ndarray] = []\n        last_move = None\n        curve_start = None\n        last_true_move = None\n\n        def move_pen(pt, *, true_move: bool = False):\n            nonlocal last_move, curve_start, last_true_move\n            last_move = pt\n            if curve_start is None:\n                curve_start = last_move\n            if true_move:\n                last_true_move = last_move\n\n        if self.n_points_per_curve == 4:\n\n            def add_cubic(start, cp1, cp2, end):\n                nonlocal all_points\n                assert len(all_points) % 4 == 0, len(all_points)\n                all_points += [start, cp1, cp2, end]\n                move_pen(end)\n\n            def add_quad(start, cp, end):\n                add_cubic(start, (start + cp + cp) / 3, (cp + cp + end) / 3, end)\n                move_pen(end)\n\n            def add_line(start, end):\n                add_cubic(\n                    start, (start + start + end) / 3, (start + end + end) / 3, end\n                )\n                move_pen(end)\n\n        else:\n\n            def add_cubic(start, cp1, cp2, end):\n                nonlocal all_points\n                assert len(all_points) % 3 == 0, len(all_points)\n                two_quads = get_quadratic_approximation_of_cubic(\n                    start,\n                    cp1,\n                    cp2,\n                    end,\n                )\n                all_points += two_quads[:3].tolist()\n                all_points += two_quads[3:].tolist()\n                move_pen(end)\n\n            def add_quad(start, cp, end):\n                nonlocal all_points\n                assert len(all_points) % 3 == 0, len(all_points)\n                all_points += [start, cp, end]\n                move_pen(end)\n\n            def add_line(start, end):\n                add_quad(start, (start + end) / 2, end)\n                move_pen(end)\n\n        for segment in self.path_obj:\n            segment_class = segment.__class__\n            if segment_class == se.Move:\n                move_pen(_convert_point_to_3d(*segment.end), true_move=True)\n            elif segment_class == se.Line:\n                add_line(last_move, _convert_point_to_3d(*segment.end))\n            elif segment_class == se.QuadraticBezier:\n                add_quad(\n                    last_move,\n                    _convert_point_to_3d(*segment.control),\n                    _convert_point_to_3d(*segment.end),\n                )\n            elif segment_class == se.CubicBezier:\n                add_cubic(\n                    last_move,\n                    _convert_point_to_3d(*segment.control1),\n                    _convert_point_to_3d(*segment.control2),\n                    _convert_point_to_3d(*segment.end),\n                )\n            elif segment_class == se.Close:\n                # If the SVG path naturally ends at the beginning of the curve,\n                # we do *not* need to draw a closing line. To account for floating\n                # point precision, we use a small value to compare the two points.\n                if abs(np.linalg.norm(last_move - last_true_move)) > 0.0001:\n                    add_line(last_move, last_true_move)\n                curve_start = None\n            else:\n                raise AssertionError(f\"Not implemented: {segment_class}\")\n\n        self.points = np.array(all_points, ndmin=2, dtype=\"float64\")\n        # If we have no points, make sure the array is shaped properly\n        # (0 rows tall by 3 columns wide) so future operations can\n        # add or remove points correctly.\n        if len(all_points) == 0:\n            self.points = np.reshape(self.points, (0, 3))", "code_sha1": "392e3c0e3bcd95c2b7e3f71abc02a47c6b886fb6"}
{"url": "https://docs.manim.community/en/stable/_modules/manim/mobject/table.html", "depth": 2, "instruction": "The code creates a scene with four tables arranged in two groups. The first group contains a standard table and a decimal table, while the second group features a math table, a mobject table with colored circles and crosses, and an integer table. The tables are scaled down and positioned at the top and bottom of the scene, respectively.", "code": "r\"\"\"Mobjects representing tables.\n\nExamples\n--------\n\n.. manim:: TableExamples\n    :save_last_frame:\n\n    class TableExamples(Scene):\n        def construct(self):\n            t0 = Table(\n                [[\"First\", \"Second\"],\n                [\"Third\",\"Fourth\"]],\n                row_labels=[Text(\"R1\"), Text(\"R2\")],\n                col_labels=[Text(\"C1\"), Text(\"C2\")],\n                top_left_entry=Text(\"TOP\"))\n            t0.add_highlighted_cell((2,2), color=GREEN)\n            x_vals = np.linspace(-2,2,5)\n            y_vals = np.exp(x_vals)\n            t1 = DecimalTable(\n                [x_vals, y_vals],\n                row_labels=[MathTex(\"x\"), MathTex(\"f(x)\")],\n                include_outer_lines=True)\n            t1.add(t1.get_cell((2,2), color=RED))\n            t2 = MathTable(\n                [[\"+\", 0, 5, 10],\n                [0, 0, 5, 10],\n                [2, 2, 7, 12],\n                [4, 4, 9, 14]],\n                include_outer_lines=True)\n            t2.get_horizontal_lines()[:3].set_color(BLUE)\n            t2.get_vertical_lines()[:3].set_color(BLUE)\n            t2.get_horizontal_lines()[:3].set_z_index(1)\n            cross = VGroup(\n                Line(UP + LEFT, DOWN + RIGHT),\n                Line(UP + RIGHT, DOWN + LEFT))\n            a = Circle().set_color(RED).scale(0.5)\n            b = cross.set_color(BLUE).scale(0.5)\n            t3 = MobjectTable(\n                [[a.copy(),b.copy(),a.copy()],\n                [b.copy(),a.copy(),a.copy()],\n                [a.copy(),b.copy(),b.copy()]])\n            t3.add(Line(\n                t3.get_corner(DL), t3.get_corner(UR)\n            ).set_color(RED))\n            vals = np.arange(1,21).reshape(5,4)\n            t4 = IntegerTable(\n                vals,\n                include_outer_lines=True\n            )\n            g1 = Group(t0, t1).scale(0.5).arrange(buff=1).to_edge(UP, buff=1)\n            g2 = Group(t2, t3, t4).scale(0.5).arrange(buff=1).to_edge(DOWN, buff=1)\n            self.add(g1, g2)\n\"\"\"\n\nfrom __future__ import annotations\n\n__all__ = [\n    \"Table\",\n    \"MathTable\",\n    \"MobjectTable\",\n    \"IntegerTable\",\n    \"DecimalTable\",\n]\n\n\nimport itertools as it\nfrom collections.abc import Iterable, Sequence\nfrom typing import Callable\n\nfrom manim.mobject.geometry.line import Line\nfrom manim.mobject.geometry.polygram import Polygon\nfrom manim.mobject.geometry.shape_matchers import BackgroundRectangle\nfrom manim.mobject.text.numbers import DecimalNumber, Integer\nfrom manim.mobject.text.tex_mobject import MathTex\nfrom manim.mobject.text.text_mobject import Paragraph\n\nfrom ..animation.animation import Animation\nfrom ..animation.composition import AnimationGroup\nfrom ..animation.creation import Create, Write\nfrom ..animation.fading import FadeIn\nfrom ..mobject.types.vectorized_mobject import VGroup, VMobject\nfrom ..utils.color import BLACK, YELLOW, ManimColor, ParsableManimColor\nfrom .utils import get_vectorized_mobject_class\n\n\n\n[docs]\nclass Table(VGroup):\n    r\"\"\"A mobject that displays a table on the screen.\n\n    Parameters\n    ----------\n    table\n        A 2D array or list of lists. Content of the table has to be a valid input\n        for the callable set in ``element_to_mobject``.\n    row_labels\n        List of :class:`~.VMobject` representing the labels of each row.\n    col_labels\n        List of :class:`~.VMobject` representing the labels of each column.\n    top_left_entry\n        The top-left entry of the table, can only be specified if row and\n        column labels are given.\n    v_buff\n        Vertical buffer passed to :meth:`~.Mobject.arrange_in_grid`, by default 0.8.\n    h_buff\n        Horizontal buffer passed to :meth:`~.Mobject.arrange_in_grid`, by default 1.3.\n    include_outer_lines\n        ``True`` if the table should include outer lines, by default False.\n    add_background_rectangles_to_entries\n        ``True`` if background rectangles should be added to entries, by default ``False``.\n    entries_background_color\n        Background color of entries if ``add_background_rectangles_to_entries`` is ``True``.\n    include_background_rectangle\n        ``True`` if the table should have a background rectangle, by default ``False``.\n    background_rectangle_color\n        Background color of table if ``include_background_rectangle`` is ``True``.\n    element_to_mobject\n        The :class:`~.Mobject` class applied to the table entries. by default :class:`~.Paragraph`. For common choices, see :mod:`~.text_mobject`/:mod:`~.tex_mobject`.\n    element_to_mobject_config\n        Custom configuration passed to :attr:`element_to_mobject`, by default {}.\n    arrange_in_grid_config\n        Dict passed to :meth:`~.Mobject.arrange_in_grid`, customizes the arrangement of the table.\n    line_config\n        Dict passed to :class:`~.Line`, customizes the lines of the table.\n    kwargs\n        Additional arguments to be passed to :class:`~.VGroup`.\n\n    Examples\n    --------\n\n    .. manim:: TableExamples\n        :save_last_frame:\n\n        class TableExamples(Scene):\n            def construct(self):\n                t0 = Table(\n                    [[\"This\", \"is a\"],\n                    [\"simple\", \"Table in \\\\n Manim.\"]])\n                t1 = Table(\n                    [[\"This\", \"is a\"],\n                    [\"simple\", \"Table.\"]],\n                    row_labels=[Text(\"R1\"), Text(\"R2\")],\n                    col_labels=[Text(\"C1\"), Text(\"C2\")])\n                t1.add_highlighted_cell((2,2), color=YELLOW)\n                t2 = Table(\n                    [[\"This\", \"is a\"],\n                    [\"simple\", \"Table.\"]],\n                    row_labels=[Text(\"R1\"), Text(\"R2\")],\n                    col_labels=[Text(\"C1\"), Text(\"C2\")],\n                    top_left_entry=Star().scale(0.3),\n                    include_outer_lines=True,\n                    arrange_in_grid_config={\"cell_alignment\": RIGHT})\n                t2.add(t2.get_cell((2,2), color=RED))\n                t3 = Table(\n                    [[\"This\", \"is a\"],\n                    [\"simple\", \"Table.\"]],\n                    row_labels=[Text(\"R1\"), Text(\"R2\")],\n                    col_labels=[Text(\"C1\"), Text(\"C2\")],\n                    top_left_entry=Star().scale(0.3),\n                    include_outer_lines=True,\n                    line_config={\"stroke_width\": 1, \"color\": YELLOW})\n                t3.remove(*t3.get_vertical_lines())\n                g = Group(\n                    t0,t1,t2,t3\n                ).scale(0.7).arrange_in_grid(buff=1)\n                self.add(g)\n\n    .. manim:: BackgroundRectanglesExample\n        :save_last_frame:\n\n        class BackgroundRectanglesExample(Scene):\n            def construct(self):\n                background = Rectangle(height=6.5, width=13)\n                background.set_fill(opacity=.5)\n                background.set_color([TEAL, RED, YELLOW])\n                self.add(background)\n                t0 = Table(\n                    [[\"This\", \"is a\"],\n                    [\"simple\", \"Table.\"]],\n                    add_background_rectangles_to_entries=True)\n                t1 = Table(\n                    [[\"This\", \"is a\"],\n                    [\"simple\", \"Table.\"]],\n                    include_background_rectangle=True)\n                g = Group(t0, t1).scale(0.7).arrange(buff=0.5)\n                self.add(g)\n    \"\"\"\n\n    def __init__(\n        self,\n        table: Iterable[Iterable[float | str | VMobject]],\n        row_labels: Iterable[VMobject] | None = None,\n        col_labels: Iterable[VMobject] | None = None,\n        top_left_entry: VMobject | None = None,\n        v_buff: float = 0.8,\n        h_buff: float = 1.3,\n        include_outer_lines: bool = False,\n        add_background_rectangles_to_entries: bool = False,\n        entries_background_color: ParsableManimColor = BLACK,\n        include_background_rectangle: bool = False,\n        background_rectangle_color: ParsableManimColor = BLACK,\n        element_to_mobject: Callable[\n            [float | str | VMobject],\n            VMobject,\n        ] = Paragraph,\n        element_to_mobject_config: dict = {},\n        arrange_in_grid_config: dict = {},\n        line_config: dict = {},\n        **kwargs,\n    ):\n        self.row_labels = row_labels\n        self.col_labels = col_labels\n        self.top_left_entry = top_left_entry\n        self.row_dim = len(table)\n        self.col_dim = len(table[0])\n        self.v_buff = v_buff\n        self.h_buff = h_buff\n        self.include_outer_lines = include_outer_lines\n        self.add_background_rectangles_to_entries = add_background_rectangles_to_entries\n        self.entries_background_color = ManimColor(entries_background_color)\n        self.include_background_rectangle = include_background_rectangle\n        self.background_rectangle_color = ManimColor(background_rectangle_color)\n        self.element_to_mobject = element_to_mobject\n        self.element_to_mobject_config = element_to_mobject_config\n        self.arrange_in_grid_config = arrange_in_grid_config\n        self.line_config = line_config\n\n        for row in table:\n            if len(row) == len(table[0]):\n                pass\n            else:\n                raise ValueError(\"Not all rows in table have the same length.\")\n\n        super().__init__(**kwargs)\n        mob_table = self._table_to_mob_table(table)\n        self.elements_without_labels = VGroup(*it.chain(*mob_table))\n        mob_table = self._add_labels(mob_table)\n        self._organize_mob_table(mob_table)\n        self.elements = VGroup(*it.chain(*mob_table))\n\n        if len(self.elements[0].get_all_points()) == 0:\n            self.elements.remove(self.elements[0])\n\n        self.add(self.elements)\n        self.center()\n        self.mob_table = mob_table\n        self._add_horizontal_lines()\n        self._add_vertical_lines()\n        if self.add_background_rectangles_to_entries:\n            self.add_background_to_entries(color=self.entries_background_color)\n        if self.include_background_rectangle:\n            self.add_background_rectangle(color=self.background_rectangle_color)\n\n\n[docs]\n    def _table_to_mob_table(\n        self,\n        table: Iterable[Iterable[float | str | VMobject]],\n    ) -> list:\n        \"\"\"Initilaizes the entries of ``table`` as :class:`~.VMobject`.\n\n        Parameters\n        ----------\n        table\n            A 2D array or list of lists. Content of the table has to be a valid input\n            for the callable set in ``element_to_mobject``.\n\n        Returns\n        --------\n        List\n            List of :class:`~.VMobject` from the entries of ``table``.\n        \"\"\"\n        return [\n            [\n                self.element_to_mobject(item, **self.element_to_mobject_config)\n                for item in row\n            ]\n            for row in table\n        ]\n\n\n\n[docs]\n    def _organize_mob_table(self, table: Iterable[Iterable[VMobject]]) -> VGroup:\n        \"\"\"Arranges the :class:`~.VMobject` of ``table`` in a grid.\n\n        Parameters\n        ----------\n        table\n            A 2D iterable object with :class:`~.VMobject` entries.\n\n        Returns\n        --------\n        :class:`~.VGroup`\n            The :class:`~.VMobject` of the ``table`` in a :class:`~.VGroup` already\n            arranged in a table-like grid.\n        \"\"\"\n        help_table = VGroup()\n        for i, row in enumerate(table):\n            for j, _ in enumerate(row):\n                help_table.add(table[i][j])\n        help_table.arrange_in_grid(\n            rows=len(table),\n            cols=len(table[0]),\n            buff=(self.h_buff, self.v_buff),\n            **self.arrange_in_grid_config,\n        )\n        return help_table\n\n\n\n[docs]\n    def _add_labels(self, mob_table: VGroup) -> VGroup:\n        \"\"\"Adds labels to an in a grid arranged :class:`~.VGroup`.\n\n        Parameters\n        ----------\n        mob_table\n            An in a grid organized class:`~.VGroup`.\n\n        Returns\n        --------\n        :class:`~.VGroup`\n            Returns the ``mob_table`` with added labels.\n        \"\"\"\n        if self.row_labels is not None:\n            for k in range(len(self.row_labels)):\n                mob_table[k] = [self.row_labels[k]] + mob_table[k]\n        if self.col_labels is not None:\n            if self.row_labels is not None:\n                if self.top_left_entry is not None:\n                    col_labels = [self.top_left_entry] + self.col_labels\n                    mob_table.insert(0, col_labels)\n                else:\n                    # Placeholder to use arrange_in_grid if top_left_entry is not set.\n                    # Import OpenGLVMobject to work with --renderer=opengl\n                    dummy_mobject = get_vectorized_mobject_class()()\n                    col_labels = [dummy_mobject] + self.col_labels\n                    mob_table.insert(0, col_labels)\n            else:\n                mob_table.insert(0, self.col_labels)\n        return mob_table\n\n\n\n[docs]\n    def _add_horizontal_lines(self) -> Table:\n        \"\"\"Adds the horizontal lines to the table.\"\"\"\n        anchor_left = self.get_left()[0] - 0.5 * self.h_buff\n        anchor_right = self.get_right()[0] + 0.5 * self.h_buff\n        line_group = VGroup()\n        if self.include_outer_lines:\n            anchor = self.get_rows()[0].get_top()[1] + 0.5 * self.v_buff\n            line = Line(\n                [anchor_left, anchor, 0], [anchor_right, anchor, 0], **self.line_config\n            )\n            line_group.add(line)\n            self.add(line)\n            anchor = self.get_rows()[-1].get_bottom()[1] - 0.5 * self.v_buff\n            line = Line(\n                [anchor_left, anchor, 0], [anchor_right, anchor, 0], **self.line_config\n            )\n            line_group.add(line)\n            self.add(line)\n        for k in range(len(self.mob_table) - 1):\n            anchor = self.get_rows()[k + 1].get_top()[1] + 0.5 * (\n                self.get_rows()[k].get_bottom()[1] - self.get_rows()[k + 1].get_top()[1]\n            )\n            line = Line(\n                [anchor_left, anchor, 0], [anchor_right, anchor, 0], **self.line_config\n            )\n            line_group.add(line)\n            self.add(line)\n        self.horizontal_lines = line_group\n        return self\n\n\n\n[docs]\n    def _add_vertical_lines(self) -> Table:\n        \"\"\"Adds the vertical lines to the table\"\"\"\n        anchor_top = self.get_rows().get_top()[1] + 0.5 * self.v_buff\n        anchor_bottom = self.get_rows().get_bottom()[1] - 0.5 * self.v_buff\n        line_group = VGroup()\n        if self.include_outer_lines:\n            anchor = self.get_columns()[0].get_left()[0] - 0.5 * self.h_buff\n            line = Line(\n                [anchor, anchor_top, 0], [anchor, anchor_bottom, 0], **self.line_config\n            )\n            line_group.add(line)\n            self.add(line)\n            anchor = self.get_columns()[-1].get_right()[0] + 0.5 * self.h_buff\n            line = Line(\n                [anchor, anchor_top, 0], [anchor, anchor_bottom, 0], **self.line_config\n            )\n            line_group.add(line)\n            self.add(line)\n        for k in range(len(self.mob_table[0]) - 1):\n            anchor = self.get_columns()[k + 1].get_left()[0] + 0.5 * (\n                self.get_columns()[k].get_right()[0]\n                - self.get_columns()[k + 1].get_left()[0]\n            )\n            line = Line(\n                [anchor, anchor_bottom, 0], [anchor, anchor_top, 0], **self.line_config\n            )\n            line_group.add(line)\n            self.add(line)\n        self.vertical_lines = line_group\n        return self\n\n\n\n[docs]\n    def get_horizontal_lines(self) -> VGroup:\n        \"\"\"Return the horizontal lines of the table.\n\n        Returns\n        --------\n        :class:`~.VGroup`\n            :class:`~.VGroup` containing all the horizontal lines of the table.\n\n        Examples\n        --------\n\n        .. manim:: GetHorizontalLinesExample\n            :save_last_frame:\n\n            class GetHorizontalLinesExample(Scene):\n                def construct(self):\n                    table = Table(\n                        [[\"First\", \"Second\"],\n                        [\"Third\",\"Fourth\"]],\n                        row_labels=[Text(\"R1\"), Text(\"R2\")],\n                        col_labels=[Text(\"C1\"), Text(\"C2\")])\n                    table.get_horizontal_lines().set_color(RED)\n                    self.add(table)\n        \"\"\"\n        return self.horizontal_lines\n\n\n\n[docs]\n    def get_vertical_lines(self) -> VGroup:\n        \"\"\"Return the vertical lines of the table.\n\n        Returns\n        --------\n        :class:`~.VGroup`\n            :class:`~.VGroup` containing all the vertical lines of the table.\n\n        Examples\n        --------\n\n        .. manim:: GetVerticalLinesExample\n            :save_last_frame:\n\n            class GetVerticalLinesExample(Scene):\n                def construct(self):\n                    table = Table(\n                        [[\"First\", \"Second\"],\n                        [\"Third\",\"Fourth\"]],\n                        row_labels=[Text(\"R1\"), Text(\"R2\")],\n                        col_labels=[Text(\"C1\"), Text(\"C2\")])\n                    table.get_vertical_lines()[0].set_color(RED)\n                    self.add(table)\n        \"\"\"\n        return self.vertical_lines\n\n\n\n[docs]\n    def get_columns(self) -> VGroup:\n        \"\"\"Return columns of the table as a :class:`~.VGroup` of :class:`~.VGroup`.\n\n        Returns\n        --------\n        :class:`~.VGroup`\n            :class:`~.VGroup` containing each column in a :class:`~.VGroup`.\n\n        Examples\n        --------\n\n        .. manim:: GetColumnsExample\n            :save_last_frame:\n\n            class GetColumnsExample(Scene):\n                def construct(self):\n                    table = Table(\n                        [[\"First\", \"Second\"],\n                        [\"Third\",\"Fourth\"]],\n                        row_labels=[Text(\"R1\"), Text(\"R2\")],\n                        col_labels=[Text(\"C1\"), Text(\"C2\")])\n                    table.add(SurroundingRectangle(table.get_columns()[1]))\n                    self.add(table)\n        \"\"\"\n        return VGroup(\n            *(\n                VGroup(*(row[i] for row in self.mob_table))\n                for i in range(len(self.mob_table[0]))\n            )\n        )\n\n\n\n[docs]\n    def get_rows(self) -> VGroup:\n        \"\"\"Return the rows of the table as a :class:`~.VGroup` of :class:`~.VGroup`.\n\n        Returns\n        --------\n        :class:`~.VGroup`\n            :class:`~.VGroup` containing each row in a :class:`~.VGroup`.\n\n        Examples\n        --------\n\n        .. manim:: GetRowsExample\n            :save_last_frame:\n\n            class GetRowsExample(Scene):\n                def construct(self):\n                    table = Table(\n                        [[\"First\", \"Second\"],\n                        [\"Third\",\"Fourth\"]],\n                        row_labels=[Text(\"R1\"), Text(\"R2\")],\n                        col_labels=[Text(\"C1\"), Text(\"C2\")])\n                    table.add(SurroundingRectangle(table.get_rows()[1]))\n                    self.add(table)\n        \"\"\"\n        return VGroup(*(VGroup(*row) for row in self.mob_table))\n\n\n\n[docs]\n    def set_column_colors(self, *colors: Iterable[ParsableManimColor]) -> Table:\n        \"\"\"Set individual colors for each column of the table.\n\n        Parameters\n        ----------\n        colors\n            An iterable of colors; each color corresponds to a column.\n\n        Examples\n        --------\n\n        .. manim:: SetColumnColorsExample\n            :save_last_frame:\n\n            class SetColumnColorsExample(Scene):\n                def construct(self):\n                    table = Table(\n                        [[\"First\", \"Second\"],\n                        [\"Third\",\"Fourth\"]],\n                        row_labels=[Text(\"R1\"), Text(\"R2\")],\n                        col_labels=[Text(\"C1\"), Text(\"C2\")]\n                    ).set_column_colors([RED,BLUE], GREEN)\n                    self.add(table)\n        \"\"\"\n        columns = self.get_columns()\n        for color, column in zip(colors, columns):\n            column.set_color(color)\n        return self\n\n\n\n[docs]\n    def set_row_colors(self, *colors: Iterable[ParsableManimColor]) -> Table:\n        \"\"\"Set individual colors for each row of the table.\n\n        Parameters\n        ----------\n        colors\n            An iterable of colors; each color corresponds to a row.\n\n        Examples\n        --------\n\n        .. manim:: SetRowColorsExample\n            :save_last_frame:\n\n            class SetRowColorsExample(Scene):\n                def construct(self):\n                    table = Table(\n                        [[\"First\", \"Second\"],\n                        [\"Third\",\"Fourth\"]],\n                        row_labels=[Text(\"R1\"), Text(\"R2\")],\n                        col_labels=[Text(\"C1\"), Text(\"C2\")]\n                    ).set_row_colors([RED,BLUE], GREEN)\n                    self.add(table)\n        \"\"\"\n        rows = self.get_rows()\n        for color, row in zip(colors, rows):\n            row.set_color(color)\n        return self\n\n\n\n[docs]\n    def get_entries(\n        self,\n        pos: Sequence[int] | None = None,\n    ) -> VMobject | VGroup:\n        \"\"\"Return the individual entries of the table (including labels) or one specific entry\n        if the parameter, ``pos``,  is set.\n\n        Parameters\n        ----------\n        pos\n            The position of a specific entry on the table. ``(1,1)`` being the top left entry\n            of the table.\n\n        Returns\n        -------\n        Union[:class:`~.VMobject`, :class:`~.VGroup`]\n            :class:`~.VGroup` containing all entries of the table (including labels)\n            or the :class:`~.VMobject` at the given position if ``pos`` is set.\n\n        Examples\n        --------\n\n        .. manim:: GetEntriesExample\n            :save_last_frame:\n\n            class GetEntriesExample(Scene):\n                def construct(self):\n                    table = Table(\n                        [[\"First\", \"Second\"],\n                        [\"Third\",\"Fourth\"]],\n                        row_labels=[Text(\"R1\"), Text(\"R2\")],\n                        col_labels=[Text(\"C1\"), Text(\"C2\")])\n                    ent = table.get_entries()\n                    for item in ent:\n                        item.set_color(random_bright_color())\n                    table.get_entries((2,2)).rotate(PI)\n                    self.add(table)\n        \"\"\"\n        if pos is not None:\n            if (\n                self.row_labels is not None\n                and self.col_labels is not None\n                and self.top_left_entry is None\n            ):\n                index = len(self.mob_table[0]) * (pos[0] - 1) + pos[1] - 2\n                return self.elements[index]\n            else:\n                index = len(self.mob_table[0]) * (pos[0] - 1) + pos[1] - 1\n                return self.elements[index]\n        else:\n            return self.elements\n\n\n\n[docs]\n    def get_entries_without_labels(\n        self,\n        pos: Sequence[int] | None = None,\n    ) -> VMobject | VGroup:\n        \"\"\"Return the individual entries of the table (without labels) or one specific entry\n        if the parameter, ``pos``, is set.\n\n        Parameters\n        ----------\n        pos\n            The position of a specific entry on the table. ``(1,1)`` being the top left entry\n            of the table (without labels).\n\n        Returns\n        -------\n        Union[:class:`~.VMobject`, :class:`~.VGroup`]\n            :class:`~.VGroup` containing all entries of the table (without labels)\n            or the :class:`~.VMobject` at the given position if ``pos`` is set.\n\n        Examples\n        --------\n\n        .. manim:: GetEntriesWithoutLabelsExample\n            :save_last_frame:\n\n            class GetEntriesWithoutLabelsExample(Scene):\n                def construct(self):\n                    table = Table(\n                        [[\"First\", \"Second\"],\n                        [\"Third\",\"Fourth\"]],\n                        row_labels=[Text(\"R1\"), Text(\"R2\")],\n                        col_labels=[Text(\"C1\"), Text(\"C2\")])\n                    ent = table.get_entries_without_labels()\n                    colors = [BLUE, GREEN, YELLOW, RED]\n                    for k in range(len(colors)):\n                        ent[k].set_color(colors[k])\n                    table.get_entries_without_labels((2,2)).rotate(PI)\n                    self.add(table)\n        \"\"\"\n        if pos is not None:\n            index = self.col_dim * (pos[0] - 1) + pos[1] - 1\n            return self.elements_without_labels[index]\n        else:\n            return self.elements_without_labels\n\n\n\n[docs]\n    def get_row_labels(self) -> VGroup:\n        \"\"\"Return the row labels of the table.\n\n        Returns\n        -------\n        :class:`~.VGroup`\n            :class:`~.VGroup` containing the row labels of the table.\n\n        Examples\n        --------\n\n        .. manim:: GetRowLabelsExample\n            :save_last_frame:\n\n            class GetRowLabelsExample(Scene):\n                def construct(self):\n                    table = Table(\n                        [[\"First\", \"Second\"],\n                        [\"Third\",\"Fourth\"]],\n                        row_labels=[Text(\"R1\"), Text(\"R2\")],\n                        col_labels=[Text(\"C1\"), Text(\"C2\")])\n                    lab = table.get_row_labels()\n                    for item in lab:\n                        item.set_color(random_bright_color())\n                    self.add(table)\n        \"\"\"\n        return VGroup(*self.row_labels)\n\n\n\n[docs]\n    def get_col_labels(self) -> VGroup:\n        \"\"\"Return the column labels of the table.\n\n        Returns\n        --------\n        :class:`~.VGroup`\n            VGroup containing the column labels of the table.\n\n        Examples\n        --------\n\n        .. manim:: GetColLabelsExample\n            :save_last_frame:\n\n            class GetColLabelsExample(Scene):\n                def construct(self):\n                    table = Table(\n                        [[\"First\", \"Second\"],\n                        [\"Third\",\"Fourth\"]],\n                        row_labels=[Text(\"R1\"), Text(\"R2\")],\n                        col_labels=[Text(\"C1\"), Text(\"C2\")])\n                    lab = table.get_col_labels()\n                    for item in lab:\n                        item.set_color(random_bright_color())\n                    self.add(table)\n        \"\"\"\n        return VGroup(*self.col_labels)\n\n\n\n[docs]\n    def get_labels(self) -> VGroup:\n        \"\"\"Returns the labels of the table.\n\n        Returns\n        --------\n        :class:`~.VGroup`\n            :class:`~.VGroup` containing all the labels of the table.\n\n        Examples\n        --------\n\n        .. manim:: GetLabelsExample\n            :save_last_frame:\n\n            class GetLabelsExample(Scene):\n                def construct(self):\n                    table = Table(\n                        [[\"First\", \"Second\"],\n                        [\"Third\",\"Fourth\"]],\n                        row_labels=[Text(\"R1\"), Text(\"R2\")],\n                        col_labels=[Text(\"C1\"), Text(\"C2\")])\n                    lab = table.get_labels()\n                    colors = [BLUE, GREEN, YELLOW, RED]\n                    for k in range(len(colors)):\n                        lab[k].set_color(colors[k])\n                    self.add(table)\n        \"\"\"\n        label_group = VGroup()\n        if self.top_left_entry is not None:\n            label_group.add(self.top_left_entry)\n        for label in (self.col_labels, self.row_labels):\n            if label is not None:\n                label_group.add(*label)\n        return label_group\n\n\n\n[docs]\n    def add_background_to_entries(self, color: ParsableManimColor = BLACK) -> Table:\n        \"\"\"Adds a black :class:`~.BackgroundRectangle` to each entry of the table.\"\"\"\n        for mob in self.get_entries():\n            mob.add_background_rectangle(color=ManimColor(color))\n        return self\n\n\n\n[docs]\n    def get_cell(self, pos: Sequence[int] = (1, 1), **kwargs) -> Polygon:\n        \"\"\"Returns one specific cell as a rectangular :class:`~.Polygon` without the entry.\n\n        Parameters\n        ----------\n        pos\n            The position of a specific entry on the table. ``(1,1)`` being the top left entry\n            of the table.\n        kwargs\n            Additional arguments to be passed to :class:`~.Polygon`.\n\n        Returns\n        -------\n        :class:`~.Polygon`\n            Polygon mimicking one specific cell of the Table.\n\n        Examples\n        --------\n\n        .. manim:: GetCellExample\n            :save_last_frame:\n\n            class GetCellExample(Scene):\n                def construct(self):\n                    table = Table(\n                        [[\"First\", \"Second\"],\n                        [\"Third\",\"Fourth\"]],\n                        row_labels=[Text(\"R1\"), Text(\"R2\")],\n                        col_labels=[Text(\"C1\"), Text(\"C2\")])\n                    cell = table.get_cell((2,2), color=RED)\n                    self.add(table, cell)\n        \"\"\"\n        row = self.get_rows()[pos[0] - 1]\n        col = self.get_columns()[pos[1] - 1]\n        edge_UL = [\n            col.get_left()[0] - self.h_buff / 2,\n            row.get_top()[1] + self.v_buff / 2,\n            0,\n        ]\n        edge_UR = [\n            col.get_right()[0] + self.h_buff / 2,\n            row.get_top()[1] + self.v_buff / 2,\n            0,\n        ]\n        edge_DL = [\n            col.get_left()[0] - self.h_buff / 2,\n            row.get_bottom()[1] - self.v_buff / 2,\n            0,\n        ]\n        edge_DR = [\n            col.get_right()[0] + self.h_buff / 2,\n            row.get_bottom()[1] - self.v_buff / 2,\n            0,\n        ]\n        rec = Polygon(edge_UL, edge_UR, edge_DR, edge_DL, **kwargs)\n        return rec\n\n\n\n[docs]\n    def get_highlighted_cell(\n        self, pos: Sequence[int] = (1, 1), color: ParsableManimColor = YELLOW, **kwargs\n    ) -> BackgroundRectangle:\n        \"\"\"Returns a :class:`~.BackgroundRectangle` of the cell at the given position.\n\n        Parameters\n        ----------\n        pos\n            The position of a specific entry on the table. ``(1,1)`` being the top left entry\n            of the table.\n        color\n            The color used to highlight the cell.\n        kwargs\n            Additional arguments to be passed to :class:`~.BackgroundRectangle`.\n\n        Examples\n        --------\n\n        .. manim:: GetHighlightedCellExample\n            :save_last_frame:\n\n            class GetHighlightedCellExample(Scene):\n                def construct(self):\n                    table = Table(\n                        [[\"First\", \"Second\"],\n                        [\"Third\",\"Fourth\"]],\n                        row_labels=[Text(\"R1\"), Text(\"R2\")],\n                        col_labels=[Text(\"C1\"), Text(\"C2\")])\n                    highlight = table.get_highlighted_cell((2,2), color=GREEN)\n                    table.add_to_back(highlight)\n                    self.add(table)\n        \"\"\"\n        cell = self.get_cell(pos)\n        bg_cell = BackgroundRectangle(cell, color=ManimColor(color), **kwargs)\n        return bg_cell\n\n\n\n[docs]\n    def add_highlighted_cell(\n        self, pos: Sequence[int] = (1, 1), color: ParsableManimColor = YELLOW, **kwargs\n    ) -> Table:\n        \"\"\"Highlights one cell at a specific position on the table by adding a :class:`~.BackgroundRectangle`.\n\n        Parameters\n        ----------\n        pos\n            The position of a specific entry on the table. ``(1,1)`` being the top left entry\n            of the table.\n        color\n            The color used to highlight the cell.\n        kwargs\n            Additional arguments to be passed to :class:`~.BackgroundRectangle`.\n\n        Examples\n        --------\n\n        .. manim:: AddHighlightedCellExample\n            :save_last_frame:\n\n            class AddHighlightedCellExample(Scene):\n                def construct(self):\n                    table = Table(\n                        [[\"First\", \"Second\"],\n                        [\"Third\",\"Fourth\"]],\n                        row_labels=[Text(\"R1\"), Text(\"R2\")],\n                        col_labels=[Text(\"C1\"), Text(\"C2\")])\n                    table.add_highlighted_cell((2,2), color=GREEN)\n                    self.add(table)\n        \"\"\"\n        bg_cell = self.get_highlighted_cell(pos, color=ManimColor(color), **kwargs)\n        self.add_to_back(bg_cell)\n        entry = self.get_entries(pos)\n        entry.background_rectangle = bg_cell\n        return self\n\n\n\n[docs]\n    def create(\n        self,\n        lag_ratio: float = 1,\n        line_animation: Callable[[VMobject | VGroup], Animation] = Create,\n        label_animation: Callable[[VMobject | VGroup], Animation] = Write,\n        element_animation: Callable[[VMobject | VGroup], Animation] = Create,\n        entry_animation: Callable[[VMobject | VGroup], Animation] = FadeIn,\n        **kwargs,\n    ) -> AnimationGroup:\n        \"\"\"Customized create-type function for tables.\n\n        Parameters\n        ----------\n        lag_ratio\n            The lag ratio of the animation.\n        line_animation\n            The animation style of the table lines, see :mod:`~.creation` for examples.\n        label_animation\n            The animation style of the table labels, see :mod:`~.creation` for examples.\n        element_animation\n            The animation style of the table elements, see :mod:`~.creation` for examples.\n        entry_animation\n            The entry animation of the table background, see :mod:`~.creation` for examples.\n        kwargs\n            Further arguments passed to the creation animations.\n\n        Returns\n        -------\n        :class:`~.AnimationGroup`\n            AnimationGroup containing creation of the lines and of the elements.\n\n        Examples\n        --------\n\n        .. manim:: CreateTableExample\n\n            class CreateTableExample(Scene):\n                def construct(self):\n                    table = Table(\n                        [[\"First\", \"Second\"],\n                        [\"Third\",\"Fourth\"]],\n                        row_labels=[Text(\"R1\"), Text(\"R2\")],\n                        col_labels=[Text(\"C1\"), Text(\"C2\")],\n                        include_outer_lines=True)\n                    self.play(table.create())\n                    self.wait()\n        \"\"\"\n        animations: Sequence[Animation] = [\n            line_animation(\n                VGroup(self.vertical_lines, self.horizontal_lines),\n                **kwargs,\n            ),\n            element_animation(self.elements_without_labels.set_z_index(2), **kwargs),\n        ]\n\n        if self.get_labels():\n            animations += [\n                label_animation(self.get_labels(), **kwargs),\n            ]\n\n        if self.get_entries():\n            for entry in self.elements_without_labels:\n                try:\n                    animations += [\n                        entry_animation(\n                            entry.background_rectangle,\n                            **kwargs,\n                        )\n                    ]\n                except AttributeError:\n                    continue\n\n        return AnimationGroup(*animations, lag_ratio=lag_ratio)\n\n\n\n[docs]\n    def scale(self, scale_factor: float, **kwargs):\n        # h_buff and v_buff must be adjusted so that Table.get_cell\n        # can construct an accurate polygon for a cell.\n        self.h_buff *= scale_factor\n        self.v_buff *= scale_factor\n        super().scale(scale_factor, **kwargs)\n        return self\n\n\n\n\n\n[docs]\nclass MathTable(Table):\n    \"\"\"A specialized :class:`~.Table` mobject for use with LaTeX.\n\n    Examples\n    --------\n\n    .. manim:: MathTableExample\n        :save_last_frame:\n\n        class MathTableExample(Scene):\n            def construct(self):\n                t0 = MathTable(\n                    [[\"+\", 0, 5, 10],\n                    [0, 0, 5, 10],\n                    [2, 2, 7, 12],\n                    [4, 4, 9, 14]],\n                    include_outer_lines=True)\n                self.add(t0)\n    \"\"\"\n\n    def __init__(\n        self,\n        table: Iterable[Iterable[float | str]],\n        element_to_mobject: Callable[[float | str], VMobject] = MathTex,\n        **kwargs,\n    ):\n        \"\"\"\n        Special case of :class:`~.Table` with `element_to_mobject` set to :class:`~.MathTex`.\n        Every entry in `table` is set in a Latex `align` environment.\n\n        Parameters\n        ----------\n        table\n            A 2d array or list of lists. Content of the table have to be valid input\n            for :class:`~.MathTex`.\n        element_to_mobject\n            The :class:`~.Mobject` class applied to the table entries. Set as :class:`~.MathTex`.\n        kwargs\n            Additional arguments to be passed to :class:`~.Table`.\n        \"\"\"\n        super().__init__(\n            table,\n            element_to_mobject=element_to_mobject,\n            **kwargs,\n        )\n\n\n\n\n[docs]\nclass MobjectTable(Table):\n    \"\"\"A specialized :class:`~.Table` mobject for use with :class:`~.Mobject`.\n\n    Examples\n    --------\n\n    .. manim:: MobjectTableExample\n        :save_last_frame:\n\n        class MobjectTableExample(Scene):\n            def construct(self):\n                cross = VGroup(\n                    Line(UP + LEFT, DOWN + RIGHT),\n                    Line(UP + RIGHT, DOWN + LEFT),\n                )\n                a = Circle().set_color(RED).scale(0.5)\n                b = cross.set_color(BLUE).scale(0.5)\n                t0 = MobjectTable(\n                    [[a.copy(),b.copy(),a.copy()],\n                    [b.copy(),a.copy(),a.copy()],\n                    [a.copy(),b.copy(),b.copy()]]\n                )\n                line = Line(\n                    t0.get_corner(DL), t0.get_corner(UR)\n                ).set_color(RED)\n                self.add(t0, line)\n    \"\"\"\n\n    def __init__(\n        self,\n        table: Iterable[Iterable[VMobject]],\n        element_to_mobject: Callable[[VMobject], VMobject] = lambda m: m,\n        **kwargs,\n    ):\n        \"\"\"\n        Special case of :class:`~.Table` with ``element_to_mobject`` set to an identity function.\n        Here, every item in ``table`` must already be of type :class:`~.Mobject`.\n\n        Parameters\n        ----------\n        table\n            A 2D array or list of lists. Content of the table must be of type :class:`~.Mobject`.\n        element_to_mobject\n            The :class:`~.Mobject` class applied to the table entries. Set as ``lambda m : m`` to return itself.\n        kwargs\n            Additional arguments to be passed to :class:`~.Table`.\n        \"\"\"\n        super().__init__(table, element_to_mobject=element_to_mobject, **kwargs)\n\n\n\n\n[docs]\nclass IntegerTable(Table):\n    r\"\"\"A specialized :class:`~.Table` mobject for use with :class:`~.Integer`.\n\n    Examples\n    --------\n\n    .. manim:: IntegerTableExample\n        :save_last_frame:\n\n        class IntegerTableExample(Scene):\n            def construct(self):\n                t0 = IntegerTable(\n                    [[0,30,45,60,90],\n                    [90,60,45,30,0]],\n                    col_labels=[\n                        MathTex(r\"\\frac{\\sqrt{0}}{2}\"),\n                        MathTex(r\"\\frac{\\sqrt{1}}{2}\"),\n                        MathTex(r\"\\frac{\\sqrt{2}}{2}\"),\n                        MathTex(r\"\\frac{\\sqrt{3}}{2}\"),\n                        MathTex(r\"\\frac{\\sqrt{4}}{2}\")],\n                    row_labels=[MathTex(r\"\\sin\"), MathTex(r\"\\cos\")],\n                    h_buff=1,\n                    element_to_mobject_config={\"unit\": r\"^{\\circ}\"})\n                self.add(t0)\n    \"\"\"\n\n    def __init__(\n        self,\n        table: Iterable[Iterable[float | str]],\n        element_to_mobject: Callable[[float | str], VMobject] = Integer,\n        **kwargs,\n    ):\n        \"\"\"\n        Special case of :class:`~.Table` with `element_to_mobject` set to :class:`~.Integer`.\n        Will round if there are decimal entries in the table.\n\n        Parameters\n        ----------\n        table\n            A 2d array or list of lists. Content of the table has to be valid input\n            for :class:`~.Integer`.\n        element_to_mobject\n            The :class:`~.Mobject` class applied to the table entries. Set as :class:`~.Integer`.\n        kwargs\n            Additional arguments to be passed to :class:`~.Table`.\n        \"\"\"\n        super().__init__(table, element_to_mobject=element_to_mobject, **kwargs)\n\n\n\n\n[docs]\nclass DecimalTable(Table):\n    \"\"\"A specialized :class:`~.Table` mobject for use with :class:`~.DecimalNumber` to display decimal entries.\n\n    Examples\n    --------\n\n    .. manim:: DecimalTableExample\n        :save_last_frame:\n\n        class DecimalTableExample(Scene):\n            def construct(self):\n                x_vals = [-2,-1,0,1,2]\n                y_vals = np.exp(x_vals)\n                t0 = DecimalTable(\n                    [x_vals, y_vals],\n                    row_labels=[MathTex(\"x\"), MathTex(\"f(x)=e^{x}\")],\n                    h_buff=1,\n                    element_to_mobject_config={\"num_decimal_places\": 2})\n                self.add(t0)\n    \"\"\"\n\n    def __init__(\n        self,\n        table: Iterable[Iterable[float | str]],\n        element_to_mobject: Callable[[float | str], VMobject] = DecimalNumber,\n        element_to_mobject_config: dict = {\"num_decimal_places\": 1},\n        **kwargs,\n    ):\n        \"\"\"\n        Special case of :class:`~.Table` with ``element_to_mobject`` set to :class:`~.DecimalNumber`.\n        By default, ``num_decimal_places`` is set to 1.\n        Will round/truncate the decimal places based on the provided ``element_to_mobject_config``.\n\n        Parameters\n        ----------\n        table\n            A 2D array, or a list of lists. Content of the table must be valid input\n            for :class:`~.DecimalNumber`.\n        element_to_mobject\n            The :class:`~.Mobject` class applied to the table entries. Set as :class:`~.DecimalNumber`.\n        element_to_mobject_config\n            Element to mobject config, here set as {\"num_decimal_places\": 1}.\n        kwargs\n            Additional arguments to be passed to :class:`~.Table`.\n        \"\"\"\n        super().__init__(\n            table,\n            element_to_mobject=element_to_mobject,\n            element_to_mobject_config=element_to_mobject_config,\n            **kwargs,\n        )", "code_sha1": "017f84abaffd95bc66dc17aa9fa2dbb450f3097e"}
{"url": "https://docs.manim.community/en/stable/_modules/manim/mobject/text/code_mobject.html", "depth": 2, "instruction": "The code creates a highlighted source code display with a dark background and white text. It includes line numbers on the left, formatted in a monospace font. The code is visually structured with a surrounding rectangle or window-like background, featuring colored buttons at the top. The overall appearance mimics a code editor interface.", "code": "\"\"\"Mobject representing highlighted source code listings.\"\"\"\n\nfrom __future__ import annotations\n\n__all__ = [\n    \"Code\",\n]\n\nfrom pathlib import Path\nfrom typing import Any, Literal\n\nfrom bs4 import BeautifulSoup, Tag\nfrom pygments import highlight\nfrom pygments.formatters.html import HtmlFormatter\nfrom pygments.lexers import get_lexer_by_name, guess_lexer, guess_lexer_for_filename\nfrom pygments.styles import get_all_styles\n\nfrom manim.constants import *\nfrom manim.mobject.geometry.arc import Dot\nfrom manim.mobject.geometry.shape_matchers import SurroundingRectangle\nfrom manim.mobject.text.text_mobject import Paragraph\nfrom manim.mobject.types.vectorized_mobject import VGroup, VMobject\nfrom manim.typing import StrPath\nfrom manim.utils.color import WHITE, ManimColor\n\n\n\n[docs]\nclass Code(VMobject):\n    \"\"\"A highlighted source code listing.\n\n    Examples\n    --------\n\n    Normal usage::\n\n        listing = Code(\n            \"helloworldcpp.cpp\",\n            tab_width=4,\n            formatter_style=\"emacs\",\n            background=\"window\",\n            language=\"cpp\",\n            background_config={\"stroke_color\": WHITE},\n            paragraph_config={\"font\": \"Noto Sans Mono\"},\n        )\n\n    We can also render code passed as a string. As the automatic language\n    detection can be a bit flaky, it is recommended to specify the language\n    explicitly:\n\n    .. manim:: CodeFromString\n        :save_last_frame:\n\n        class CodeFromString(Scene):\n            def construct(self):\n                code = '''from manim import Scene, Square\n\n        class FadeInSquare(Scene):\n            def construct(self):\n                s = Square()\n                self.play(FadeIn(s))\n                self.play(s.animate.scale(2))\n                self.wait()'''\n\n                rendered_code = Code(\n                    code_string=code,\n                    language=\"python\",\n                    background=\"window\",\n                    background_config={\"stroke_color\": \"maroon\"},\n                )\n                self.add(rendered_code)\n\n    Parameters\n    ----------\n    code_file\n        The path to the code file to display.\n    code_string\n        Alternatively, the code string to display.\n    language\n        The programming language of the code. If not specified, it will be\n        guessed from the file extension or the code itself.\n    formatter_style\n        The style to use for the code highlighting. Defaults to ``\"vim\"``.\n        A list of all available styles can be obtained by calling\n        :meth:`.Code.get_styles_list`.\n    tab_width\n        The width of a tab character in spaces. Defaults to 4.\n    add_line_numbers\n        Whether to display line numbers. Defaults to ``True``.\n    line_numbers_from\n        The first line number to display. Defaults to 1.\n    background\n        The type of background to use. Can be either ``\"rectangle\"`` (the\n        default) or ``\"window\"``.\n    background_config\n        Keyword arguments passed to the background constructor. Default\n        settings are stored in the class attribute\n        :attr:`.default_background_config` (which can also be modified\n        directly).\n    paragraph_config\n        Keyword arguments passed to the constructor of the\n        :class:`.Paragraph` objects holding the code, and the line\n        numbers. Default settings are stored in the class attribute\n        :attr:`.default_paragraph_config` (which can also be modified\n        directly).\n    \"\"\"\n\n    _styles_list_cache: list[str] | None = None\n    default_background_config: dict[str, Any] = {\n        \"buff\": 0.3,\n        \"fill_color\": ManimColor(\"#222\"),\n        \"stroke_color\": WHITE,\n        \"corner_radius\": 0.2,\n        \"stroke_width\": 1,\n        \"fill_opacity\": 1,\n    }\n    default_paragraph_config: dict[str, Any] = {\n        \"font\": \"Monospace\",\n        \"font_size\": 24,\n        \"line_spacing\": 0.5,\n        \"disable_ligatures\": True,\n    }\n\n    def __init__(\n        self,\n        code_file: StrPath | None = None,\n        code_string: str | None = None,\n        language: str | None = None,\n        formatter_style: str = \"vim\",\n        tab_width: int = 4,\n        add_line_numbers: bool = True,\n        line_numbers_from: int = 1,\n        background: Literal[\"rectangle\", \"window\"] = \"rectangle\",\n        background_config: dict[str, Any] | None = None,\n        paragraph_config: dict[str, Any] | None = None,\n    ):\n        super().__init__()\n\n        if code_file is not None:\n            code_file = Path(code_file)\n            code_string = code_file.read_text(encoding=\"utf-8\")\n            lexer = guess_lexer_for_filename(code_file.name, code_string)\n        elif code_string is not None:\n            if language is not None:\n                lexer = get_lexer_by_name(language)\n            else:\n                lexer = guess_lexer(code_string)\n        else:\n            raise ValueError(\"Either a code file or a code string must be specified.\")\n\n        code_string = code_string.expandtabs(tabsize=tab_width)\n\n        formatter = HtmlFormatter(\n            style=formatter_style,\n            noclasses=True,\n            cssclasses=\"\",\n        )\n        soup = BeautifulSoup(\n            highlight(code_string, lexer, formatter), features=\"html.parser\"\n        )\n        self._code_html = soup.find(\"pre\")\n        assert isinstance(self._code_html, Tag)\n\n        # as we are using Paragraph to render the text, we need to find the character indices\n        # of the segments of changed color in the HTML code\n        color_ranges = []\n        current_line_color_ranges = []\n        current_line_char_index = 0\n        for child in self._code_html.children:\n            if child.name == \"span\":\n                try:\n                    child_style = child[\"style\"]\n                    if isinstance(child_style, str):\n                        color = child_style.removeprefix(\"color: \")\n                    else:\n                        color = None\n                except KeyError:\n                    color = None\n                current_line_color_ranges.append(\n                    (\n                        current_line_char_index,\n                        current_line_char_index + len(child.text),\n                        color,\n                    )\n                )\n                current_line_char_index += len(child.text)\n            else:\n                for char in child.text:\n                    if char == \"\\n\":\n                        color_ranges.append(current_line_color_ranges)\n                        current_line_color_ranges = []\n                        current_line_char_index = 0\n                    else:\n                        current_line_char_index += 1\n\n        color_ranges.append(current_line_color_ranges)\n        code_lines = self._code_html.get_text().removesuffix(\"\\n\").split(\"\\n\")\n\n        if paragraph_config is None:\n            paragraph_config = {}\n        base_paragraph_config = self.default_paragraph_config.copy()\n        base_paragraph_config.update(paragraph_config)\n\n        self.code_lines = Paragraph(\n            *code_lines,\n            **base_paragraph_config,\n        )\n        for line, color_range in zip(self.code_lines, color_ranges):\n            for start, end, color in color_range:\n                line[start:end].set_color(color)\n\n        if add_line_numbers:\n            base_paragraph_config.update({\"alignment\": \"right\"})\n            self.line_numbers = Paragraph(\n                *[\n                    str(i)\n                    for i in range(\n                        line_numbers_from, line_numbers_from + len(self.code_lines)\n                    )\n                ],\n                **base_paragraph_config,\n            )\n            self.line_numbers.next_to(self.code_lines, direction=LEFT).align_to(\n                self.code_lines, UP\n            )\n            self.add(self.line_numbers)\n\n        self.add(self.code_lines)\n\n        if background_config is None:\n            background_config = {}\n        background_config_base = self.default_background_config.copy()\n        background_config_base.update(background_config)\n\n        if background == \"rectangle\":\n            self.background = SurroundingRectangle(\n                self,\n                **background_config_base,\n            )\n        elif background == \"window\":\n            buttons = VGroup(\n                Dot(radius=0.1, stroke_width=0, color=button_color)\n                for button_color in [\"#ff5f56\", \"#ffbd2e\", \"#27c93f\"]\n            ).arrange(RIGHT, buff=0.1)\n            buttons.next_to(self, UP, buff=0.1).align_to(self, LEFT).shift(LEFT * 0.1)\n            self.background = SurroundingRectangle(\n                VGroup(self, buttons),\n                **background_config_base,\n            )\n            buttons.shift(UP * 0.1 + LEFT * 0.1)\n            self.background.add(buttons)\n        else:\n            raise ValueError(f\"Unknown background type: {background}\")\n\n        self.add_to_back(self.background)\n\n\n[docs]\n    @classmethod\n    def get_styles_list(cls) -> list[str]:\n        \"\"\"Get the list of all available formatter styles.\"\"\"\n        if cls._styles_list_cache is None:\n            cls._styles_list_cache = list(get_all_styles())\n        return cls._styles_list_cache", "code_sha1": "aaa778e97e3cb80ccbaa18abfb15eb61d32adc00"}
{"url": "https://docs.manim.community/en/stable/_modules/manim/mobject/text/numbers.html", "depth": 2, "instruction": "The code defines three classes for displaying numbers: `DecimalNumber`, `Integer`, and `Variable`. The visual result includes animated text representations of numbers, with properties like color, size, and position. The `Variable` class shows a label and a continuously updated value, while `DecimalNumber` and `Integer` display formatted numeric values.", "code": "\"\"\"Mobjects representing numbers.\"\"\"\n\nfrom __future__ import annotations\n\n__all__ = [\"DecimalNumber\", \"Integer\", \"Variable\"]\n\nfrom collections.abc import Sequence\nfrom typing import Any\n\nimport numpy as np\n\nfrom manim import config\nfrom manim.constants import *\nfrom manim.mobject.opengl.opengl_compatibility import ConvertToOpenGL\nfrom manim.mobject.text.tex_mobject import MathTex, SingleStringMathTex, Tex\nfrom manim.mobject.text.text_mobject import Text\nfrom manim.mobject.types.vectorized_mobject import VMobject\nfrom manim.mobject.value_tracker import ValueTracker\n\nstring_to_mob_map = {}\n\n__all__ = [\"DecimalNumber\", \"Integer\", \"Variable\"]\n\n\n\n[docs]\nclass DecimalNumber(VMobject, metaclass=ConvertToOpenGL):\n    r\"\"\"An mobject representing a decimal number.\n\n    Parameters\n    ----------\n    number\n        The numeric value to be displayed. It can later be modified using :meth:`.set_value`.\n    num_decimal_places\n        The number of decimal places after the decimal separator. Values are automatically rounded.\n    mob_class\n        The class for rendering digits and units, by default :class:`.MathTex`.\n    include_sign\n        Set to ``True`` to include a sign for positive numbers and zero.\n    group_with_commas\n        When ``True`` thousands groups are separated by commas for readability.\n    digit_buff_per_font_unit\n        Additional spacing between digits. Scales with font size.\n    show_ellipsis\n        When a number has been truncated by rounding, indicate with an ellipsis (``...``).\n    unit\n        A unit string which can be placed to the right of the numerical values.\n    unit_buff_per_font_unit\n        An additional spacing between the numerical values and the unit. A value\n        of ``unit_buff_per_font_unit=0.003`` gives a decent spacing. Scales with font size.\n    include_background_rectangle\n        Adds a background rectangle to increase contrast on busy scenes.\n    edge_to_fix\n        Assuring right- or left-alignment of the full object.\n    font_size\n        Size of the font.\n\n    Examples\n    --------\n\n    .. manim:: MovingSquareWithUpdaters\n\n        class MovingSquareWithUpdaters(Scene):\n            def construct(self):\n                decimal = DecimalNumber(\n                    0,\n                    show_ellipsis=True,\n                    num_decimal_places=3,\n                    include_sign=True,\n                    unit=r\"\\text{M-Units}\",\n                    unit_buff_per_font_unit=0.003\n                )\n                square = Square().to_edge(UP)\n\n                decimal.add_updater(lambda d: d.next_to(square, RIGHT))\n                decimal.add_updater(lambda d: d.set_value(square.get_center()[1]))\n                self.add(square, decimal)\n                self.play(\n                    square.animate.to_edge(DOWN),\n                    rate_func=there_and_back,\n                    run_time=5,\n                )\n                self.wait()\n\n    \"\"\"\n\n    def __init__(\n        self,\n        number: float = 0,\n        num_decimal_places: int = 2,\n        mob_class: VMobject = MathTex,\n        include_sign: bool = False,\n        group_with_commas: bool = True,\n        digit_buff_per_font_unit: float = 0.001,\n        show_ellipsis: bool = False,\n        unit: str | None = None,  # Aligned to bottom unless it starts with \"^\"\n        unit_buff_per_font_unit: float = 0,\n        include_background_rectangle: bool = False,\n        edge_to_fix: Sequence[float] = LEFT,\n        font_size: float = DEFAULT_FONT_SIZE,\n        stroke_width: float = 0,\n        fill_opacity: float = 1.0,\n        **kwargs,\n    ):\n        super().__init__(**kwargs, stroke_width=stroke_width)\n        self.number = number\n        self.num_decimal_places = num_decimal_places\n        self.include_sign = include_sign\n        self.mob_class = mob_class\n        self.group_with_commas = group_with_commas\n        self.digit_buff_per_font_unit = digit_buff_per_font_unit\n        self.show_ellipsis = show_ellipsis\n        self.unit = unit\n        self.unit_buff_per_font_unit = unit_buff_per_font_unit\n        self.include_background_rectangle = include_background_rectangle\n        self.edge_to_fix = edge_to_fix\n        self._font_size = font_size\n        self.fill_opacity = fill_opacity\n\n        self.initial_config = kwargs.copy()\n        self.initial_config.update(\n            {\n                \"num_decimal_places\": num_decimal_places,\n                \"include_sign\": include_sign,\n                \"group_with_commas\": group_with_commas,\n                \"digit_buff_per_font_unit\": digit_buff_per_font_unit,\n                \"show_ellipsis\": show_ellipsis,\n                \"unit\": unit,\n                \"unit_buff_per_font_unit\": unit_buff_per_font_unit,\n                \"include_background_rectangle\": include_background_rectangle,\n                \"edge_to_fix\": edge_to_fix,\n                \"font_size\": font_size,\n                \"stroke_width\": stroke_width,\n                \"fill_opacity\": fill_opacity,\n            },\n        )\n\n        self._set_submobjects_from_number(number)\n        self.init_colors()\n\n    @property\n    def font_size(self):\n        \"\"\"The font size of the tex mobject.\"\"\"\n        return self.height / self.initial_height * self._font_size\n\n    @font_size.setter\n    def font_size(self, font_val):\n        if font_val <= 0:\n            raise ValueError(\"font_size must be greater than 0.\")\n        elif self.height > 0:\n            # sometimes manim generates a SingleStringMathex mobject with 0 height.\n            # can't be scaled regardless and will error without the elif.\n\n            # scale to a factor of the initial height so that setting\n            # font_size does not depend on current size.\n            self.scale(font_val / self.font_size)\n\n    def _set_submobjects_from_number(self, number):\n        self.number = number\n        self.submobjects = []\n\n        num_string = self._get_num_string(number)\n        self.add(*(map(self._string_to_mob, num_string)))\n\n        # Add non-numerical bits\n        if self.show_ellipsis:\n            self.add(\n                self._string_to_mob(\"\\\\dots\", SingleStringMathTex, color=self.color),\n            )\n\n        self.arrange(\n            buff=self.digit_buff_per_font_unit * self._font_size,\n            aligned_edge=DOWN,\n        )\n\n        if self.unit is not None:\n            self.unit_sign = self._string_to_mob(self.unit, SingleStringMathTex)\n            self.add(\n                self.unit_sign.next_to(\n                    self,\n                    direction=RIGHT,\n                    buff=(self.unit_buff_per_font_unit + self.digit_buff_per_font_unit)\n                    * self._font_size,\n                    aligned_edge=DOWN,\n                )\n            )\n\n        self.move_to(ORIGIN)\n\n        # Handle alignment of parts that should be aligned\n        # to the bottom\n        for i, c in enumerate(num_string):\n            if c == \"-\" and len(num_string) > i + 1:\n                self[i].align_to(self[i + 1], UP)\n                self[i].shift(self[i + 1].height * DOWN / 2)\n            elif c == \",\":\n                self[i].shift(self[i].height * DOWN / 2)\n        if self.unit and self.unit.startswith(\"^\"):\n            self.unit_sign.align_to(self, UP)\n\n        # track the initial height to enable scaling via font_size\n        self.initial_height = self.height\n\n        if self.include_background_rectangle:\n            self.add_background_rectangle()\n\n    def _get_num_string(self, number):\n        if isinstance(number, complex):\n            formatter = self._get_complex_formatter()\n        else:\n            formatter = self._get_formatter()\n        num_string = formatter.format(number)\n\n        rounded_num = np.round(number, self.num_decimal_places)\n        if num_string.startswith(\"-\") and rounded_num == 0:\n            num_string = \"+\" + num_string[1:] if self.include_sign else num_string[1:]\n\n        return num_string\n\n    def _string_to_mob(self, string: str, mob_class: VMobject | None = None, **kwargs):\n        if mob_class is None:\n            mob_class = self.mob_class\n\n        if string not in string_to_mob_map:\n            string_to_mob_map[string] = mob_class(string, **kwargs)\n        mob = string_to_mob_map[string].copy()\n        mob.font_size = self._font_size\n        return mob\n\n\n[docs]\n    def _get_formatter(self, **kwargs):\n        \"\"\"\n        Configuration is based first off instance attributes,\n        but overwritten by any kew word argument.  Relevant\n        key words:\n        - include_sign\n        - group_with_commas\n        - num_decimal_places\n        - field_name (e.g. 0 or 0.real)\n        \"\"\"\n        config = {\n            attr: getattr(self, attr)\n            for attr in [\n                \"include_sign\",\n                \"group_with_commas\",\n                \"num_decimal_places\",\n            ]\n        }\n        config.update(kwargs)\n        return \"\".join(\n            [\n                \"{\",\n                config.get(\"field_name\", \"\"),\n                \":\",\n                \"+\" if config[\"include_sign\"] else \"\",\n                \",\" if config[\"group_with_commas\"] else \"\",\n                \".\",\n                str(config[\"num_decimal_places\"]),\n                \"f\",\n                \"}\",\n            ],\n        )\n\n\n    def _get_complex_formatter(self):\n        return \"\".join(\n            [\n                self._get_formatter(field_name=\"0.real\"),\n                self._get_formatter(field_name=\"0.imag\", include_sign=True),\n                \"i\",\n            ],\n        )\n\n\n[docs]\n    def set_value(self, number: float):\n        \"\"\"Set the value of the :class:`~.DecimalNumber` to a new number.\n\n        Parameters\n        ----------\n        number\n            The value that will overwrite the current number of the :class:`~.DecimalNumber`.\n\n        \"\"\"\n        # creates a new number mob via `set_submobjects_from_number`\n        # then matches the properties (color, font_size, etc...)\n        # of the previous mobject to the new one\n\n        # old_family needed with cairo\n        old_family = self.get_family()\n\n        old_font_size = self.font_size\n        move_to_point = self.get_edge_center(self.edge_to_fix)\n        old_submobjects = self.submobjects\n\n        self._set_submobjects_from_number(number)\n        self.font_size = old_font_size\n        self.move_to(move_to_point, self.edge_to_fix)\n        for sm1, sm2 in zip(self.submobjects, old_submobjects):\n            sm1.match_style(sm2)\n\n        if config.renderer == RendererType.CAIRO:\n            for mob in old_family:\n                # Dumb hack...due to how scene handles families\n                # of animated mobjects\n                # for compatibility with updaters to not leave first number in place while updating,\n                # not needed with opengl renderer\n                mob.points[:] = 0\n\n        self.init_colors()\n        return self\n\n\n    def get_value(self):\n        return self.number\n\n    def increment_value(self, delta_t=1):\n        self.set_value(self.get_value() + delta_t)\n\n\n\n\n[docs]\nclass Integer(DecimalNumber):\n    \"\"\"A class for displaying Integers.\n\n    Examples\n    --------\n\n    .. manim:: IntegerExample\n        :save_last_frame:\n\n        class IntegerExample(Scene):\n            def construct(self):\n                self.add(Integer(number=2.5).set_color(ORANGE).scale(2.5).set_x(-0.5).set_y(0.8))\n                self.add(Integer(number=3.14159, show_ellipsis=True).set_x(3).set_y(3.3).scale(3.14159))\n                self.add(Integer(number=42).set_x(2.5).set_y(-2.3).set_color_by_gradient(BLUE, TEAL).scale(1.7))\n                self.add(Integer(number=6.28).set_x(-1.5).set_y(-2).set_color(YELLOW).scale(1.4))\n    \"\"\"\n\n    def __init__(\n        self, number: float = 0, num_decimal_places: int = 0, **kwargs: Any\n    ) -> None:\n        super().__init__(number=number, num_decimal_places=num_decimal_places, **kwargs)\n\n    def get_value(self):\n        return int(np.round(super().get_value()))\n\n\n\n\n[docs]\nclass Variable(VMobject, metaclass=ConvertToOpenGL):\n    \"\"\"A class for displaying text that shows \"label = value\" with\n    the value continuously updated from a :class:`~.ValueTracker`.\n\n    Parameters\n    ----------\n    var\n        The initial value you need to keep track of and display.\n    label\n        The label for your variable. Raw strings are convertex to :class:`~.MathTex` objects.\n    var_type\n        The class used for displaying the number. Defaults to :class:`DecimalNumber`.\n    num_decimal_places\n        The number of decimal places to display in your variable. Defaults to 2.\n        If `var_type` is an :class:`Integer`, this parameter is ignored.\n    kwargs\n            Other arguments to be passed to `~.Mobject`.\n\n    Attributes\n    ----------\n    label : Union[:class:`str`, :class:`~.Tex`, :class:`~.MathTex`, :class:`~.Text`, :class:`~.SingleStringMathTex`]\n        The label for your variable, for example ``x = ...``.\n    tracker : :class:`~.ValueTracker`\n        Useful in updating the value of your variable on-screen.\n    value : Union[:class:`DecimalNumber`, :class:`Integer`]\n        The tex for the value of your variable.\n\n    Examples\n    --------\n    Normal usage::\n\n        # DecimalNumber type\n        var = 0.5\n        on_screen_var = Variable(var, Text(\"var\"), num_decimal_places=3)\n        # Integer type\n        int_var = 0\n        on_screen_int_var = Variable(int_var, Text(\"int_var\"), var_type=Integer)\n        # Using math mode for the label\n        on_screen_int_var = Variable(int_var, \"{a}_{i}\", var_type=Integer)\n\n    .. manim:: VariablesWithValueTracker\n\n        class VariablesWithValueTracker(Scene):\n            def construct(self):\n                var = 0.5\n                on_screen_var = Variable(var, Text(\"var\"), num_decimal_places=3)\n\n                # You can also change the colours for the label and value\n                on_screen_var.label.set_color(RED)\n                on_screen_var.value.set_color(GREEN)\n\n                self.play(Write(on_screen_var))\n                # The above line will just display the variable with\n                # its initial value on the screen. If you also wish to\n                # update it, you can do so by accessing the `tracker` attribute\n                self.wait()\n                var_tracker = on_screen_var.tracker\n                var = 10.5\n                self.play(var_tracker.animate.set_value(var))\n                self.wait()\n\n                int_var = 0\n                on_screen_int_var = Variable(\n                    int_var, Text(\"int_var\"), var_type=Integer\n                ).next_to(on_screen_var, DOWN)\n                on_screen_int_var.label.set_color(RED)\n                on_screen_int_var.value.set_color(GREEN)\n\n                self.play(Write(on_screen_int_var))\n                self.wait()\n                var_tracker = on_screen_int_var.tracker\n                var = 10.5\n                self.play(var_tracker.animate.set_value(var))\n                self.wait()\n\n                # If you wish to have a somewhat more complicated label for your\n                # variable with subscripts, superscripts, etc. the default class\n                # for the label is MathTex\n                subscript_label_var = 10\n                on_screen_subscript_var = Variable(subscript_label_var, \"{a}_{i}\").next_to(\n                    on_screen_int_var, DOWN\n                )\n                self.play(Write(on_screen_subscript_var))\n                self.wait()\n\n    .. manim:: VariableExample\n\n        class VariableExample(Scene):\n            def construct(self):\n                start = 2.0\n\n                x_var = Variable(start, 'x', num_decimal_places=3)\n                sqr_var = Variable(start**2, 'x^2', num_decimal_places=3)\n                Group(x_var, sqr_var).arrange(DOWN)\n\n                sqr_var.add_updater(lambda v: v.tracker.set_value(x_var.tracker.get_value()**2))\n\n                self.add(x_var, sqr_var)\n                self.play(x_var.tracker.animate.set_value(5), run_time=2, rate_func=linear)\n                self.wait(0.1)\n\n    \"\"\"\n\n    def __init__(\n        self,\n        var: float,\n        label: str | Tex | MathTex | Text | SingleStringMathTex,\n        var_type: DecimalNumber | Integer = DecimalNumber,\n        num_decimal_places: int = 2,\n        **kwargs,\n    ):\n        self.label = MathTex(label) if isinstance(label, str) else label\n        equals = MathTex(\"=\").next_to(self.label, RIGHT)\n        self.label.add(equals)\n\n        self.tracker = ValueTracker(var)\n\n        if var_type == DecimalNumber:\n            self.value = DecimalNumber(\n                self.tracker.get_value(),\n                num_decimal_places=num_decimal_places,\n            )\n        elif var_type == Integer:\n            self.value = Integer(self.tracker.get_value())\n\n        self.value.add_updater(lambda v: v.set_value(self.tracker.get_value())).next_to(\n            self.label,\n            RIGHT,\n        )\n\n        super().__init__(**kwargs)\n        self.add(self.label, self.value)", "code_sha1": "79cddffde3372589b2d982d30cdd8d9621fa7562"}
{"url": "https://docs.manim.community/en/stable/_modules/manim/mobject/text/tex_mobject.html", "depth": 2, "instruction": "The code defines various LaTeX-rendering mobjects in Manim, including `SingleStringMathTex`, `MathTex`, `Tex`, `BulletedList`, and `Title`. These mobjects can display text with customizable properties like color, font size, and alignment, and support animations such as fading and arranging. They can also include underlines and bullet points, enhancing visual presentation in scenes.", "code": "r\"\"\"Mobjects representing text rendered using LaTeX.\n\n.. important::\n\n   See the corresponding tutorial :ref:`rendering-with-latex`\n\n.. note::\n\n   Just as you can use :class:`~.Text` (from the module :mod:`~.text_mobject`) to add text to your videos, you can use :class:`~.Tex` and :class:`~.MathTex` to insert LaTeX.\n\n\"\"\"\n\nfrom __future__ import annotations\n\nfrom manim.utils.color import BLACK, ManimColor, ParsableManimColor\n\n__all__ = [\n    \"SingleStringMathTex\",\n    \"MathTex\",\n    \"Tex\",\n    \"BulletedList\",\n    \"Title\",\n]\n\n\nimport itertools as it\nimport operator as op\nimport re\nfrom collections.abc import Iterable\nfrom functools import reduce\nfrom textwrap import dedent\n\nfrom manim import config, logger\nfrom manim.constants import *\nfrom manim.mobject.geometry.line import Line\nfrom manim.mobject.svg.svg_mobject import SVGMobject\nfrom manim.mobject.types.vectorized_mobject import VGroup, VMobject\nfrom manim.utils.tex import TexTemplate\nfrom manim.utils.tex_file_writing import tex_to_svg_file\n\ntex_string_to_mob_map = {}\n\n\n\n[docs]\nclass SingleStringMathTex(SVGMobject):\n    \"\"\"Elementary building block for rendering text with LaTeX.\n\n    Tests\n    -----\n    Check that creating a :class:`~.SingleStringMathTex` object works::\nSingleStringMathTex('Test') # doctest: +SKIP\n        SingleStringMathTex('Test')\n    \"\"\"\n\n    def __init__(\n        self,\n        tex_string: str,\n        stroke_width: float = 0,\n        should_center: bool = True,\n        height: float | None = None,\n        organize_left_to_right: bool = False,\n        tex_environment: str = \"align*\",\n        tex_template: TexTemplate | None = None,\n        font_size: float = DEFAULT_FONT_SIZE,\n        color: ParsableManimColor | None = None,\n        **kwargs,\n    ):\n        if color is None:\n            color = VMobject().color\n\n        self._font_size = font_size\n        self.organize_left_to_right = organize_left_to_right\n        self.tex_environment = tex_environment\n        if tex_template is None:\n            tex_template = config[\"tex_template\"]\n        self.tex_template = tex_template\n\n        assert isinstance(tex_string, str)\n        self.tex_string = tex_string\n        file_name = tex_to_svg_file(\n            self._get_modified_expression(tex_string),\n            environment=self.tex_environment,\n            tex_template=self.tex_template,\n        )\n        super().__init__(\n            file_name=file_name,\n            should_center=should_center,\n            stroke_width=stroke_width,\n            height=height,\n            color=color,\n            path_string_config={\n                \"should_subdivide_sharp_curves\": True,\n                \"should_remove_null_curves\": True,\n            },\n            **kwargs,\n        )\n        self.init_colors()\n\n        # used for scaling via font_size.setter\n        self.initial_height = self.height\n\n        if height is None:\n            self.font_size = self._font_size\n\n        if self.organize_left_to_right:\n            self._organize_submobjects_left_to_right()\n\n    def __repr__(self):\n        return f\"{type(self).__name__}({repr(self.tex_string)})\"\n\n    @property\n    def font_size(self):\n        \"\"\"The font size of the tex mobject.\"\"\"\n        return self.height / self.initial_height / SCALE_FACTOR_PER_FONT_POINT\n\n    @font_size.setter\n    def font_size(self, font_val):\n        if font_val <= 0:\n            raise ValueError(\"font_size must be greater than 0.\")\n        elif self.height > 0:\n            # sometimes manim generates a SingleStringMathex mobject with 0 height.\n            # can't be scaled regardless and will error without the elif.\n\n            # scale to a factor of the initial height so that setting\n            # font_size does not depend on current size.\n            self.scale(font_val / self.font_size)\n\n    def _get_modified_expression(self, tex_string):\n        result = tex_string\n        result = result.strip()\n        result = self._modify_special_strings(result)\n        return result\n\n    def _modify_special_strings(self, tex):\n        tex = tex.strip()\n        should_add_filler = reduce(\n            op.or_,\n            [\n                # Fraction line needs something to be over\n                tex == \"\\\\over\",\n                tex == \"\\\\overline\",\n                # Make sure sqrt has overbar\n                tex == \"\\\\sqrt\",\n                tex == \"\\\\sqrt{\",\n                # Need to add blank subscript or superscript\n                tex.endswith(\"_\"),\n                tex.endswith(\"^\"),\n                tex.endswith(\"dot\"),\n            ],\n        )\n\n        if should_add_filler:\n            filler = \"{\\\\quad}\"\n            tex += filler\n\n        if tex == \"\\\\substack\":\n            tex = \"\\\\quad\"\n\n        if tex == \"\":\n            tex = \"\\\\quad\"\n\n        # To keep files from starting with a line break\n        if tex.startswith(\"\\\\\\\\\"):\n            tex = tex.replace(\"\\\\\\\\\", \"\\\\quad\\\\\\\\\")\n\n        # Handle imbalanced \\left and \\right\n        num_lefts, num_rights = (\n            len([s for s in tex.split(substr)[1:] if s and s[0] in \"(){}[]|.\\\\\"])\n            for substr in (\"\\\\left\", \"\\\\right\")\n        )\n        if num_lefts != num_rights:\n            tex = tex.replace(\"\\\\left\", \"\\\\big\")\n            tex = tex.replace(\"\\\\right\", \"\\\\big\")\n\n        tex = self._remove_stray_braces(tex)\n\n        for context in [\"array\"]:\n            begin_in = (\"\\\\begin{%s}\" % context) in tex  # noqa: UP031\n            end_in = (\"\\\\end{%s}\" % context) in tex  # noqa: UP031\n            if begin_in ^ end_in:\n                # Just turn this into a blank string,\n                # which means caller should leave a\n                # stray \\\\begin{...} with other symbols\n                tex = \"\"\n        return tex\n\n\n[docs]\n    def _remove_stray_braces(self, tex):\n        r\"\"\"\n        Makes :class:`~.MathTex` resilient to unmatched braces.\n\n        This is important when the braces in the TeX code are spread over\n        multiple arguments as in, e.g., ``MathTex(r\"e^{i\", r\"\\tau} = 1\")``.\n        \"\"\"\n        # \"\\{\" does not count (it's a brace literal), but \"\\\\{\" counts (it's a new line and then brace)\n        num_lefts = tex.count(\"{\") - tex.count(\"\\\\{\") + tex.count(\"\\\\\\\\{\")\n        num_rights = tex.count(\"}\") - tex.count(\"\\\\}\") + tex.count(\"\\\\\\\\}\")\n        while num_rights > num_lefts:\n            tex = \"{\" + tex\n            num_lefts += 1\n        while num_lefts > num_rights:\n            tex = tex + \"}\"\n            num_rights += 1\n        return tex\n\n\n    def _organize_submobjects_left_to_right(self):\n        self.sort(lambda p: p[0])\n        return self\n\n    def get_tex_string(self):\n        return self.tex_string\n\n\n[docs]\n    def init_colors(self, propagate_colors=True):\n        for submobject in self.submobjects:\n            # needed to preserve original (non-black)\n            # TeX colors of individual submobjects\n            if submobject.color != BLACK:\n                continue\n            submobject.color = self.color\n            if config.renderer == RendererType.OPENGL:\n                submobject.init_colors()\n            elif config.renderer == RendererType.CAIRO:\n                submobject.init_colors(propagate_colors=propagate_colors)\n\n\n\n\n\n[docs]\nclass MathTex(SingleStringMathTex):\n    r\"\"\"A string compiled with LaTeX in math mode.\n\n    Examples\n    --------\n    .. manim:: Formula\n        :save_last_frame:\n\n        class Formula(Scene):\n            def construct(self):\n                t = MathTex(r\"\\int_a^b f'(x) dx = f(b)- f(a)\")\n                self.add(t)\n\n    Tests\n    -----\n    Check that creating a :class:`~.MathTex` works::\nMathTex('a^2 + b^2 = c^2') # doctest: +SKIP\n        MathTex('a^2 + b^2 = c^2')\n\n    Check that double brace group splitting works correctly::\nt1 = MathTex('{{ a }} + {{ b }} = {{ c }}') # doctest: +SKIP\nlen(t1.submobjects) # doctest: +SKIP\n        5\nt2 = MathTex(r\"\\frac{1}{a+b\\sqrt{2}}\") # doctest: +SKIP\nlen(t2.submobjects) # doctest: +SKIP\n        1\n\n    \"\"\"\n\n    def __init__(\n        self,\n        *tex_strings,\n        arg_separator: str = \" \",\n        substrings_to_isolate: Iterable[str] | None = None,\n        tex_to_color_map: dict[str, ManimColor] = None,\n        tex_environment: str = \"align*\",\n        **kwargs,\n    ):\n        self.tex_template = kwargs.pop(\"tex_template\", config[\"tex_template\"])\n        self.arg_separator = arg_separator\n        self.substrings_to_isolate = (\n            [] if substrings_to_isolate is None else substrings_to_isolate\n        )\n        self.tex_to_color_map = tex_to_color_map\n        if self.tex_to_color_map is None:\n            self.tex_to_color_map = {}\n        self.tex_environment = tex_environment\n        self.brace_notation_split_occurred = False\n        self.tex_strings = self._break_up_tex_strings(tex_strings)\n        try:\n            super().__init__(\n                self.arg_separator.join(self.tex_strings),\n                tex_environment=self.tex_environment,\n                tex_template=self.tex_template,\n                **kwargs,\n            )\n            self._break_up_by_substrings()\n        except ValueError as compilation_error:\n            if self.brace_notation_split_occurred:\n                logger.error(\n                    dedent(\n                        \"\"\"\\\n                        A group of double braces, {{ ... }}, was detected in\n                        your string. Manim splits TeX strings at the double\n                        braces, which might have caused the current\n                        compilation error. If you didn't use the double brace\n                        split intentionally, add spaces between the braces to\n                        avoid the automatic splitting: {{ ... }} --> { { ... } }.\n                        \"\"\",\n                    ),\n                )\n            raise compilation_error\n        self.set_color_by_tex_to_color_map(self.tex_to_color_map)\n\n        if self.organize_left_to_right:\n            self._organize_submobjects_left_to_right()\n\n    def _break_up_tex_strings(self, tex_strings):\n        # Separate out anything surrounded in double braces\n        pre_split_length = len(tex_strings)\n        tex_strings = [re.split(\"{{(.*?)}}\", str(t)) for t in tex_strings]\n        tex_strings = sum(tex_strings, [])\n        if len(tex_strings) > pre_split_length:\n            self.brace_notation_split_occurred = True\n\n        # Separate out any strings specified in the isolate\n        # or tex_to_color_map lists.\n        patterns = []\n        patterns.extend(\n            [\n                f\"({re.escape(ss)})\"\n                for ss in it.chain(\n                    self.substrings_to_isolate,\n                    self.tex_to_color_map.keys(),\n                )\n            ],\n        )\n        pattern = \"|\".join(patterns)\n        if pattern:\n            pieces = []\n            for s in tex_strings:\n                pieces.extend(re.split(pattern, s))\n        else:\n            pieces = tex_strings\n        return [p for p in pieces if p]\n\n\n[docs]\n    def _break_up_by_substrings(self):\n        \"\"\"\n        Reorganize existing submobjects one layer\n        deeper based on the structure of tex_strings (as a list\n        of tex_strings)\n        \"\"\"\n        new_submobjects = []\n        curr_index = 0\n        for tex_string in self.tex_strings:\n            sub_tex_mob = SingleStringMathTex(\n                tex_string,\n                tex_environment=self.tex_environment,\n                tex_template=self.tex_template,\n            )\n            num_submobs = len(sub_tex_mob.submobjects)\n            new_index = (\n                curr_index + num_submobs + len(\"\".join(self.arg_separator.split()))\n            )\n            if num_submobs == 0:\n                last_submob_index = min(curr_index, len(self.submobjects) - 1)\n                sub_tex_mob.move_to(self.submobjects[last_submob_index], RIGHT)\n            else:\n                sub_tex_mob.submobjects = self.submobjects[curr_index:new_index]\n            new_submobjects.append(sub_tex_mob)\n            curr_index = new_index\n        self.submobjects = new_submobjects\n        return self\n\n\n    def get_parts_by_tex(self, tex, substring=True, case_sensitive=True):\n        def test(tex1, tex2):\n            if not case_sensitive:\n                tex1 = tex1.lower()\n                tex2 = tex2.lower()\n            if substring:\n                return tex1 in tex2\n            else:\n                return tex1 == tex2\n\n        return VGroup(*(m for m in self.submobjects if test(tex, m.get_tex_string())))\n\n    def get_part_by_tex(self, tex, **kwargs):\n        all_parts = self.get_parts_by_tex(tex, **kwargs)\n        return all_parts[0] if all_parts else None\n\n    def set_color_by_tex(self, tex, color, **kwargs):\n        parts_to_color = self.get_parts_by_tex(tex, **kwargs)\n        for part in parts_to_color:\n            part.set_color(color)\n        return self\n\n\n[docs]\n    def set_opacity_by_tex(\n        self, tex: str, opacity: float = 0.5, remaining_opacity: float = None, **kwargs\n    ):\n        \"\"\"\n        Sets the opacity of the tex specified. If 'remaining_opacity' is specified,\n        then the remaining tex will be set to that opacity.\n\n        Parameters\n        ----------\n        tex\n            The tex to set the opacity of.\n        opacity\n            Default 0.5. The opacity to set the tex to\n        remaining_opacity\n            Default None. The opacity to set the remaining tex to.\n            If None, then the remaining tex will not be changed\n        \"\"\"\n        if remaining_opacity is not None:\n            self.set_opacity(opacity=remaining_opacity)\n        for part in self.get_parts_by_tex(tex):\n            part.set_opacity(opacity)\n        return self\n\n\n    def set_color_by_tex_to_color_map(self, texs_to_color_map, **kwargs):\n        for texs, color in list(texs_to_color_map.items()):\n            try:\n                # If the given key behaves like tex_strings\n                texs + \"\"\n                self.set_color_by_tex(texs, color, **kwargs)\n            except TypeError:\n                # If the given key is a tuple\n                for tex in texs:\n                    self.set_color_by_tex(tex, color, **kwargs)\n        return self\n\n    def index_of_part(self, part):\n        split_self = self.split()\n        if part not in split_self:\n            raise ValueError(\"Trying to get index of part not in MathTex\")\n        return split_self.index(part)\n\n    def index_of_part_by_tex(self, tex, **kwargs):\n        part = self.get_part_by_tex(tex, **kwargs)\n        return self.index_of_part(part)\n\n    def sort_alphabetically(self):\n        self.submobjects.sort(key=lambda m: m.get_tex_string())\n\n\n\n\n[docs]\nclass Tex(MathTex):\n    r\"\"\"A string compiled with LaTeX in normal mode.\n\n    The color can be set using\n    the ``color`` argument. Any parts of the ``tex_string`` that are colored by the\n    TeX commands ``\\color`` or ``\\textcolor`` will retain their original color.\n\n    Tests\n    -----\n\n    Check whether writing a LaTeX string works::\nTex('The horse does not eat cucumber salad.') # doctest: +SKIP\n        Tex('The horse does not eat cucumber salad.')\n\n    \"\"\"\n\n    def __init__(\n        self, *tex_strings, arg_separator=\"\", tex_environment=\"center\", **kwargs\n    ):\n        super().__init__(\n            *tex_strings,\n            arg_separator=arg_separator,\n            tex_environment=tex_environment,\n            **kwargs,\n        )\n\n\n\n\n[docs]\nclass BulletedList(Tex):\n    \"\"\"A bulleted list.\n\n    Examples\n    --------\n\n    .. manim:: BulletedListExample\n        :save_last_frame:\n\n        class BulletedListExample(Scene):\n            def construct(self):\n                blist = BulletedList(\"Item 1\", \"Item 2\", \"Item 3\", height=2, width=2)\n                blist.set_color_by_tex(\"Item 1\", RED)\n                blist.set_color_by_tex(\"Item 2\", GREEN)\n                blist.set_color_by_tex(\"Item 3\", BLUE)\n                self.add(blist)\n    \"\"\"\n\n    def __init__(\n        self,\n        *items,\n        buff=MED_LARGE_BUFF,\n        dot_scale_factor=2,\n        tex_environment=None,\n        **kwargs,\n    ):\n        self.buff = buff\n        self.dot_scale_factor = dot_scale_factor\n        self.tex_environment = tex_environment\n        line_separated_items = [s + \"\\\\\\\\\" for s in items]\n        super().__init__(\n            *line_separated_items, tex_environment=tex_environment, **kwargs\n        )\n        for part in self:\n            dot = MathTex(\"\\\\cdot\").scale(self.dot_scale_factor)\n            dot.next_to(part[0], LEFT, SMALL_BUFF)\n            part.add_to_back(dot)\n        self.arrange(DOWN, aligned_edge=LEFT, buff=self.buff)\n\n    def fade_all_but(self, index_or_string, opacity=0.5):\n        arg = index_or_string\n        if isinstance(arg, str):\n            part = self.get_part_by_tex(arg)\n        elif isinstance(arg, int):\n            part = self.submobjects[arg]\n        else:\n            raise TypeError(f\"Expected int or string, got {arg}\")\n        for other_part in self.submobjects:\n            if other_part is part:\n                other_part.set_fill(opacity=1)\n            else:\n                other_part.set_fill(opacity=opacity)\n\n\n\n\n[docs]\nclass Title(Tex):\n    \"\"\"A mobject representing an underlined title.\n\n    Examples\n    --------\n    .. manim:: TitleExample\n        :save_last_frame:\n\n        import manim\n\n        class TitleExample(Scene):\n            def construct(self):\n                banner = ManimBanner()\n                title = Title(f\"Manim version {manim.__version__}\")\n                self.add(banner, title)\n\n    \"\"\"\n\n    def __init__(\n        self,\n        *text_parts,\n        include_underline=True,\n        match_underline_width_to_text=False,\n        underline_buff=MED_SMALL_BUFF,\n        **kwargs,\n    ):\n        self.include_underline = include_underline\n        self.match_underline_width_to_text = match_underline_width_to_text\n        self.underline_buff = underline_buff\n        super().__init__(*text_parts, **kwargs)\n        self.to_edge(UP)\n        if self.include_underline:\n            underline_width = config[\"frame_width\"] - 2\n            underline = Line(LEFT, RIGHT)\n            underline.next_to(self, DOWN, buff=self.underline_buff)\n            if self.match_underline_width_to_text:\n                underline.match_width(self)\n            else:\n                underline.width = underline_width\n            self.add(underline)\n            self.underline = underline", "code_sha1": "b191205f7de2c5c5b00be53b2ab6a9fd03d0d825"}
{"url": "https://docs.manim.community/en/stable/_modules/manim/mobject/text/text_mobject.html", "depth": 2, "instruction": "The code generates a scene displaying the text \"K-means clustering and Logistic Regression\" in white, scaled to 0.75, positioned at the top edge. Below, four additional text items (\"1. Measuring\", \"2. Clustering\", \"3. Regression\", \"4. Prediction\") are arranged vertically, slightly transparent, with full opacity for the second item, and aligned to the left.", "code": "\"\"\"Mobjects used for displaying (non-LaTeX) text.\n\n.. note::\n   Just as you can use :class:`~.Tex` and :class:`~.MathTex` (from the module :mod:`~.tex_mobject`)\n   to insert LaTeX to your videos, you can use :class:`~.Text` to to add normal text.\n\n.. important::\n\n   See the corresponding tutorial :ref:`using-text-objects`, especially for information about fonts.\n\n\nThe simplest way to add text to your animations is to use the :class:`~.Text` class. It uses the Pango library to render text.\nWith Pango, you are also able to render non-English alphabets like `你好` or  `こんにちは` or `안녕하세요` or `مرحبا بالعالم`.\n\nExamples\n--------\n\n.. manim:: HelloWorld\n    :save_last_frame:\n\n    class HelloWorld(Scene):\n        def construct(self):\n            text = Text('Hello world').scale(3)\n            self.add(text)\n\n.. manim:: TextAlignment\n    :save_last_frame:\n\n    class TextAlignment(Scene):\n        def construct(self):\n            title = Text(\"K-means clustering and Logistic Regression\", color=WHITE)\n            title.scale(0.75)\n            self.add(title.to_edge(UP))\n\n            t1 = Text(\"1. Measuring\").set_color(WHITE)\n\n            t2 = Text(\"2. Clustering\").set_color(WHITE)\n\n            t3 = Text(\"3. Regression\").set_color(WHITE)\n\n            t4 = Text(\"4. Prediction\").set_color(WHITE)\n\n            x = VGroup(t1, t2, t3, t4).arrange(direction=DOWN, aligned_edge=LEFT).scale(0.7).next_to(ORIGIN,DR)\n            x.set_opacity(0.5)\n            x.submobjects[1].set_opacity(1)\n            self.add(x)\n\n\"\"\"\n\nfrom __future__ import annotations\n\nimport functools\n\n__all__ = [\"Text\", \"Paragraph\", \"MarkupText\", \"register_font\"]\n\n\nimport copy\nimport hashlib\nimport re\nfrom collections.abc import Iterable, Sequence\nfrom contextlib import contextmanager\nfrom itertools import chain\nfrom pathlib import Path\n\nimport manimpango\nimport numpy as np\nfrom manimpango import MarkupUtils, PangoUtils, TextSetting\n\nfrom manim import config, logger\nfrom manim.constants import *\nfrom manim.mobject.geometry.arc import Dot\nfrom manim.mobject.svg.svg_mobject import SVGMobject\nfrom manim.mobject.types.vectorized_mobject import VGroup, VMobject\nfrom manim.utils.color import ManimColor, ParsableManimColor, color_gradient\nfrom manim.utils.deprecation import deprecated\n\nTEXT_MOB_SCALE_FACTOR = 0.05\nDEFAULT_LINE_SPACING_SCALE = 0.3\nTEXT2SVG_ADJUSTMENT_FACTOR = 4.8\n\n__all__ = [\"Text\", \"Paragraph\", \"MarkupText\", \"register_font\"]\n\n\n\n[docs]\ndef remove_invisible_chars(mobject: SVGMobject) -> SVGMobject:\n    \"\"\"Function to remove unwanted invisible characters from some mobjects.\n\n    Parameters\n    ----------\n    mobject\n        Any SVGMobject from which we want to remove unwanted invisible characters.\n\n    Returns\n    -------\n    :class:`~.SVGMobject`\n        The SVGMobject without unwanted invisible characters.\n    \"\"\"\n    # TODO: Refactor needed\n    iscode = False\n    if mobject.__class__.__name__ == \"Text\":\n        mobject = mobject[:]\n    elif mobject.__class__.__name__ == \"Code\":\n        iscode = True\n        code = mobject\n        mobject = mobject.code\n    mobject_without_dots = VGroup()\n    if mobject[0].__class__ == VGroup:\n        for i in range(len(mobject)):\n            mobject_without_dots.add(VGroup())\n            mobject_without_dots[i].add(*(k for k in mobject[i] if k.__class__ != Dot))\n    else:\n        mobject_without_dots.add(*(k for k in mobject if k.__class__ != Dot))\n    if iscode:\n        code.code = mobject_without_dots\n        return code\n    return mobject_without_dots\n\n\n\n\n[docs]\nclass Paragraph(VGroup):\n    r\"\"\"Display a paragraph of text.\n\n    For a given :class:`.Paragraph` ``par``, the attribute ``par.chars`` is a\n    :class:`.VGroup` containing all the lines. In this context, every line is\n    constructed as a :class:`.VGroup` of characters contained in the line.\n\n\n    Parameters\n    ----------\n    line_spacing\n        Represents the spacing between lines. Defaults to -1, which means auto.\n    alignment\n        Defines the alignment of paragraph. Defaults to None. Possible values are \"left\", \"right\" or \"center\".\n\n    Examples\n    --------\n    Normal usage::\n\n        paragraph = Paragraph(\n            \"this is a awesome\",\n            \"paragraph\",\n            \"With \\nNewlines\",\n            \"\\tWith Tabs\",\n            \"  With Spaces\",\n            \"With Alignments\",\n            \"center\",\n            \"left\",\n            \"right\",\n        )\n\n    Remove unwanted invisible characters::\n\n        self.play(Transform(remove_invisible_chars(paragraph.chars[0:2]),\n                            remove_invisible_chars(paragraph.chars[3][0:3]))\n\n    \"\"\"\n\n    def __init__(\n        self,\n        *text: Sequence[str],\n        line_spacing: float = -1,\n        alignment: str | None = None,\n        **kwargs,\n    ) -> None:\n        self.line_spacing = line_spacing\n        self.alignment = alignment\n        self.consider_spaces_as_chars = kwargs.get(\"disable_ligatures\", False)\n        super().__init__()\n\n        lines_str = \"\\n\".join(list(text))\n        self.lines_text = Text(lines_str, line_spacing=line_spacing, **kwargs)\n        lines_str_list = lines_str.split(\"\\n\")\n        self.chars = self._gen_chars(lines_str_list)\n\n        self.lines = [list(self.chars), [self.alignment] * len(self.chars)]\n        self.lines_initial_positions = [line.get_center() for line in self.lines[0]]\n        self.add(*self.lines[0])\n        self.move_to(np.array([0, 0, 0]))\n        if self.alignment:\n            self._set_all_lines_alignments(self.alignment)\n\n\n[docs]\n    def _gen_chars(self, lines_str_list: list) -> VGroup:\n        \"\"\"Function to convert a list of plain strings to a VGroup of VGroups of chars.\n\n        Parameters\n        ----------\n        lines_str_list\n            List of plain text strings.\n\n        Returns\n        -------\n        :class:`~.VGroup`\n            The generated 2d-VGroup of chars.\n        \"\"\"\n        char_index_counter = 0\n        chars = self.get_group_class()()\n        for line_no in range(len(lines_str_list)):\n            line_str = lines_str_list[line_no]\n            # Count all the characters in line_str\n            # Spaces may or may not count as characters\n            if self.consider_spaces_as_chars:\n                char_count = len(line_str)\n            else:\n                char_count = 0\n                for char in line_str:\n                    if not char.isspace():\n                        char_count += 1\n\n            chars.add(self.get_group_class()())\n            chars[line_no].add(\n                *self.lines_text.chars[\n                    char_index_counter : char_index_counter + char_count\n                ]\n            )\n            char_index_counter += char_count\n            if self.consider_spaces_as_chars:\n                # If spaces count as characters, count the extra \\n character\n                # which separates Paragraph's lines to avoid issues\n                char_index_counter += 1\n        return chars\n\n\n\n[docs]\n    def _set_all_lines_alignments(self, alignment: str) -> Paragraph:\n        \"\"\"Function to set all line's alignment to a specific value.\n\n        Parameters\n        ----------\n        alignment\n            Defines the alignment of paragraph. Possible values are \"left\", \"right\", \"center\".\n        \"\"\"\n        for line_no in range(len(self.lines[0])):\n            self._change_alignment_for_a_line(alignment, line_no)\n        return self\n\n\n\n[docs]\n    def _set_line_alignment(self, alignment: str, line_no: int) -> Paragraph:\n        \"\"\"Function to set one line's alignment to a specific value.\n\n        Parameters\n        ----------\n        alignment\n            Defines the alignment of paragraph. Possible values are \"left\", \"right\", \"center\".\n        line_no\n            Defines the line number for which we want to set given alignment.\n        \"\"\"\n        self._change_alignment_for_a_line(alignment, line_no)\n        return self\n\n\n\n[docs]\n    def _set_all_lines_to_initial_positions(self) -> Paragraph:\n        \"\"\"Set all lines to their initial positions.\"\"\"\n        self.lines[1] = [None] * len(self.lines[0])\n        for line_no in range(len(self.lines[0])):\n            self[line_no].move_to(\n                self.get_center() + self.lines_initial_positions[line_no],\n            )\n        return self\n\n\n\n[docs]\n    def _set_line_to_initial_position(self, line_no: int) -> Paragraph:\n        \"\"\"Function to set one line to initial positions.\n\n        Parameters\n        ----------\n        line_no\n            Defines the line number for which we want to set given alignment.\n        \"\"\"\n        self.lines[1][line_no] = None\n        self[line_no].move_to(self.get_center() + self.lines_initial_positions[line_no])\n        return self\n\n\n\n[docs]\n    def _change_alignment_for_a_line(self, alignment: str, line_no: int) -> None:\n        \"\"\"Function to change one line's alignment to a specific value.\n\n        Parameters\n        ----------\n        alignment\n            Defines the alignment of paragraph. Possible values are \"left\", \"right\", \"center\".\n        line_no\n            Defines the line number for which we want to set given alignment.\n        \"\"\"\n        self.lines[1][line_no] = alignment\n        if self.lines[1][line_no] == \"center\":\n            self[line_no].move_to(\n                np.array([self.get_center()[0], self[line_no].get_center()[1], 0]),\n            )\n        elif self.lines[1][line_no] == \"right\":\n            self[line_no].move_to(\n                np.array(\n                    [\n                        self.get_right()[0] - self[line_no].width / 2,\n                        self[line_no].get_center()[1],\n                        0,\n                    ],\n                ),\n            )\n        elif self.lines[1][line_no] == \"left\":\n            self[line_no].move_to(\n                np.array(\n                    [\n                        self.get_left()[0] + self[line_no].width / 2,\n                        self[line_no].get_center()[1],\n                        0,\n                    ],\n                ),\n            )\n\n\n\n\n\n[docs]\nclass Text(SVGMobject):\n    r\"\"\"Display (non-LaTeX) text rendered using `Pango <https://pango.gnome.org/>`_.\n\n    Text objects behave like a :class:`.VGroup`-like iterable of all characters\n    in the given text. In particular, slicing is possible.\n\n    Parameters\n    ----------\n    text\n        The text that needs to be created as a mobject.\n    font\n        The font family to be used to render the text. This is either a system font or\n        one loaded with `register_font()`. Note that font family names may be different\n        across operating systems.\n    warn_missing_font\n        If True (default), Manim will issue a warning if the font does not exist in the\n        (case-sensitive) list of fonts returned from `manimpango.list_fonts()`.\n\n    Returns\n    -------\n    :class:`Text`\n        The mobject-like :class:`.VGroup`.\n\n    Examples\n    ---------\n\n    .. manim:: Example1Text\n        :save_last_frame:\n\n        class Example1Text(Scene):\n            def construct(self):\n                text = Text('Hello world').scale(3)\n                self.add(text)\n\n    .. manim:: TextColorExample\n        :save_last_frame:\n\n        class TextColorExample(Scene):\n            def construct(self):\n                text1 = Text('Hello world', color=BLUE).scale(3)\n                text2 = Text('Hello world', gradient=(BLUE, GREEN)).scale(3).next_to(text1, DOWN)\n                self.add(text1, text2)\n\n    .. manim:: TextItalicAndBoldExample\n        :save_last_frame:\n\n        class TextItalicAndBoldExample(Scene):\n            def construct(self):\n                text1 = Text(\"Hello world\", slant=ITALIC)\n                text2 = Text(\"Hello world\", t2s={'world':ITALIC})\n                text3 = Text(\"Hello world\", weight=BOLD)\n                text4 = Text(\"Hello world\", t2w={'world':BOLD})\n                text5 = Text(\"Hello world\", t2c={'o':YELLOW}, disable_ligatures=True)\n                text6 = Text(\n                    \"Visit us at docs.manim.community\",\n                    t2c={\"docs.manim.community\": YELLOW},\n                    disable_ligatures=True,\n               )\n                text6.scale(1.3).shift(DOWN)\n                self.add(text1, text2, text3, text4, text5 , text6)\n                Group(*self.mobjects).arrange(DOWN, buff=.8).set(height=config.frame_height-LARGE_BUFF)\n\n    .. manim:: TextMoreCustomization\n            :save_last_frame:\n\n            class TextMoreCustomization(Scene):\n                def construct(self):\n                    text1 = Text(\n                        'Google',\n                        t2c={'[:1]': '#3174f0', '[1:2]': '#e53125',\n                             '[2:3]': '#fbb003', '[3:4]': '#3174f0',\n                             '[4:5]': '#269a43', '[5:]': '#e53125'}, font_size=58).scale(3)\n                    self.add(text1)\n\n    As :class:`Text` uses Pango to render text, rendering non-English\n    characters is easily possible:\n\n    .. manim:: MultipleFonts\n        :save_last_frame:\n\n        class MultipleFonts(Scene):\n            def construct(self):\n                morning = Text(\"வணக்கம்\", font=\"sans-serif\")\n                japanese = Text(\n                    \"日本へようこそ\", t2c={\"日本\": BLUE}\n                )  # works same as ``Text``.\n                mess = Text(\"Multi-Language\", weight=BOLD)\n                russ = Text(\"Здравствуйте मस नम म \", font=\"sans-serif\")\n                hin = Text(\"नमस्ते\", font=\"sans-serif\")\n                arb = Text(\n                    \"صباح الخير \\n تشرفت بمقابلتك\", font=\"sans-serif\"\n                )  # don't mix RTL and LTR languages nothing shows up then ;-)\n                chinese = Text(\"臂猿「黛比」帶著孩子\", font=\"sans-serif\")\n                self.add(morning, japanese, mess, russ, hin, arb, chinese)\n                for i,mobj in enumerate(self.mobjects):\n                    mobj.shift(DOWN*(i-3))\n\n\n    .. manim:: PangoRender\n        :quality: low\n\n        class PangoRender(Scene):\n            def construct(self):\n                morning = Text(\"வணக்கம்\", font=\"sans-serif\")\n                self.play(Write(morning))\n                self.wait(2)\n\n    Tests\n    -----\n\n    Check that the creation of :class:`~.Text` works::\nText('The horse does not eat cucumber salad.')\n        Text('The horse does not eat cucumber salad.')\n\n    \"\"\"\n\n    @staticmethod\n    @functools.cache\n    def font_list() -> list[str]:\n        return manimpango.list_fonts()\n\n    def __init__(\n        self,\n        text: str,\n        fill_opacity: float = 1.0,\n        stroke_width: float = 0,\n        color: ParsableManimColor | None = None,\n        font_size: float = DEFAULT_FONT_SIZE,\n        line_spacing: float = -1,\n        font: str = \"\",\n        slant: str = NORMAL,\n        weight: str = NORMAL,\n        t2c: dict[str, str] = None,\n        t2f: dict[str, str] = None,\n        t2g: dict[str, tuple] = None,\n        t2s: dict[str, str] = None,\n        t2w: dict[str, str] = None,\n        gradient: tuple = None,\n        tab_width: int = 4,\n        warn_missing_font: bool = True,\n        # Mobject\n        height: float = None,\n        width: float = None,\n        should_center: bool = True,\n        disable_ligatures: bool = False,\n        use_svg_cache: bool = False,\n        **kwargs,\n    ) -> None:\n        self.line_spacing = line_spacing\n        if font and warn_missing_font:\n            fonts_list = Text.font_list()\n            # handle special case of sans/sans-serif\n            if font.lower() == \"sans-serif\":\n                font = \"sans\"\n            if font not in fonts_list:\n                # check if the capitalized version is in the supported fonts\n                if font.capitalize() in fonts_list:\n                    font = font.capitalize()\n                elif font.lower() in fonts_list:\n                    font = font.lower()\n                elif font.title() in fonts_list:\n                    font = font.title()\n                else:\n                    logger.warning(f\"Font {font} not in {fonts_list}.\")\n        self.font = font\n        self._font_size = float(font_size)\n        # needs to be a float or else size is inflated when font_size = 24\n        # (unknown cause)\n        self.slant = slant\n        self.weight = weight\n        self.gradient = gradient\n        self.tab_width = tab_width\n        if t2c is None:\n            t2c = {}\n        if t2f is None:\n            t2f = {}\n        if t2g is None:\n            t2g = {}\n        if t2s is None:\n            t2s = {}\n        if t2w is None:\n            t2w = {}\n        # If long form arguments are present, they take precedence\n        t2c = kwargs.pop(\"text2color\", t2c)\n        t2f = kwargs.pop(\"text2font\", t2f)\n        t2g = kwargs.pop(\"text2gradient\", t2g)\n        t2s = kwargs.pop(\"text2slant\", t2s)\n        t2w = kwargs.pop(\"text2weight\", t2w)\n        self.t2c = {k: ManimColor(v).to_hex() for k, v in t2c.items()}\n        self.t2f = t2f\n        self.t2g = t2g\n        self.t2s = t2s\n        self.t2w = t2w\n\n        self.original_text = text\n        self.disable_ligatures = disable_ligatures\n        text_without_tabs = text\n        if text.find(\"\\t\") != -1:\n            text_without_tabs = text.replace(\"\\t\", \" \" * self.tab_width)\n        self.text = text_without_tabs\n        if self.line_spacing == -1:\n            self.line_spacing = (\n                self._font_size + self._font_size * DEFAULT_LINE_SPACING_SCALE\n            )\n        else:\n            self.line_spacing = self._font_size + self._font_size * self.line_spacing\n\n        color: ManimColor = ManimColor(color) if color else VMobject().color\n        file_name = self._text2svg(color.to_hex())\n        PangoUtils.remove_last_M(file_name)\n        super().__init__(\n            file_name,\n            fill_opacity=fill_opacity,\n            stroke_width=stroke_width,\n            height=height,\n            width=width,\n            should_center=should_center,\n            use_svg_cache=use_svg_cache,\n            **kwargs,\n        )\n        self.text = text\n        if self.disable_ligatures:\n            self.submobjects = [*self._gen_chars()]\n        self.chars = self.get_group_class()(*self.submobjects)\n        self.text = text_without_tabs.replace(\" \", \"\").replace(\"\\n\", \"\")\n        nppc = self.n_points_per_curve\n        for each in self:\n            if len(each.points) == 0:\n                continue\n            points = each.points\n            curve_start = points[0]\n            assert len(curve_start) == self.dim, curve_start\n            # Some of the glyphs in this text might not be closed,\n            # so we close them by identifying when one curve ends\n            # but it is not where the next curve starts.\n            # It is more efficient to temporarily create a list\n            # of points and add them one at a time, then turn them\n            # into a numpy array at the end, rather than creating\n            # new numpy arrays every time a point or fixing line\n            # is added (which is O(n^2) for numpy arrays).\n            closed_curve_points = []\n            # OpenGL has points be part of quadratic Bezier curves;\n            # Cairo uses cubic Bezier curves.\n            if nppc == 3:  # RendererType.OPENGL\n\n                def add_line_to(end):\n                    nonlocal closed_curve_points\n                    start = closed_curve_points[-1]\n                    closed_curve_points += [\n                        start,\n                        (start + end) / 2,\n                        end,\n                    ]\n\n            else:  # RendererType.CAIRO\n\n                def add_line_to(end):\n                    nonlocal closed_curve_points\n                    start = closed_curve_points[-1]\n                    closed_curve_points += [\n                        start,\n                        (start + start + end) / 3,\n                        (start + end + end) / 3,\n                        end,\n                    ]\n\n            for index, point in enumerate(points):\n                closed_curve_points.append(point)\n                if (\n                    index != len(points) - 1\n                    and (index + 1) % nppc == 0\n                    and any(point != points[index + 1])\n                ):\n                    # Add straight line from last point on this curve to the\n                    # start point on the next curve. We represent the line\n                    # as a cubic bezier curve where the two control points\n                    # are half-way between the start and stop point.\n                    add_line_to(curve_start)\n                    curve_start = points[index + 1]\n            # Make sure last curve is closed\n            add_line_to(curve_start)\n            each.points = np.array(closed_curve_points, ndmin=2)\n        # anti-aliasing\n        if height is None and width is None:\n            self.scale(TEXT_MOB_SCALE_FACTOR)\n        self.initial_height = self.height\n\n    def __repr__(self):\n        return f\"Text({repr(self.original_text)})\"\n\n    @property\n    def font_size(self):\n        return (\n            self.height\n            / self.initial_height\n            / TEXT_MOB_SCALE_FACTOR\n            * 2.4\n            * self._font_size\n            / DEFAULT_FONT_SIZE\n        )\n\n    @font_size.setter\n    def font_size(self, font_val):\n        # TODO: use pango's font size scaling.\n        if font_val <= 0:\n            raise ValueError(\"font_size must be greater than 0.\")\n        else:\n            self.scale(font_val / self.font_size)\n\n    def _gen_chars(self):\n        chars = self.get_group_class()()\n        submobjects_char_index = 0\n        for char_index in range(len(self.text)):\n            if self.text[char_index].isspace():\n                space = Dot(radius=0, fill_opacity=0, stroke_opacity=0)\n                if char_index == 0:\n                    space.move_to(self.submobjects[submobjects_char_index].get_center())\n                else:\n                    space.move_to(\n                        self.submobjects[submobjects_char_index - 1].get_center(),\n                    )\n                chars.add(space)\n            else:\n                chars.add(self.submobjects[submobjects_char_index])\n                submobjects_char_index += 1\n        return chars\n\n\n[docs]\n    def _find_indexes(self, word: str, text: str):\n        \"\"\"Finds the indexes of ``text`` in ``word``.\"\"\"\n        temp = re.match(r\"\\[([0-9\\-]{0,}):([0-9\\-]{0,})\\]\", word)\n        if temp:\n            start = int(temp.group(1)) if temp.group(1) != \"\" else 0\n            end = int(temp.group(2)) if temp.group(2) != \"\" else len(text)\n            start = len(text) + start if start < 0 else start\n            end = len(text) + end if end < 0 else end\n            return [(start, end)]\n        indexes = []\n        index = text.find(word)\n        while index != -1:\n            indexes.append((index, index + len(word)))\n            index = text.find(word, index + len(word))\n        return indexes\n\n\n\n[docs]\n    @deprecated(\n        since=\"v0.14.0\",\n        until=\"v0.15.0\",\n        message=\"This was internal function, you shouldn't be using it anyway.\",\n    )\n    def _set_color_by_t2c(self, t2c=None):\n        \"\"\"Sets color for specified strings.\"\"\"\n        t2c = t2c if t2c else self.t2c\n        for word, color in list(t2c.items()):\n            for start, end in self._find_indexes(word, self.text):\n                self.chars[start:end].set_color(color)\n\n\n\n[docs]\n    @deprecated(\n        since=\"v0.14.0\",\n        until=\"v0.15.0\",\n        message=\"This was internal function, you shouldn't be using it anyway.\",\n    )\n    def _set_color_by_t2g(self, t2g=None):\n        \"\"\"Sets gradient colors for specified\n        strings. Behaves similarly to ``set_color_by_t2c``.\n        \"\"\"\n        t2g = t2g if t2g else self.t2g\n        for word, gradient in list(t2g.items()):\n            for start, end in self._find_indexes(word, self.text):\n                self.chars[start:end].set_color_by_gradient(*gradient)\n\n\n\n[docs]\n    def _text2hash(self, color: ManimColor):\n        \"\"\"Generates ``sha256`` hash for file name.\"\"\"\n        settings = (\n            \"PANGO\" + self.font + self.slant + self.weight + str(color)\n        )  # to differentiate Text and CairoText\n        settings += str(self.t2f) + str(self.t2s) + str(self.t2w) + str(self.t2c)\n        settings += str(self.line_spacing) + str(self._font_size)\n        settings += str(self.disable_ligatures)\n        id_str = self.text + settings\n        hasher = hashlib.sha256()\n        hasher.update(id_str.encode())\n        return hasher.hexdigest()[:16]\n\n\n    def _merge_settings(\n        self,\n        left_setting: TextSetting,\n        right_setting: TextSetting,\n        default_args: dict[str, Iterable[str]],\n    ) -> TextSetting:\n        contained = right_setting.end < left_setting.end\n        new_setting = copy.copy(left_setting) if contained else copy.copy(right_setting)\n\n        new_setting.start = right_setting.end if contained else left_setting.end\n        left_setting.end = right_setting.start\n        if not contained:\n            right_setting.end = new_setting.start\n\n        for arg in default_args:\n            left = getattr(left_setting, arg)\n            right = getattr(right_setting, arg)\n            default = default_args[arg]\n            if left != default and getattr(right_setting, arg) != default:\n                raise ValueError(\n                    f\"Ambiguous style for text '{self.text[right_setting.start : right_setting.end]}':\"\n                    + f\"'{arg}' cannot be both '{left}' and '{right}'.\"\n                )\n            setattr(right_setting, arg, left if left != default else right)\n        return new_setting\n\n    def _get_settings_from_t2xs(\n        self,\n        t2xs: Sequence[tuple[dict[str, str], str]],\n        default_args: dict[str, Iterable[str]],\n    ) -> Sequence[TextSetting]:\n        settings = []\n        t2xwords = set(chain(*([*t2x.keys()] for t2x, _ in t2xs)))\n        for word in t2xwords:\n            setting_args = {\n                arg: str(t2x[word]) if word in t2x else default_args[arg]\n                # NOTE: when t2x[word] is a ManimColor, str will yield the\n                # hex representation\n                for t2x, arg in t2xs\n            }\n\n            for start, end in self._find_indexes(word, self.text):\n                settings.append(TextSetting(start, end, **setting_args))\n        return settings\n\n    def _get_settings_from_gradient(\n        self, default_args: dict[str, Iterable[str]]\n    ) -> Sequence[TextSetting]:\n        settings = []\n        args = copy.copy(default_args)\n        if self.gradient:\n            colors = color_gradient(self.gradient, len(self.text))\n            for i in range(len(self.text)):\n                args[\"color\"] = colors[i].to_hex()\n                settings.append(TextSetting(i, i + 1, **args))\n\n        for word, gradient in self.t2g.items():\n            if isinstance(gradient, str) or len(gradient) == 1:\n                color = gradient if isinstance(gradient, str) else gradient[0]\n                gradient = [ManimColor(color)]\n            colors = (\n                color_gradient(gradient, len(word))\n                if len(gradient) != 1\n                else len(word) * gradient\n            )\n            for start, end in self._find_indexes(word, self.text):\n                for i in range(start, end):\n                    args[\"color\"] = colors[i - start].to_hex()\n                    settings.append(TextSetting(i, i + 1, **args))\n        return settings\n\n\n[docs]\n    def _text2settings(self, color: str):\n        \"\"\"Converts the texts and styles to a setting for parsing.\"\"\"\n        t2xs = [\n            (self.t2f, \"font\"),\n            (self.t2s, \"slant\"),\n            (self.t2w, \"weight\"),\n            (self.t2c, \"color\"),\n        ]\n        # setting_args requires values to be strings\n\n        default_args = {\n            arg: getattr(self, arg) if arg != \"color\" else color for _, arg in t2xs\n        }\n\n        settings = self._get_settings_from_t2xs(t2xs, default_args)\n        settings.extend(self._get_settings_from_gradient(default_args))\n\n        # Handle overlaps\n\n        settings.sort(key=lambda setting: setting.start)\n        for index, setting in enumerate(settings):\n            if index + 1 == len(settings):\n                break\n\n            next_setting = settings[index + 1]\n            if setting.end > next_setting.start:\n                new_setting = self._merge_settings(setting, next_setting, default_args)\n                new_index = index + 1\n                while (\n                    new_index < len(settings)\n                    and settings[new_index].start < new_setting.start\n                ):\n                    new_index += 1\n                settings.insert(new_index, new_setting)\n\n        # Set all text settings (default font, slant, weight)\n        temp_settings = settings.copy()\n        start = 0\n        for setting in settings:\n            if setting.start != start:\n                temp_settings.append(TextSetting(start, setting.start, **default_args))\n            start = setting.end\n        if start != len(self.text):\n            temp_settings.append(TextSetting(start, len(self.text), **default_args))\n        settings = sorted(temp_settings, key=lambda setting: setting.start)\n\n        line_num = 0\n        if re.search(r\"\\n\", self.text):\n            for start, end in self._find_indexes(\"\\n\", self.text):\n                for setting in settings:\n                    if setting.line_num == -1:\n                        setting.line_num = line_num\n                    if start < setting.end:\n                        line_num += 1\n                        new_setting = copy.copy(setting)\n                        setting.end = end\n                        new_setting.start = end\n                        new_setting.line_num = line_num\n                        settings.append(new_setting)\n                        settings.sort(key=lambda setting: setting.start)\n                        break\n        for setting in settings:\n            if setting.line_num == -1:\n                setting.line_num = line_num\n\n        return settings\n\n\n\n[docs]\n    def _text2svg(self, color: ManimColor):\n        \"\"\"Convert the text to SVG using Pango.\"\"\"\n        size = self._font_size\n        line_spacing = self.line_spacing\n        size /= TEXT2SVG_ADJUSTMENT_FACTOR\n        line_spacing /= TEXT2SVG_ADJUSTMENT_FACTOR\n\n        dir_name = config.get_dir(\"text_dir\")\n        if not dir_name.is_dir():\n            dir_name.mkdir(parents=True)\n        hash_name = self._text2hash(color)\n        file_name = dir_name / (hash_name + \".svg\")\n\n        if file_name.exists():\n            svg_file = str(file_name.resolve())\n        else:\n            settings = self._text2settings(color)\n            width = config[\"pixel_width\"]\n            height = config[\"pixel_height\"]\n\n            svg_file = manimpango.text2svg(\n                settings,\n                size,\n                line_spacing,\n                self.disable_ligatures,\n                str(file_name.resolve()),\n                START_X,\n                START_Y,\n                width,\n                height,\n                self.text,\n            )\n\n        return svg_file\n\n\n\n[docs]\n    def init_colors(self, propagate_colors=True):\n        if config.renderer == RendererType.OPENGL:\n            super().init_colors()\n        elif config.renderer == RendererType.CAIRO:\n            super().init_colors(propagate_colors=propagate_colors)\n\n\n\n\n\n[docs]\nclass MarkupText(SVGMobject):\n    r\"\"\"Display (non-LaTeX) text rendered using `Pango <https://pango.gnome.org/>`_.\n\n    Text objects behave like a :class:`.VGroup`-like iterable of all characters\n    in the given text. In particular, slicing is possible.\n\n    **What is PangoMarkup?**\n\n    PangoMarkup is a small markup language like html and it helps you avoid using\n    \"range of characters\" while coloring or styling a piece a Text. You can use\n    this language with :class:`~.MarkupText`.\n\n    A simple example of a marked-up string might be::\n\n        <span foreground=\"blue\" size=\"x-large\">Blue text</span> is <i>cool</i>!\"\n\n    and it can be used with :class:`~.MarkupText` as\n\n    .. manim:: MarkupExample\n        :save_last_frame:\n\n        class MarkupExample(Scene):\n            def construct(self):\n                text = MarkupText('<span foreground=\"blue\" size=\"x-large\">Blue text</span> is <i>cool</i>!\"')\n                self.add(text)\n\n    A more elaborate example would be:\n\n    .. manim:: MarkupElaborateExample\n        :save_last_frame:\n\n        class MarkupElaborateExample(Scene):\n            def construct(self):\n                text = MarkupText(\n                    '<span foreground=\"purple\">ا</span><span foreground=\"red\">َ</span>'\n                    'ل<span foreground=\"blue\">ْ</span>ع<span foreground=\"red\">َ</span>ر'\n                    '<span foreground=\"red\">َ</span>ب<span foreground=\"red\">ِ</span>ي'\n                    '<span foreground=\"green\">ّ</span><span foreground=\"red\">َ</span>ة'\n                    '<span foreground=\"blue\">ُ</span>'\n                )\n                self.add(text)\n\n    PangoMarkup can also contain XML features such as numeric character\n    entities such as ``&#169;`` for © can be used too.\n\n    The most general markup tag is ``<span>``, then there are some\n    convenience tags.\n\n    Here is a list of supported tags:\n\n    - ``<b>bold</b>``, ``<i>italic</i>`` and ``<b><i>bold+italic</i></b>``\n    - ``<u>underline</u>`` and ``<s>strike through</s>``\n    - ``<tt>typewriter font</tt>``\n    - ``<big>bigger font</big>`` and ``<small>smaller font</small>``\n    - ``<sup>superscript</sup>`` and ``<sub>subscript</sub>``\n    - ``<span underline=\"double\" underline_color=\"green\">double underline</span>``\n    - ``<span underline=\"error\">error underline</span>``\n    - ``<span overline=\"single\" overline_color=\"green\">overline</span>``\n    - ``<span strikethrough=\"true\" strikethrough_color=\"red\">strikethrough</span>``\n    - ``<span font_family=\"sans\">temporary change of font</span>``\n    - ``<span foreground=\"red\">temporary change of color</span>``\n    - ``<span fgcolor=\"red\">temporary change of color</span>``\n    - ``<gradient from=\"YELLOW\" to=\"RED\">temporary gradient</gradient>``\n\n    For ``<span>`` markup, colors can be specified either as\n    hex triples like ``#aabbcc`` or as named CSS colors like\n    ``AliceBlue``.\n    The ``<gradient>`` tag is handled by Manim rather than\n    Pango, and supports hex triplets or Manim constants like\n    ``RED`` or ``RED_A``.\n    If you want to use Manim constants like ``RED_A`` together\n    with ``<span>``, you will need to use Python's f-String\n    syntax as follows::\n\n        MarkupText(f'<span foreground=\"{RED_A}\">here you go</span>')\n\n    If your text contains ligatures, the :class:`MarkupText` class may\n    incorrectly determine the first and last letter when creating the\n    gradient. This is due to the fact that ``fl`` are two separate characters,\n    but might be set as one single glyph - a ligature. If your language\n    does not depend on ligatures, consider setting ``disable_ligatures``\n    to ``True``. If you must use ligatures, the ``gradient`` tag supports an optional\n    attribute ``offset`` which can be used to compensate for that error.\n\n    For example:\n\n    - ``<gradient from=\"RED\" to=\"YELLOW\" offset=\"1\">example</gradient>`` to *start* the gradient one letter earlier\n    - ``<gradient from=\"RED\" to=\"YELLOW\" offset=\",1\">example</gradient>`` to *end* the gradient one letter earlier\n    - ``<gradient from=\"RED\" to=\"YELLOW\" offset=\"2,1\">example</gradient>`` to *start* the gradient two letters earlier and *end* it one letter earlier\n\n    Specifying a second offset may be necessary if the text to be colored does\n    itself contain ligatures. The same can happen when using HTML entities for\n    special chars.\n\n    When using ``underline``, ``overline`` or ``strikethrough`` together with\n    ``<gradient>`` tags, you will also need to use the offset, because\n    underlines are additional paths in the final :class:`SVGMobject`.\n    Check out the following example.\n\n    Escaping of special characters: ``>`` **should** be written as ``&gt;``\n    whereas ``<`` and ``&`` *must* be written as ``&lt;`` and\n    ``&amp;``.\n\n    You can find more information about Pango markup formatting at the\n    corresponding documentation page:\n    `Pango Markup <https://docs.gtk.org/Pango/pango_markup.html>`_.\n    Please be aware that not all features are supported by this class and that\n    the ``<gradient>`` tag mentioned above is not supported by Pango.\n\n    Parameters\n    ----------\n\n    text\n        The text that needs to be created as mobject.\n    fill_opacity\n        The fill opacity, with 1 meaning opaque and 0 meaning transparent.\n    stroke_width\n        Stroke width.\n    font_size\n        Font size.\n    line_spacing\n        Line spacing.\n    font\n        Global font setting for the entire text. Local overrides are possible.\n    slant\n        Global slant setting, e.g. `NORMAL` or `ITALIC`. Local overrides are possible.\n    weight\n        Global weight setting, e.g. `NORMAL` or `BOLD`. Local overrides are possible.\n    gradient\n        Global gradient setting. Local overrides are possible.\n    warn_missing_font\n        If True (default), Manim will issue a warning if the font does not exist in the\n        (case-sensitive) list of fonts returned from `manimpango.list_fonts()`.\n\n    Returns\n    -------\n    :class:`MarkupText`\n        The text displayed in form of a :class:`.VGroup`-like mobject.\n\n    Examples\n    ---------\n\n    .. manim:: BasicMarkupExample\n        :save_last_frame:\n\n        class BasicMarkupExample(Scene):\n            def construct(self):\n                text1 = MarkupText(\"<b>foo</b> <i>bar</i> <b><i>foobar</i></b>\")\n                text2 = MarkupText(\"<s>foo</s> <u>bar</u> <big>big</big> <small>small</small>\")\n                text3 = MarkupText(\"H<sub>2</sub>O and H<sub>3</sub>O<sup>+</sup>\")\n                text4 = MarkupText(\"type <tt>help</tt> for help\")\n                text5 = MarkupText(\n                    '<span underline=\"double\">foo</span> <span underline=\"error\">bar</span>'\n                )\n                group = VGroup(text1, text2, text3, text4, text5).arrange(DOWN)\n                self.add(group)\n\n    .. manim:: ColorExample\n        :save_last_frame:\n\n        class ColorExample(Scene):\n            def construct(self):\n                text1 = MarkupText(\n                    f'all in red <span fgcolor=\"{YELLOW}\">except this</span>', color=RED\n                )\n                text2 = MarkupText(\"nice gradient\", gradient=(BLUE, GREEN))\n                text3 = MarkupText(\n                    'nice <gradient from=\"RED\" to=\"YELLOW\">intermediate</gradient> gradient',\n                    gradient=(BLUE, GREEN),\n                )\n                text4 = MarkupText(\n                    'fl ligature <gradient from=\"RED\" to=\"YELLOW\">causing trouble</gradient> here'\n                )\n                text5 = MarkupText(\n                    'fl ligature <gradient from=\"RED\" to=\"YELLOW\" offset=\"1\">defeated</gradient> with offset'\n                )\n                text6 = MarkupText(\n                    'fl ligature <gradient from=\"RED\" to=\"YELLOW\" offset=\"1\">floating</gradient> inside'\n                )\n                text7 = MarkupText(\n                    'fl ligature <gradient from=\"RED\" to=\"YELLOW\" offset=\"1,1\">floating</gradient> inside'\n                )\n                group = VGroup(text1, text2, text3, text4, text5, text6, text7).arrange(DOWN)\n                self.add(group)\n\n    .. manim:: UnderlineExample\n        :save_last_frame:\n\n        class UnderlineExample(Scene):\n            def construct(self):\n                text1 = MarkupText(\n                    '<span underline=\"double\" underline_color=\"green\">bla</span>'\n                )\n                text2 = MarkupText(\n                    '<span underline=\"single\" underline_color=\"green\">xxx</span><gradient from=\"#ffff00\" to=\"RED\">aabb</gradient>y'\n                )\n                text3 = MarkupText(\n                    '<span underline=\"single\" underline_color=\"green\">xxx</span><gradient from=\"#ffff00\" to=\"RED\" offset=\"-1\">aabb</gradient>y'\n                )\n                text4 = MarkupText(\n                    '<span underline=\"double\" underline_color=\"green\">xxx</span><gradient from=\"#ffff00\" to=\"RED\">aabb</gradient>y'\n                )\n                text5 = MarkupText(\n                    '<span underline=\"double\" underline_color=\"green\">xxx</span><gradient from=\"#ffff00\" to=\"RED\" offset=\"-2\">aabb</gradient>y'\n                )\n                group = VGroup(text1, text2, text3, text4, text5).arrange(DOWN)\n                self.add(group)\n\n    .. manim:: FontExample\n        :save_last_frame:\n\n        class FontExample(Scene):\n            def construct(self):\n                text1 = MarkupText(\n                    'all in sans <span font_family=\"serif\">except this</span>', font=\"sans\"\n                )\n                text2 = MarkupText(\n                    '<span font_family=\"serif\">mixing</span> <span font_family=\"sans\">fonts</span> <span font_family=\"monospace\">is ugly</span>'\n                )\n                text3 = MarkupText(\"special char > or &gt;\")\n                text4 = MarkupText(\"special char &lt; and &amp;\")\n                group = VGroup(text1, text2, text3, text4).arrange(DOWN)\n                self.add(group)\n\n    .. manim:: NewlineExample\n        :save_last_frame:\n\n        class NewlineExample(Scene):\n            def construct(self):\n                text = MarkupText('foooo<span foreground=\"red\">oo\\nbaa</span>aar')\n                self.add(text)\n\n    .. manim:: NoLigaturesExample\n        :save_last_frame:\n\n        class NoLigaturesExample(Scene):\n            def construct(self):\n                text1 = MarkupText('fl<gradient from=\"RED\" to=\"GREEN\">oat</gradient>ing')\n                text2 = MarkupText('fl<gradient from=\"RED\" to=\"GREEN\">oat</gradient>ing', disable_ligatures=True)\n                group = VGroup(text1, text2).arrange(DOWN)\n                self.add(group)\n\n\n    As :class:`MarkupText` uses Pango to render text, rendering non-English\n    characters is easily possible:\n\n    .. manim:: MultiLanguage\n        :save_last_frame:\n\n        class MultiLanguage(Scene):\n            def construct(self):\n                morning = MarkupText(\"வணக்கம்\", font=\"sans-serif\")\n                japanese = MarkupText(\n                    '<span fgcolor=\"blue\">日本</span>へようこそ'\n                )  # works as in ``Text``.\n                mess = MarkupText(\"Multi-Language\", weight=BOLD)\n                russ = MarkupText(\"Здравствуйте मस नम म \", font=\"sans-serif\")\n                hin = MarkupText(\"नमस्ते\", font=\"sans-serif\")\n                chinese = MarkupText(\"臂猿「黛比」帶著孩子\", font=\"sans-serif\")\n                group = VGroup(morning, japanese, mess, russ, hin, chinese).arrange(DOWN)\n                self.add(group)\n\n    You can justify the text by passing :attr:`justify` parameter.\n\n    .. manim:: JustifyText\n\n        class JustifyText(Scene):\n            def construct(self):\n                ipsum_text = (\n                    \"Lorem ipsum dolor sit amet, consectetur adipiscing elit.\"\n                    \"Praesent feugiat metus sit amet iaculis pulvinar. Nulla posuere \"\n                    \"quam a ex aliquam, eleifend consectetur tellus viverra. Aliquam \"\n                    \"fermentum interdum justo, nec rutrum elit pretium ac. Nam quis \"\n                    \"leo pulvinar, dignissim est at, venenatis nisi.\"\n                )\n                justified_text = MarkupText(ipsum_text, justify=True).scale(0.4)\n                not_justified_text = MarkupText(ipsum_text, justify=False).scale(0.4)\n                just_title = Title(\"Justified\")\n                njust_title = Title(\"Not Justified\")\n                self.add(njust_title, not_justified_text)\n                self.play(\n                    FadeOut(not_justified_text),\n                    FadeIn(justified_text),\n                    FadeOut(njust_title),\n                    FadeIn(just_title),\n                )\n                self.wait(1)\n\n    Tests\n    -----\n\n    Check that the creation of :class:`~.MarkupText` works::\nMarkupText('The horse does not eat cucumber salad.')\n        MarkupText('The horse does not eat cucumber salad.')\n\n    \"\"\"\n\n    @staticmethod\n    @functools.cache\n    def font_list() -> list[str]:\n        return manimpango.list_fonts()\n\n    def __init__(\n        self,\n        text: str,\n        fill_opacity: float = 1,\n        stroke_width: float = 0,\n        color: ParsableManimColor | None = None,\n        font_size: float = DEFAULT_FONT_SIZE,\n        line_spacing: int = -1,\n        font: str = \"\",\n        slant: str = NORMAL,\n        weight: str = NORMAL,\n        justify: bool = False,\n        gradient: tuple = None,\n        tab_width: int = 4,\n        height: int = None,\n        width: int = None,\n        should_center: bool = True,\n        disable_ligatures: bool = False,\n        warn_missing_font: bool = True,\n        **kwargs,\n    ) -> None:\n        self.text = text\n        self.line_spacing = line_spacing\n        if font and warn_missing_font:\n            fonts_list = Text.font_list()\n            # handle special case of sans/sans-serif\n            if font.lower() == \"sans-serif\":\n                font = \"sans\"\n            if font not in fonts_list:\n                # check if the capitalized version is in the supported fonts\n                if font.capitalize() in fonts_list:\n                    font = font.capitalize()\n                elif font.lower() in fonts_list:\n                    font = font.lower()\n                elif font.title() in fonts_list:\n                    font = font.title()\n                else:\n                    logger.warning(f\"Font {font} not in {fonts_list}.\")\n        self.font = font\n        self._font_size = float(font_size)\n        self.slant = slant\n        self.weight = weight\n        self.gradient = gradient\n        self.tab_width = tab_width\n        self.justify = justify\n\n        self.original_text = text\n        self.disable_ligatures = disable_ligatures\n        text_without_tabs = text\n        if \"\\t\" in text:\n            text_without_tabs = text.replace(\"\\t\", \" \" * self.tab_width)\n\n        colormap = self._extract_color_tags()\n        if len(colormap) > 0:\n            logger.warning(\n                'Using <color> tags in MarkupText is deprecated. Please use <span foreground=\"...\"> instead.',\n            )\n        gradientmap = self._extract_gradient_tags()\n        validate_error = MarkupUtils.validate(self.text)\n        if validate_error:\n            raise ValueError(validate_error)\n\n        if self.line_spacing == -1:\n            self.line_spacing = (\n                self._font_size + self._font_size * DEFAULT_LINE_SPACING_SCALE\n            )\n        else:\n            self.line_spacing = self._font_size + self._font_size * self.line_spacing\n\n        color: ManimColor = ManimColor(color) if color else VMobject().color\n        file_name = self._text2svg(color)\n\n        PangoUtils.remove_last_M(file_name)\n        super().__init__(\n            file_name,\n            fill_opacity=fill_opacity,\n            stroke_width=stroke_width,\n            height=height,\n            width=width,\n            should_center=should_center,\n            **kwargs,\n        )\n\n        self.chars = self.get_group_class()(*self.submobjects)\n        self.text = text_without_tabs.replace(\" \", \"\").replace(\"\\n\", \"\")\n\n        nppc = self.n_points_per_curve\n        for each in self:\n            if len(each.points) == 0:\n                continue\n            points = each.points\n            curve_start = points[0]\n            assert len(curve_start) == self.dim, curve_start\n            # Some of the glyphs in this text might not be closed,\n            # so we close them by identifying when one curve ends\n            # but it is not where the next curve starts.\n            # It is more efficient to temporarily create a list\n            # of points and add them one at a time, then turn them\n            # into a numpy array at the end, rather than creating\n            # new numpy arrays every time a point or fixing line\n            # is added (which is O(n^2) for numpy arrays).\n            closed_curve_points = []\n            # OpenGL has points be part of quadratic Bezier curves;\n            # Cairo uses cubic Bezier curves.\n            if nppc == 3:  # RendererType.OPENGL\n\n                def add_line_to(end):\n                    nonlocal closed_curve_points\n                    start = closed_curve_points[-1]\n                    closed_curve_points += [\n                        start,\n                        (start + end) / 2,\n                        end,\n                    ]\n\n            else:  # RendererType.CAIRO\n\n                def add_line_to(end):\n                    nonlocal closed_curve_points\n                    start = closed_curve_points[-1]\n                    closed_curve_points += [\n                        start,\n                        (start + start + end) / 3,\n                        (start + end + end) / 3,\n                        end,\n                    ]\n\n            for index, point in enumerate(points):\n                closed_curve_points.append(point)\n                if (\n                    index != len(points) - 1\n                    and (index + 1) % nppc == 0\n                    and any(point != points[index + 1])\n                ):\n                    # Add straight line from last point on this curve to the\n                    # start point on the next curve.\n                    add_line_to(curve_start)\n                    curve_start = points[index + 1]\n            # Make sure last curve is closed\n            add_line_to(curve_start)\n            each.points = np.array(closed_curve_points, ndmin=2)\n\n        if self.gradient:\n            self.set_color_by_gradient(*self.gradient)\n        for col in colormap:\n            self.chars[\n                col[\"start\"] - col[\"start_offset\"] : col[\"end\"]\n                - col[\"start_offset\"]\n                - col[\"end_offset\"]\n            ].set_color(self._parse_color(col[\"color\"]))\n        for grad in gradientmap:\n            self.chars[\n                grad[\"start\"] - grad[\"start_offset\"] : grad[\"end\"]\n                - grad[\"start_offset\"]\n                - grad[\"end_offset\"]\n            ].set_color_by_gradient(\n                *(self._parse_color(grad[\"from\"]), self._parse_color(grad[\"to\"]))\n            )\n        # anti-aliasing\n        if height is None and width is None:\n            self.scale(TEXT_MOB_SCALE_FACTOR)\n\n        self.initial_height = self.height\n\n    @property\n    def font_size(self):\n        return (\n            self.height\n            / self.initial_height\n            / TEXT_MOB_SCALE_FACTOR\n            * 2.4\n            * self._font_size\n            / DEFAULT_FONT_SIZE\n        )\n\n    @font_size.setter\n    def font_size(self, font_val):\n        # TODO: use pango's font size scaling.\n        if font_val <= 0:\n            raise ValueError(\"font_size must be greater than 0.\")\n        else:\n            self.scale(font_val / self.font_size)\n\n\n[docs]\n    def _text2hash(self, color: ParsableManimColor):\n        \"\"\"Generates ``sha256`` hash for file name.\"\"\"\n        settings = (\n            \"MARKUPPANGO\"\n            + self.font\n            + self.slant\n            + self.weight\n            + ManimColor(color).to_hex().lower()\n        )  # to differentiate from classical Pango Text\n        settings += str(self.line_spacing) + str(self._font_size)\n        settings += str(self.disable_ligatures)\n        settings += str(self.justify)\n        id_str = self.text + settings\n        hasher = hashlib.sha256()\n        hasher.update(id_str.encode())\n        return hasher.hexdigest()[:16]\n\n\n\n[docs]\n    def _text2svg(self, color: ParsableManimColor | None):\n        \"\"\"Convert the text to SVG using Pango.\"\"\"\n        color = ManimColor(color)\n        size = self._font_size\n        line_spacing = self.line_spacing\n        size /= TEXT2SVG_ADJUSTMENT_FACTOR\n        line_spacing /= TEXT2SVG_ADJUSTMENT_FACTOR\n\n        dir_name = config.get_dir(\"text_dir\")\n        if not dir_name.is_dir():\n            dir_name.mkdir(parents=True)\n        hash_name = self._text2hash(color)\n        file_name = dir_name / (hash_name + \".svg\")\n\n        if file_name.exists():\n            svg_file = str(file_name.resolve())\n        else:\n            final_text = (\n                f'<span foreground=\"{color.to_hex()}\">{self.text}</span>'\n                if color is not None\n                else self.text\n            )\n            logger.debug(f\"Setting Text {self.text}\")\n            svg_file = MarkupUtils.text2svg(\n                final_text,\n                self.font,\n                self.slant,\n                self.weight,\n                size,\n                line_spacing,\n                self.disable_ligatures,\n                str(file_name.resolve()),\n                START_X,\n                START_Y,\n                600,  # width\n                400,  # height\n                justify=self.justify,\n                pango_width=500,\n            )\n        return svg_file\n\n\n\n[docs]\n    def _count_real_chars(self, s):\n        \"\"\"Counts characters that will be displayed.\n\n        This is needed for partial coloring or gradients, because space\n        counts to the text's `len`, but has no corresponding character.\n        \"\"\"\n        count = 0\n        level = 0\n        # temporarily replace HTML entities by single char\n        s = re.sub(\"&[^;]+;\", \"x\", s)\n        for c in s:\n            if c == \"<\":\n                level += 1\n            if c == \">\" and level > 0:\n                level -= 1\n            elif c != \" \" and c != \"\\t\" and level == 0:\n                count += 1\n        return count\n\n\n\n[docs]\n    def _extract_gradient_tags(self):\n        \"\"\"Used to determine which parts (if any) of the string should be formatted\n        with a gradient.\n\n        Removes the ``<gradient>`` tag, as it is not part of Pango's markup and would cause an error.\n        \"\"\"\n        tags = re.finditer(\n            r'<gradient\\s+from=\"([^\"]+)\"\\s+to=\"([^\"]+)\"(\\s+offset=\"([^\"]+)\")?>(.+?)</gradient>',\n            self.original_text,\n            re.S,\n        )\n        gradientmap = []\n        for tag in tags:\n            start = self._count_real_chars(self.original_text[: tag.start(0)])\n            end = start + self._count_real_chars(tag.group(5))\n            offsets = tag.group(4).split(\",\") if tag.group(4) else [0]\n            start_offset = int(offsets[0]) if offsets[0] else 0\n            end_offset = int(offsets[1]) if len(offsets) == 2 and offsets[1] else 0\n\n            gradientmap.append(\n                {\n                    \"start\": start,\n                    \"end\": end,\n                    \"from\": tag.group(1),\n                    \"to\": tag.group(2),\n                    \"start_offset\": start_offset,\n                    \"end_offset\": end_offset,\n                },\n            )\n        self.text = re.sub(\n            \"<gradient[^>]+>(.+?)</gradient>\", r\"\\1\", self.text, count=0, flags=re.S\n        )\n        return gradientmap\n\n\n\n[docs]\n    def _parse_color(self, col):\n        \"\"\"Parse color given in ``<color>`` or ``<gradient>`` tags.\"\"\"\n        if re.match(\"#[0-9a-f]{6}\", col):\n            return col\n        else:\n            return ManimColor(col).to_hex()\n\n\n\n[docs]\n    def _extract_color_tags(self):\n        \"\"\"Used to determine which parts (if any) of the string should be formatted\n        with a custom color.\n\n        Removes the ``<color>`` tag, as it is not part of Pango's markup and would cause an error.\n\n        Note: Using the ``<color>`` tags is deprecated. As soon as the legacy syntax is gone, this function\n        will be removed.\n        \"\"\"\n        tags = re.finditer(\n            r'<color\\s+col=\"([^\"]+)\"(\\s+offset=\"([^\"]+)\")?>(.+?)</color>',\n            self.original_text,\n            re.S,\n        )\n\n        colormap = []\n        for tag in tags:\n            start = self._count_real_chars(self.original_text[: tag.start(0)])\n            end = start + self._count_real_chars(tag.group(4))\n            offsets = tag.group(3).split(\",\") if tag.group(3) else [0]\n            start_offset = int(offsets[0]) if offsets[0] else 0\n            end_offset = int(offsets[1]) if len(offsets) == 2 and offsets[1] else 0\n\n            colormap.append(\n                {\n                    \"start\": start,\n                    \"end\": end,\n                    \"color\": tag.group(1),\n                    \"start_offset\": start_offset,\n                    \"end_offset\": end_offset,\n                },\n            )\n        self.text = re.sub(\n            \"<color[^>]+>(.+?)</color>\", r\"\\1\", self.text, count=0, flags=re.S\n        )\n        return colormap\n\n\n    def __repr__(self):\n        return f\"MarkupText({repr(self.original_text)})\"\n\n\n\n\n[docs]\n@contextmanager\ndef register_font(font_file: str | Path):\n    \"\"\"Temporarily add a font file to Pango's search path.\n\n    This searches for the font_file at various places. The order it searches it described below.\n\n    1. Absolute path.\n    2. In ``assets/fonts`` folder.\n    3. In ``font/`` folder.\n    4. In the same directory.\n\n    Parameters\n    ----------\n    font_file\n        The font file to add.\n\n    Examples\n    --------\n    Use ``with register_font(...)`` to add a font file to search\n    path.\n\n    .. code-block:: python\n\n        with register_font(\"path/to/font_file.ttf\"):\n            a = Text(\"Hello\", font=\"Custom Font Name\")\n\n    Raises\n    ------\n    FileNotFoundError:\n        If the font doesn't exists.\n\n    AttributeError:\n        If this method is used on macOS.\n\n    .. important ::\n\n        This method is available for macOS for ``ManimPango>=v0.2.3``. Using this\n        method with previous releases will raise an :class:`AttributeError` on macOS.\n    \"\"\"\n    input_folder = Path(config.input_file).parent.resolve()\n    possible_paths = [\n        Path(font_file),\n        input_folder / \"assets/fonts\" / font_file,\n        input_folder / \"fonts\" / font_file,\n        input_folder / font_file,\n    ]\n    for path in possible_paths:\n        path = path.resolve()\n        if path.exists():\n            file_path = path\n            logger.debug(\"Found file at %s\", file_path.absolute())\n            break\n    else:\n        error = f\"Can't find {font_file}.Tried these : {possible_paths}\"\n        raise FileNotFoundError(error)\n\n    try:\n        assert manimpango.register_font(str(file_path))\n        yield\n    finally:\n        manimpango.unregister_font(str(file_path))", "code_sha1": "6dd08ec65a640e7e811471965362d155fb6b4207"}
{"url": "https://docs.manim.community/en/stable/_modules/manim/mobject/three_d/polyhedra.html", "depth": 2, "instruction": "A 3D scene displays a polyhedron (e.g., tetrahedron, octahedron) with a transparent fill and shaded faces, set against a backdrop. The camera orbits around the object, showcasing its geometry from various angles, while the edges are invisible, emphasizing the polyhedron's structure.", "code": "\"\"\"General polyhedral class and platonic solids.\"\"\"\n\nfrom __future__ import annotations\n\nfrom typing import TYPE_CHECKING\n\nimport numpy as np\n\nfrom manim.mobject.geometry.polygram import Polygon\nfrom manim.mobject.graph import Graph\nfrom manim.mobject.three_d.three_dimensions import Dot3D\nfrom manim.mobject.types.vectorized_mobject import VGroup\nfrom manim.utils.qhull import QuickHull\n\nif TYPE_CHECKING:\n    from manim.mobject.mobject import Mobject\n    from manim.typing import Point3D\n\n__all__ = [\n    \"Polyhedron\",\n    \"Tetrahedron\",\n    \"Octahedron\",\n    \"Icosahedron\",\n    \"Dodecahedron\",\n    \"ConvexHull3D\",\n]\n\n\n\n[docs]\nclass Polyhedron(VGroup):\n    \"\"\"An abstract polyhedra class.\n\n    In this implementation, polyhedra are defined with a list of vertex coordinates in space, and a list\n    of faces. This implementation mirrors that of a standard polyhedral data format (OFF, object file format).\n\n    Parameters\n    ----------\n    vertex_coords\n        A list of coordinates of the corresponding vertices in the polyhedron. Each coordinate will correspond to\n        a vertex. The vertices are indexed with the usual indexing of Python.\n    faces_list\n        A list of faces. Each face is a sublist containing the indices of the vertices that form the corners of that face.\n    faces_config\n        Configuration for the polygons representing the faces of the polyhedron.\n    graph_config\n        Configuration for the graph containing the vertices and edges of the polyhedron.\n\n    Examples\n    --------\n    To understand how to create a custom polyhedra, let's use the example of a rather simple one - a square pyramid.\n\n    .. manim:: SquarePyramidScene\n        :save_last_frame:\n\n        class SquarePyramidScene(ThreeDScene):\n            def construct(self):\n                self.set_camera_orientation(phi=75 * DEGREES, theta=30 * DEGREES)\n                vertex_coords = [\n                    [1, 1, 0],\n                    [1, -1, 0],\n                    [-1, -1, 0],\n                    [-1, 1, 0],\n                    [0, 0, 2]\n                ]\n                faces_list = [\n                    [0, 1, 4],\n                    [1, 2, 4],\n                    [2, 3, 4],\n                    [3, 0, 4],\n                    [0, 1, 2, 3]\n                ]\n                pyramid = Polyhedron(vertex_coords, faces_list)\n                self.add(pyramid)\n\n    In defining the polyhedron above, we first defined the coordinates of the vertices.\n    These are the corners of the square base, given as the first four coordinates in the vertex list,\n    and the apex, the last coordinate in the list.\n\n    Next, we define the faces of the polyhedron. The triangular surfaces of the pyramid are polygons\n    with two adjacent vertices in the base and the vertex at the apex as corners. We thus define these\n    surfaces in the first four elements of our face list. The last element defines the base of the pyramid.\n\n    The graph and faces of polyhedra can also be accessed and modified directly, after instantiation.\n    They are stored in the `graph` and `faces` attributes respectively.\n\n    .. manim:: PolyhedronSubMobjects\n        :save_last_frame:\n\n        class PolyhedronSubMobjects(ThreeDScene):\n            def construct(self):\n                self.set_camera_orientation(phi=75 * DEGREES, theta=30 * DEGREES)\n                octahedron = Octahedron(edge_length = 3)\n                octahedron.graph[0].set_color(RED)\n                octahedron.faces[2].set_color(YELLOW)\n                self.add(octahedron)\n    \"\"\"\n\n    def __init__(\n        self,\n        vertex_coords: list[list[float] | np.ndarray],\n        faces_list: list[list[int]],\n        faces_config: dict[str, str | int | float | bool] = {},\n        graph_config: dict[str, str | int | float | bool] = {},\n    ):\n        super().__init__()\n        self.faces_config = dict(\n            {\"fill_opacity\": 0.5, \"shade_in_3d\": True}, **faces_config\n        )\n        self.graph_config = dict(\n            {\n                \"vertex_type\": Dot3D,\n                \"edge_config\": {\n                    \"stroke_opacity\": 0,  # I find that having the edges visible makes the polyhedra look weird\n                },\n            },\n            **graph_config,\n        )\n        self.vertex_coords = vertex_coords\n        self.vertex_indices = list(range(len(self.vertex_coords)))\n        self.layout = dict(enumerate(self.vertex_coords))\n        self.faces_list = faces_list\n        self.face_coords = [[self.layout[j] for j in i] for i in faces_list]\n        self.edges = self.get_edges(self.faces_list)\n        self.faces = self.create_faces(self.face_coords)\n        self.graph = Graph(\n            self.vertex_indices, self.edges, layout=self.layout, **self.graph_config\n        )\n        self.add(self.faces, self.graph)\n        self.add_updater(self.update_faces)\n\n\n[docs]\n    def get_edges(self, faces_list: list[list[int]]) -> list[tuple[int, int]]:\n        \"\"\"Creates list of cyclic pairwise tuples.\"\"\"\n        edges = []\n        for face in faces_list:\n            edges += zip(face, face[1:] + face[:1])\n        return edges\n\n\n\n[docs]\n    def create_faces(\n        self,\n        face_coords: list[list[list | np.ndarray]],\n    ) -> VGroup:\n        \"\"\"Creates VGroup of faces from a list of face coordinates.\"\"\"\n        face_group = VGroup()\n        for face in face_coords:\n            face_group.add(Polygon(*face, **self.faces_config))\n        return face_group\n\n\n    def update_faces(self, m: Mobject):\n        face_coords = self.extract_face_coords()\n        new_faces = self.create_faces(face_coords)\n        self.faces.match_points(new_faces)\n\n\n[docs]\n    def extract_face_coords(self) -> list[list[np.ndarray]]:\n        \"\"\"Extracts the coordinates of the vertices in the graph.\n        Used for updating faces.\n        \"\"\"\n        new_vertex_coords = []\n        for v in self.graph.vertices:\n            new_vertex_coords.append(self.graph[v].get_center())\n        layout = dict(enumerate(new_vertex_coords))\n        return [[layout[j] for j in i] for i in self.faces_list]\n\n\n\n\n\n[docs]\nclass Tetrahedron(Polyhedron):\n    \"\"\"A tetrahedron, one of the five platonic solids. It has 4 faces, 6 edges, and 4 vertices.\n\n    Parameters\n    ----------\n    edge_length\n        The length of an edge between any two vertices.\n\n    Examples\n    --------\n\n    .. manim:: TetrahedronScene\n        :save_last_frame:\n\n        class TetrahedronScene(ThreeDScene):\n            def construct(self):\n                self.set_camera_orientation(phi=75 * DEGREES, theta=30 * DEGREES)\n                obj = Tetrahedron()\n                self.add(obj)\n    \"\"\"\n\n    def __init__(self, edge_length: float = 1, **kwargs):\n        unit = edge_length * np.sqrt(2) / 4\n        super().__init__(\n            vertex_coords=[\n                np.array([unit, unit, unit]),\n                np.array([unit, -unit, -unit]),\n                np.array([-unit, unit, -unit]),\n                np.array([-unit, -unit, unit]),\n            ],\n            faces_list=[[0, 1, 2], [3, 0, 2], [0, 1, 3], [3, 1, 2]],\n            **kwargs,\n        )\n\n\n\n\n[docs]\nclass Octahedron(Polyhedron):\n    \"\"\"An octahedron, one of the five platonic solids. It has 8 faces, 12 edges and 6 vertices.\n\n    Parameters\n    ----------\n    edge_length\n        The length of an edge between any two vertices.\n\n    Examples\n    --------\n\n    .. manim:: OctahedronScene\n        :save_last_frame:\n\n        class OctahedronScene(ThreeDScene):\n            def construct(self):\n                self.set_camera_orientation(phi=75 * DEGREES, theta=30 * DEGREES)\n                obj = Octahedron()\n                self.add(obj)\n    \"\"\"\n\n    def __init__(self, edge_length: float = 1, **kwargs):\n        unit = edge_length * np.sqrt(2) / 2\n        super().__init__(\n            vertex_coords=[\n                np.array([unit, 0, 0]),\n                np.array([-unit, 0, 0]),\n                np.array([0, unit, 0]),\n                np.array([0, -unit, 0]),\n                np.array([0, 0, unit]),\n                np.array([0, 0, -unit]),\n            ],\n            faces_list=[\n                [2, 4, 1],\n                [0, 4, 2],\n                [4, 3, 0],\n                [1, 3, 4],\n                [3, 5, 0],\n                [1, 5, 3],\n                [2, 5, 1],\n                [0, 5, 2],\n            ],\n            **kwargs,\n        )\n\n\n\n\n[docs]\nclass Icosahedron(Polyhedron):\n    \"\"\"An icosahedron, one of the five platonic solids. It has 20 faces, 30 edges and 12 vertices.\n\n    Parameters\n    ----------\n    edge_length\n        The length of an edge between any two vertices.\n\n    Examples\n    --------\n\n    .. manim:: IcosahedronScene\n        :save_last_frame:\n\n        class IcosahedronScene(ThreeDScene):\n            def construct(self):\n                self.set_camera_orientation(phi=75 * DEGREES, theta=30 * DEGREES)\n                obj = Icosahedron()\n                self.add(obj)\n    \"\"\"\n\n    def __init__(self, edge_length: float = 1, **kwargs):\n        unit_a = edge_length * ((1 + np.sqrt(5)) / 4)\n        unit_b = edge_length * (1 / 2)\n        super().__init__(\n            vertex_coords=[\n                np.array([0, unit_b, unit_a]),\n                np.array([0, -unit_b, unit_a]),\n                np.array([0, unit_b, -unit_a]),\n                np.array([0, -unit_b, -unit_a]),\n                np.array([unit_b, unit_a, 0]),\n                np.array([unit_b, -unit_a, 0]),\n                np.array([-unit_b, unit_a, 0]),\n                np.array([-unit_b, -unit_a, 0]),\n                np.array([unit_a, 0, unit_b]),\n                np.array([unit_a, 0, -unit_b]),\n                np.array([-unit_a, 0, unit_b]),\n                np.array([-unit_a, 0, -unit_b]),\n            ],\n            faces_list=[\n                [1, 8, 0],\n                [1, 5, 7],\n                [8, 5, 1],\n                [7, 3, 5],\n                [5, 9, 3],\n                [8, 9, 5],\n                [3, 2, 9],\n                [9, 4, 2],\n                [8, 4, 9],\n                [0, 4, 8],\n                [6, 4, 0],\n                [6, 2, 4],\n                [11, 2, 6],\n                [3, 11, 2],\n                [0, 6, 10],\n                [10, 1, 0],\n                [10, 7, 1],\n                [11, 7, 3],\n                [10, 11, 7],\n                [10, 11, 6],\n            ],\n            **kwargs,\n        )\n\n\n\n\n[docs]\nclass Dodecahedron(Polyhedron):\n    \"\"\"A dodecahedron, one of the five platonic solids. It has 12 faces, 30 edges and 20 vertices.\n\n    Parameters\n    ----------\n    edge_length\n        The length of an edge between any two vertices.\n\n    Examples\n    --------\n\n    .. manim:: DodecahedronScene\n        :save_last_frame:\n\n        class DodecahedronScene(ThreeDScene):\n            def construct(self):\n                self.set_camera_orientation(phi=75 * DEGREES, theta=30 * DEGREES)\n                obj = Dodecahedron()\n                self.add(obj)\n    \"\"\"\n\n    def __init__(self, edge_length: float = 1, **kwargs):\n        unit_a = edge_length * ((1 + np.sqrt(5)) / 4)\n        unit_b = edge_length * ((3 + np.sqrt(5)) / 4)\n        unit_c = edge_length * (1 / 2)\n        super().__init__(\n            vertex_coords=[\n                np.array([unit_a, unit_a, unit_a]),\n                np.array([unit_a, unit_a, -unit_a]),\n                np.array([unit_a, -unit_a, unit_a]),\n                np.array([unit_a, -unit_a, -unit_a]),\n                np.array([-unit_a, unit_a, unit_a]),\n                np.array([-unit_a, unit_a, -unit_a]),\n                np.array([-unit_a, -unit_a, unit_a]),\n                np.array([-unit_a, -unit_a, -unit_a]),\n                np.array([0, unit_c, unit_b]),\n                np.array([0, unit_c, -unit_b]),\n                np.array([0, -unit_c, -unit_b]),\n                np.array([0, -unit_c, unit_b]),\n                np.array([unit_c, unit_b, 0]),\n                np.array([-unit_c, unit_b, 0]),\n                np.array([unit_c, -unit_b, 0]),\n                np.array([-unit_c, -unit_b, 0]),\n                np.array([unit_b, 0, unit_c]),\n                np.array([-unit_b, 0, unit_c]),\n                np.array([unit_b, 0, -unit_c]),\n                np.array([-unit_b, 0, -unit_c]),\n            ],\n            faces_list=[\n                [18, 16, 0, 12, 1],\n                [3, 18, 16, 2, 14],\n                [3, 10, 9, 1, 18],\n                [1, 9, 5, 13, 12],\n                [0, 8, 4, 13, 12],\n                [2, 16, 0, 8, 11],\n                [4, 17, 6, 11, 8],\n                [17, 19, 5, 13, 4],\n                [19, 7, 15, 6, 17],\n                [6, 15, 14, 2, 11],\n                [19, 5, 9, 10, 7],\n                [7, 10, 3, 14, 15],\n            ],\n            **kwargs,\n        )\n\n\n\n\n[docs]\nclass ConvexHull3D(Polyhedron):\n    \"\"\"A convex hull for a set of points\n\n    Parameters\n    ----------\n    points\n        The points to consider.\n    tolerance\n        The tolerance used for quickhull.\n    kwargs\n        Forwarded to the parent constructor.\n\n    Examples\n    --------\n    .. manim:: ConvexHull3DExample\n        :save_last_frame:\n        :quality: high\n\n        class ConvexHull3DExample(ThreeDScene):\n            def construct(self):\n                self.set_camera_orientation(phi=75 * DEGREES, theta=30 * DEGREES)\n                points = [\n                    [ 1.93192757,  0.44134585, -1.52407061],\n                    [-0.93302521,  1.23206983,  0.64117067],\n                    [-0.44350918, -0.61043677,  0.21723705],\n                    [-0.42640268, -1.05260843,  1.61266094],\n                    [-1.84449637,  0.91238739, -1.85172623],\n                    [ 1.72068132, -0.11880457,  0.51881751],\n                    [ 0.41904805,  0.44938012, -1.86440686],\n                    [ 0.83864666,  1.66653337,  1.88960123],\n                    [ 0.22240514, -0.80986286,  1.34249326],\n                    [-1.29585759,  1.01516189,  0.46187522],\n                    [ 1.7776499,  -1.59550796, -1.70240747],\n                    [ 0.80065226, -0.12530398,  1.70063977],\n                    [ 1.28960948, -1.44158255,  1.39938582],\n                    [-0.93538943,  1.33617705, -0.24852643],\n                    [-1.54868271,  1.7444399,  -0.46170734]\n                ]\n                hull = ConvexHull3D(\n                    *points,\n                    faces_config = {\"stroke_opacity\": 0},\n                    graph_config = {\n                        \"vertex_type\": Dot3D,\n                        \"edge_config\": {\n                            \"stroke_color\": BLUE,\n                            \"stroke_width\": 2,\n                            \"stroke_opacity\": 0.05,\n                        }\n                    }\n                )\n                dots = VGroup(*[Dot3D(point) for point in points])\n                self.add(hull)\n                self.add(dots)\n    \"\"\"\n\n    def __init__(self, *points: Point3D, tolerance: float = 1e-5, **kwargs):\n        # Build Convex Hull\n        array = np.array(points)\n        hull = QuickHull(tolerance)\n        hull.build(array)\n\n        # Setup Lists\n        vertices = []\n        faces = []\n\n        # Extract Faces\n        c = 0\n        d = {}\n        facets = set(hull.facets) - hull.removed\n        for facet in facets:\n            tmp = set()\n            for subfacet in facet.subfacets:\n                for point in subfacet.points:\n                    if point not in d:\n                        vertices.append(point.coordinates)\n                        d[point] = c\n                        c += 1\n                    tmp.add(point)\n            faces.append([d[point] for point in tmp])\n\n        # Call Polyhedron\n        super().__init__(\n            vertex_coords=vertices,\n            faces_list=faces,\n            **kwargs,\n        )", "code_sha1": "25868e0968266cb3f6466e1e4ba4ba43567e037b"}
{"url": "https://docs.manim.community/en/stable/_modules/manim/mobject/three_d/three_dimensions.html", "depth": 2, "instruction": "The code defines various 3D geometric objects in Manim, including spheres, cubes, and cones, with customizable properties like color, opacity, and resolution. Each object can be animated in a 3D scene, with camera orientation set to specific angles, showcasing their shapes and interactions in a visually appealing manner.", "code": "\"\"\"Three-dimensional mobjects.\"\"\"\n\nfrom __future__ import annotations\n\nfrom manim.typing import Point3DLike, Vector3D\nfrom manim.utils.color import BLUE, BLUE_D, BLUE_E, LIGHT_GREY, WHITE, interpolate_color\n\n__all__ = [\n    \"ThreeDVMobject\",\n    \"Surface\",\n    \"Sphere\",\n    \"Dot3D\",\n    \"Cube\",\n    \"Prism\",\n    \"Cone\",\n    \"Arrow3D\",\n    \"Cylinder\",\n    \"Line3D\",\n    \"Torus\",\n]\n\nfrom collections.abc import Iterable, Sequence\nfrom typing import Any, Callable\n\nimport numpy as np\nfrom typing_extensions import Self\n\nfrom manim import config, logger\nfrom manim.constants import *\nfrom manim.mobject.geometry.arc import Circle\nfrom manim.mobject.geometry.polygram import Square\nfrom manim.mobject.mobject import *\nfrom manim.mobject.opengl.opengl_compatibility import ConvertToOpenGL\nfrom manim.mobject.opengl.opengl_mobject import OpenGLMobject\nfrom manim.mobject.types.vectorized_mobject import VectorizedPoint, VGroup, VMobject\nfrom manim.utils.color import (\n    ManimColor,\n    ParsableManimColor,\n)\nfrom manim.utils.iterables import tuplify\nfrom manim.utils.space_ops import normalize, perpendicular_bisector, z_to_vector\n\n\n\n[docs]\nclass ThreeDVMobject(VMobject, metaclass=ConvertToOpenGL):\n    def __init__(self, shade_in_3d: bool = True, **kwargs):\n        super().__init__(shade_in_3d=shade_in_3d, **kwargs)\n\n\n\n\n[docs]\nclass Surface(VGroup, metaclass=ConvertToOpenGL):\n    \"\"\"Creates a Parametric Surface using a checkerboard pattern.\n\n    Parameters\n    ----------\n    func\n        The function defining the :class:`Surface`.\n    u_range\n        The range of the ``u`` variable: ``(u_min, u_max)``.\n    v_range\n        The range of the ``v`` variable: ``(v_min, v_max)``.\n    resolution\n        The number of samples taken of the :class:`Surface`. A tuple can be\n        used to define different resolutions for ``u`` and ``v`` respectively.\n    fill_color\n        The color of the :class:`Surface`. Ignored if ``checkerboard_colors``\n        is set.\n    fill_opacity\n        The opacity of the :class:`Surface`, from 0 being fully transparent\n        to 1 being fully opaque. Defaults to 1.\n    checkerboard_colors\n        ng individual faces alternating colors. Overrides ``fill_color``.\n    stroke_color\n        Color of the stroke surrounding each face of :class:`Surface`.\n    stroke_width\n        Width of the stroke surrounding each face of :class:`Surface`.\n        Defaults to 0.5.\n    should_make_jagged\n        Changes the anchor mode of the Bézier curves from smooth to jagged.\n        Defaults to ``False``.\n\n    Examples\n    --------\n    .. manim:: ParaSurface\n        :save_last_frame:\n\n        class ParaSurface(ThreeDScene):\n            def func(self, u, v):\n                return np.array([np.cos(u) * np.cos(v), np.cos(u) * np.sin(v), u])\n\n            def construct(self):\n                axes = ThreeDAxes(x_range=[-4,4], x_length=8)\n                surface = Surface(\n                    lambda u, v: axes.c2p(*self.func(u, v)),\n                    u_range=[-PI, PI],\n                    v_range=[0, TAU],\n                    resolution=8,\n                )\n                self.set_camera_orientation(theta=70 * DEGREES, phi=75 * DEGREES)\n                self.add(axes, surface)\n    \"\"\"\n\n    def __init__(\n        self,\n        func: Callable[[float, float], np.ndarray],\n        u_range: Sequence[float] = [0, 1],\n        v_range: Sequence[float] = [0, 1],\n        resolution: Sequence[int] = 32,\n        surface_piece_config: dict = {},\n        fill_color: ParsableManimColor = BLUE_D,\n        fill_opacity: float = 1.0,\n        checkerboard_colors: Sequence[ParsableManimColor] | bool = [BLUE_D, BLUE_E],\n        stroke_color: ParsableManimColor = LIGHT_GREY,\n        stroke_width: float = 0.5,\n        should_make_jagged: bool = False,\n        pre_function_handle_to_anchor_scale_factor: float = 0.00001,\n        **kwargs: Any,\n    ) -> None:\n        self.u_range = u_range\n        self.v_range = v_range\n        super().__init__(**kwargs)\n        self.resolution = resolution\n        self.surface_piece_config = surface_piece_config\n        self.fill_color: ManimColor = ManimColor(fill_color)\n        self.fill_opacity = fill_opacity\n        if checkerboard_colors:\n            self.checkerboard_colors: list[ManimColor] = [\n                ManimColor(x) for x in checkerboard_colors\n            ]\n        else:\n            self.checkerboard_colors = checkerboard_colors\n        self.stroke_color: ManimColor = ManimColor(stroke_color)\n        self.stroke_width = stroke_width\n        self.should_make_jagged = should_make_jagged\n        self.pre_function_handle_to_anchor_scale_factor = (\n            pre_function_handle_to_anchor_scale_factor\n        )\n        self._func = func\n        self._setup_in_uv_space()\n        self.apply_function(lambda p: func(p[0], p[1]))\n        if self.should_make_jagged:\n            self.make_jagged()\n\n    def func(self, u: float, v: float) -> np.ndarray:\n        return self._func(u, v)\n\n    def _get_u_values_and_v_values(self) -> tuple[np.ndarray, np.ndarray]:\n        res = tuplify(self.resolution)\n        if len(res) == 1:\n            u_res = v_res = res[0]\n        else:\n            u_res, v_res = res\n\n        u_values = np.linspace(*self.u_range, u_res + 1)\n        v_values = np.linspace(*self.v_range, v_res + 1)\n\n        return u_values, v_values\n\n    def _setup_in_uv_space(self) -> None:\n        u_values, v_values = self._get_u_values_and_v_values()\n        faces = VGroup()\n        for i in range(len(u_values) - 1):\n            for j in range(len(v_values) - 1):\n                u1, u2 = u_values[i : i + 2]\n                v1, v2 = v_values[j : j + 2]\n                face = ThreeDVMobject()\n                face.set_points_as_corners(\n                    [\n                        [u1, v1, 0],\n                        [u2, v1, 0],\n                        [u2, v2, 0],\n                        [u1, v2, 0],\n                        [u1, v1, 0],\n                    ],\n                )\n                faces.add(face)\n                face.u_index = i\n                face.v_index = j\n                face.u1 = u1\n                face.u2 = u2\n                face.v1 = v1\n                face.v2 = v2\n        faces.set_fill(color=self.fill_color, opacity=self.fill_opacity)\n        faces.set_stroke(\n            color=self.stroke_color,\n            width=self.stroke_width,\n            opacity=self.stroke_opacity,\n        )\n        self.add(*faces)\n        if self.checkerboard_colors:\n            self.set_fill_by_checkerboard(*self.checkerboard_colors)\n\n\n[docs]\n    def set_fill_by_checkerboard(\n        self, *colors: Iterable[ParsableManimColor], opacity: float | None = None\n    ) -> Self:\n        \"\"\"Sets the fill_color of each face of :class:`Surface` in\n        an alternating pattern.\n\n        Parameters\n        ----------\n        colors\n            List of colors for alternating pattern.\n        opacity\n            The fill_opacity of :class:`Surface`, from 0 being fully transparent\n            to 1 being fully opaque.\n\n        Returns\n        -------\n        :class:`~.Surface`\n            The parametric surface with an alternating pattern.\n        \"\"\"\n        n_colors = len(colors)\n        for face in self:\n            c_index = (face.u_index + face.v_index) % n_colors\n            face.set_fill(colors[c_index], opacity=opacity)\n        return self\n\n\n\n[docs]\n    def set_fill_by_value(\n        self,\n        axes: Mobject,\n        colorscale: list[ParsableManimColor] | ParsableManimColor | None = None,\n        axis: int = 2,\n        **kwargs,\n    ) -> Self:\n        \"\"\"Sets the color of each mobject of a parametric surface to a color\n        relative to its axis-value.\n\n        Parameters\n        ----------\n        axes\n            The axes for the parametric surface, which will be used to map\n            axis-values to colors.\n        colorscale\n            A list of colors, ordered from lower axis-values to higher axis-values.\n            If a list of tuples is passed containing colors paired with numbers,\n            then those numbers will be used as the pivots.\n        axis\n            The chosen axis to use for the color mapping. (0 = x, 1 = y, 2 = z)\n\n        Returns\n        -------\n        :class:`~.Surface`\n            The parametric surface with a gradient applied by value. For chaining.\n\n        Examples\n        --------\n        .. manim:: FillByValueExample\n            :save_last_frame:\n\n            class FillByValueExample(ThreeDScene):\n                def construct(self):\n                    resolution_fa = 8\n                    self.set_camera_orientation(phi=75 * DEGREES, theta=-160 * DEGREES)\n                    axes = ThreeDAxes(x_range=(0, 5, 1), y_range=(0, 5, 1), z_range=(-1, 1, 0.5))\n                    def param_surface(u, v):\n                        x = u\n                        y = v\n                        z = np.sin(x) * np.cos(y)\n                        return z\n                    surface_plane = Surface(\n                        lambda u, v: axes.c2p(u, v, param_surface(u, v)),\n                        resolution=(resolution_fa, resolution_fa),\n                        v_range=[0, 5],\n                        u_range=[0, 5],\n                        )\n                    surface_plane.set_style(fill_opacity=1)\n                    surface_plane.set_fill_by_value(axes=axes, colorscale=[(RED, -0.5), (YELLOW, 0), (GREEN, 0.5)], axis=2)\n                    self.add(axes, surface_plane)\n        \"\"\"\n        if \"colors\" in kwargs and colorscale is None:\n            colorscale = kwargs.pop(\"colors\")\n            if kwargs:\n                raise ValueError(\n                    \"Unsupported keyword argument(s): \"\n                    f\"{', '.join(str(key) for key in kwargs)}\"\n                )\n        if colorscale is None:\n            logger.warning(\n                \"The value passed to the colorscale keyword argument was None, \"\n                \"the surface fill color has not been changed\"\n            )\n            return self\n\n        ranges = [axes.x_range, axes.y_range, axes.z_range]\n\n        if type(colorscale[0]) is tuple:\n            new_colors, pivots = [\n                [i for i, j in colorscale],\n                [j for i, j in colorscale],\n            ]\n        else:\n            new_colors = colorscale\n\n            pivot_min = ranges[axis][0]\n            pivot_max = ranges[axis][1]\n            pivot_frequency = (pivot_max - pivot_min) / (len(new_colors) - 1)\n            pivots = np.arange(\n                start=pivot_min,\n                stop=pivot_max + pivot_frequency,\n                step=pivot_frequency,\n            )\n\n        for mob in self.family_members_with_points():\n            axis_value = axes.point_to_coords(mob.get_midpoint())[axis]\n            if axis_value <= pivots[0]:\n                mob.set_color(new_colors[0])\n            elif axis_value >= pivots[-1]:\n                mob.set_color(new_colors[-1])\n            else:\n                for i, pivot in enumerate(pivots):\n                    if pivot > axis_value:\n                        color_index = (axis_value - pivots[i - 1]) / (\n                            pivots[i] - pivots[i - 1]\n                        )\n                        color_index = min(color_index, 1)\n                        mob_color = interpolate_color(\n                            new_colors[i - 1],\n                            new_colors[i],\n                            color_index,\n                        )\n                        if config.renderer == RendererType.OPENGL:\n                            mob.set_color(mob_color, recurse=False)\n                        elif config.renderer == RendererType.CAIRO:\n                            mob.set_color(mob_color, family=False)\n                        break\n\n        return self\n\n\n\n\n# Specific shapes\n\n\n\n[docs]\nclass Sphere(Surface):\n    \"\"\"A three-dimensional sphere.\n\n    Parameters\n    ----------\n    center\n        Center of the :class:`Sphere`.\n    radius\n        The radius of the :class:`Sphere`.\n    resolution\n        The number of samples taken of the :class:`Sphere`. A tuple can be used\n        to define different resolutions for ``u`` and ``v`` respectively.\n    u_range\n        The range of the ``u`` variable: ``(u_min, u_max)``.\n    v_range\n        The range of the ``v`` variable: ``(v_min, v_max)``.\n\n    Examples\n    --------\n\n    .. manim:: ExampleSphere\n        :save_last_frame:\n\n        class ExampleSphere(ThreeDScene):\n            def construct(self):\n                self.set_camera_orientation(phi=PI / 6, theta=PI / 6)\n                sphere1 = Sphere(\n                    center=(3, 0, 0),\n                    radius=1,\n                    resolution=(20, 20),\n                    u_range=[0.001, PI - 0.001],\n                    v_range=[0, TAU]\n                )\n                sphere1.set_color(RED)\n                self.add(sphere1)\n                sphere2 = Sphere(center=(-1, -3, 0), radius=2, resolution=(18, 18))\n                sphere2.set_color(GREEN)\n                self.add(sphere2)\n                sphere3 = Sphere(center=(-1, 2, 0), radius=2, resolution=(16, 16))\n                sphere3.set_color(BLUE)\n                self.add(sphere3)\n    \"\"\"\n\n    def __init__(\n        self,\n        center: Point3DLike = ORIGIN,\n        radius: float = 1,\n        resolution: Sequence[int] | None = None,\n        u_range: Sequence[float] = (0, TAU),\n        v_range: Sequence[float] = (0, PI),\n        **kwargs,\n    ) -> None:\n        if config.renderer == RendererType.OPENGL:\n            res_value = (101, 51)\n        elif config.renderer == RendererType.CAIRO:\n            res_value = (24, 12)\n        else:\n            raise Exception(\"Unknown renderer\")\n\n        resolution = resolution if resolution is not None else res_value\n\n        self.radius = radius\n\n        super().__init__(\n            self.func,\n            resolution=resolution,\n            u_range=u_range,\n            v_range=v_range,\n            **kwargs,\n        )\n\n        self.shift(center)\n\n\n[docs]\n    def func(self, u: float, v: float) -> np.ndarray:\n        \"\"\"The z values defining the :class:`Sphere` being plotted.\n\n        Returns\n        -------\n        :class:`numpy.array`\n            The z values defining the :class:`Sphere`.\n        \"\"\"\n        return self.radius * np.array(\n            [np.cos(u) * np.sin(v), np.sin(u) * np.sin(v), -np.cos(v)],\n        )\n\n\n\n\n\n[docs]\nclass Dot3D(Sphere):\n    \"\"\"A spherical dot.\n\n    Parameters\n    ----------\n    point\n        The location of the dot.\n    radius\n        The radius of the dot.\n    color\n        The color of the :class:`Dot3D`.\n    resolution\n        The number of samples taken of the :class:`Dot3D`. A tuple can be\n        used to define different resolutions for ``u`` and ``v`` respectively.\n\n    Examples\n    --------\n\n    .. manim:: Dot3DExample\n        :save_last_frame:\n\n        class Dot3DExample(ThreeDScene):\n            def construct(self):\n                self.set_camera_orientation(phi=75*DEGREES, theta=-45*DEGREES)\n\n                axes = ThreeDAxes()\n                dot_1 = Dot3D(point=axes.coords_to_point(0, 0, 1), color=RED)\n                dot_2 = Dot3D(point=axes.coords_to_point(2, 0, 0), radius=0.1, color=BLUE)\n                dot_3 = Dot3D(point=[0, 0, 0], radius=0.1, color=ORANGE)\n                self.add(axes, dot_1, dot_2,dot_3)\n    \"\"\"\n\n    def __init__(\n        self,\n        point: list | np.ndarray = ORIGIN,\n        radius: float = DEFAULT_DOT_RADIUS,\n        color: ParsableManimColor = WHITE,\n        resolution: tuple[int, int] = (8, 8),\n        **kwargs,\n    ) -> None:\n        super().__init__(center=point, radius=radius, resolution=resolution, **kwargs)\n        self.set_color(color)\n\n\n\n\n[docs]\nclass Cube(VGroup):\n    \"\"\"A three-dimensional cube.\n\n    Parameters\n    ----------\n    side_length\n        Length of each side of the :class:`Cube`.\n    fill_opacity\n        The opacity of the :class:`Cube`, from 0 being fully transparent to 1 being\n        fully opaque. Defaults to 0.75.\n    fill_color\n        The color of the :class:`Cube`.\n    stroke_width\n        The width of the stroke surrounding each face of the :class:`Cube`.\n\n    Examples\n    --------\n\n    .. manim:: CubeExample\n        :save_last_frame:\n\n        class CubeExample(ThreeDScene):\n            def construct(self):\n                self.set_camera_orientation(phi=75*DEGREES, theta=-45*DEGREES)\n\n                axes = ThreeDAxes()\n                cube = Cube(side_length=3, fill_opacity=0.7, fill_color=BLUE)\n                self.add(cube)\n    \"\"\"\n\n    def __init__(\n        self,\n        side_length: float = 2,\n        fill_opacity: float = 0.75,\n        fill_color: ParsableManimColor = BLUE,\n        stroke_width: float = 0,\n        **kwargs,\n    ) -> None:\n        self.side_length = side_length\n        super().__init__(\n            fill_color=fill_color,\n            fill_opacity=fill_opacity,\n            stroke_width=stroke_width,\n            **kwargs,\n        )\n\n\n[docs]\n    def generate_points(self) -> None:\n        \"\"\"Creates the sides of the :class:`Cube`.\"\"\"\n        for vect in IN, OUT, LEFT, RIGHT, UP, DOWN:\n            face = Square(\n                side_length=self.side_length,\n                shade_in_3d=True,\n            )\n            face.flip()\n            face.shift(self.side_length * OUT / 2.0)\n            face.apply_matrix(z_to_vector(vect))\n\n            self.add(face)\n\n\n    init_points = generate_points\n\n\n\n\n[docs]\nclass Prism(Cube):\n    \"\"\"A right rectangular prism (or rectangular cuboid).\n    Defined by the length of each side in ``[x, y, z]`` format.\n\n    Parameters\n    ----------\n    dimensions\n        Dimensions of the :class:`Prism` in ``[x, y, z]`` format.\n\n    Examples\n    --------\n\n    .. manim:: ExamplePrism\n        :save_last_frame:\n\n        class ExamplePrism(ThreeDScene):\n            def construct(self):\n                self.set_camera_orientation(phi=60 * DEGREES, theta=150 * DEGREES)\n                prismSmall = Prism(dimensions=[1, 2, 3]).rotate(PI / 2)\n                prismLarge = Prism(dimensions=[1.5, 3, 4.5]).move_to([2, 0, 0])\n                self.add(prismSmall, prismLarge)\n    \"\"\"\n\n    def __init__(\n        self, dimensions: tuple[float, float, float] | np.ndarray = [3, 2, 1], **kwargs\n    ) -> None:\n        self.dimensions = dimensions\n        super().__init__(**kwargs)\n\n\n[docs]\n    def generate_points(self) -> None:\n        \"\"\"Creates the sides of the :class:`Prism`.\"\"\"\n        super().generate_points()\n        for dim, value in enumerate(self.dimensions):\n            self.rescale_to_fit(value, dim, stretch=True)\n\n\n\n\n\n[docs]\nclass Cone(Surface):\n    \"\"\"A circular cone.\n    Can be defined using 2 parameters: its height, and its base radius.\n    The polar angle, theta, can be calculated using arctan(base_radius /\n    height) The spherical radius, r, is calculated using the pythagorean\n    theorem.\n\n    Parameters\n    ----------\n    base_radius\n        The base radius from which the cone tapers.\n    height\n        The height measured from the plane formed by the base_radius to\n        the apex of the cone.\n    direction\n        The direction of the apex.\n    show_base\n        Whether to show the base plane or not.\n    v_range\n        The azimuthal angle to start and end at.\n    u_min\n        The radius at the apex.\n    checkerboard_colors\n        Show checkerboard grid texture on the cone.\n\n    Examples\n    --------\n    .. manim:: ExampleCone\n        :save_last_frame:\n\n        class ExampleCone(ThreeDScene):\n            def construct(self):\n                axes = ThreeDAxes()\n                cone = Cone(direction=X_AXIS+Y_AXIS+2*Z_AXIS, resolution=8)\n                self.set_camera_orientation(phi=5*PI/11, theta=PI/9)\n                self.add(axes, cone)\n    \"\"\"\n\n    def __init__(\n        self,\n        base_radius: float = 1,\n        height: float = 1,\n        direction: np.ndarray = Z_AXIS,\n        show_base: bool = False,\n        v_range: Sequence[float] = [0, TAU],\n        u_min: float = 0,\n        checkerboard_colors: bool = False,\n        **kwargs: Any,\n    ) -> None:\n        self.direction = direction\n        self.theta = PI - np.arctan(base_radius / height)\n\n        super().__init__(\n            self.func,\n            v_range=v_range,\n            u_range=[u_min, np.sqrt(base_radius**2 + height**2)],\n            checkerboard_colors=checkerboard_colors,\n            **kwargs,\n        )\n        # used for rotations\n        self.new_height = height\n        self._current_theta = 0\n        self._current_phi = 0\n        self.base_circle = Circle(\n            radius=base_radius,\n            color=self.fill_color,\n            fill_opacity=self.fill_opacity,\n            stroke_width=0,\n        )\n        self.base_circle.shift(height * IN)\n        self._set_start_and_end_attributes(direction)\n        if show_base:\n            self.add(self.base_circle)\n\n        self._rotate_to_direction()\n\n\n[docs]\n    def func(self, u: float, v: float) -> np.ndarray:\n        \"\"\"Converts from spherical coordinates to cartesian.\n\n        Parameters\n        ----------\n        u\n            The radius.\n        v\n            The azimuthal angle.\n\n        Returns\n        -------\n        :class:`numpy.array`\n            Points defining the :class:`Cone`.\n        \"\"\"\n        r = u\n        phi = v\n        return np.array(\n            [\n                r * np.sin(self.theta) * np.cos(phi),\n                r * np.sin(self.theta) * np.sin(phi),\n                r * np.cos(self.theta),\n            ],\n        )\n\n\n\n[docs]\n    def get_start(self) -> np.ndarray:\n        return self.start_point.get_center()\n\n\n\n[docs]\n    def get_end(self) -> np.ndarray:\n        return self.end_point.get_center()\n\n\n    def _rotate_to_direction(self) -> None:\n        x, y, z = self.direction\n\n        r = np.sqrt(x**2 + y**2 + z**2)\n        theta = np.arccos(z / r) if r > 0 else 0\n\n        if x == 0:\n            if y == 0:  # along the z axis\n                phi = 0\n            else:\n                phi = np.arctan(np.inf)\n                if y < 0:\n                    phi += PI\n        else:\n            phi = np.arctan(y / x)\n        if x < 0:\n            phi += PI\n\n        # Undo old rotation (in reverse order)\n        self.rotate(-self._current_phi, Z_AXIS, about_point=ORIGIN)\n        self.rotate(-self._current_theta, Y_AXIS, about_point=ORIGIN)\n\n        # Do new rotation\n        self.rotate(theta, Y_AXIS, about_point=ORIGIN)\n        self.rotate(phi, Z_AXIS, about_point=ORIGIN)\n\n        # Store values\n        self._current_theta = theta\n        self._current_phi = phi\n\n\n[docs]\n    def set_direction(self, direction: np.ndarray) -> None:\n        \"\"\"Changes the direction of the apex of the :class:`Cone`.\n\n        Parameters\n        ----------\n        direction\n            The direction of the apex.\n        \"\"\"\n        self.direction = direction\n        self._rotate_to_direction()\n\n\n\n[docs]\n    def get_direction(self) -> np.ndarray:\n        \"\"\"Returns the current direction of the apex of the :class:`Cone`.\n\n        Returns\n        -------\n        direction : :class:`numpy.array`\n            The direction of the apex.\n        \"\"\"\n        return self.direction\n\n\n    def _set_start_and_end_attributes(self, direction):\n        normalized_direction = direction * np.linalg.norm(direction)\n\n        start = self.base_circle.get_center()\n        end = start + normalized_direction * self.new_height\n        self.start_point = VectorizedPoint(start)\n        self.end_point = VectorizedPoint(end)\n        self.add(self.start_point, self.end_point)\n\n\n\n\n[docs]\nclass Cylinder(Surface):\n    \"\"\"A cylinder, defined by its height, radius and direction,\n\n    Parameters\n    ----------\n    radius\n        The radius of the cylinder.\n    height\n        The height of the cylinder.\n    direction\n        The direction of the central axis of the cylinder.\n    v_range\n        The height along the height axis (given by direction) to start and end on.\n    show_ends\n        Whether to show the end caps or not.\n    resolution\n        The number of samples taken of the :class:`Cylinder`. A tuple can be used\n        to define different resolutions for ``u`` and ``v`` respectively.\n\n    Examples\n    --------\n    .. manim:: ExampleCylinder\n        :save_last_frame:\n\n        class ExampleCylinder(ThreeDScene):\n            def construct(self):\n                axes = ThreeDAxes()\n                cylinder = Cylinder(radius=2, height=3)\n                self.set_camera_orientation(phi=75 * DEGREES, theta=30 * DEGREES)\n                self.add(axes, cylinder)\n    \"\"\"\n\n    def __init__(\n        self,\n        radius: float = 1,\n        height: float = 2,\n        direction: np.ndarray = Z_AXIS,\n        v_range: Sequence[float] = [0, TAU],\n        show_ends: bool = True,\n        resolution: Sequence[int] = (24, 24),\n        **kwargs,\n    ) -> None:\n        self._height = height\n        self.radius = radius\n        super().__init__(\n            self.func,\n            resolution=resolution,\n            u_range=[-self._height / 2, self._height / 2],\n            v_range=v_range,\n            **kwargs,\n        )\n        if show_ends:\n            self.add_bases()\n        self._current_phi = 0\n        self._current_theta = 0\n        self.set_direction(direction)\n\n\n[docs]\n    def func(self, u: float, v: float) -> np.ndarray:\n        \"\"\"Converts from cylindrical coordinates to cartesian.\n\n        Parameters\n        ----------\n        u\n            The height.\n        v\n            The azimuthal angle.\n\n        Returns\n        -------\n        :class:`numpy.ndarray`\n            Points defining the :class:`Cylinder`.\n        \"\"\"\n        height = u\n        phi = v\n        r = self.radius\n        return np.array([r * np.cos(phi), r * np.sin(phi), height])\n\n\n\n[docs]\n    def add_bases(self) -> None:\n        \"\"\"Adds the end caps of the cylinder.\"\"\"\n        if config.renderer == RendererType.OPENGL:\n            color = self.color\n            opacity = self.opacity\n        elif config.renderer == RendererType.CAIRO:\n            color = self.fill_color\n            opacity = self.fill_opacity\n\n        self.base_top = Circle(\n            radius=self.radius,\n            color=color,\n            fill_opacity=opacity,\n            shade_in_3d=True,\n            stroke_width=0,\n        )\n        self.base_top.shift(self.u_range[1] * IN)\n        self.base_bottom = Circle(\n            radius=self.radius,\n            color=color,\n            fill_opacity=opacity,\n            shade_in_3d=True,\n            stroke_width=0,\n        )\n        self.base_bottom.shift(self.u_range[0] * IN)\n        self.add(self.base_top, self.base_bottom)\n\n\n    def _rotate_to_direction(self) -> None:\n        x, y, z = self.direction\n\n        r = np.sqrt(x**2 + y**2 + z**2)\n        theta = np.arccos(z / r) if r > 0 else 0\n\n        if x == 0:\n            if y == 0:  # along the z axis\n                phi = 0\n            else:  # along the x axis\n                phi = np.arctan(np.inf)\n                if y < 0:\n                    phi += PI\n        else:\n            phi = np.arctan(y / x)\n        if x < 0:\n            phi += PI\n\n        # undo old rotation (in reverse direction)\n        self.rotate(-self._current_phi, Z_AXIS, about_point=ORIGIN)\n        self.rotate(-self._current_theta, Y_AXIS, about_point=ORIGIN)\n\n        # do new rotation\n        self.rotate(theta, Y_AXIS, about_point=ORIGIN)\n        self.rotate(phi, Z_AXIS, about_point=ORIGIN)\n\n        # store new values\n        self._current_theta = theta\n        self._current_phi = phi\n\n\n[docs]\n    def set_direction(self, direction: np.ndarray) -> None:\n        \"\"\"Sets the direction of the central axis of the :class:`Cylinder`.\n\n        Parameters\n        ----------\n        direction : :class:`numpy.array`\n            The direction of the central axis of the :class:`Cylinder`.\n        \"\"\"\n        # if get_norm(direction) is get_norm(self.direction):\n        #     pass\n        self.direction = direction\n        self._rotate_to_direction()\n\n\n\n[docs]\n    def get_direction(self) -> np.ndarray:\n        \"\"\"Returns the direction of the central axis of the :class:`Cylinder`.\n\n        Returns\n        -------\n        direction : :class:`numpy.array`\n            The direction of the central axis of the :class:`Cylinder`.\n        \"\"\"\n        return self.direction\n\n\n\n\n\n[docs]\nclass Line3D(Cylinder):\n    \"\"\"A cylindrical line, for use in ThreeDScene.\n\n    Parameters\n    ----------\n    start\n        The start point of the line.\n    end\n        The end point of the line.\n    thickness\n        The thickness of the line.\n    color\n        The color of the line.\n    resolution\n        The resolution of the line.\n        By default this value is the number of points the line will sampled at.\n        If you want the line to also come out checkered, use a tuple.\n        For example, for a line made of 24 points with 4 checker points on each\n        cylinder, pass the tuple (4, 24).\n\n    Examples\n    --------\n    .. manim:: ExampleLine3D\n        :save_last_frame:\n\n        class ExampleLine3D(ThreeDScene):\n            def construct(self):\n                axes = ThreeDAxes()\n                line = Line3D(start=np.array([0, 0, 0]), end=np.array([2, 2, 2]))\n                self.set_camera_orientation(phi=75 * DEGREES, theta=30 * DEGREES)\n                self.add(axes, line)\n    \"\"\"\n\n    def __init__(\n        self,\n        start: np.ndarray = LEFT,\n        end: np.ndarray = RIGHT,\n        thickness: float = 0.02,\n        color: ParsableManimColor | None = None,\n        resolution: int | Sequence[int] = 24,\n        **kwargs,\n    ):\n        self.thickness = thickness\n        self.resolution = (2, resolution) if isinstance(resolution, int) else resolution\n        self.set_start_and_end_attrs(start, end, **kwargs)\n        if color is not None:\n            self.set_color(color)\n\n\n[docs]\n    def set_start_and_end_attrs(\n        self, start: np.ndarray, end: np.ndarray, **kwargs\n    ) -> None:\n        \"\"\"Sets the start and end points of the line.\n\n        If either ``start`` or ``end`` are :class:`Mobjects <.Mobject>`,\n        this gives their centers.\n\n        Parameters\n        ----------\n        start\n            Starting point or :class:`Mobject`.\n        end\n            Ending point or :class:`Mobject`.\n        \"\"\"\n        rough_start = self.pointify(start)\n        rough_end = self.pointify(end)\n        self.vect = rough_end - rough_start\n        self.length = np.linalg.norm(self.vect)\n        self.direction = normalize(self.vect)\n        # Now that we know the direction between them,\n        # we can the appropriate boundary point from\n        # start and end, if they're mobjects\n        self.start = self.pointify(start, self.direction)\n        self.end = self.pointify(end, -self.direction)\n        super().__init__(\n            height=np.linalg.norm(self.vect),\n            radius=self.thickness,\n            direction=self.direction,\n            resolution=self.resolution,\n            **kwargs,\n        )\n        self.shift((self.start + self.end) / 2)\n\n\n\n[docs]\n    def pointify(\n        self,\n        mob_or_point: Mobject | Point3DLike,\n        direction: Vector3D = None,\n    ) -> np.ndarray:\n        \"\"\"Gets a point representing the center of the :class:`Mobjects <.Mobject>`.\n\n        Parameters\n        ----------\n        mob_or_point\n            :class:`Mobjects <.Mobject>` or point whose center should be returned.\n        direction\n            If an edge of a :class:`Mobjects <.Mobject>` should be returned, the direction of the edge.\n\n        Returns\n        -------\n        :class:`numpy.array`\n            Center of the :class:`Mobjects <.Mobject>` or point, or edge if direction is given.\n        \"\"\"\n        if isinstance(mob_or_point, (Mobject, OpenGLMobject)):\n            mob = mob_or_point\n            if direction is None:\n                return mob.get_center()\n            else:\n                return mob.get_boundary_point(direction)\n        return np.array(mob_or_point)\n\n\n\n[docs]\n    def get_start(self) -> np.ndarray:\n        \"\"\"Returns the starting point of the :class:`Line3D`.\n\n        Returns\n        -------\n        start : :class:`numpy.array`\n            Starting point of the :class:`Line3D`.\n        \"\"\"\n        return self.start\n\n\n\n[docs]\n    def get_end(self) -> np.ndarray:\n        \"\"\"Returns the ending point of the :class:`Line3D`.\n\n        Returns\n        -------\n        end : :class:`numpy.array`\n            Ending point of the :class:`Line3D`.\n        \"\"\"\n        return self.end\n\n\n\n[docs]\n    @classmethod\n    def parallel_to(\n        cls,\n        line: Line3D,\n        point: Vector3D = ORIGIN,\n        length: float = 5,\n        **kwargs,\n    ) -> Line3D:\n        \"\"\"Returns a line parallel to another line going through\n        a given point.\n\n        Parameters\n        ----------\n        line\n            The line to be parallel to.\n        point\n            The point to pass through.\n        length\n            Length of the parallel line.\n        kwargs\n            Additional parameters to be passed to the class.\n\n        Returns\n        -------\n        :class:`Line3D`\n            Line parallel to ``line``.\n\n        Examples\n        --------\n        .. manim:: ParallelLineExample\n            :save_last_frame:\n\n            class ParallelLineExample(ThreeDScene):\n                def construct(self):\n                    self.set_camera_orientation(PI / 3, -PI / 4)\n                    ax = ThreeDAxes((-5, 5), (-5, 5), (-5, 5), 10, 10, 10)\n                    line1 = Line3D(RIGHT * 2, UP + OUT, color=RED)\n                    line2 = Line3D.parallel_to(line1, color=YELLOW)\n                    self.add(ax, line1, line2)\n        \"\"\"\n        point = np.array(point)\n        vect = normalize(line.vect)\n        return cls(\n            point + vect * length / 2,\n            point - vect * length / 2,\n            **kwargs,\n        )\n\n\n\n[docs]\n    @classmethod\n    def perpendicular_to(\n        cls,\n        line: Line3D,\n        point: Vector3D = ORIGIN,\n        length: float = 5,\n        **kwargs,\n    ) -> Line3D:\n        \"\"\"Returns a line perpendicular to another line going through\n        a given point.\n\n        Parameters\n        ----------\n        line\n            The line to be perpendicular to.\n        point\n            The point to pass through.\n        length\n            Length of the perpendicular line.\n        kwargs\n            Additional parameters to be passed to the class.\n\n        Returns\n        -------\n        :class:`Line3D`\n            Line perpendicular to ``line``.\n\n        Examples\n        --------\n        .. manim:: PerpLineExample\n            :save_last_frame:\n\n            class PerpLineExample(ThreeDScene):\n                def construct(self):\n                    self.set_camera_orientation(PI / 3, -PI / 4)\n                    ax = ThreeDAxes((-5, 5), (-5, 5), (-5, 5), 10, 10, 10)\n                    line1 = Line3D(RIGHT * 2, UP + OUT, color=RED)\n                    line2 = Line3D.perpendicular_to(line1, color=BLUE)\n                    self.add(ax, line1, line2)\n        \"\"\"\n        point = np.array(point)\n\n        norm = np.cross(line.vect, point - line.start)\n        if all(np.linalg.norm(norm) == np.zeros(3)):\n            raise ValueError(\"Could not find the perpendicular.\")\n\n        start, end = perpendicular_bisector([line.start, line.end], norm)\n        vect = normalize(end - start)\n        return cls(\n            point + vect * length / 2,\n            point - vect * length / 2,\n            **kwargs,\n        )\n\n\n\n\n\n[docs]\nclass Arrow3D(Line3D):\n    \"\"\"An arrow made out of a cylindrical line and a conical tip.\n\n    Parameters\n    ----------\n    start\n        The start position of the arrow.\n    end\n        The end position of the arrow.\n    thickness\n        The thickness of the arrow.\n    height\n        The height of the conical tip.\n    base_radius\n        The base radius of the conical tip.\n    color\n        The color of the arrow.\n    resolution\n        The resolution of the arrow line.\n\n    Examples\n    --------\n    .. manim:: ExampleArrow3D\n        :save_last_frame:\n\n        class ExampleArrow3D(ThreeDScene):\n            def construct(self):\n                axes = ThreeDAxes()\n                arrow = Arrow3D(\n                    start=np.array([0, 0, 0]),\n                    end=np.array([2, 2, 2]),\n                    resolution=8\n                )\n                self.set_camera_orientation(phi=75 * DEGREES, theta=30 * DEGREES)\n                self.add(axes, arrow)\n    \"\"\"\n\n    def __init__(\n        self,\n        start: np.ndarray = LEFT,\n        end: np.ndarray = RIGHT,\n        thickness: float = 0.02,\n        height: float = 0.3,\n        base_radius: float = 0.08,\n        color: ParsableManimColor = WHITE,\n        resolution: int | Sequence[int] = 24,\n        **kwargs,\n    ) -> None:\n        super().__init__(\n            start=start,\n            end=end,\n            thickness=thickness,\n            color=color,\n            resolution=resolution,\n            **kwargs,\n        )\n\n        self.length = np.linalg.norm(self.vect)\n        self.set_start_and_end_attrs(\n            self.start,\n            self.end - height * self.direction,\n            **kwargs,\n        )\n        self.cone = Cone(\n            direction=self.direction,\n            base_radius=base_radius,\n            height=height,\n            **kwargs,\n        )\n        self.cone.shift(end)\n        self.end_point = VectorizedPoint(end)\n        self.add(self.end_point, self.cone)\n        self.set_color(color)\n\n\n[docs]\n    def get_end(self) -> np.ndarray:\n        return self.end_point.get_center()\n\n\n\n\n\n[docs]\nclass Torus(Surface):\n    \"\"\"A torus.\n\n    Parameters\n    ----------\n    major_radius\n        Distance from the center of the tube to the center of the torus.\n    minor_radius\n        Radius of the tube.\n    u_range\n        The range of the ``u`` variable: ``(u_min, u_max)``.\n    v_range\n        The range of the ``v`` variable: ``(v_min, v_max)``.\n    resolution\n        The number of samples taken of the :class:`Torus`. A tuple can be\n        used to define different resolutions for ``u`` and ``v`` respectively.\n\n    Examples\n    --------\n    .. manim :: ExampleTorus\n        :save_last_frame:\n\n        class ExampleTorus(ThreeDScene):\n            def construct(self):\n                axes = ThreeDAxes()\n                torus = Torus()\n                self.set_camera_orientation(phi=75 * DEGREES, theta=30 * DEGREES)\n                self.add(axes, torus)\n    \"\"\"\n\n    def __init__(\n        self,\n        major_radius: float = 3,\n        minor_radius: float = 1,\n        u_range: Sequence[float] = (0, TAU),\n        v_range: Sequence[float] = (0, TAU),\n        resolution: tuple[int, int] | None = None,\n        **kwargs,\n    ) -> None:\n        if config.renderer == RendererType.OPENGL:\n            res_value = (101, 101)\n        elif config.renderer == RendererType.CAIRO:\n            res_value = (24, 24)\n\n        resolution = resolution if resolution is not None else res_value\n\n        self.R = major_radius\n        self.r = minor_radius\n        super().__init__(\n            self.func,\n            u_range=u_range,\n            v_range=v_range,\n            resolution=resolution,\n            **kwargs,\n        )\n\n\n[docs]\n    def func(self, u: float, v: float) -> np.ndarray:\n        \"\"\"The z values defining the :class:`Torus` being plotted.\n\n        Returns\n        -------\n        :class:`numpy.ndarray`\n            The z values defining the :class:`Torus`.\n        \"\"\"\n        P = np.array([np.cos(u), np.sin(u), 0])\n        return (self.R - self.r * np.cos(v)) * P - self.r * np.sin(v) * OUT", "code_sha1": "da582de2c2b105561f9756394f43d7fee0a10dd8"}
{"url": "https://docs.manim.community/en/stable/_modules/manim/mobject/types/image_mobject.html", "depth": 2, "instruction": "The code defines classes for displaying raster images in Manim, allowing for image manipulation such as color setting, opacity adjustments, and resampling algorithms. The `ImageMobject` class can display images from arrays or files, while `ImageMobjectFromCamera` captures images directly from a camera. Both classes support interpolation between images and can be styled with various properties.", "code": "\"\"\"Mobjects representing raster images.\"\"\"\n\nfrom __future__ import annotations\n\n__all__ = [\"AbstractImageMobject\", \"ImageMobject\", \"ImageMobjectFromCamera\"]\n\nimport pathlib\nfrom typing import TYPE_CHECKING\n\nimport numpy as np\nfrom PIL import Image\nfrom PIL.Image import Resampling\n\nfrom manim.mobject.geometry.shape_matchers import SurroundingRectangle\n\nfrom ... import config\nfrom ...constants import *\nfrom ...mobject.mobject import Mobject\nfrom ...utils.bezier import interpolate\nfrom ...utils.color import WHITE, ManimColor, color_to_int_rgb\nfrom ...utils.images import change_to_rgba_array, get_full_raster_image_path\n\n__all__ = [\"ImageMobject\", \"ImageMobjectFromCamera\"]\n\nif TYPE_CHECKING:\n    from typing import Any\n\n    import numpy.typing as npt\n    from typing_extensions import Self\n\n    from manim.typing import StrPath\n\n\n\n[docs]\nclass AbstractImageMobject(Mobject):\n    \"\"\"\n    Automatically filters out black pixels\n\n    Parameters\n    ----------\n    scale_to_resolution\n        At this resolution the image is placed pixel by pixel onto the screen, so it\n        will look the sharpest and best.\n        This is a custom parameter of ImageMobject so that rendering a scene with\n        e.g. the ``--quality low`` or ``--quality medium`` flag for faster rendering\n        won't effect the position of the image on the screen.\n    \"\"\"\n\n    def __init__(\n        self,\n        scale_to_resolution: int,\n        pixel_array_dtype: str = \"uint8\",\n        resampling_algorithm: Resampling = Resampling.BICUBIC,\n        **kwargs: Any,\n    ) -> None:\n        self.pixel_array_dtype = pixel_array_dtype\n        self.scale_to_resolution = scale_to_resolution\n        self.set_resampling_algorithm(resampling_algorithm)\n        super().__init__(**kwargs)\n\n    def get_pixel_array(self) -> None:\n        raise NotImplementedError()\n\n\n[docs]\n    def set_color(self, color, alpha=None, family=True):\n        # Likely to be implemented in subclasses, but no obligation\n        pass\n\n\n\n[docs]\n    def set_resampling_algorithm(self, resampling_algorithm: int) -> Self:\n        \"\"\"\n        Sets the interpolation method for upscaling the image. By default the image is\n        interpolated using bicubic algorithm. This method lets you change it.\n        Interpolation is done internally using Pillow, and the function besides the\n        string constants describing the algorithm accepts the Pillow integer constants.\n\n        Parameters\n        ----------\n        resampling_algorithm\n            An integer constant described in the Pillow library,\n            or one from the RESAMPLING_ALGORITHMS global dictionary,\n            under the following keys:\n\n            * 'bicubic' or 'cubic'\n            * 'nearest' or 'none'\n            * 'box'\n            * 'bilinear' or 'linear'\n            * 'hamming'\n            * 'lanczos' or 'antialias'\n        \"\"\"\n        if isinstance(resampling_algorithm, int):\n            self.resampling_algorithm = resampling_algorithm\n        else:\n            raise ValueError(\n                \"resampling_algorithm has to be an int, one of the values defined in \"\n                \"RESAMPLING_ALGORITHMS or a Pillow resampling filter constant. \"\n                \"Available algorithms: 'bicubic', 'nearest', 'box', 'bilinear', \"\n                \"'hamming', 'lanczos'.\",\n            )\n        return self\n\n\n\n[docs]\n    def reset_points(self) -> None:\n        \"\"\"Sets :attr:`points` to be the four image corners.\"\"\"\n        self.points = np.array(\n            [\n                UP + LEFT,\n                UP + RIGHT,\n                DOWN + LEFT,\n                DOWN + RIGHT,\n            ],\n        )\n        self.center()\n        h, w = self.get_pixel_array().shape[:2]\n        if self.scale_to_resolution:\n            height = h / self.scale_to_resolution * config[\"frame_height\"]\n        else:\n            height = 3  # this is the case for ImageMobjectFromCamera\n        self.stretch_to_fit_height(height)\n        self.stretch_to_fit_width(height * w / h)\n\n\n\n\n\n[docs]\nclass ImageMobject(AbstractImageMobject):\n    \"\"\"Displays an Image from a numpy array or a file.\n\n    Parameters\n    ----------\n    scale_to_resolution\n        At this resolution the image is placed pixel by pixel onto the screen, so it\n        will look the sharpest and best.\n        This is a custom parameter of ImageMobject so that rendering a scene with\n        e.g. the ``--quality low`` or ``--quality medium`` flag for faster rendering\n        won't effect the position of the image on the screen.\n\n\n    Example\n    -------\n    .. manim:: ImageFromArray\n        :save_last_frame:\n\n        class ImageFromArray(Scene):\n            def construct(self):\n                image = ImageMobject(np.uint8([[0, 100, 30, 200],\n                                               [255, 0, 5, 33]]))\n                image.height = 7\n                self.add(image)\n\n\n    Changing interpolation style:\n\n    .. manim:: ImageInterpolationEx\n        :save_last_frame:\n\n        class ImageInterpolationEx(Scene):\n            def construct(self):\n                img = ImageMobject(np.uint8([[63, 0, 0, 0],\n                                                [0, 127, 0, 0],\n                                                [0, 0, 191, 0],\n                                                [0, 0, 0, 255]\n                                                ]))\n\n                img.height = 2\n                img1 = img.copy()\n                img2 = img.copy()\n                img3 = img.copy()\n                img4 = img.copy()\n                img5 = img.copy()\n\n                img1.set_resampling_algorithm(RESAMPLING_ALGORITHMS[\"nearest\"])\n                img2.set_resampling_algorithm(RESAMPLING_ALGORITHMS[\"lanczos\"])\n                img3.set_resampling_algorithm(RESAMPLING_ALGORITHMS[\"linear\"])\n                img4.set_resampling_algorithm(RESAMPLING_ALGORITHMS[\"cubic\"])\n                img5.set_resampling_algorithm(RESAMPLING_ALGORITHMS[\"box\"])\n                img1.add(Text(\"nearest\").scale(0.5).next_to(img1,UP))\n                img2.add(Text(\"lanczos\").scale(0.5).next_to(img2,UP))\n                img3.add(Text(\"linear\").scale(0.5).next_to(img3,UP))\n                img4.add(Text(\"cubic\").scale(0.5).next_to(img4,UP))\n                img5.add(Text(\"box\").scale(0.5).next_to(img5,UP))\n\n                x= Group(img1,img2,img3,img4,img5)\n                x.arrange()\n                self.add(x)\n    \"\"\"\n\n    def __init__(\n        self,\n        filename_or_array: StrPath | npt.NDArray,\n        scale_to_resolution: int = QUALITIES[DEFAULT_QUALITY][\"pixel_height\"],\n        invert: bool = False,\n        image_mode: str = \"RGBA\",\n        **kwargs: Any,\n    ) -> None:\n        self.fill_opacity: float = 1\n        self.stroke_opacity: float = 1\n        self.invert_image = invert\n        self.image_mode = image_mode\n        if isinstance(filename_or_array, (str, pathlib.PurePath)):\n            path = get_full_raster_image_path(filename_or_array)\n            image = Image.open(path).convert(self.image_mode)\n            self.pixel_array = np.array(image)\n            self.path = path\n        else:\n            self.pixel_array = np.array(filename_or_array)\n        self.pixel_array_dtype = kwargs.get(\"pixel_array_dtype\", \"uint8\")\n        self.pixel_array = change_to_rgba_array(\n            self.pixel_array, self.pixel_array_dtype\n        )\n        if self.invert_image:\n            self.pixel_array[:, :, :3] = (\n                np.iinfo(self.pixel_array_dtype).max - self.pixel_array[:, :, :3]\n            )\n        super().__init__(scale_to_resolution, **kwargs)\n\n\n[docs]\n    def get_pixel_array(self):\n        \"\"\"A simple getter method.\"\"\"\n        return self.pixel_array\n\n\n\n[docs]\n    def set_color(self, color, alpha=None, family=True):\n        rgb = color_to_int_rgb(color)\n        self.pixel_array[:, :, :3] = rgb\n        if alpha is not None:\n            self.pixel_array[:, :, 3] = int(255 * alpha)\n        for submob in self.submobjects:\n            submob.set_color(color, alpha, family)\n        self.color = color\n        return self\n\n\n\n[docs]\n    def set_opacity(self, alpha: float) -> Self:\n        \"\"\"Sets the image's opacity.\n\n        Parameters\n        ----------\n        alpha\n            The alpha value of the object, 1 being opaque and 0 being\n            transparent.\n        \"\"\"\n        self.pixel_array[:, :, 3] = int(255 * alpha)\n        self.fill_opacity = alpha\n        self.stroke_opacity = alpha\n        return self\n\n\n\n[docs]\n    def fade(self, darkness: float = 0.5, family: bool = True) -> Self:\n        \"\"\"Sets the image's opacity using a 1 - alpha relationship.\n\n        Parameters\n        ----------\n        darkness\n            The alpha value of the object, 1 being transparent and 0 being\n            opaque.\n        family\n            Whether the submobjects of the ImageMobject should be affected.\n        \"\"\"\n        self.set_opacity(1 - darkness)\n        super().fade(darkness, family)\n        return self\n\n\n\n[docs]\n    def interpolate_color(\n        self, mobject1: ImageMobject, mobject2: ImageMobject, alpha: float\n    ) -> None:\n        \"\"\"Interpolates the array of pixel color values from one ImageMobject\n        into an array of equal size in the target ImageMobject.\n\n        Parameters\n        ----------\n        mobject1\n            The ImageMobject to transform from.\n\n        mobject2\n            The ImageMobject to transform into.\n\n        alpha\n            Used to track the lerp relationship. Not opacity related.\n        \"\"\"\n        assert mobject1.pixel_array.shape == mobject2.pixel_array.shape, (\n            f\"Mobject pixel array shapes incompatible for interpolation.\\n\"\n            f\"Mobject 1 ({mobject1}) : {mobject1.pixel_array.shape}\\n\"\n            f\"Mobject 2 ({mobject2}) : {mobject2.pixel_array.shape}\"\n        )\n        self.fill_opacity = interpolate(\n            mobject1.fill_opacity,\n            mobject2.fill_opacity,\n            alpha,\n        )\n        self.stroke_opacity = interpolate(\n            mobject1.stroke_opacity,\n            mobject2.stroke_opacity,\n            alpha,\n        )\n        self.pixel_array = interpolate(\n            mobject1.pixel_array,\n            mobject2.pixel_array,\n            alpha,\n        ).astype(self.pixel_array_dtype)\n\n\n    def get_style(self) -> dict[str, Any]:\n        return {\n            \"fill_color\": ManimColor(self.color.get_rgb()).to_hex(),\n            \"fill_opacity\": self.fill_opacity,\n        }\n\n\n\n# TODO, add the ability to have the dimensions/orientation of this\n# mobject more strongly tied to the frame of the camera it contains,\n# in the case where that's a MovingCamera\n\n\n\n[docs]\nclass ImageMobjectFromCamera(AbstractImageMobject):\n    def __init__(\n        self,\n        camera,\n        default_display_frame_config: dict[str, Any] | None = None,\n        **kwargs: Any,\n    ) -> None:\n        self.camera = camera\n        if default_display_frame_config is None:\n            default_display_frame_config = {\n                \"stroke_width\": 3,\n                \"stroke_color\": WHITE,\n                \"buff\": 0,\n            }\n        self.default_display_frame_config = default_display_frame_config\n        self.pixel_array = self.camera.pixel_array\n        super().__init__(scale_to_resolution=False, **kwargs)\n\n    # TODO: Get rid of this.\n    def get_pixel_array(self):\n        self.pixel_array = self.camera.pixel_array\n        return self.pixel_array\n\n    def add_display_frame(self, **kwargs: Any) -> Self:\n        config = dict(self.default_display_frame_config)\n        config.update(kwargs)\n        self.display_frame = SurroundingRectangle(self, **config)\n        self.add(self.display_frame)\n        return self\n\n    def interpolate_color(self, mobject1, mobject2, alpha) -> None:\n        assert mobject1.pixel_array.shape == mobject2.pixel_array.shape, (\n            f\"Mobject pixel array shapes incompatible for interpolation.\\n\"\n            f\"Mobject 1 ({mobject1}) : {mobject1.pixel_array.shape}\\n\"\n            f\"Mobject 2 ({mobject2}) : {mobject2.pixel_array.shape}\"\n        )\n        self.pixel_array = interpolate(\n            mobject1.pixel_array,\n            mobject2.pixel_array,\n            alpha,\n        ).astype(self.pixel_array_dtype)", "code_sha1": "df7ce4239d5b6334f45423f67ab50ac629fc5e97"}
{"url": "https://docs.manim.community/en/stable/_modules/manim/mobject/types/point_cloud_mobject.html", "depth": 2, "instruction": "The code defines various mobjects for creating point clouds in Manim, including `PointCloudDot`, `Mobject1D`, and `PGroup`. These mobjects can be customized with colors, stroke widths, and densities, and can be arranged in grids or manipulated through animations. The visual result includes colorful, dynamic point clouds that can be grouped and transformed.", "code": "\"\"\"Mobjects representing point clouds.\"\"\"\n\nfrom __future__ import annotations\n\n__all__ = [\"PMobject\", \"Mobject1D\", \"Mobject2D\", \"PGroup\", \"PointCloudDot\", \"Point\"]\n\nfrom typing import TYPE_CHECKING\n\nimport numpy as np\n\nfrom manim.mobject.opengl.opengl_compatibility import ConvertToOpenGL\nfrom manim.mobject.opengl.opengl_point_cloud_mobject import OpenGLPMobject\n\nfrom ...constants import *\nfrom ...mobject.mobject import Mobject\nfrom ...utils.bezier import interpolate\nfrom ...utils.color import (\n    BLACK,\n    WHITE,\n    YELLOW,\n    ManimColor,\n    ParsableManimColor,\n    color_gradient,\n    color_to_rgba,\n    rgba_to_color,\n)\nfrom ...utils.iterables import stretch_array_to_length\n\n__all__ = [\"PMobject\", \"Mobject1D\", \"Mobject2D\", \"PGroup\", \"PointCloudDot\", \"Point\"]\n\nif TYPE_CHECKING:\n    from collections.abc import Callable\n    from typing import Any\n\n    import numpy.typing as npt\n    from typing_extensions import Self\n\n    from manim.typing import ManimFloat, Point3DLike, Vector3D\n\n\n\n[docs]\nclass PMobject(Mobject, metaclass=ConvertToOpenGL):\n    \"\"\"A disc made of a cloud of Dots\n\n    Examples\n    --------\n\n    .. manim:: PMobjectExample\n        :save_last_frame:\n\n        class PMobjectExample(Scene):\n            def construct(self):\n\n                pG = PGroup()  # This is just a collection of PMobject's\n\n                # As the scale factor increases, the number of points\n                # removed increases.\n                for sf in range(1, 9 + 1):\n                    p = PointCloudDot(density=20, radius=1).thin_out(sf)\n                    # PointCloudDot is a type of PMobject\n                    # and can therefore be added to a PGroup\n                    pG.add(p)\n\n                # This organizes all the shapes in a grid.\n                pG.arrange_in_grid()\n\n                self.add(pG)\n\n    \"\"\"\n\n    def __init__(self, stroke_width: int = DEFAULT_STROKE_WIDTH, **kwargs: Any) -> None:\n        self.stroke_width = stroke_width\n        super().__init__(**kwargs)\n\n\n[docs]\n    def reset_points(self) -> Self:\n        self.rgbas = np.zeros((0, 4))\n        self.points = np.zeros((0, 3))\n        return self\n\n\n    def get_array_attrs(self) -> list[str]:\n        return super().get_array_attrs() + [\"rgbas\"]\n\n\n[docs]\n    def add_points(\n        self,\n        points: npt.NDArray,\n        rgbas: npt.NDArray | None = None,\n        color: ParsableManimColor | None = None,\n        alpha: float = 1,\n    ) -> Self:\n        \"\"\"Add points.\n\n        Points must be a Nx3 numpy array.\n        Rgbas must be a Nx4 numpy array if it is not None.\n        \"\"\"\n        if not isinstance(points, np.ndarray):\n            points = np.array(points)\n        num_new_points = len(points)\n        self.points = np.append(self.points, points, axis=0)\n        if rgbas is None:\n            color = ManimColor(color) if color else self.color\n            rgbas = np.repeat([color_to_rgba(color, alpha)], num_new_points, axis=0)\n        elif len(rgbas) != len(points):\n            raise ValueError(\"points and rgbas must have same length\")\n        self.rgbas = np.append(self.rgbas, rgbas, axis=0)\n        return self\n\n\n\n[docs]\n    def set_color(\n        self, color: ParsableManimColor = YELLOW, family: bool = True\n    ) -> Self:\n        rgba = color_to_rgba(color)\n        mobs = self.family_members_with_points() if family else [self]\n        for mob in mobs:\n            mob.rgbas[:, :] = rgba\n        self.color = ManimColor.parse(color)\n        return self\n\n\n    def get_stroke_width(self) -> int:\n        return self.stroke_width\n\n    def set_stroke_width(self, width: int, family: bool = True) -> Self:\n        mobs = self.family_members_with_points() if family else [self]\n        for mob in mobs:\n            mob.stroke_width = width\n        return self\n\n\n[docs]\n    def set_color_by_gradient(self, *colors: ParsableManimColor) -> Self:\n        self.rgbas = np.array(\n            list(map(color_to_rgba, color_gradient(*colors, len(self.points)))),\n        )\n        return self\n\n\n    def set_colors_by_radial_gradient(\n        self,\n        center: Point3DLike | None = None,\n        radius: float = 1,\n        inner_color: ParsableManimColor = WHITE,\n        outer_color: ParsableManimColor = BLACK,\n    ) -> Self:\n        start_rgba, end_rgba = list(map(color_to_rgba, [inner_color, outer_color]))\n        if center is None:\n            center = self.get_center()\n        for mob in self.family_members_with_points():\n            distances = np.abs(self.points - center)\n            alphas = np.linalg.norm(distances, axis=1) / radius\n\n            mob.rgbas = np.array(\n                np.array(\n                    [interpolate(start_rgba, end_rgba, alpha) for alpha in alphas],\n                ),\n            )\n        return self\n\n    def match_colors(self, mobject: Mobject) -> Self:\n        Mobject.align_data(self, mobject)\n        self.rgbas = np.array(mobject.rgbas)\n        return self\n\n    def filter_out(self, condition: npt.NDArray) -> Self:\n        for mob in self.family_members_with_points():\n            to_eliminate = ~np.apply_along_axis(condition, 1, mob.points)\n            mob.points = mob.points[to_eliminate]\n            mob.rgbas = mob.rgbas[to_eliminate]\n        return self\n\n\n[docs]\n    def thin_out(self, factor: int = 5) -> Self:\n        \"\"\"Removes all but every nth point for n = factor\"\"\"\n        for mob in self.family_members_with_points():\n            num_points = self.get_num_points()\n            mob.apply_over_attr_arrays(\n                lambda arr, n=num_points: arr[np.arange(0, n, factor)],\n            )\n        return self\n\n\n\n[docs]\n    def sort_points(\n        self, function: Callable[[npt.NDArray[ManimFloat]], float] = lambda p: p[0]\n    ) -> Self:\n        \"\"\"Function is any map from R^3 to R\"\"\"\n        for mob in self.family_members_with_points():\n            indices = np.argsort(np.apply_along_axis(function, 1, mob.points))\n            mob.apply_over_attr_arrays(lambda arr, idx=indices: arr[idx])\n        return self\n\n\n    def fade_to(\n        self, color: ParsableManimColor, alpha: float, family: bool = True\n    ) -> Self:\n        self.rgbas = interpolate(self.rgbas, color_to_rgba(color), alpha)\n        for mob in self.submobjects:\n            mob.fade_to(color, alpha, family)\n        return self\n\n    def get_all_rgbas(self) -> npt.NDArray:\n        return self.get_merged_array(\"rgbas\")\n\n    def ingest_submobjects(self) -> Self:\n        attrs = self.get_array_attrs()\n        arrays = list(map(self.get_merged_array, attrs))\n        for attr, array in zip(attrs, arrays):\n            setattr(self, attr, array)\n        self.submobjects = []\n        return self\n\n\n[docs]\n    def get_color(self) -> ManimColor:\n        return rgba_to_color(self.rgbas[0, :])\n\n\n    def point_from_proportion(self, alpha: float) -> Any:\n        index = alpha * (self.get_num_points() - 1)\n        return self.points[np.floor(index)]\n\n\n[docs]\n    @staticmethod\n    def get_mobject_type_class() -> type[PMobject]:\n        return PMobject\n\n\n    # Alignment\n    def align_points_with_larger(self, larger_mobject: Mobject) -> None:\n        assert isinstance(larger_mobject, PMobject)\n        self.apply_over_attr_arrays(\n            lambda a: stretch_array_to_length(a, larger_mobject.get_num_points()),\n        )\n\n\n[docs]\n    def get_point_mobject(self, center: Point3DLike | None = None) -> Point:\n        if center is None:\n            center = self.get_center()\n        return Point(center)\n\n\n    def interpolate_color(\n        self, mobject1: Mobject, mobject2: Mobject, alpha: float\n    ) -> Self:\n        self.rgbas = interpolate(mobject1.rgbas, mobject2.rgbas, alpha)\n        self.set_stroke_width(\n            interpolate(\n                mobject1.get_stroke_width(),\n                mobject2.get_stroke_width(),\n                alpha,\n            ),\n        )\n        return self\n\n    def pointwise_become_partial(self, mobject: Mobject, a: float, b: float) -> None:\n        lower_index, upper_index = (int(x * mobject.get_num_points()) for x in (a, b))\n        for attr in self.get_array_attrs():\n            full_array = getattr(mobject, attr)\n            partial_array = full_array[lower_index:upper_index]\n            setattr(self, attr, partial_array)\n\n\n\n# TODO, Make the two implementations below non-redundant\n\n[docs]\nclass Mobject1D(PMobject, metaclass=ConvertToOpenGL):\n    def __init__(self, density: int = DEFAULT_POINT_DENSITY_1D, **kwargs: Any) -> None:\n        self.density = density\n        self.epsilon = 1.0 / self.density\n        super().__init__(**kwargs)\n\n    def add_line(\n        self,\n        start: npt.NDArray,\n        end: npt.NDArray,\n        color: ParsableManimColor | None = None,\n    ) -> None:\n        start, end = list(map(np.array, [start, end]))\n        length = np.linalg.norm(end - start)\n        if length == 0:\n            points = np.array([start])\n        else:\n            epsilon = self.epsilon / length\n            points = np.array(\n                [interpolate(start, end, t) for t in np.arange(0, 1, epsilon)]\n            )\n        self.add_points(points, color=color)\n\n\n\n\n[docs]\nclass Mobject2D(PMobject, metaclass=ConvertToOpenGL):\n    def __init__(self, density: int = DEFAULT_POINT_DENSITY_2D, **kwargs: Any) -> None:\n        self.density = density\n        self.epsilon = 1.0 / self.density\n        super().__init__(**kwargs)\n\n\n\n\n[docs]\nclass PGroup(PMobject):\n    \"\"\"A group for several point mobjects.\n\n    Examples\n    --------\n\n    .. manim:: PgroupExample\n        :save_last_frame:\n\n        class PgroupExample(Scene):\n            def construct(self):\n\n                p1 = PointCloudDot(radius=1, density=20, color=BLUE)\n                p1.move_to(4.5 * LEFT)\n                p2 = PointCloudDot()\n                p3 = PointCloudDot(radius=1.5, stroke_width=2.5, color=PINK)\n                p3.move_to(4.5 * RIGHT)\n                pList = PGroup(p1, p2, p3)\n\n                self.add(pList)\n\n    \"\"\"\n\n    def __init__(self, *pmobs: Any, **kwargs: Any) -> None:\n        if not all(isinstance(m, (PMobject, OpenGLPMobject)) for m in pmobs):\n            raise ValueError(\n                \"All submobjects must be of type PMobject or OpenGLPMObject\"\n                \" if using the opengl renderer\",\n            )\n        super().__init__(**kwargs)\n        self.add(*pmobs)\n\n    def fade_to(\n        self, color: ParsableManimColor, alpha: float, family: bool = True\n    ) -> Self:\n        if family:\n            for mob in self.submobjects:\n                mob.fade_to(color, alpha, family)\n        return self\n\n\n\n\n[docs]\nclass PointCloudDot(Mobject1D):\n    \"\"\"A disc made of a cloud of dots.\n\n    Examples\n    --------\n    .. manim:: PointCloudDotExample\n        :save_last_frame:\n\n        class PointCloudDotExample(Scene):\n            def construct(self):\n                cloud_1 = PointCloudDot(color=RED)\n                cloud_2 = PointCloudDot(stroke_width=4, radius=1)\n                cloud_3 = PointCloudDot(density=15)\n\n                group = Group(cloud_1, cloud_2, cloud_3).arrange()\n                self.add(group)\n\n    .. manim:: PointCloudDotExample2\n\n        class PointCloudDotExample2(Scene):\n            def construct(self):\n                plane = ComplexPlane()\n                cloud = PointCloudDot(color=RED)\n                self.add(\n                    plane, cloud\n                )\n                self.wait()\n                self.play(\n                    cloud.animate.apply_complex_function(lambda z: np.exp(z))\n                )\n    \"\"\"\n\n    def __init__(\n        self,\n        center: Vector3D = ORIGIN,\n        radius: float = 2.0,\n        stroke_width: int = 2,\n        density: int = DEFAULT_POINT_DENSITY_1D,\n        color: ManimColor = YELLOW,\n        **kwargs: Any,\n    ) -> None:\n        self.radius = radius\n        self.epsilon = 1.0 / density\n        super().__init__(\n            stroke_width=stroke_width, density=density, color=color, **kwargs\n        )\n        self.shift(center)\n\n    def init_points(self) -> None:\n        self.reset_points()\n        self.generate_points()\n\n\n[docs]\n    def generate_points(self) -> None:\n        self.add_points(\n            np.array(\n                [\n                    r * (np.cos(theta) * RIGHT + np.sin(theta) * UP)\n                    for r in np.arange(self.epsilon, self.radius, self.epsilon)\n                    # Num is equal to int(stop - start)/ (step + 1) reformulated.\n                    for theta in np.linspace(\n                        0,\n                        2 * np.pi,\n                        num=int(2 * np.pi * (r + self.epsilon) / self.epsilon),\n                    )\n                ]\n            ),\n        )\n\n\n\n\n\n[docs]\nclass Point(PMobject):\n    \"\"\"A mobject representing a point.\n\n    Examples\n    --------\n\n    .. manim:: ExamplePoint\n        :save_last_frame:\n\n        class ExamplePoint(Scene):\n            def construct(self):\n                colorList = [RED, GREEN, BLUE, YELLOW]\n                for i in range(200):\n                    point = Point(location=[0.63 * np.random.randint(-4, 4), 0.37 * np.random.randint(-4, 4), 0], color=np.random.choice(colorList))\n                    self.add(point)\n                for i in range(200):\n                    point = Point(location=[0.37 * np.random.randint(-4, 4), 0.63 * np.random.randint(-4, 4), 0], color=np.random.choice(colorList))\n                    self.add(point)\n                self.add(point)\n    \"\"\"\n\n    def __init__(\n        self, location: Vector3D = ORIGIN, color: ManimColor = BLACK, **kwargs: Any\n    ) -> None:\n        self.location = location\n        super().__init__(color=color, **kwargs)\n\n    def init_points(self) -> None:\n        self.reset_points()\n        self.generate_points()\n        self.set_points([self.location])\n\n\n[docs]\n    def generate_points(self) -> None:\n        self.add_points(np.array([self.location]))", "code_sha1": "1335bf6a7b21a04f854b48fd9479e6ac3b7f37c7"}
{"url": "https://docs.manim.community/en/stable/_modules/manim/mobject/types/vectorized_mobject.html", "depth": 2, "instruction": "The code defines a `VMobject` class for vector graphics in Manim, allowing for customizable shapes with properties like fill color, stroke color, and opacity. It includes methods for manipulating curves, colors, and styles, enabling the creation of complex vectorized objects. The `VGroup` and `VDict` classes facilitate grouping and managing multiple `VMobject` instances.", "code": "\"\"\"Mobjects that use vector graphics.\"\"\"\n\nfrom __future__ import annotations\n\n__all__ = [\n    \"VMobject\",\n    \"VGroup\",\n    \"VDict\",\n    \"VectorizedPoint\",\n    \"CurvesAsSubmobjects\",\n    \"DashedVMobject\",\n]\n\n\nimport itertools as it\nimport sys\nfrom collections.abc import Hashable, Iterable, Mapping, Sequence\nfrom typing import TYPE_CHECKING, Callable, Literal\n\nimport numpy as np\nfrom PIL.Image import Image\n\nfrom manim import config\nfrom manim.constants import *\nfrom manim.mobject.mobject import Mobject\nfrom manim.mobject.opengl.opengl_compatibility import ConvertToOpenGL\nfrom manim.mobject.opengl.opengl_mobject import OpenGLMobject\nfrom manim.mobject.opengl.opengl_vectorized_mobject import OpenGLVMobject\nfrom manim.mobject.three_d.three_d_utils import (\n    get_3d_vmob_gradient_start_and_end_points,\n)\nfrom manim.utils.bezier import (\n    bezier,\n    bezier_remap,\n    get_smooth_cubic_bezier_handle_points,\n    integer_interpolate,\n    interpolate,\n    partial_bezier_points,\n    proportions_along_bezier_curve_for_point,\n)\nfrom manim.utils.color import BLACK, WHITE, ManimColor, ParsableManimColor\nfrom manim.utils.iterables import (\n    make_even,\n    resize_array,\n    stretch_array_to_length,\n    tuplify,\n)\nfrom manim.utils.space_ops import rotate_vector, shoelace_direction\n\nif TYPE_CHECKING:\n    from typing import Any\n\n    import numpy.typing as npt\n    from typing_extensions import Self\n\n    from manim.typing import (\n        CubicBezierPath,\n        CubicBezierPointsLike,\n        CubicSpline,\n        ManimFloat,\n        MappingFunction,\n        Point2DLike,\n        Point3D,\n        Point3D_Array,\n        Point3DLike,\n        Point3DLike_Array,\n        RGBA_Array_Float,\n        Vector3D,\n        Zeros,\n    )\n\n# TODO\n# - Change cubic curve groups to have 4 points instead of 3\n# - Change sub_path idea accordingly\n# - No more mark_paths_closed, instead have the camera test\n#   if last point in close to first point\n# - Think about length of self.points.  Always 0 or 1 mod 4?\n#   That's kind of weird.\n\n\n\n[docs]\nclass VMobject(Mobject):\n    \"\"\"A vectorized mobject.\n\n    Parameters\n    ----------\n    background_stroke_color\n        The purpose of background stroke is to have something\n        that won't overlap fill, e.g.  For text against some\n        textured background.\n    sheen_factor\n        When a color c is set, there will be a second color\n        computed based on interpolating c to WHITE by with\n        sheen_factor, and the display will gradient to this\n        secondary color in the direction of sheen_direction.\n    close_new_points\n        Indicates that it will not be displayed, but\n        that it should count in parent mobject's path\n    tolerance_for_point_equality\n        This is within a pixel\n    joint_type\n        The line joint type used to connect the curve segments\n        of this vectorized mobject. See :class:`.LineJointType`\n        for options.\n    \"\"\"\n\n    sheen_factor = 0.0\n\n    def __init__(\n        self,\n        fill_color: ParsableManimColor | None = None,\n        fill_opacity: float = 0.0,\n        stroke_color: ParsableManimColor | None = None,\n        stroke_opacity: float = 1.0,\n        stroke_width: float = DEFAULT_STROKE_WIDTH,\n        background_stroke_color: ParsableManimColor | None = BLACK,\n        background_stroke_opacity: float = 1.0,\n        background_stroke_width: float = 0,\n        sheen_factor: float = 0.0,\n        joint_type: LineJointType | None = None,\n        sheen_direction: Vector3D = UL,\n        close_new_points: bool = False,\n        pre_function_handle_to_anchor_scale_factor: float = 0.01,\n        make_smooth_after_applying_functions: bool = False,\n        background_image: Image | str | None = None,\n        shade_in_3d: bool = False,\n        # TODO, do we care about accounting for varying zoom levels?\n        tolerance_for_point_equality: float = 1e-6,\n        n_points_per_cubic_curve: int = 4,\n        cap_style: CapStyleType = CapStyleType.AUTO,\n        **kwargs: Any,\n    ):\n        self.fill_opacity = fill_opacity\n        self.stroke_opacity = stroke_opacity\n        self.stroke_width = stroke_width\n        if background_stroke_color is not None:\n            self.background_stroke_color: ManimColor = ManimColor(\n                background_stroke_color\n            )\n        self.background_stroke_opacity: float = background_stroke_opacity\n        self.background_stroke_width: float = background_stroke_width\n        self.sheen_factor: float = sheen_factor\n        self.joint_type: LineJointType = (\n            LineJointType.AUTO if joint_type is None else joint_type\n        )\n        self.sheen_direction: Vector3D = sheen_direction\n        self.close_new_points: bool = close_new_points\n        self.pre_function_handle_to_anchor_scale_factor: float = (\n            pre_function_handle_to_anchor_scale_factor\n        )\n        self.make_smooth_after_applying_functions: bool = (\n            make_smooth_after_applying_functions\n        )\n        self.background_image: Image | str | None = background_image\n        self.shade_in_3d: bool = shade_in_3d\n        self.tolerance_for_point_equality: float = tolerance_for_point_equality\n        self.n_points_per_cubic_curve: int = n_points_per_cubic_curve\n        self._bezier_t_values: npt.NDArray[float] = np.linspace(\n            0, 1, n_points_per_cubic_curve\n        )\n        self.cap_style: CapStyleType = cap_style\n        super().__init__(**kwargs)\n        self.submobjects: list[VMobject]\n\n        # TODO: Find where color overwrites are happening and remove the color doubling\n        # if \"color\" in kwargs:\n        #     fill_color = kwargs[\"color\"]\n        #     stroke_color = kwargs[\"color\"]\n        if fill_color is not None:\n            self.fill_color = ManimColor.parse(fill_color)\n        if stroke_color is not None:\n            self.stroke_color = ManimColor.parse(stroke_color)\n\n\n[docs]\n    def _assert_valid_submobjects(self, submobjects: Iterable[VMobject]) -> Self:\n        return self._assert_valid_submobjects_internal(submobjects, VMobject)\n\n\n    # OpenGL compatibility\n    @property\n    def n_points_per_curve(self) -> int:\n        return self.n_points_per_cubic_curve\n\n    def get_group_class(self) -> type[VGroup]:\n        return VGroup\n\n\n[docs]\n    @staticmethod\n    def get_mobject_type_class() -> type[VMobject]:\n        return VMobject\n\n\n    # Colors\n\n[docs]\n    def init_colors(self, propagate_colors: bool = True) -> Self:\n        self.set_fill(\n            color=self.fill_color,\n            opacity=self.fill_opacity,\n            family=propagate_colors,\n        )\n        self.set_stroke(\n            color=self.stroke_color,\n            width=self.stroke_width,\n            opacity=self.stroke_opacity,\n            family=propagate_colors,\n        )\n        self.set_background_stroke(\n            color=self.background_stroke_color,\n            width=self.background_stroke_width,\n            opacity=self.background_stroke_opacity,\n            family=propagate_colors,\n        )\n        self.set_sheen(\n            factor=self.sheen_factor,\n            direction=self.sheen_direction,\n            family=propagate_colors,\n        )\n\n        if not propagate_colors:\n            for submobject in self.submobjects:\n                submobject.init_colors(propagate_colors=False)\n\n        return self\n\n\n\n[docs]\n    def generate_rgbas_array(\n        self, color: ManimColor | list[ManimColor], opacity: float | Iterable[float]\n    ) -> RGBA_Array_Float:\n        \"\"\"\n        First arg can be either a color, or a tuple/list of colors.\n        Likewise, opacity can either be a float, or a tuple of floats.\n        If self.sheen_factor is not zero, and only\n        one color was passed in, a second slightly light color\n        will automatically be added for the gradient\n        \"\"\"\n        colors: list[ManimColor] = [\n            ManimColor(c) if (c is not None) else BLACK for c in tuplify(color)\n        ]\n        opacities: list[float] = [\n            o if (o is not None) else 0.0 for o in tuplify(opacity)\n        ]\n        rgbas: npt.NDArray[RGBA_Array_Float] = np.array(\n            [c.to_rgba_with_alpha(o) for c, o in zip(*make_even(colors, opacities))],\n        )\n\n        sheen_factor = self.get_sheen_factor()\n        if sheen_factor != 0 and len(rgbas) == 1:\n            light_rgbas = np.array(rgbas)\n            light_rgbas[:, :3] += sheen_factor\n            np.clip(light_rgbas, 0, 1, out=light_rgbas)\n            rgbas = np.append(rgbas, light_rgbas, axis=0)\n        return rgbas\n\n\n    def update_rgbas_array(\n        self,\n        array_name: str,\n        color: ManimColor | None = None,\n        opacity: float | None = None,\n    ) -> Self:\n        rgbas = self.generate_rgbas_array(color, opacity)\n        if not hasattr(self, array_name):\n            setattr(self, array_name, rgbas)\n            return self\n        # Match up current rgbas array with the newly calculated\n        # one. 99% of the time they'll be the same.\n        curr_rgbas = getattr(self, array_name)\n        if len(curr_rgbas) < len(rgbas):\n            curr_rgbas = stretch_array_to_length(curr_rgbas, len(rgbas))\n            setattr(self, array_name, curr_rgbas)\n        elif len(rgbas) < len(curr_rgbas):\n            rgbas = stretch_array_to_length(rgbas, len(curr_rgbas))\n        # Only update rgb if color was not None, and only\n        # update alpha channel if opacity was passed in\n        if color is not None:\n            curr_rgbas[:, :3] = rgbas[:, :3]\n        if opacity is not None:\n            curr_rgbas[:, 3] = rgbas[:, 3]\n        return self\n\n\n[docs]\n    def set_fill(\n        self,\n        color: ParsableManimColor | None = None,\n        opacity: float | None = None,\n        family: bool = True,\n    ) -> Self:\n        \"\"\"Set the fill color and fill opacity of a :class:`VMobject`.\n\n        Parameters\n        ----------\n        color\n            Fill color of the :class:`VMobject`.\n        opacity\n            Fill opacity of the :class:`VMobject`.\n        family\n            If ``True``, the fill color of all submobjects is also set.\n\n        Returns\n        -------\n        :class:`VMobject`\n            ``self``\n\n        Examples\n        --------\n        .. manim:: SetFill\n            :save_last_frame:\n\n            class SetFill(Scene):\n                def construct(self):\n                    square = Square().scale(2).set_fill(WHITE,1)\n                    circle1 = Circle().set_fill(GREEN,0.8)\n                    circle2 = Circle().set_fill(YELLOW) # No fill_opacity\n                    circle3 = Circle().set_fill(color = '#FF2135', opacity = 0.2)\n                    group = Group(circle1,circle2,circle3).arrange()\n                    self.add(square)\n                    self.add(group)\n\n        See Also\n        --------\n        :meth:`~.VMobject.set_style`\n        \"\"\"\n        if family:\n            for submobject in self.submobjects:\n                submobject.set_fill(color, opacity, family)\n        self.update_rgbas_array(\"fill_rgbas\", color, opacity)\n        self.fill_rgbas: RGBA_Array_Float\n        if opacity is not None:\n            self.fill_opacity = opacity\n        return self\n\n\n    def set_stroke(\n        self,\n        color: ParsableManimColor = None,\n        width: float | None = None,\n        opacity: float | None = None,\n        background=False,\n        family: bool = True,\n    ) -> Self:\n        if family:\n            for submobject in self.submobjects:\n                submobject.set_stroke(color, width, opacity, background, family)\n        if background:\n            array_name = \"background_stroke_rgbas\"\n            width_name = \"background_stroke_width\"\n            opacity_name = \"background_stroke_opacity\"\n        else:\n            array_name = \"stroke_rgbas\"\n            width_name = \"stroke_width\"\n            opacity_name = \"stroke_opacity\"\n        self.update_rgbas_array(array_name, color, opacity)\n        if width is not None:\n            setattr(self, width_name, width)\n        if opacity is not None:\n            setattr(self, opacity_name, opacity)\n        if color is not None and background:\n            if isinstance(color, (list, tuple)):\n                self.background_stroke_color = ManimColor.parse(color)\n            else:\n                self.background_stroke_color = ManimColor(color)\n        return self\n\n\n[docs]\n    def set_cap_style(self, cap_style: CapStyleType) -> Self:\n        \"\"\"\n        Sets the cap style of the :class:`VMobject`.\n\n        Parameters\n        ----------\n        cap_style\n            The cap style to be set. See :class:`.CapStyleType` for options.\n\n        Returns\n        -------\n        :class:`VMobject`\n            ``self``\n\n        Examples\n        --------\n        .. manim:: CapStyleExample\n            :save_last_frame:\n\n            class CapStyleExample(Scene):\n                def construct(self):\n                    line = Line(LEFT, RIGHT, color=YELLOW, stroke_width=20)\n                    line.set_cap_style(CapStyleType.ROUND)\n                    self.add(line)\n        \"\"\"\n        self.cap_style = cap_style\n        return self\n\n\n    def set_background_stroke(self, **kwargs) -> Self:\n        kwargs[\"background\"] = True\n        self.set_stroke(**kwargs)\n        return self\n\n    def set_style(\n        self,\n        fill_color: ParsableManimColor | None = None,\n        fill_opacity: float | None = None,\n        stroke_color: ParsableManimColor | None = None,\n        stroke_width: float | None = None,\n        stroke_opacity: float | None = None,\n        background_stroke_color: ParsableManimColor | None = None,\n        background_stroke_width: float | None = None,\n        background_stroke_opacity: float | None = None,\n        sheen_factor: float | None = None,\n        sheen_direction: Vector3D | None = None,\n        background_image: Image | str | None = None,\n        family: bool = True,\n    ) -> Self:\n        self.set_fill(color=fill_color, opacity=fill_opacity, family=family)\n        self.set_stroke(\n            color=stroke_color,\n            width=stroke_width,\n            opacity=stroke_opacity,\n            family=family,\n        )\n        self.set_background_stroke(\n            color=background_stroke_color,\n            width=background_stroke_width,\n            opacity=background_stroke_opacity,\n            family=family,\n        )\n        if sheen_factor:\n            self.set_sheen(\n                factor=sheen_factor,\n                direction=sheen_direction,\n                family=family,\n            )\n        if background_image:\n            self.color_using_background_image(background_image)\n        return self\n\n    def get_style(self, simple: bool = False) -> dict:\n        ret = {\n            \"stroke_opacity\": self.get_stroke_opacity(),\n            \"stroke_width\": self.get_stroke_width(),\n        }\n\n        # TODO: FIX COLORS HERE\n        if simple:\n            ret[\"fill_color\"] = self.get_fill_color()\n            ret[\"fill_opacity\"] = self.get_fill_opacity()\n            ret[\"stroke_color\"] = self.get_stroke_color()\n        else:\n            ret[\"fill_color\"] = self.get_fill_colors()\n            ret[\"fill_opacity\"] = self.get_fill_opacities()\n            ret[\"stroke_color\"] = self.get_stroke_colors()\n            ret[\"background_stroke_color\"] = self.get_stroke_colors(background=True)\n            ret[\"background_stroke_width\"] = self.get_stroke_width(background=True)\n            ret[\"background_stroke_opacity\"] = self.get_stroke_opacity(background=True)\n            ret[\"sheen_factor\"] = self.get_sheen_factor()\n            ret[\"sheen_direction\"] = self.get_sheen_direction()\n            ret[\"background_image\"] = self.get_background_image()\n\n        return ret\n\n    def match_style(self, vmobject: VMobject, family: bool = True) -> Self:\n        self.set_style(**vmobject.get_style(), family=False)\n\n        if family:\n            # Does its best to match up submobject lists, and\n            # match styles accordingly\n            submobs1, submobs2 = self.submobjects, vmobject.submobjects\n            if len(submobs1) == 0:\n                return self\n            elif len(submobs2) == 0:\n                submobs2 = [vmobject]\n            for sm1, sm2 in zip(*make_even(submobs1, submobs2)):\n                sm1.match_style(sm2)\n        return self\n\n\n[docs]\n    def set_color(self, color: ParsableManimColor, family: bool = True) -> Self:\n        self.set_fill(color, family=family)\n        self.set_stroke(color, family=family)\n        return self\n\n\n    def set_opacity(self, opacity: float, family: bool = True) -> Self:\n        self.set_fill(opacity=opacity, family=family)\n        self.set_stroke(opacity=opacity, family=family)\n        self.set_stroke(opacity=opacity, family=family, background=True)\n        return self\n\n\n[docs]\n    def scale(self, scale_factor: float, scale_stroke: bool = False, **kwargs) -> Self:\n        r\"\"\"Scale the size by a factor.\n\n        Default behavior is to scale about the center of the vmobject.\n\n        Parameters\n        ----------\n        scale_factor\n            The scaling factor :math:`\\alpha`. If :math:`0 < |\\alpha| < 1`, the mobject\n            will shrink, and for :math:`|\\alpha| > 1` it will grow. Furthermore,\n            if :math:`\\alpha < 0`, the mobject is also flipped.\n        scale_stroke\n            Boolean determining if the object's outline is scaled when the object is scaled.\n            If enabled, and object with 2px outline is scaled by a factor of .5, it will have an outline of 1px.\n        kwargs\n            Additional keyword arguments passed to\n            :meth:`~.Mobject.scale`.\n\n        Returns\n        -------\n        :class:`VMobject`\n            ``self``\n\n        Examples\n        --------\n\n        .. manim:: MobjectScaleExample\n            :save_last_frame:\n\n            class MobjectScaleExample(Scene):\n                def construct(self):\n                    c1 = Circle(1, RED).set_x(-1)\n                    c2 = Circle(1, GREEN).set_x(1)\n\n                    vg = VGroup(c1, c2)\n                    vg.set_stroke(width=50)\n                    self.add(vg)\n\n                    self.play(\n                        c1.animate.scale(.25),\n                        c2.animate.scale(.25,\n                            scale_stroke=True)\n                    )\n\n        See also\n        --------\n        :meth:`move_to`\n\n        \"\"\"\n        if scale_stroke:\n            self.set_stroke(width=abs(scale_factor) * self.get_stroke_width())\n            self.set_stroke(\n                width=abs(scale_factor) * self.get_stroke_width(background=True),\n                background=True,\n            )\n        super().scale(scale_factor, **kwargs)\n        return self\n\n\n    def fade(self, darkness: float = 0.5, family: bool = True) -> Self:\n        factor = 1.0 - darkness\n        self.set_fill(opacity=factor * self.get_fill_opacity(), family=False)\n        self.set_stroke(opacity=factor * self.get_stroke_opacity(), family=False)\n        self.set_background_stroke(\n            opacity=factor * self.get_stroke_opacity(background=True),\n            family=False,\n        )\n        super().fade(darkness, family)\n        return self\n\n    def get_fill_rgbas(self) -> RGBA_Array_Float | Zeros:\n        try:\n            return self.fill_rgbas\n        except AttributeError:\n            return np.zeros((1, 4))\n\n\n[docs]\n    def get_fill_color(self) -> ManimColor:\n        \"\"\"\n        If there are multiple colors (for gradient)\n        this returns the first one\n        \"\"\"\n        return self.get_fill_colors()[0]\n\n\n    fill_color = property(get_fill_color, set_fill)\n\n\n[docs]\n    def get_fill_opacity(self) -> ManimFloat:\n        \"\"\"\n        If there are multiple opacities, this returns the\n        first\n        \"\"\"\n        return self.get_fill_opacities()[0]\n\n\n    # TODO: Does this just do a copy?\n    # TODO: I have the feeling that this function should not return None, does that have any usage ?\n    def get_fill_colors(self) -> list[ManimColor | None]:\n        return [\n            ManimColor(rgba[:3]) if rgba.any() else None\n            for rgba in self.get_fill_rgbas()\n        ]\n\n    def get_fill_opacities(self) -> npt.NDArray[ManimFloat]:\n        return self.get_fill_rgbas()[:, 3]\n\n    def get_stroke_rgbas(self, background: bool = False) -> RGBA_Array_float | Zeros:\n        try:\n            if background:\n                self.background_stroke_rgbas: RGBA_Array_Float\n                rgbas = self.background_stroke_rgbas\n            else:\n                self.stroke_rgbas: RGBA_Array_Float\n                rgbas = self.stroke_rgbas\n            return rgbas\n        except AttributeError:\n            return np.zeros((1, 4))\n\n    def get_stroke_color(self, background: bool = False) -> ManimColor | None:\n        return self.get_stroke_colors(background)[0]\n\n    stroke_color = property(get_stroke_color, set_stroke)\n\n    def get_stroke_width(self, background: bool = False) -> float:\n        if background:\n            self.background_stroke_width: float\n            width = self.background_stroke_width\n        else:\n            width = self.stroke_width\n            if isinstance(width, str):\n                width = int(width)\n        return max(0.0, width)\n\n    def get_stroke_opacity(self, background: bool = False) -> ManimFloat:\n        return self.get_stroke_opacities(background)[0]\n\n    def get_stroke_colors(self, background: bool = False) -> list[ManimColor | None]:\n        return [\n            ManimColor(rgba[:3]) if rgba.any() else None\n            for rgba in self.get_stroke_rgbas(background)\n        ]\n\n    def get_stroke_opacities(self, background: bool = False) -> npt.NDArray[ManimFloat]:\n        return self.get_stroke_rgbas(background)[:, 3]\n\n\n[docs]\n    def get_color(self) -> ManimColor:\n        if np.all(self.get_fill_opacities() == 0):\n            return self.get_stroke_color()\n        return self.get_fill_color()\n\n\n    color = property(get_color, set_color)\n\n\n[docs]\n    def set_sheen_direction(self, direction: Vector3D, family: bool = True) -> Self:\n        \"\"\"Sets the direction of the applied sheen.\n\n        Parameters\n        ----------\n        direction\n            Direction from where the gradient is applied.\n\n        Examples\n        --------\n        Normal usage::\n\n            Circle().set_sheen_direction(UP)\n\n        See Also\n        --------\n        :meth:`~.VMobject.set_sheen`\n        :meth:`~.VMobject.rotate_sheen_direction`\n        \"\"\"\n        direction = np.array(direction)\n        if family:\n            for submob in self.get_family():\n                submob.sheen_direction = direction\n        else:\n            self.sheen_direction: Vector3D = direction\n        return self\n\n\n\n[docs]\n    def rotate_sheen_direction(\n        self, angle: float, axis: Vector3D = OUT, family: bool = True\n    ) -> Self:\n        \"\"\"Rotates the direction of the applied sheen.\n\n        Parameters\n        ----------\n        angle\n            Angle by which the direction of sheen is rotated.\n        axis\n            Axis of rotation.\n\n        Examples\n        --------\n        Normal usage::\n\n            Circle().set_sheen_direction(UP).rotate_sheen_direction(PI)\n\n        See Also\n        --------\n        :meth:`~.VMobject.set_sheen_direction`\n        \"\"\"\n        if family:\n            for submob in self.get_family():\n                submob.sheen_direction = rotate_vector(\n                    submob.sheen_direction,\n                    angle,\n                    axis,\n                )\n        else:\n            self.sheen_direction = rotate_vector(self.sheen_direction, angle, axis)\n        return self\n\n\n\n[docs]\n    def set_sheen(\n        self, factor: float, direction: Vector3D | None = None, family: bool = True\n    ) -> Self:\n        \"\"\"Applies a color gradient from a direction.\n\n        Parameters\n        ----------\n        factor\n            The extent of lustre/gradient to apply. If negative, the gradient\n            starts from black, if positive the gradient starts from white and\n            changes to the current color.\n        direction\n            Direction from where the gradient is applied.\n\n        Examples\n        --------\n        .. manim:: SetSheen\n            :save_last_frame:\n\n            class SetSheen(Scene):\n                def construct(self):\n                    circle = Circle(fill_opacity=1).set_sheen(-0.3, DR)\n                    self.add(circle)\n        \"\"\"\n        if family:\n            for submob in self.submobjects:\n                submob.set_sheen(factor, direction, family)\n        self.sheen_factor: float = factor\n        if direction is not None:\n            # family set to false because recursion will\n            # already be handled above\n            self.set_sheen_direction(direction, family=False)\n        # Reset color to put sheen_factor into effect\n        if factor != 0:\n            self.set_stroke(self.get_stroke_color(), family=family)\n            self.set_fill(self.get_fill_color(), family=family)\n        return self\n\n\n    def get_sheen_direction(self) -> Vector3D:\n        return np.array(self.sheen_direction)\n\n    def get_sheen_factor(self) -> float:\n        return self.sheen_factor\n\n    def get_gradient_start_and_end_points(self) -> tuple[Point3D, Point3D]:\n        if self.shade_in_3d:\n            return get_3d_vmob_gradient_start_and_end_points(self)\n        else:\n            direction = self.get_sheen_direction()\n            c = self.get_center()\n            bases = np.array(\n                [self.get_edge_center(vect) - c for vect in [RIGHT, UP, OUT]],\n            ).transpose()\n            offset = np.dot(bases, direction)\n            return (c - offset, c + offset)\n\n    def color_using_background_image(self, background_image: Image | str) -> Self:\n        self.background_image: Image | str = background_image\n        self.set_color(WHITE)\n        for submob in self.submobjects:\n            submob.color_using_background_image(background_image)\n        return self\n\n    def get_background_image(self) -> Image | str:\n        return self.background_image\n\n    def match_background_image(self, vmobject: VMobject) -> Self:\n        self.color_using_background_image(vmobject.get_background_image())\n        return self\n\n    def set_shade_in_3d(\n        self, value: bool = True, z_index_as_group: bool = False\n    ) -> Self:\n        for submob in self.get_family():\n            submob.shade_in_3d = value\n            if z_index_as_group:\n                submob.z_index_group = self\n        return self\n\n    def set_points(self, points: Point3DLike_Array) -> Self:\n        self.points: Point3D_Array = np.array(points)\n        return self\n\n\n[docs]\n    def resize_points(\n        self,\n        new_length: int,\n        resize_func: Callable[[Point3D_Array, int], Point3D_Array] = resize_array,\n    ) -> Self:\n        \"\"\"Resize the array of anchor points and handles to have\n        the specified size.\n\n        Parameters\n        ----------\n        new_length\n            The new (total) number of points.\n        resize_func\n            A function mapping a Numpy array (the points) and an integer\n            (the target size) to a Numpy array. The default implementation\n            is based on Numpy's ``resize`` function.\n        \"\"\"\n        if new_length != len(self.points):\n            self.points = resize_func(self.points, new_length)\n        return self\n\n\n\n[docs]\n    def set_anchors_and_handles(\n        self,\n        anchors1: Point3DLike_Array,\n        handles1: Point3DLike_Array,\n        handles2: Point3DLike_Array,\n        anchors2: Point3DLike_Array,\n    ) -> Self:\n        \"\"\"Given two sets of anchors and handles, process them to set them as anchors\n        and handles of the VMobject.\n\n        anchors1[i], handles1[i], handles2[i] and anchors2[i] define the i-th bezier\n        curve of the vmobject. There are four hardcoded parameters and this is a\n        problem as it makes the number of points per cubic curve unchangeable from 4\n        (two anchors and two handles).\n\n        Returns\n        -------\n        :class:`VMobject`\n            ``self``\n        \"\"\"\n        assert len(anchors1) == len(handles1) == len(handles2) == len(anchors2)\n        nppcc = self.n_points_per_cubic_curve  # 4\n        total_len = nppcc * len(anchors1)\n        self.points = np.empty((total_len, self.dim))\n        # the following will, from the four sets, dispatch them in points such that\n        # self.points = [\n        #     anchors1[0], handles1[0], handles2[0], anchors1[0], anchors1[1],\n        #     handles1[1], ...\n        # ]\n        arrays = [anchors1, handles1, handles2, anchors2]\n        for index, array in enumerate(arrays):\n            self.points[index::nppcc] = array\n        return self\n\n\n    def clear_points(self) -> None:\n        # TODO: shouldn't this return self instead of None?\n        self.points = np.zeros((0, self.dim))\n\n\n[docs]\n    def append_points(self, new_points: Point3DLike_Array) -> Self:\n        \"\"\"Append the given ``new_points`` to the end of\n        :attr:`VMobject.points`.\n\n        Parameters\n        ----------\n        new_points\n            An array of 3D points to append.\n\n        Returns\n        -------\n        :class:`VMobject`\n            The VMobject itself, after appending ``new_points``.\n        \"\"\"\n        # TODO, check that number new points is a multiple of 4?\n        # or else that if len(self.points) % 4 == 1, then\n        # len(new_points) % 4 == 3?\n        n = len(self.points)\n        points = np.empty((n + len(new_points), self.dim))\n        points[:n] = self.points\n        points[n:] = new_points\n        self.points = points\n        return self\n\n\n\n[docs]\n    def start_new_path(self, point: Point3DLike) -> Self:\n        \"\"\"Append a ``point`` to the :attr:`VMobject.points`, which will be the\n        beginning of a new Bézier curve in the path given by the points. If\n        there's an unfinished curve at the end of :attr:`VMobject.points`,\n        complete it by appending the last Bézier curve's start anchor as many\n        times as needed.\n\n        Parameters\n        ----------\n        point\n            A 3D point to append to :attr:`VMobject.points`.\n\n        Returns\n        -------\n        :class:`VMobject`\n            The VMobject itself, after appending ``point`` and starting a new\n            curve.\n        \"\"\"\n        n_points = len(self.points)\n        nppc = self.n_points_per_curve\n        if n_points % nppc != 0:\n            # close the open path by appending the last\n            # start anchor sufficiently often\n            last_anchor = self.get_start_anchors()[-1]\n            closure = [last_anchor] * (nppc - (n_points % nppc))\n            self.append_points(closure + [point])\n        else:\n            self.append_points([point])\n        return self\n\n\n    def add_cubic_bezier_curve(\n        self,\n        anchor1: Point3DLike,\n        handle1: Point3DLike,\n        handle2: Point3DLike,\n        anchor2: Point3DLike,\n    ) -> None:\n        # TODO, check the len(self.points) % 4 == 0?\n        self.append_points([anchor1, handle1, handle2, anchor2])\n\n    # what type is curves?\n    def add_cubic_bezier_curves(self, curves) -> None:\n        self.append_points(curves.flatten())\n\n\n[docs]\n    def add_cubic_bezier_curve_to(\n        self,\n        handle1: Point3DLike,\n        handle2: Point3DLike,\n        anchor: Point3DLike,\n    ) -> Self:\n        \"\"\"Add cubic bezier curve to the path.\n\n        NOTE : the first anchor is not a parameter as by default the end of the last sub-path!\n\n        Parameters\n        ----------\n        handle1\n            first handle\n        handle2\n            second handle\n        anchor\n            anchor\n\n        Returns\n        -------\n        :class:`VMobject`\n            ``self``\n        \"\"\"\n        self.throw_error_if_no_points()\n        new_points = [handle1, handle2, anchor]\n        if self.has_new_path_started():\n            self.append_points(new_points)\n        else:\n            self.append_points([self.get_last_point()] + new_points)\n        return self\n\n\n\n[docs]\n    def add_quadratic_bezier_curve_to(\n        self,\n        handle: Point3DLike,\n        anchor: Point3DLike,\n    ) -> Self:\n        \"\"\"Add Quadratic bezier curve to the path.\n\n        Returns\n        -------\n        :class:`VMobject`\n            ``self``\n        \"\"\"\n        # How does one approximate a quadratic with a cubic?\n        # refer to the Wikipedia page on Bezier curves\n        # https://en.wikipedia.org/wiki/B%C3%A9zier_curve#Degree_elevation, accessed Jan 20, 2021\n        # 1. Copy the end points, and then\n        # 2. Place the 2 middle control points 2/3 along the line segments\n        # from the end points to the quadratic curve's middle control point.\n        # I think that's beautiful.\n        self.add_cubic_bezier_curve_to(\n            2 / 3 * handle + 1 / 3 * self.get_last_point(),\n            2 / 3 * handle + 1 / 3 * anchor,\n            anchor,\n        )\n        return self\n\n\n\n[docs]\n    def add_line_to(self, point: Point3DLike) -> Self:\n        \"\"\"Add a straight line from the last point of VMobject to the given point.\n\n        Parameters\n        ----------\n\n        point\n            The end of the straight line.\n\n        Returns\n        -------\n        :class:`VMobject`\n            ``self``\n        \"\"\"\n        self.add_cubic_bezier_curve_to(\n            *(\n                interpolate(self.get_last_point(), point, t)\n                for t in self._bezier_t_values[1:]\n            )\n        )\n        return self\n\n\n\n[docs]\n    def add_smooth_curve_to(self, *points: Point3DLike) -> Self:\n        \"\"\"Creates a smooth curve from given points and add it to the VMobject. If two points are passed in, the first is interpreted\n        as a handle, the second as an anchor.\n\n        Parameters\n        ----------\n        points\n            Points (anchor and handle, or just anchor) to add a smooth curve from\n\n        Returns\n        -------\n        :class:`VMobject`\n            ``self``\n\n        Raises\n        ------\n        ValueError\n            If 0 or more than 2 points are given.\n        \"\"\"\n        # TODO remove the value error and just add two parameters with one optional\n        if len(points) == 1:\n            handle2 = None\n            new_anchor = points[0]\n        elif len(points) == 2:\n            handle2, new_anchor = points\n        else:\n            name = sys._getframe(0).f_code.co_name\n            raise ValueError(f\"Only call {name} with 1 or 2 points\")\n\n        if self.has_new_path_started():\n            self.add_line_to(new_anchor)\n        else:\n            self.throw_error_if_no_points()\n            last_h2, last_a2 = self.points[-2:]\n            last_tangent = last_a2 - last_h2\n            handle1 = last_a2 + last_tangent\n            if handle2 is None:\n                to_anchor_vect = new_anchor - last_a2\n                new_tangent = rotate_vector(last_tangent, PI, axis=to_anchor_vect)\n                handle2 = new_anchor - new_tangent\n            self.append_points([last_a2, handle1, handle2, new_anchor])\n        return self\n\n\n    def has_new_path_started(self) -> bool:\n        nppcc = self.n_points_per_cubic_curve  # 4\n        # A new path starting is defined by a control point which is not part of a bezier subcurve.\n        return len(self.points) % nppcc == 1\n\n    def get_last_point(self) -> Point3D:\n        return self.points[-1]\n\n    def is_closed(self) -> bool:\n        # TODO use consider_points_equals_2d ?\n        return self.consider_points_equals(self.points[0], self.points[-1])\n\n    def close_path(self) -> None:\n        if not self.is_closed():\n            self.add_line_to(self.get_subpaths()[-1][0])\n\n\n[docs]\n    def add_points_as_corners(self, points: Point3DLike_Array) -> Self:\n        \"\"\"Append multiple straight lines at the end of\n        :attr:`VMobject.points`, which connect the given ``points`` in order\n        starting from the end of the current path. These ``points`` would be\n        therefore the corners of the new polyline appended to the path.\n\n        Parameters\n        ----------\n        points\n            An array of 3D points representing the corners of the polyline to\n            append to :attr:`VMobject.points`.\n\n        Returns\n        -------\n        :class:`VMobject`\n            The VMobject itself, after appending the straight lines to its\n            path.\n        \"\"\"\n        points = np.asarray(points).reshape(-1, self.dim)\n        num_points = points.shape[0]\n        if num_points == 0:\n            return self\n\n        if self.has_new_path_started():\n            # Pop the last point from self.points and\n            # add it to start_corners\n            start_corners = np.empty((num_points, self.dim))\n            start_corners[0] = self.points[-1]\n            start_corners[1:] = points[:-1]\n            end_corners = points\n            self.points = self.points[:-1]\n        else:\n            start_corners = points[:-1]\n            end_corners = points[1:]\n\n        nppcc = self.n_points_per_cubic_curve\n        new_points = np.empty((nppcc * start_corners.shape[0], self.dim))\n        new_points[::nppcc] = start_corners\n        new_points[nppcc - 1 :: nppcc] = end_corners\n        for i, t in enumerate(self._bezier_t_values):\n            new_points[i::nppcc] = interpolate(start_corners, end_corners, t)\n\n        self.append_points(new_points)\n        return self\n\n\n\n[docs]\n    def set_points_as_corners(self, points: Point3DLike_Array) -> Self:\n        \"\"\"Given an array of points, set them as corners of the\n        :class:`VMobject`.\n\n        To achieve that, this algorithm sets handles aligned with the anchors\n        such that the resultant Bézier curve will be the segment between the\n        two anchors.\n\n        Parameters\n        ----------\n        points\n            Array of points that will be set as corners.\n\n        Returns\n        -------\n        :class:`VMobject`\n            The VMobject itself, after setting the new points as corners.\n\n\n        Examples\n        --------\n        .. manim:: PointsAsCornersExample\n            :save_last_frame:\n\n            class PointsAsCornersExample(Scene):\n                def construct(self):\n                    corners = (\n                        # create square\n                        UR, UL,\n                        DL, DR,\n                        UR,\n                        # create crosses\n                        DL, UL,\n                        DR\n                    )\n                    vmob = VMobject(stroke_color=RED)\n                    vmob.set_points_as_corners(corners).scale(2)\n                    self.add(vmob)\n        \"\"\"\n        points = np.array(points)\n        # This will set the handles aligned with the anchors.\n        # Id est, a bezier curve will be the segment from the two anchors such that the handles belongs to this segment.\n        self.set_anchors_and_handles(\n            *(interpolate(points[:-1], points[1:], t) for t in self._bezier_t_values)\n        )\n        return self\n\n\n    def set_points_smoothly(self, points: Point3DLike_Array) -> Self:\n        self.set_points_as_corners(points)\n        self.make_smooth()\n        return self\n\n\n[docs]\n    def change_anchor_mode(self, mode: Literal[\"jagged\", \"smooth\"]) -> Self:\n        \"\"\"Changes the anchor mode of the bezier curves. This will modify the handles.\n\n        There can be only two modes, \"jagged\", and \"smooth\".\n\n        Returns\n        -------\n        :class:`VMobject`\n            ``self``\n        \"\"\"\n        assert mode in [\"jagged\", \"smooth\"], 'mode must be either \"jagged\" or \"smooth\"'\n        nppcc = self.n_points_per_cubic_curve\n        for submob in self.family_members_with_points():\n            subpaths = submob.get_subpaths()\n            submob.clear_points()\n            # A subpath can be composed of several bezier curves.\n            for subpath in subpaths:\n                # This will retrieve the anchors of the subpath, by selecting every n element in the array subpath\n                # The append is needed as the last element is not reached when slicing with numpy.\n                anchors = np.append(subpath[::nppcc], subpath[-1:], 0)\n                if mode == \"smooth\":\n                    h1, h2 = get_smooth_cubic_bezier_handle_points(anchors)\n                else:  # mode == \"jagged\"\n                    # The following will make the handles aligned with the anchors, thus making the bezier curve a segment\n                    a1 = anchors[:-1]\n                    a2 = anchors[1:]\n                    h1 = interpolate(a1, a2, 1.0 / 3)\n                    h2 = interpolate(a1, a2, 2.0 / 3)\n                new_subpath = np.array(subpath)\n                new_subpath[1::nppcc] = h1\n                new_subpath[2::nppcc] = h2\n                submob.append_points(new_subpath)\n        return self\n\n\n    def make_smooth(self) -> Self:\n        return self.change_anchor_mode(\"smooth\")\n\n    def make_jagged(self) -> Self:\n        return self.change_anchor_mode(\"jagged\")\n\n    def add_subpath(self, points: CubicBezierPathLike) -> Self:\n        assert len(points) % 4 == 0\n        self.append_points(points)\n        return self\n\n    def append_vectorized_mobject(self, vectorized_mobject: VMobject) -> None:\n        if self.has_new_path_started():\n            # Remove last point, which is starting\n            # a new path\n            self.points = self.points[:-1]\n        self.append_points(vectorized_mobject.points)\n\n    def apply_function(self, function: MappingFunction) -> Self:\n        factor = self.pre_function_handle_to_anchor_scale_factor\n        self.scale_handle_to_anchor_distances(factor)\n        super().apply_function(function)\n        self.scale_handle_to_anchor_distances(1.0 / factor)\n        if self.make_smooth_after_applying_functions:\n            self.make_smooth()\n        return self\n\n\n[docs]\n    def rotate(\n        self,\n        angle: float,\n        axis: Vector3D = OUT,\n        about_point: Point3DLike | None = None,\n        **kwargs,\n    ) -> Self:\n        self.rotate_sheen_direction(angle, axis)\n        super().rotate(angle, axis, about_point, **kwargs)\n        return self\n\n\n\n[docs]\n    def scale_handle_to_anchor_distances(self, factor: float) -> Self:\n        \"\"\"If the distance between a given handle point H and its associated\n        anchor point A is d, then it changes H to be a distances factor*d\n        away from A, but so that the line from A to H doesn't change.\n        This is mostly useful in the context of applying a (differentiable)\n        function, to preserve tangency properties.  One would pull all the\n        handles closer to their anchors, apply the function then push them out\n        again.\n\n        Parameters\n        ----------\n        factor\n            The factor used for scaling.\n\n        Returns\n        -------\n        :class:`VMobject`\n            ``self``\n        \"\"\"\n        for submob in self.family_members_with_points():\n            if len(submob.points) < self.n_points_per_cubic_curve:\n                # The case that a bezier quad is not complete (there is no bezier curve as there is not enough control points.)\n                continue\n            a1, h1, h2, a2 = submob.get_anchors_and_handles()\n            a1_to_h1 = h1 - a1\n            a2_to_h2 = h2 - a2\n            new_h1 = a1 + factor * a1_to_h1\n            new_h2 = a2 + factor * a2_to_h2\n            submob.set_anchors_and_handles(a1, new_h1, new_h2, a2)\n        return self\n\n\n    #\n    def consider_points_equals(self, p0: Point3DLike, p1: Point3DLike) -> bool:\n        return np.allclose(p0, p1, atol=self.tolerance_for_point_equality)\n\n\n[docs]\n    def consider_points_equals_2d(self, p0: Point2DLike, p1: Point2DLike) -> bool:\n        \"\"\"Determine if two points are close enough to be considered equal.\n\n        This uses the algorithm from np.isclose(), but expanded here for the\n        2D point case. NumPy is overkill for such a small question.\n        Parameters\n        ----------\n        p0\n            first point\n        p1\n            second point\n\n        Returns\n        -------\n        bool\n            whether two points considered close.\n        \"\"\"\n        rtol = 1.0e-5  # default from np.isclose()\n        atol = self.tolerance_for_point_equality\n        if abs(p0[0] - p1[0]) > atol + rtol * abs(p1[0]):\n            return False\n        return abs(p0[1] - p1[1]) <= atol + rtol * abs(p1[1])\n\n\n    # Information about line\n    def get_cubic_bezier_tuples_from_points(\n        self, points: CubicBezierPathLike\n    ) -> CubicBezierPoints_Array:\n        return np.array(self.gen_cubic_bezier_tuples_from_points(points))\n\n\n[docs]\n    def gen_cubic_bezier_tuples_from_points(\n        self, points: CubicBezierPathLike\n    ) -> tuple[CubicBezierPointsLike, ...]:\n        \"\"\"Returns the bezier tuples from an array of points.\n\n        self.points is a list of the anchors and handles of the bezier curves of the mobject (ie [anchor1, handle1, handle2, anchor2, anchor3 ..])\n        This algorithm basically retrieve them by taking an element every n, where n is the number of control points\n        of the bezier curve.\n\n\n        Parameters\n        ----------\n        points\n            Points from which control points will be extracted.\n\n        Returns\n        -------\n        tuple\n            Bezier control points.\n        \"\"\"\n        nppcc = self.n_points_per_cubic_curve\n        remainder = len(points) % nppcc\n        points = points[: len(points) - remainder]\n        # Basically take every nppcc element.\n        return tuple(points[i : i + nppcc] for i in range(0, len(points), nppcc))\n\n\n    def get_cubic_bezier_tuples(self) -> CubicBezierPoints_Array:\n        return self.get_cubic_bezier_tuples_from_points(self.points)\n\n\n[docs]\n    def _gen_subpaths_from_points(\n        self,\n        points: CubicBezierPath,\n        filter_func: Callable[[int], bool],\n    ) -> Iterable[CubicSpline]:\n        \"\"\"Given an array of points defining the bezier curves of the vmobject, return subpaths formed by these points.\n        Here, Two bezier curves form a path if at least two of their anchors are evaluated True by the relation defined by filter_func.\n\n        The algorithm every bezier tuple (anchors and handles) in ``self.points`` (by regrouping each n elements, where\n        n is the number of points per cubic curve)), and evaluate the relation between two anchors with filter_func.\n        NOTE : The filter_func takes an int n as parameter, and will evaluate the relation between points[n] and points[n - 1]. This should probably be changed so\n        the function takes two points as parameters.\n\n        Parameters\n        ----------\n        points\n            points defining the bezier curve.\n        filter_func\n            Filter-func defining the relation.\n\n        Returns\n        -------\n        Iterable[CubicSpline]\n            subpaths formed by the points.\n        \"\"\"\n        nppcc = self.n_points_per_cubic_curve\n        filtered = filter(filter_func, range(nppcc, len(points), nppcc))\n        split_indices = [0] + list(filtered) + [len(points)]\n        return (\n            points[i1:i2]\n            for i1, i2 in zip(split_indices, split_indices[1:])\n            if (i2 - i1) >= nppcc\n        )\n\n\n    def get_subpaths_from_points(self, points: CubicBezierPath) -> list[CubicSpline]:\n        return list(\n            self._gen_subpaths_from_points(\n                points,\n                lambda n: not self.consider_points_equals(points[n - 1], points[n]),\n            ),\n        )\n\n    def gen_subpaths_from_points_2d(\n        self, points: CubicBezierPath\n    ) -> Iterable[CubicSpline]:\n        return self._gen_subpaths_from_points(\n            points,\n            lambda n: not self.consider_points_equals_2d(points[n - 1], points[n]),\n        )\n\n\n[docs]\n    def get_subpaths(self) -> list[CubicSpline]:\n        \"\"\"Returns subpaths formed by the curves of the VMobject.\n\n        Subpaths are ranges of curves with each pair of consecutive curves having their end/start points coincident.\n\n        Returns\n        -------\n        list[CubicSpline]\n            subpaths.\n        \"\"\"\n        return self.get_subpaths_from_points(self.points)\n\n\n\n[docs]\n    def get_nth_curve_points(self, n: int) -> CubicBezierPoints:\n        \"\"\"Returns the points defining the nth curve of the vmobject.\n\n        Parameters\n        ----------\n        n\n            index of the desired bezier curve.\n\n        Returns\n        -------\n        CubicBezierPoints\n            points defining the nth bezier curve (anchors, handles)\n        \"\"\"\n        assert n < self.get_num_curves()\n        nppcc = self.n_points_per_cubic_curve\n        return self.points[nppcc * n : nppcc * (n + 1)]\n\n\n\n[docs]\n    def get_nth_curve_function(self, n: int) -> Callable[[float], Point3D]:\n        \"\"\"Returns the expression of the nth curve.\n\n        Parameters\n        ----------\n        n\n            index of the desired curve.\n\n        Returns\n        -------\n        Callable[float, Point3D]\n            expression of the nth bezier curve.\n        \"\"\"\n        return bezier(self.get_nth_curve_points(n))\n\n\n\n[docs]\n    def get_nth_curve_length_pieces(\n        self,\n        n: int,\n        sample_points: int | None = None,\n    ) -> npt.NDArray[ManimFloat]:\n        \"\"\"Returns the array of short line lengths used for length approximation.\n\n        Parameters\n        ----------\n        n\n            The index of the desired curve.\n        sample_points\n            The number of points to sample to find the length.\n\n        Returns\n        -------\n            The short length-pieces of the nth curve.\n        \"\"\"\n        if sample_points is None:\n            sample_points = 10\n\n        curve = self.get_nth_curve_function(n)\n        points = np.array([curve(a) for a in np.linspace(0, 1, sample_points)])\n        diffs = points[1:] - points[:-1]\n        norms = np.linalg.norm(diffs, axis=1)\n\n        return norms\n\n\n\n[docs]\n    def get_nth_curve_length(\n        self,\n        n: int,\n        sample_points: int | None = None,\n    ) -> float:\n        \"\"\"Returns the (approximate) length of the nth curve.\n\n        Parameters\n        ----------\n        n\n            The index of the desired curve.\n        sample_points\n            The number of points to sample to find the length.\n\n        Returns\n        -------\n        length : :class:`float`\n            The length of the nth curve.\n        \"\"\"\n        _, length = self.get_nth_curve_function_with_length(n, sample_points)\n\n        return length\n\n\n\n[docs]\n    def get_nth_curve_function_with_length(\n        self,\n        n: int,\n        sample_points: int | None = None,\n    ) -> tuple[Callable[[float], Point3D], float]:\n        \"\"\"Returns the expression of the nth curve along with its (approximate) length.\n\n        Parameters\n        ----------\n        n\n            The index of the desired curve.\n        sample_points\n            The number of points to sample to find the length.\n\n        Returns\n        -------\n        curve : Callable[[float], Point3D]\n            The function for the nth curve.\n        length : :class:`float`\n            The length of the nth curve.\n        \"\"\"\n        curve = self.get_nth_curve_function(n)\n        norms = self.get_nth_curve_length_pieces(n, sample_points=sample_points)\n        length = np.sum(norms)\n\n        return curve, length\n\n\n\n[docs]\n    def get_num_curves(self) -> int:\n        \"\"\"Returns the number of curves of the vmobject.\n\n        Returns\n        -------\n        int\n            number of curves of the vmobject.\n        \"\"\"\n        nppcc = self.n_points_per_cubic_curve\n        return len(self.points) // nppcc\n\n\n\n[docs]\n    def get_curve_functions(\n        self,\n    ) -> Iterable[Callable[[float], Point3D]]:\n        \"\"\"Gets the functions for the curves of the mobject.\n\n        Returns\n        -------\n        Iterable[Callable[[float], Point3D]]\n            The functions for the curves.\n        \"\"\"\n        num_curves = self.get_num_curves()\n\n        for n in range(num_curves):\n            yield self.get_nth_curve_function(n)\n\n\n\n[docs]\n    def get_curve_functions_with_lengths(\n        self, **kwargs\n    ) -> Iterable[tuple[Callable[[float], Point3D], float]]:\n        \"\"\"Gets the functions and lengths of the curves for the mobject.\n\n        Parameters\n        ----------\n        **kwargs\n            The keyword arguments passed to :meth:`get_nth_curve_function_with_length`\n\n        Returns\n        -------\n        Iterable[tuple[Callable[[float], Point3D], float]]\n            The functions and lengths of the curves.\n        \"\"\"\n        num_curves = self.get_num_curves()\n\n        for n in range(num_curves):\n            yield self.get_nth_curve_function_with_length(n, **kwargs)\n\n\n\n[docs]\n    def point_from_proportion(self, alpha: float) -> Point3D:\n        \"\"\"Gets the point at a proportion along the path of the :class:`VMobject`.\n\n        Parameters\n        ----------\n        alpha\n            The proportion along the the path of the :class:`VMobject`.\n\n        Returns\n        -------\n        :class:`numpy.ndarray`\n            The point on the :class:`VMobject`.\n\n        Raises\n        ------\n        :exc:`ValueError`\n            If ``alpha`` is not between 0 and 1.\n        :exc:`Exception`\n            If the :class:`VMobject` has no points.\n\n        Example\n        -------\n        .. manim:: PointFromProportion\n            :save_last_frame:\n\n            class PointFromProportion(Scene):\n                def construct(self):\n                    line = Line(2*DL, 2*UR)\n                    self.add(line)\n                    colors = (RED, BLUE, YELLOW)\n                    proportions = (1/4, 1/2, 3/4)\n                    for color, proportion in zip(colors, proportions):\n                        self.add(Dot(color=color).move_to(\n                                line.point_from_proportion(proportion)\n                        ))\n        \"\"\"\n        if alpha < 0 or alpha > 1:\n            raise ValueError(f\"Alpha {alpha} not between 0 and 1.\")\n\n        self.throw_error_if_no_points()\n        if alpha == 1:\n            return self.points[-1]\n\n        curves_and_lengths = tuple(self.get_curve_functions_with_lengths())\n\n        target_length = alpha * sum(length for _, length in curves_and_lengths)\n        current_length = 0\n\n        for curve, length in curves_and_lengths:\n            if current_length + length >= target_length:\n                if length != 0:\n                    residue = (target_length - current_length) / length\n                else:\n                    residue = 0\n\n                return curve(residue)\n\n            current_length += length\n        raise Exception(\n            \"Not sure how you reached here, please file a bug report at https://github.com/ManimCommunity/manim/issues/new/choose\"\n        )\n\n\n\n[docs]\n    def proportion_from_point(\n        self,\n        point: Point3DLike,\n    ) -> float:\n        \"\"\"Returns the proportion along the path of the :class:`VMobject`\n        a particular given point is at.\n\n        Parameters\n        ----------\n        point\n            The Cartesian coordinates of the point which may or may not lie on the :class:`VMobject`\n\n        Returns\n        -------\n        float\n            The proportion along the path of the :class:`VMobject`.\n\n        Raises\n        ------\n        :exc:`ValueError`\n            If ``point`` does not lie on the curve.\n        :exc:`Exception`\n            If the :class:`VMobject` has no points.\n        \"\"\"\n        self.throw_error_if_no_points()\n\n        # Iterate over each bezier curve that the ``VMobject`` is composed of, checking\n        # if the point lies on that curve. If it does not lie on that curve, add\n        # the whole length of the curve to ``target_length`` and move onto the next\n        # curve. If the point does lie on the curve, add how far along the curve\n        # the point is to ``target_length``.\n        # Then, divide ``target_length`` by the total arc length of the shape to get\n        # the proportion along the ``VMobject`` the point is at.\n\n        num_curves = self.get_num_curves()\n        total_length = self.get_arc_length()\n        target_length = 0\n        for n in range(num_curves):\n            control_points = self.get_nth_curve_points(n)\n            length = self.get_nth_curve_length(n)\n            proportions_along_bezier = proportions_along_bezier_curve_for_point(\n                point,\n                control_points,\n            )\n            if len(proportions_along_bezier) > 0:\n                proportion_along_nth_curve = max(proportions_along_bezier)\n                target_length += length * proportion_along_nth_curve\n                break\n            target_length += length\n        else:\n            raise ValueError(f\"Point {point} does not lie on this curve.\")\n\n        alpha = target_length / total_length\n\n        return alpha\n\n\n\n[docs]\n    def get_anchors_and_handles(self) -> list[Point3D_Array]:\n        \"\"\"Returns anchors1, handles1, handles2, anchors2,\n        where (anchors1[i], handles1[i], handles2[i], anchors2[i])\n        will be four points defining a cubic bezier curve\n        for any i in range(0, len(anchors1))\n\n        Returns\n        -------\n        `list[Point3D_Array]`\n            Iterable of the anchors and handles.\n        \"\"\"\n        nppcc = self.n_points_per_cubic_curve\n        return [self.points[i::nppcc] for i in range(nppcc)]\n\n\n\n[docs]\n    def get_start_anchors(self) -> Point3D_Array:\n        \"\"\"Returns the start anchors of the bezier curves.\n\n        Returns\n        -------\n        Point3D_Array\n            Starting anchors\n        \"\"\"\n        return self.points[:: self.n_points_per_cubic_curve]\n\n\n\n[docs]\n    def get_end_anchors(self) -> Point3D_Array:\n        \"\"\"Return the end anchors of the bezier curves.\n\n        Returns\n        -------\n        Point3D_Array\n            Starting anchors\n        \"\"\"\n        nppcc = self.n_points_per_cubic_curve\n        return self.points[nppcc - 1 :: nppcc]\n\n\n\n[docs]\n    def get_anchors(self) -> list[Point3D]:\n        \"\"\"Returns the anchors of the curves forming the VMobject.\n\n        Returns\n        -------\n        Point3D_Array\n            The anchors.\n        \"\"\"\n        if self.points.shape[0] == 1:\n            return self.points\n\n        s = self.get_start_anchors()\n        e = self.get_end_anchors()\n        return list(it.chain.from_iterable(zip(s, e)))\n\n\n    def get_points_defining_boundary(self) -> Point3D_Array:\n        # Probably returns all anchors, but this is weird regarding  the name of the method.\n        return np.array(\n            tuple(it.chain(*(sm.get_anchors() for sm in self.get_family())))\n        )\n\n\n[docs]\n    def get_arc_length(self, sample_points_per_curve: int | None = None) -> float:\n        \"\"\"Return the approximated length of the whole curve.\n\n        Parameters\n        ----------\n        sample_points_per_curve\n            Number of sample points per curve used to approximate the length. More points result in a better approximation.\n\n        Returns\n        -------\n        float\n            The length of the :class:`VMobject`.\n        \"\"\"\n        return sum(\n            length\n            for _, length in self.get_curve_functions_with_lengths(\n                sample_points=sample_points_per_curve,\n            )\n        )\n\n\n    # Alignment\n\n[docs]\n    def align_points(self, vmobject: VMobject) -> Self:\n        \"\"\"Adds points to self and vmobject so that they both have the same number of subpaths, with\n        corresponding subpaths each containing the same number of points.\n\n        Points are added either by subdividing curves evenly along the subpath, or by creating new subpaths consisting\n        of a single point repeated.\n\n        Parameters\n        ----------\n        vmobject\n            The object to align points with.\n\n        Returns\n        -------\n        :class:`VMobject`\n           ``self``\n        \"\"\"\n        self.align_rgbas(vmobject)\n        # TODO: This shortcut can be a bit over eager. What if they have the same length, but different subpath lengths?\n        if self.get_num_points() == vmobject.get_num_points():\n            return\n\n        for mob in self, vmobject:\n            # If there are no points, add one to\n            # wherever the \"center\" is\n            if mob.has_no_points():\n                mob.start_new_path(mob.get_center())\n            # If there's only one point, turn it into\n            # a null curve\n            if mob.has_new_path_started():\n                mob.add_line_to(mob.get_last_point())\n\n        # Figure out what the subpaths are\n        subpaths1 = self.get_subpaths()\n        subpaths2 = vmobject.get_subpaths()\n        n_subpaths = max(len(subpaths1), len(subpaths2))\n        # Start building new ones\n        new_path1 = np.zeros((0, self.dim))\n        new_path2 = np.zeros((0, self.dim))\n\n        nppcc = self.n_points_per_cubic_curve\n\n        def get_nth_subpath(path_list, n):\n            if n >= len(path_list):\n                # Create a null path at the very end\n                return [path_list[-1][-1]] * nppcc\n            path = path_list[n]\n            # Check for useless points at the end of the path and remove them\n            # https://github.com/ManimCommunity/manim/issues/1959\n            while len(path) > nppcc:\n                # If the last nppc points are all equal to the preceding point\n                if self.consider_points_equals(path[-nppcc:], path[-nppcc - 1]):\n                    path = path[:-nppcc]\n                else:\n                    break\n            return path\n\n        for n in range(n_subpaths):\n            # For each pair of subpaths, add points until they are the same length\n            sp1 = get_nth_subpath(subpaths1, n)\n            sp2 = get_nth_subpath(subpaths2, n)\n            diff1 = max(0, (len(sp2) - len(sp1)) // nppcc)\n            diff2 = max(0, (len(sp1) - len(sp2)) // nppcc)\n            sp1 = self.insert_n_curves_to_point_list(diff1, sp1)\n            sp2 = self.insert_n_curves_to_point_list(diff2, sp2)\n            new_path1 = np.append(new_path1, sp1, axis=0)\n            new_path2 = np.append(new_path2, sp2, axis=0)\n        self.set_points(new_path1)\n        vmobject.set_points(new_path2)\n        return self\n\n\n\n[docs]\n    def insert_n_curves(self, n: int) -> Self:\n        \"\"\"Inserts n curves to the bezier curves of the vmobject.\n\n        Parameters\n        ----------\n        n\n            Number of curves to insert.\n\n        Returns\n        -------\n        :class:`VMobject`\n            ``self``\n        \"\"\"\n        new_path_point = None\n        if self.has_new_path_started():\n            new_path_point = self.get_last_point()\n\n        new_points = self.insert_n_curves_to_point_list(n, self.points)\n        self.set_points(new_points)\n\n        if new_path_point is not None:\n            self.append_points([new_path_point])\n        return self\n\n\n\n[docs]\n    def insert_n_curves_to_point_list(\n        self, n: int, points: BezierPathLike\n    ) -> BezierPath:\n        \"\"\"Given an array of k points defining a bezier curves (anchors and handles), returns points defining exactly k + n bezier curves.\n\n        Parameters\n        ----------\n        n\n            Number of desired curves.\n        points\n            Starting points.\n\n        Returns\n        -------\n            Points generated.\n        \"\"\"\n        if len(points) == 1:\n            nppcc = self.n_points_per_cubic_curve\n            return np.repeat(points, nppcc * n, 0)\n        bezier_tuples = self.get_cubic_bezier_tuples_from_points(points)\n        current_number_of_curves = len(bezier_tuples)\n        new_number_of_curves = current_number_of_curves + n\n        new_bezier_tuples = bezier_remap(bezier_tuples, new_number_of_curves)\n        new_points = new_bezier_tuples.reshape(-1, 3)\n        return new_points\n\n\n    def align_rgbas(self, vmobject: VMobject) -> Self:\n        attrs = [\"fill_rgbas\", \"stroke_rgbas\", \"background_stroke_rgbas\"]\n        for attr in attrs:\n            a1 = getattr(self, attr)\n            a2 = getattr(vmobject, attr)\n            if len(a1) > len(a2):\n                new_a2 = stretch_array_to_length(a2, len(a1))\n                setattr(vmobject, attr, new_a2)\n            elif len(a2) > len(a1):\n                new_a1 = stretch_array_to_length(a1, len(a2))\n                setattr(self, attr, new_a1)\n        return self\n\n\n[docs]\n    def get_point_mobject(self, center: Point3DLike | None = None) -> VectorizedPoint:\n        if center is None:\n            center = self.get_center()\n        point = VectorizedPoint(center)\n        point.match_style(self)\n        return point\n\n\n    def interpolate_color(\n        self, mobject1: VMobject, mobject2: VMobject, alpha: float\n    ) -> None:\n        attrs = [\n            \"fill_rgbas\",\n            \"stroke_rgbas\",\n            \"background_stroke_rgbas\",\n            \"stroke_width\",\n            \"background_stroke_width\",\n            \"sheen_direction\",\n            \"sheen_factor\",\n        ]\n        for attr in attrs:\n            setattr(\n                self,\n                attr,\n                interpolate(getattr(mobject1, attr), getattr(mobject2, attr), alpha),\n            )\n            if alpha == 1.0:\n                val = getattr(mobject2, attr)\n                if isinstance(val, np.ndarray):\n                    val = val.copy()\n                setattr(self, attr, val)\n\n\n[docs]\n    def pointwise_become_partial(\n        self,\n        vmobject: VMobject,\n        a: float,\n        b: float,\n    ) -> Self:\n        \"\"\"Given a 2nd :class:`.VMobject` ``vmobject``, a lower bound ``a`` and\n        an upper bound ``b``, modify this :class:`.VMobject`'s points to\n        match the portion of the Bézier spline described by ``vmobject.points``\n        with the parameter ``t`` between ``a`` and ``b``.\n\n        Parameters\n        ----------\n        vmobject\n            The :class:`.VMobject` that will serve as a model.\n        a\n            The lower bound for ``t``.\n        b\n            The upper bound for ``t``\n\n        Returns\n        -------\n        :class:`.VMobject`\n            The :class:`.VMobject` itself, after the transformation.\n\n        Raises\n        ------\n        TypeError\n            If ``vmobject`` is not an instance of :class:`VMobject`.\n        \"\"\"\n        if not isinstance(vmobject, VMobject):\n            raise TypeError(\n                f\"Expected a VMobject, got value {vmobject} of type \"\n                f\"{type(vmobject).__name__}.\"\n            )\n        # Partial curve includes three portions:\n        # - A middle section, which matches the curve exactly.\n        # - A start, which is some ending portion of an inner cubic.\n        # - An end, which is the starting portion of a later inner cubic.\n        if a <= 0 and b >= 1:\n            self.set_points(vmobject.points)\n            return self\n        num_curves = vmobject.get_num_curves()\n        if num_curves == 0:\n            self.clear_points()\n            return self\n\n        # The following two lines will compute which Bézier curves of the given Mobject must be processed.\n        # The residue indicates the proportion of the selected Bézier curve which must be selected.\n        #\n        # Example: if num_curves is 10, a is 0.34 and b is 0.78, then:\n        # - lower_index is 3 and lower_residue is 0.4, which means the algorithm will look at the 3rd Bézier\n        #   and select its part which ranges from t=0.4 to t=1.\n        # - upper_index is 7 and upper_residue is 0.8, which means the algorithm will look at the 7th Bézier\n        #   and select its part which ranges from t=0 to t=0.8.\n        lower_index, lower_residue = integer_interpolate(0, num_curves, a)\n        upper_index, upper_residue = integer_interpolate(0, num_curves, b)\n\n        nppc = self.n_points_per_curve\n        # If both indices coincide, get a part of a single Bézier curve.\n        if lower_index == upper_index:\n            # Look at the \"lower_index\"-th Bézier curve and select its part from\n            # t=lower_residue to t=upper_residue.\n            self.points = partial_bezier_points(\n                vmobject.points[nppc * lower_index : nppc * (lower_index + 1)],\n                lower_residue,\n                upper_residue,\n            )\n        else:\n            # Allocate space for (upper_index-lower_index+1) Bézier curves.\n            self.points = np.empty((nppc * (upper_index - lower_index + 1), self.dim))\n            # Look at the \"lower_index\"-th Bezier curve and select its part from\n            # t=lower_residue to t=1. This is the first curve in self.points.\n            self.points[:nppc] = partial_bezier_points(\n                vmobject.points[nppc * lower_index : nppc * (lower_index + 1)],\n                lower_residue,\n                1,\n            )\n            # If there are more curves between the \"lower_index\"-th and the\n            # \"upper_index\"-th Béziers, add them all to self.points.\n            self.points[nppc:-nppc] = vmobject.points[\n                nppc * (lower_index + 1) : nppc * upper_index\n            ]\n            # Look at the \"upper_index\"-th Bézier curve and select its part from\n            # t=0 to t=upper_residue. This is the last curve in self.points.\n            self.points[-nppc:] = partial_bezier_points(\n                vmobject.points[nppc * upper_index : nppc * (upper_index + 1)],\n                0,\n                upper_residue,\n            )\n\n        return self\n\n\n\n[docs]\n    def get_subcurve(self, a: float, b: float) -> Self:\n        \"\"\"Returns the subcurve of the VMobject between the interval [a, b].\n        The curve is a VMobject itself.\n\n        Parameters\n        ----------\n\n        a\n            The lower bound.\n        b\n            The upper bound.\n\n        Returns\n        -------\n        VMobject\n            The subcurve between of [a, b]\n        \"\"\"\n        if self.is_closed() and a > b:\n            vmob = self.copy()\n            vmob.pointwise_become_partial(self, a, 1)\n            vmob2 = self.copy()\n            vmob2.pointwise_become_partial(self, 0, b)\n            vmob.append_vectorized_mobject(vmob2)\n        else:\n            vmob = self.copy()\n            vmob.pointwise_become_partial(self, a, b)\n        return vmob\n\n\n\n[docs]\n    def get_direction(self) -> Literal[\"CW\", \"CCW\"]:\n        \"\"\"Uses :func:`~.space_ops.shoelace_direction` to calculate the direction.\n        The direction of points determines in which direction the\n        object is drawn, clockwise or counterclockwise.\n\n        Examples\n        --------\n        The default direction of a :class:`~.Circle` is counterclockwise::\nfrom manim import Circle\nCircle().get_direction()\n            'CCW'\n\n        Returns\n        -------\n        :class:`str`\n            Either ``\"CW\"`` or ``\"CCW\"``.\n        \"\"\"\n        return shoelace_direction(self.get_start_anchors())\n\n\n\n[docs]\n    def reverse_direction(self) -> Self:\n        \"\"\"Reverts the point direction by inverting the point order.\n\n        Returns\n        -------\n        :class:`VMobject`\n            Returns self.\n\n        Examples\n        --------\n        .. manim:: ChangeOfDirection\n\n            class ChangeOfDirection(Scene):\n                def construct(self):\n                    ccw = RegularPolygon(5)\n                    ccw.shift(LEFT)\n                    cw = RegularPolygon(5)\n                    cw.shift(RIGHT).reverse_direction()\n\n                    self.play(Create(ccw), Create(cw),\n                    run_time=4)\n        \"\"\"\n        self.points = self.points[::-1]\n        return self\n\n\n\n[docs]\n    def force_direction(self, target_direction: Literal[\"CW\", \"CCW\"]) -> Self:\n        \"\"\"Makes sure that points are either directed clockwise or\n        counterclockwise.\n\n        Parameters\n        ----------\n        target_direction\n            Either ``\"CW\"`` or ``\"CCW\"``.\n        \"\"\"\n        if target_direction not in (\"CW\", \"CCW\"):\n            raise ValueError('Invalid input for force_direction. Use \"CW\" or \"CCW\"')\n        if self.get_direction() != target_direction:\n            # Since we already assured the input is CW or CCW,\n            # and the directions don't match, we just reverse\n            self.reverse_direction()\n        return self\n\n\n\n\n\n[docs]\nclass VGroup(VMobject, metaclass=ConvertToOpenGL):\n    \"\"\"A group of vectorized mobjects.\n\n    This can be used to group multiple :class:`~.VMobject` instances together\n    in order to scale, move, ... them together.\n\n    Notes\n    -----\n    When adding the same mobject more than once, repetitions are ignored.\n    Use :meth:`.Mobject.copy` to create a separate copy which can then\n    be added to the group.\n\n    Examples\n    --------\n\n    To add :class:`~.VMobject`s to a :class:`~.VGroup`, you can either use the\n    :meth:`~.VGroup.add` method, or use the `+` and `+=` operators. Similarly, you\n    can subtract elements of a VGroup via :meth:`~.VGroup.remove` method, or\n    `-` and `-=` operators:\nfrom manim import Triangle, Square, VGroup\nvg = VGroup()\ntriangle, square = Triangle(), Square()\nvg.add(triangle)\n        VGroup(Triangle)\nvg + square  # a new VGroup is constructed\n        VGroup(Triangle, Square)\nvg  # not modified\n        VGroup(Triangle)\nvg += square\nvg  # modifies vg\n        VGroup(Triangle, Square)\nvg.remove(triangle)\n        VGroup(Square)\nvg - square  # a new VGroup is constructed\n        VGroup()\nvg  # not modified\n        VGroup(Square)\nvg -= square\nvg  # modifies vg\n        VGroup()\n\n    .. manim:: ArcShapeIris\n        :save_last_frame:\n\n        class ArcShapeIris(Scene):\n            def construct(self):\n                colors = [DARK_BROWN, BLUE_E, BLUE_D, BLUE_A, TEAL_B, GREEN_B, YELLOW_E]\n                radius = [1 + rad * 0.1 for rad in range(len(colors))]\n\n                circles_group = VGroup()\n\n                # zip(radius, color) makes the iterator [(radius[i], color[i]) for i in range(radius)]\n                circles_group.add(*[Circle(radius=rad, stroke_width=10, color=col)\n                                    for rad, col in zip(radius, colors)])\n                self.add(circles_group)\n\n    \"\"\"\n\n    def __init__(\n        self, *vmobjects: VMobject | Iterable[VMobject], **kwargs: Any\n    ) -> None:\n        super().__init__(**kwargs)\n        self.add(*vmobjects)\n\n    def __repr__(self) -> str:\n        return f\"{self.__class__.__name__}({', '.join(str(mob) for mob in self.submobjects)})\"\n\n    def __str__(self) -> str:\n        return (\n            f\"{self.__class__.__name__} of {len(self.submobjects)} \"\n            f\"submobject{'s' if len(self.submobjects) > 0 else ''}\"\n        )\n\n\n[docs]\n    def add(\n        self,\n        *vmobjects: VMobject | Iterable[VMobject],\n    ) -> Self:\n        \"\"\"Checks if all passed elements are an instance, or iterables of VMobject and then adds them to submobjects\n\n        Parameters\n        ----------\n        vmobjects\n            List or iterable of VMobjects to add\n\n        Returns\n        -------\n        :class:`VGroup`\n\n        Raises\n        ------\n        TypeError\n            If one element of the list, or iterable is not an instance of VMobject\n\n        Examples\n        --------\n        The following example shows how to add individual or multiple `VMobject` instances through the `VGroup`\n        constructor and its `.add()` method.\n\n        .. manim:: AddToVGroup\n\n            class AddToVGroup(Scene):\n                def construct(self):\n                    circle_red = Circle(color=RED)\n                    circle_green = Circle(color=GREEN)\n                    circle_blue = Circle(color=BLUE)\n                    circle_red.shift(LEFT)\n                    circle_blue.shift(RIGHT)\n                    gr = VGroup(circle_red, circle_green)\n                    gr2 = VGroup(circle_blue) # Constructor uses add directly\n                    self.add(gr,gr2)\n                    self.wait()\n                    gr += gr2 # Add group to another\n                    self.play(\n                        gr.animate.shift(DOWN),\n                    )\n                    gr -= gr2 # Remove group\n                    self.play( # Animate groups separately\n                        gr.animate.shift(LEFT),\n                        gr2.animate.shift(UP),\n                    )\n                    self.play( #Animate groups without modification\n                        (gr+gr2).animate.shift(RIGHT)\n                    )\n                    self.play( # Animate group without component\n                        (gr-circle_red).animate.shift(RIGHT)\n                    )\n\n        A `VGroup` can be created using iterables as well. Keep in mind that all generated values from an\n        iterable must be an instance of `VMobject`. This is demonstrated below:\n\n        .. manim:: AddIterableToVGroupExample\n            :save_last_frame:\n\n            class AddIterableToVGroupExample(Scene):\n                def construct(self):\n                    v = VGroup(\n                        Square(),               # Singular VMobject instance\n                        [Circle(), Triangle()], # List of VMobject instances\n                        Dot(),\n                        (Dot() for _ in range(2)), # Iterable that generates VMobjects\n                    )\n                    v.arrange()\n                    self.add(v)\n\n        To facilitate this, the iterable is unpacked before its individual instances are added to the `VGroup`.\n        As a result, when you index a `VGroup`, you will never get back an iterable.\n        Instead, you will always receive `VMobject` instances, including those\n        that were part of the iterable/s that you originally added to the `VGroup`.\n        \"\"\"\n\n        def get_type_error_message(invalid_obj, invalid_indices):\n            return (\n                f\"Only values of type {vmobject_render_type.__name__} can be added \"\n                \"as submobjects of VGroup, but the value \"\n                f\"{repr(invalid_obj)} (at index {invalid_indices[1]} of \"\n                f\"parameter {invalid_indices[0]}) is of type \"\n                f\"{type(invalid_obj).__name__}.\"\n            )\n\n        vmobject_render_type = (\n            OpenGLVMobject if config.renderer == RendererType.OPENGL else VMobject\n        )\n        valid_vmobjects = []\n\n        for i, vmobject in enumerate(vmobjects):\n            if isinstance(vmobject, vmobject_render_type):\n                valid_vmobjects.append(vmobject)\n            elif isinstance(vmobject, Iterable) and not isinstance(\n                vmobject, (Mobject, OpenGLMobject)\n            ):\n                for j, subvmobject in enumerate(vmobject):\n                    if not isinstance(subvmobject, vmobject_render_type):\n                        raise TypeError(get_type_error_message(subvmobject, (i, j)))\n                    valid_vmobjects.append(subvmobject)\n            elif isinstance(vmobject, Iterable) and isinstance(\n                vmobject, (Mobject, OpenGLMobject)\n            ):\n                raise TypeError(\n                    f\"{get_type_error_message(vmobject, (i, 0))} \"\n                    \"You can try adding this value into a Group instead.\"\n                )\n            else:\n                raise TypeError(get_type_error_message(vmobject, (i, 0)))\n\n        return super().add(*valid_vmobjects)\n\n\n    def __add__(self, vmobject: VMobject) -> Self:\n        return VGroup(*self.submobjects, vmobject)\n\n    def __iadd__(self, vmobject: VMobject) -> Self:\n        return self.add(vmobject)\n\n    def __sub__(self, vmobject: VMobject) -> Self:\n        copy = VGroup(*self.submobjects)\n        copy.remove(vmobject)\n        return copy\n\n    def __isub__(self, vmobject: VMobject) -> Self:\n        return self.remove(vmobject)\n\n    def __setitem__(self, key: int, value: VMobject | Sequence[VMobject]) -> None:\n        \"\"\"Override the [] operator for item assignment.\n\n        Parameters\n        ----------\n        key\n            The index of the submobject to be assigned\n        value\n            The vmobject value to assign to the key\n\n        Returns\n        -------\n        None\n\n        Tests\n        -----\n        Check that item assignment does not raise error::\nvgroup = VGroup(VMobject())\nnew_obj = VMobject()\nvgroup[0] = new_obj\n        \"\"\"\n        self._assert_valid_submobjects(tuplify(value))\n        self.submobjects[key] = value\n\n\n\n\n[docs]\nclass VDict(VMobject, metaclass=ConvertToOpenGL):\n    \"\"\"A VGroup-like class, also offering submobject access by\n    key, like a python dict\n\n    Parameters\n    ----------\n    mapping_or_iterable\n            The parameter specifying the key-value mapping of keys and mobjects.\n    show_keys\n            Whether to also display the key associated with\n            the mobject. This might be useful when debugging,\n            especially when there are a lot of mobjects in the\n            :class:`VDict`. Defaults to False.\n    kwargs\n            Other arguments to be passed to `Mobject`.\n\n    Attributes\n    ----------\n    show_keys : :class:`bool`\n            Whether to also display the key associated with\n            the mobject. This might be useful when debugging,\n            especially when there are a lot of mobjects in the\n            :class:`VDict`. When displayed, the key is towards\n            the left of the mobject.\n            Defaults to False.\n    submob_dict : :class:`dict`\n            Is the actual python dictionary that is used to bind\n            the keys to the mobjects.\n\n    Examples\n    --------\n\n    .. manim:: ShapesWithVDict\n\n        class ShapesWithVDict(Scene):\n            def construct(self):\n                square = Square().set_color(RED)\n                circle = Circle().set_color(YELLOW).next_to(square, UP)\n\n                # create dict from list of tuples each having key-mobject pair\n                pairs = [(\"s\", square), (\"c\", circle)]\n                my_dict = VDict(pairs, show_keys=True)\n\n                # display it just like a VGroup\n                self.play(Create(my_dict))\n                self.wait()\n\n                text = Tex(\"Some text\").set_color(GREEN).next_to(square, DOWN)\n\n                # add a key-value pair by wrapping it in a single-element list of tuple\n                # after attrs branch is merged, it will be easier like `.add(t=text)`\n                my_dict.add([(\"t\", text)])\n                self.wait()\n\n                rect = Rectangle().next_to(text, DOWN)\n                # can also do key assignment like a python dict\n                my_dict[\"r\"] = rect\n\n                # access submobjects like a python dict\n                my_dict[\"t\"].set_color(PURPLE)\n                self.play(my_dict[\"t\"].animate.scale(3))\n                self.wait()\n\n                # also supports python dict styled reassignment\n                my_dict[\"t\"] = Tex(\"Some other text\").set_color(BLUE)\n                self.wait()\n\n                # remove submobject by key\n                my_dict.remove(\"t\")\n                self.wait()\n\n                self.play(Uncreate(my_dict[\"s\"]))\n                self.wait()\n\n                self.play(FadeOut(my_dict[\"c\"]))\n                self.wait()\n\n                self.play(FadeOut(my_dict[\"r\"], shift=DOWN))\n                self.wait()\n\n                # you can also make a VDict from an existing dict of mobjects\n                plain_dict = {\n                    1: Integer(1).shift(DOWN),\n                    2: Integer(2).shift(2 * DOWN),\n                    3: Integer(3).shift(3 * DOWN),\n                }\n\n                vdict_from_plain_dict = VDict(plain_dict)\n                vdict_from_plain_dict.shift(1.5 * (UP + LEFT))\n                self.play(Create(vdict_from_plain_dict))\n\n                # you can even use zip\n                vdict_using_zip = VDict(zip([\"s\", \"c\", \"r\"], [Square(), Circle(), Rectangle()]))\n                vdict_using_zip.shift(1.5 * RIGHT)\n                self.play(Create(vdict_using_zip))\n                self.wait()\n    \"\"\"\n\n    def __init__(\n        self,\n        mapping_or_iterable: (\n            Mapping[Hashable, VMobject] | Iterable[tuple[Hashable, VMobject]]\n        ) = {},\n        show_keys: bool = False,\n        **kwargs,\n    ) -> None:\n        super().__init__(**kwargs)\n        self.show_keys = show_keys\n        self.submob_dict = {}\n        self.add(mapping_or_iterable)\n\n    def __repr__(self) -> str:\n        return f\"{self.__class__.__name__}({repr(self.submob_dict)})\"\n\n\n[docs]\n    def add(\n        self,\n        mapping_or_iterable: (\n            Mapping[Hashable, VMobject] | Iterable[tuple[Hashable, VMobject]]\n        ),\n    ) -> Self:\n        \"\"\"Adds the key-value pairs to the :class:`VDict` object.\n\n        Also, it internally adds the value to the `submobjects` :class:`list`\n        of :class:`~.Mobject`, which is responsible for actual on-screen display.\n\n        Parameters\n        ---------\n        mapping_or_iterable\n            The parameter specifying the key-value mapping of keys and mobjects.\n\n        Returns\n        -------\n        :class:`VDict`\n            Returns the :class:`VDict` object on which this method was called.\n\n        Examples\n        --------\n        Normal usage::\n\n            square_obj = Square()\n            my_dict.add([(\"s\", square_obj)])\n        \"\"\"\n        for key, value in dict(mapping_or_iterable).items():\n            self.add_key_value_pair(key, value)\n\n        return self\n\n\n\n[docs]\n    def remove(self, key: Hashable) -> Self:\n        \"\"\"Removes the mobject from the :class:`VDict` object having the key `key`\n\n        Also, it internally removes the mobject from the `submobjects` :class:`list`\n        of :class:`~.Mobject`, (which is responsible for removing it from the screen)\n\n        Parameters\n        ----------\n        key\n            The key of the submoject to be removed.\n\n        Returns\n        -------\n        :class:`VDict`\n            Returns the :class:`VDict` object on which this method was called.\n\n        Examples\n        --------\n        Normal usage::\n\n            my_dict.remove(\"square\")\n        \"\"\"\n        if key not in self.submob_dict:\n            raise KeyError(f\"The given key '{key!s}' is not present in the VDict\")\n        super().remove(self.submob_dict[key])\n        del self.submob_dict[key]\n        return self\n\n\n    def __getitem__(self, key: Hashable):\n        \"\"\"Override the [] operator for item retrieval.\n\n        Parameters\n        ----------\n        key\n           The key of the submoject to be accessed\n\n        Returns\n        -------\n        :class:`VMobject`\n           The submobject corresponding to the key `key`\n\n        Examples\n        --------\n        Normal usage::\n\n           self.play(Create(my_dict[\"s\"]))\n        \"\"\"\n        submob = self.submob_dict[key]\n        return submob\n\n    def __setitem__(self, key: Hashable, value: VMobject) -> None:\n        \"\"\"Override the [] operator for item assignment.\n\n        Parameters\n        ----------\n        key\n            The key of the submoject to be assigned\n        value\n            The submobject to bind the key to\n\n        Returns\n        -------\n        None\n\n        Examples\n        --------\n        Normal usage::\n\n            square_obj = Square()\n            my_dict[\"sq\"] = square_obj\n        \"\"\"\n        if key in self.submob_dict:\n            self.remove(key)\n        self.add([(key, value)])\n\n    def __delitem__(self, key: Hashable):\n        \"\"\"Override the del operator for deleting an item.\n\n        Parameters\n        ----------\n        key\n            The key of the submoject to be deleted\n\n        Returns\n        -------\n        None\n\n        Examples\n        --------\n        ::\nfrom manim import *\nmy_dict = VDict({'sq': Square()})\n'sq' in my_dict\n            True\ndel my_dict['sq']\n'sq' in my_dict\n            False\n\n        Notes\n        -----\n        Removing an item from a VDict does not remove that item from any Scene\n        that the VDict is part of.\n\n        \"\"\"\n        del self.submob_dict[key]\n\n    def __contains__(self, key: Hashable):\n        \"\"\"Override the in operator.\n\n        Parameters\n        ----------\n        key\n            The key to check membership of.\n\n        Returns\n        -------\n        :class:`bool`\n\n        Examples\n        --------\n        ::\nfrom manim import *\nmy_dict = VDict({'sq': Square()})\n'sq' in my_dict\n            True\n\n        \"\"\"\n        return key in self.submob_dict\n\n\n[docs]\n    def get_all_submobjects(self) -> list[list]:\n        \"\"\"To get all the submobjects associated with a particular :class:`VDict` object\n\n        Returns\n        -------\n        :class:`dict_values`\n            All the submobjects associated with the :class:`VDict` object\n\n        Examples\n        --------\n        Normal usage::\n\n            for submob in my_dict.get_all_submobjects():\n                self.play(Create(submob))\n        \"\"\"\n        submobjects = self.submob_dict.values()\n        return submobjects\n\n\n\n[docs]\n    def add_key_value_pair(self, key: Hashable, value: VMobject) -> None:\n        \"\"\"A utility function used by :meth:`add` to add the key-value pair\n        to :attr:`submob_dict`. Not really meant to be used externally.\n\n        Parameters\n        ----------\n        key\n            The key of the submobject to be added.\n        value\n            The mobject associated with the key\n\n        Returns\n        -------\n        None\n\n        Raises\n        ------\n        TypeError\n            If the value is not an instance of VMobject\n\n        Examples\n        --------\n        Normal usage::\n\n            square_obj = Square()\n            self.add_key_value_pair(\"s\", square_obj)\n\n        \"\"\"\n        self._assert_valid_submobjects([value])\n        mob = value\n        if self.show_keys:\n            # This import is here and not at the top to avoid circular import\n            from manim.mobject.text.tex_mobject import Tex\n\n            key_text = Tex(str(key)).next_to(value, LEFT)\n            mob.add(key_text)\n\n        self.submob_dict[key] = mob\n        super().add(value)\n\n\n\n\n\n[docs]\nclass VectorizedPoint(VMobject, metaclass=ConvertToOpenGL):\n    def __init__(\n        self,\n        location: Point3DLike = ORIGIN,\n        color: ManimColor = BLACK,\n        fill_opacity: float = 0,\n        stroke_width: float = 0,\n        artificial_width: float = 0.01,\n        artificial_height: float = 0.01,\n        **kwargs,\n    ) -> None:\n        self.artificial_width = artificial_width\n        self.artificial_height = artificial_height\n        super().__init__(\n            color=color,\n            fill_opacity=fill_opacity,\n            stroke_width=stroke_width,\n            **kwargs,\n        )\n        self.set_points(np.array([location]))\n\n    basecls = OpenGLVMobject if config.renderer == RendererType.OPENGL else VMobject\n\n    @basecls.width.getter\n    def width(self) -> float:\n        return self.artificial_width\n\n    @basecls.height.getter\n    def height(self) -> float:\n        return self.artificial_height\n\n    def get_location(self) -> Point3D:\n        return np.array(self.points[0])\n\n    def set_location(self, new_loc: Point3D):\n        self.set_points(np.array([new_loc]))\n\n\n\n\n[docs]\nclass CurvesAsSubmobjects(VGroup):\n    \"\"\"Convert a curve's elements to submobjects.\n\n    Examples\n    --------\n    .. manim:: LineGradientExample\n        :save_last_frame:\n\n        class LineGradientExample(Scene):\n            def construct(self):\n                curve = ParametricFunction(lambda t: [t, np.sin(t), 0], t_range=[-PI, PI, 0.01], stroke_width=10)\n                new_curve = CurvesAsSubmobjects(curve)\n                new_curve.set_color_by_gradient(BLUE, RED)\n                self.add(new_curve.shift(UP), curve)\n\n    \"\"\"\n\n    def __init__(self, vmobject: VMobject, **kwargs) -> None:\n        super().__init__(**kwargs)\n        tuples = vmobject.get_cubic_bezier_tuples()\n        for tup in tuples:\n            part = VMobject()\n            part.set_points(tup)\n            part.match_style(vmobject)\n            self.add(part)\n\n\n[docs]\n    def point_from_proportion(self, alpha: float) -> Point3D:\n        \"\"\"Gets the point at a proportion along the path of the :class:`CurvesAsSubmobjects`.\n\n        Parameters\n        ----------\n        alpha\n            The proportion along the the path of the :class:`CurvesAsSubmobjects`.\n\n        Returns\n        -------\n        :class:`numpy.ndarray`\n            The point on the :class:`CurvesAsSubmobjects`.\n\n        Raises\n        ------\n        :exc:`ValueError`\n            If ``alpha`` is not between 0 and 1.\n        :exc:`Exception`\n            If the :class:`CurvesAsSubmobjects` has no submobjects, or no submobject has points.\n        \"\"\"\n        if alpha < 0 or alpha > 1:\n            raise ValueError(f\"Alpha {alpha} not between 0 and 1.\")\n\n        self._throw_error_if_no_submobjects()\n        submobjs_with_pts = self._get_submobjects_with_points()\n\n        if alpha == 1:\n            return submobjs_with_pts[-1].points[-1]\n\n        submobjs_arc_lengths = tuple(\n            part.get_arc_length() for part in submobjs_with_pts\n        )\n\n        total_length = sum(submobjs_arc_lengths)\n        target_length = alpha * total_length\n        current_length = 0\n\n        for i, part in enumerate(submobjs_with_pts):\n            part_length = submobjs_arc_lengths[i]\n            if current_length + part_length >= target_length:\n                residue = (target_length - current_length) / part_length\n                return part.point_from_proportion(residue)\n\n            current_length += part_length\n\n\n    def _throw_error_if_no_submobjects(self):\n        if len(self.submobjects) == 0:\n            caller_name = sys._getframe(1).f_code.co_name\n            raise Exception(\n                f\"Cannot call CurvesAsSubmobjects. {caller_name} for a CurvesAsSubmobject with no submobjects\"\n            )\n\n    def _get_submobjects_with_points(self):\n        submobjs_with_pts = tuple(\n            part for part in self.submobjects if len(part.points) > 0\n        )\n        if len(submobjs_with_pts) == 0:\n            caller_name = sys._getframe(1).f_code.co_name\n            raise Exception(\n                f\"Cannot call CurvesAsSubmobjects. {caller_name} for a CurvesAsSubmobject whose submobjects have no points\"\n            )\n        return submobjs_with_pts\n\n\n\n\n[docs]\nclass DashedVMobject(VMobject, metaclass=ConvertToOpenGL):\n    \"\"\"A :class:`VMobject` composed of dashes instead of lines.\n\n    Parameters\n    ----------\n        vmobject\n            The object that will get dashed\n        num_dashes\n            Number of dashes to add.\n        dashed_ratio\n            Ratio of dash to empty space.\n        dash_offset\n            Shifts the starting point of dashes along the\n            path. Value 1 shifts by one full dash length.\n        equal_lengths\n            If ``True``, dashes will be (approximately) equally long.\n            If ``False``, dashes will be split evenly in the curve's\n            input t variable (legacy behavior).\n\n    Examples\n    --------\n    .. manim:: DashedVMobjectExample\n        :save_last_frame:\n\n        class DashedVMobjectExample(Scene):\n            def construct(self):\n                r = 0.5\n\n                top_row = VGroup()  # Increasing num_dashes\n                for dashes in range(1, 12):\n                    circ = DashedVMobject(Circle(radius=r, color=WHITE), num_dashes=dashes)\n                    top_row.add(circ)\n\n                middle_row = VGroup()  # Increasing dashed_ratio\n                for ratio in np.arange(1 / 11, 1, 1 / 11):\n                    circ = DashedVMobject(\n                        Circle(radius=r, color=WHITE), dashed_ratio=ratio\n                    )\n                    middle_row.add(circ)\n\n                func1 = FunctionGraph(lambda t: t**5,[-1,1],color=WHITE)\n                func_even = DashedVMobject(func1,num_dashes=6,equal_lengths=True)\n                func_stretched = DashedVMobject(func1, num_dashes=6, equal_lengths=False)\n                bottom_row = VGroup(func_even,func_stretched)\n\n\n                top_row.arrange(buff=0.3)\n                middle_row.arrange()\n                bottom_row.arrange(buff=1)\n                everything = VGroup(top_row, middle_row, bottom_row).arrange(DOWN, buff=1)\n                self.add(everything)\n\n    \"\"\"\n\n    def __init__(\n        self,\n        vmobject: VMobject,\n        num_dashes: int = 15,\n        dashed_ratio: float = 0.5,\n        dash_offset: float = 0,\n        color: ManimColor = WHITE,\n        equal_lengths: bool = True,\n        **kwargs,\n    ) -> None:\n        self.dashed_ratio = dashed_ratio\n        self.num_dashes = num_dashes\n        super().__init__(color=color, **kwargs)\n        r = self.dashed_ratio\n        n = self.num_dashes\n        if n > 0:\n            # Assuming total length is 1\n            dash_len = r / n\n            if vmobject.is_closed():\n                void_len = (1 - r) / n\n            else:\n                void_len = 1 - r if n == 1 else (1 - r) / (n - 1)\n\n            period = dash_len + void_len\n            phase_shift = (dash_offset % 1) * period\n\n            if vmobject.is_closed():  # noqa: SIM108\n                # closed curves have equal amount of dashes and voids\n                pattern_len = 1\n            else:\n                # open curves start and end with a dash, so the whole dash pattern with the last void is longer\n                pattern_len = 1 + void_len\n\n            dash_starts = [((i * period + phase_shift) % pattern_len) for i in range(n)]\n            dash_ends = [\n                ((i * period + dash_len + phase_shift) % pattern_len) for i in range(n)\n            ]\n\n            # closed shapes can handle overflow at the 0-point\n            # open shapes need special treatment for it\n            if not vmobject.is_closed():\n                # due to phase shift being [0...1] range, always the last dash element needs attention for overflow\n                # if an entire dash moves out of the shape end:\n                if dash_ends[-1] > 1 and dash_starts[-1] > 1:\n                    # remove the last element since it is out-of-bounds\n                    dash_ends.pop()\n                    dash_starts.pop()\n                elif dash_ends[-1] < dash_len:  # if it overflowed\n                    if (\n                        dash_starts[-1] < 1\n                    ):  # if the beginning of the piece is still in range\n                        dash_starts.append(0)\n                        dash_ends.append(dash_ends[-1])\n                        dash_ends[-2] = 1\n                    else:\n                        dash_starts[-1] = 0\n                elif dash_starts[-1] > (1 - dash_len):\n                    dash_ends[-1] = 1\n\n            if equal_lengths:\n                # calculate the entire length by adding up short line-pieces\n                norms = np.array(0)\n                for k in range(vmobject.get_num_curves()):\n                    norms = np.append(norms, vmobject.get_nth_curve_length_pieces(k))\n                # add up length-pieces in array form\n                length_vals = np.cumsum(norms)\n                ref_points = np.linspace(0, 1, length_vals.size)\n                curve_length = length_vals[-1]\n                self.add(\n                    *(\n                        vmobject.get_subcurve(\n                            np.interp(\n                                dash_starts[i] * curve_length,\n                                length_vals,\n                                ref_points,\n                            ),\n                            np.interp(\n                                dash_ends[i] * curve_length,\n                                length_vals,\n                                ref_points,\n                            ),\n                        )\n                        for i in range(len(dash_starts))\n                    )\n                )\n            else:\n                self.add(\n                    *(\n                        vmobject.get_subcurve(\n                            dash_starts[i],\n                            dash_ends[i],\n                        )\n                        for i in range(len(dash_starts))\n                    )\n                )\n        # Family is already taken care of by get_subcurve\n        # implementation\n        if config.renderer == RendererType.OPENGL:\n            self.match_style(vmobject, recurse=False)\n        else:\n            self.match_style(vmobject, family=False)", "code_sha1": "5e54a61cf48d4e0c96c65569f7f5dafd9ac7fe62"}
{"url": "https://docs.manim.community/en/stable/_modules/manim/mobject/value_tracker.html", "depth": 2, "instruction": "The code defines two classes, `ValueTracker` and `ComplexValueTracker`, for tracking real and complex values, respectively. The visual result includes a number line with a pointer and label that updates its position based on the tracked value, animated over time with smooth transitions, while a dot moves according to complex values on a number plane.", "code": "\"\"\"Simple mobjects that can be used for storing (and updating) a value.\"\"\"\n\nfrom __future__ import annotations\n\n__all__ = [\"ValueTracker\", \"ComplexValueTracker\"]\n\n\nimport numpy as np\n\nfrom manim.mobject.mobject import Mobject\nfrom manim.mobject.opengl.opengl_compatibility import ConvertToOpenGL\nfrom manim.utils.paths import straight_path\n\n\n\n[docs]\nclass ValueTracker(Mobject, metaclass=ConvertToOpenGL):\n    \"\"\"A mobject that can be used for tracking (real-valued) parameters.\n    Useful for animating parameter changes.\n\n    Not meant to be displayed.  Instead the position encodes some\n    number, often one which another animation or continual_animation\n    uses for its update function, and by treating it as a mobject it can\n    still be animated and manipulated just like anything else.\n\n    This value changes continuously when animated using the :attr:`animate` syntax.\n\n    Examples\n    --------\n    .. manim:: ValueTrackerExample\n\n        class ValueTrackerExample(Scene):\n            def construct(self):\n                number_line = NumberLine()\n                pointer = Vector(DOWN)\n                label = MathTex(\"x\").add_updater(lambda m: m.next_to(pointer, UP))\n\n                tracker = ValueTracker(0)\n                pointer.add_updater(\n                    lambda m: m.next_to(\n                                number_line.n2p(tracker.get_value()),\n                                UP\n                            )\n                )\n                self.add(number_line, pointer,label)\n                tracker += 1.5\n                self.wait(1)\n                tracker -= 4\n                self.wait(0.5)\n                self.play(tracker.animate.set_value(5))\n                self.wait(0.5)\n                self.play(tracker.animate.set_value(3))\n                self.play(tracker.animate.increment_value(-2))\n                self.wait(0.5)\n\n    .. note::\n\n        You can also link ValueTrackers to updaters. In this case, you have to make sure that the\n        ValueTracker is added to the scene by ``add``\n\n    .. manim:: ValueTrackerExample\n\n        class ValueTrackerExample(Scene):\n            def construct(self):\n                tracker = ValueTracker(0)\n                label = Dot(radius=3).add_updater(lambda x : x.set_x(tracker.get_value()))\n                self.add(label)\n                self.add(tracker)\n                tracker.add_updater(lambda mobject, dt: mobject.increment_value(dt))\n                self.wait(2)\n\n    \"\"\"\n\n    def __init__(self, value=0, **kwargs):\n        super().__init__(**kwargs)\n        self.set(points=np.zeros((1, 3)))\n        self.set_value(value)\n\n\n[docs]\n    def get_value(self) -> float:\n        \"\"\"Get the current value of this ValueTracker.\"\"\"\n        return self.points[0, 0]\n\n\n\n[docs]\n    def set_value(self, value: float):\n        \"\"\"Sets a new scalar value to the ValueTracker\"\"\"\n        self.points[0, 0] = value\n        return self\n\n\n\n[docs]\n    def increment_value(self, d_value: float):\n        \"\"\"Increments (adds) a scalar value  to the ValueTracker\"\"\"\n        self.set_value(self.get_value() + d_value)\n        return self\n\n\n    def __bool__(self):\n        \"\"\"Return whether the value of this value tracker evaluates as true.\"\"\"\n        return bool(self.get_value())\n\n    def __iadd__(self, d_value: float):\n        \"\"\"adds ``+=`` syntax to increment the value of the ValueTracker\"\"\"\n        self.increment_value(d_value)\n        return self\n\n    def __ifloordiv__(self, d_value: float):\n        \"\"\"Set the value of this value tracker to the floor division of the current value by ``d_value``.\"\"\"\n        self.set_value(self.get_value() // d_value)\n        return self\n\n    def __imod__(self, d_value: float):\n        \"\"\"Set the value of this value tracker to the current value modulo ``d_value``.\"\"\"\n        self.set_value(self.get_value() % d_value)\n        return self\n\n    def __imul__(self, d_value: float):\n        \"\"\"Set the value of this value tracker to the product of the current value and ``d_value``.\"\"\"\n        self.set_value(self.get_value() * d_value)\n        return self\n\n    def __ipow__(self, d_value: float):\n        \"\"\"Set the value of this value tracker to the current value raised to the power of ``d_value``.\"\"\"\n        self.set_value(self.get_value() ** d_value)\n        return self\n\n    def __isub__(self, d_value: float):\n        \"\"\"adds ``-=`` syntax to decrement the value of the ValueTracker\"\"\"\n        self.increment_value(-d_value)\n        return self\n\n    def __itruediv__(self, d_value: float):\n        \"\"\"Sets the value of this value tracker to the current value divided by ``d_value``.\"\"\"\n        self.set_value(self.get_value() / d_value)\n        return self\n\n\n[docs]\n    def interpolate(self, mobject1, mobject2, alpha, path_func=straight_path()):\n        \"\"\"\n        Turns self into an interpolation between mobject1\n        and mobject2.\n        \"\"\"\n        self.set(points=path_func(mobject1.points, mobject2.points, alpha))\n        return self\n\n\n\n\n\n[docs]\nclass ComplexValueTracker(ValueTracker):\n    \"\"\"Tracks a complex-valued parameter.\n\n    When the value is set through :attr:`animate`, the value will take a straight path from the\n    source point to the destination point.\n\n    Examples\n    --------\n    .. manim:: ComplexValueTrackerExample\n\n        class ComplexValueTrackerExample(Scene):\n            def construct(self):\n                tracker = ComplexValueTracker(-2+1j)\n                dot = Dot().add_updater(\n                    lambda x: x.move_to(tracker.points)\n                )\n\n                self.add(NumberPlane(), dot)\n\n                self.play(tracker.animate.set_value(3+2j))\n                self.play(tracker.animate.set_value(tracker.get_value() * 1j))\n                self.play(tracker.animate.set_value(tracker.get_value() - 2j))\n                self.play(tracker.animate.set_value(tracker.get_value() / (-2 + 3j)))\n    \"\"\"\n\n\n[docs]\n    def get_value(self):\n        \"\"\"Get the current value of this value tracker as a complex number.\n\n        The value is internally stored as a points array [a, b, 0]. This can be accessed directly\n        to represent the value geometrically, see the usage example.\n        \"\"\"\n        return complex(*self.points[0, :2])\n\n\n\n[docs]\n    def set_value(self, z):\n        \"\"\"Sets a new complex value to the ComplexValueTracker\"\"\"\n        z = complex(z)\n        self.points[0, :2] = (z.real, z.imag)\n        return self", "code_sha1": "cc68cb637dcde26295df8c84249d154f6927a852"}
{"url": "https://docs.manim.community/en/stable/_modules/manim/mobject/vector_field.html", "depth": 2, "instruction": "The code defines a `VectorField` class in Manim, which visually represents vector fields using arrows or streamlines. It allows for customizable colors, scaling, and movement of objects along the field. The resulting animation showcases dynamic vector fields with varying colors based on magnitude, and objects smoothly nudging along the field's direction, creating an engaging visual flow.", "code": "\"\"\"Mobjects representing vector fields.\"\"\"\n\nfrom __future__ import annotations\n\n__all__ = [\n    \"VectorField\",\n    \"ArrowVectorField\",\n    \"StreamLines\",\n]\n\nimport itertools as it\nimport random\nfrom collections.abc import Iterable, Sequence\nfrom math import ceil, floor\nfrom typing import Callable\n\nimport numpy as np\nfrom PIL import Image\n\nfrom manim.animation.updaters.update import UpdateFromAlphaFunc\nfrom manim.mobject.geometry.line import Vector\nfrom manim.mobject.graphing.coordinate_systems import CoordinateSystem\n\nfrom .. import config\nfrom ..animation.composition import AnimationGroup, Succession\nfrom ..animation.creation import Create\nfrom ..animation.indication import ShowPassingFlash\nfrom ..constants import OUT, RIGHT, UP, RendererType\nfrom ..mobject.mobject import Mobject\nfrom ..mobject.types.vectorized_mobject import VGroup\nfrom ..mobject.utils import get_vectorized_mobject_class\nfrom ..utils.bezier import interpolate, inverse_interpolate\nfrom ..utils.color import (\n    BLUE_E,\n    GREEN,\n    RED,\n    YELLOW,\n    ManimColor,\n    ParsableManimColor,\n    color_to_rgb,\n    rgb_to_color,\n)\nfrom ..utils.rate_functions import ease_out_sine, linear\nfrom ..utils.simple_functions import sigmoid\n\nDEFAULT_SCALAR_FIELD_COLORS: list = [BLUE_E, GREEN, YELLOW, RED]\n\n\n\n[docs]\nclass VectorField(VGroup):\n    \"\"\"A vector field.\n\n    Vector fields are based on a function defining a vector at every position.\n    This class does by default not include any visible elements but provides\n    methods to move other :class:`~.Mobject` s along the vector field.\n\n    Parameters\n    ----------\n    func\n        The function defining the rate of change at every position of the `VectorField`.\n    color\n        The color of the vector field. If set, position-specific coloring is disabled.\n    color_scheme\n        A function mapping a vector to a single value. This value gives the position in the color gradient defined using `min_color_scheme_value`, `max_color_scheme_value` and `colors`.\n    min_color_scheme_value\n        The value of the color_scheme function to be mapped to the first color in `colors`. Lower values also result in the first color of the gradient.\n    max_color_scheme_value\n        The value of the color_scheme function to be mapped to the last color in `colors`. Higher values also result in the last color of the gradient.\n    colors\n        The colors defining the color gradient of the vector field.\n    kwargs\n        Additional arguments to be passed to the :class:`~.VGroup` constructor\n\n    \"\"\"\n\n    def __init__(\n        self,\n        func: Callable[[np.ndarray], np.ndarray],\n        color: ParsableManimColor | None = None,\n        color_scheme: Callable[[np.ndarray], float] | None = None,\n        min_color_scheme_value: float = 0,\n        max_color_scheme_value: float = 2,\n        colors: Sequence[ParsableManimColor] = DEFAULT_SCALAR_FIELD_COLORS,\n        **kwargs,\n    ):\n        super().__init__(**kwargs)\n        self.func = func\n        if color is None:\n            self.single_color = False\n            if color_scheme is None:\n\n                def color_scheme(p):\n                    return np.linalg.norm(p)\n\n            self.color_scheme = color_scheme  # TODO maybe other default for direction?\n            self.rgbs = np.array(list(map(color_to_rgb, colors)))\n\n            def pos_to_rgb(pos: np.ndarray) -> tuple[float, float, float, float]:\n                vec = self.func(pos)\n                color_value = np.clip(\n                    self.color_scheme(vec),\n                    min_color_scheme_value,\n                    max_color_scheme_value,\n                )\n                alpha = inverse_interpolate(\n                    min_color_scheme_value,\n                    max_color_scheme_value,\n                    color_value,\n                )\n                alpha *= len(self.rgbs) - 1\n                c1 = self.rgbs[int(alpha)]\n                c2 = self.rgbs[min(int(alpha + 1), len(self.rgbs) - 1)]\n                alpha %= 1\n                return interpolate(c1, c2, alpha)\n\n            self.pos_to_rgb = pos_to_rgb\n            self.pos_to_color = lambda pos: rgb_to_color(self.pos_to_rgb(pos))\n        else:\n            self.single_color = True\n            self.color = ManimColor.parse(color)\n        self.submob_movement_updater = None\n\n\n[docs]\n    @staticmethod\n    def shift_func(\n        func: Callable[[np.ndarray], np.ndarray],\n        shift_vector: np.ndarray,\n    ) -> Callable[[np.ndarray], np.ndarray]:\n        \"\"\"Shift a vector field function.\n\n        Parameters\n        ----------\n        func\n            The function defining a vector field.\n        shift_vector\n            The shift to be applied to the vector field.\n\n        Returns\n        -------\n        `Callable[[np.ndarray], np.ndarray]`\n            The shifted vector field function.\n\n        \"\"\"\n        return lambda p: func(p - shift_vector)\n\n\n\n[docs]\n    @staticmethod\n    def scale_func(\n        func: Callable[[np.ndarray], np.ndarray],\n        scalar: float,\n    ) -> Callable[[np.ndarray], np.ndarray]:\n        \"\"\"Scale a vector field function.\n\n        Parameters\n        ----------\n        func\n            The function defining a vector field.\n        scalar\n            The scalar to be applied to the vector field.\n\n        Examples\n        --------\n        .. manim:: ScaleVectorFieldFunction\n\n            class ScaleVectorFieldFunction(Scene):\n                def construct(self):\n                    func = lambda pos: np.sin(pos[1]) * RIGHT + np.cos(pos[0]) * UP\n                    vector_field = ArrowVectorField(func)\n                    self.add(vector_field)\n                    self.wait()\n\n                    func = VectorField.scale_func(func, 0.5)\n                    self.play(vector_field.animate.become(ArrowVectorField(func)))\n                    self.wait()\n\n        Returns\n        -------\n        `Callable[[np.ndarray], np.ndarray]`\n            The scaled vector field function.\n\n        \"\"\"\n        return lambda p: func(p * scalar)\n\n\n\n[docs]\n    def fit_to_coordinate_system(self, coordinate_system: CoordinateSystem):\n        \"\"\"Scale the vector field to fit a coordinate system.\n\n        This method is useful when the vector field is defined in a coordinate system\n        different from the one used to display the vector field.\n\n        This method can only be used once because it transforms the origin of each vector.\n\n        Parameters\n        ----------\n        coordinate_system\n            The coordinate system to fit the vector field to.\n\n        \"\"\"\n        self.apply_function(lambda pos: coordinate_system.coords_to_point(*pos))\n\n\n\n[docs]\n    def nudge(\n        self,\n        mob: Mobject,\n        dt: float = 1,\n        substeps: int = 1,\n        pointwise: bool = False,\n    ) -> VectorField:\n        \"\"\"Nudge a :class:`~.Mobject` along the vector field.\n\n        Parameters\n        ----------\n        mob\n            The mobject to move along the vector field\n        dt\n            A scalar to the amount the mobject is moved along the vector field.\n            The actual distance is based on the magnitude of the vector field.\n        substeps\n            The amount of steps the whole nudge is divided into. Higher values\n            give more accurate approximations.\n        pointwise\n            Whether to move the mobject along the vector field. If `False` the\n            vector field takes effect on the center of the given\n            :class:`~.Mobject`. If `True` the vector field takes effect on the\n            points of the individual points of the :class:`~.Mobject`,\n            potentially distorting it.\n\n        Returns\n        -------\n        VectorField\n            This vector field.\n\n        Examples\n        --------\n\n        .. manim:: Nudging\n\n            class Nudging(Scene):\n                def construct(self):\n                    func = lambda pos: np.sin(pos[1] / 2) * RIGHT + np.cos(pos[0] / 2) * UP\n                    vector_field = ArrowVectorField(\n                        func, x_range=[-7, 7, 1], y_range=[-4, 4, 1], length_func=lambda x: x / 2\n                    )\n                    self.add(vector_field)\n                    circle = Circle(radius=2).shift(LEFT)\n                    self.add(circle.copy().set_color(GRAY))\n                    dot = Dot().move_to(circle)\n\n                    vector_field.nudge(circle, -2, 60, True)\n                    vector_field.nudge(dot, -2, 60)\n\n                    circle.add_updater(vector_field.get_nudge_updater(pointwise=True))\n                    dot.add_updater(vector_field.get_nudge_updater())\n                    self.add(circle, dot)\n                    self.wait(6)\n\n        \"\"\"\n\n        def runge_kutta(self, p: Sequence[float], step_size: float) -> float:\n            \"\"\"Returns the change in position of a point along a vector field.\n            Parameters\n            ----------\n            p\n               The position of each point being moved along the vector field.\n            step_size\n               A scalar that is used to determine how much a point is shifted in a single step.\n\n            Returns\n            -------\n            float\n               How much the point is shifted.\n            \"\"\"\n            k_1 = self.func(p)\n            k_2 = self.func(p + step_size * (k_1 * 0.5))\n            k_3 = self.func(p + step_size * (k_2 * 0.5))\n            k_4 = self.func(p + step_size * k_3)\n            return step_size / 6.0 * (k_1 + 2.0 * k_2 + 2.0 * k_3 + k_4)\n\n        step_size = dt / substeps\n        for _ in range(substeps):\n            if pointwise:\n                mob.apply_function(lambda p: p + runge_kutta(self, p, step_size))\n            else:\n                mob.shift(runge_kutta(self, mob.get_center(), step_size))\n        return self\n\n\n\n[docs]\n    def nudge_submobjects(\n        self,\n        dt: float = 1,\n        substeps: int = 1,\n        pointwise: bool = False,\n    ) -> VectorField:\n        \"\"\"Apply a nudge along the vector field to all submobjects.\n\n        Parameters\n        ----------\n        dt\n            A scalar to the amount the mobject is moved along the vector field.\n            The actual distance is based on the magnitude of the vector field.\n        substeps\n            The amount of steps the whole nudge is divided into. Higher values\n            give more accurate approximations.\n        pointwise\n            Whether to move the mobject along the vector field. See :meth:`nudge` for details.\n\n        Returns\n        -------\n        VectorField\n            This vector field.\n\n        \"\"\"\n        for mob in self.submobjects:\n            self.nudge(mob, dt, substeps, pointwise)\n        return self\n\n\n\n[docs]\n    def get_nudge_updater(\n        self,\n        speed: float = 1,\n        pointwise: bool = False,\n    ) -> Callable[[Mobject, float], Mobject]:\n        \"\"\"Get an update function to move a :class:`~.Mobject` along the vector field.\n\n        When used with :meth:`~.Mobject.add_updater`, the mobject will move along the vector field, where its speed is determined by the magnitude of the vector field.\n\n        Parameters\n        ----------\n        speed\n            At `speed=1` the distance a mobject moves per second is equal to the magnitude of the vector field along its path. The speed value scales the speed of such a mobject.\n        pointwise\n            Whether to move the mobject along the vector field. See :meth:`nudge` for details.\n\n        Returns\n        -------\n        Callable[[Mobject, float], Mobject]\n            The update function.\n        \"\"\"\n        return lambda mob, dt: self.nudge(mob, dt * speed, pointwise=pointwise)\n\n\n\n[docs]\n    def start_submobject_movement(\n        self,\n        speed: float = 1,\n        pointwise: bool = False,\n    ) -> VectorField:\n        \"\"\"Start continuously moving all submobjects along the vector field.\n\n        Calling this method multiple times will result in removing the previous updater created by this method.\n\n        Parameters\n        ----------\n        speed\n            The speed at which to move the submobjects. See :meth:`get_nudge_updater` for details.\n        pointwise\n            Whether to move the mobject along the vector field. See :meth:`nudge` for details.\n\n        Returns\n        -------\n        VectorField\n            This vector field.\n\n        \"\"\"\n        self.stop_submobject_movement()\n        self.submob_movement_updater = lambda mob, dt: mob.nudge_submobjects(\n            dt * speed,\n            pointwise=pointwise,\n        )\n        self.add_updater(self.submob_movement_updater)\n        return self\n\n\n\n[docs]\n    def stop_submobject_movement(self) -> VectorField:\n        \"\"\"Stops the continuous movement started using :meth:`start_submobject_movement`.\n\n        Returns\n        -------\n        VectorField\n            This vector field.\n        \"\"\"\n        self.remove_updater(self.submob_movement_updater)\n        self.submob_movement_updater = None\n        return self\n\n\n\n[docs]\n    def get_colored_background_image(self, sampling_rate: int = 5) -> Image.Image:\n        \"\"\"Generate an image that displays the vector field.\n\n        The color at each position is calculated by passing the positing through a\n        series of steps:\n        Calculate the vector field function at that position, map that vector to a\n        single value using `self.color_scheme` and finally generate a color from\n        that value using the color gradient.\n\n        Parameters\n        ----------\n        sampling_rate\n            The stepsize at which pixels get included in the image. Lower values give\n            more accurate results, but may take a long time to compute.\n\n        Returns\n        -------\n        Image.Imgae\n            The vector field image.\n        \"\"\"\n        if self.single_color:\n            raise ValueError(\n                \"There is no point in generating an image if the vector field uses a single color.\",\n            )\n        ph = int(config[\"pixel_height\"] / sampling_rate)\n        pw = int(config[\"pixel_width\"] / sampling_rate)\n        fw = config[\"frame_width\"]\n        fh = config[\"frame_height\"]\n        points_array = np.zeros((ph, pw, 3))\n        x_array = np.linspace(-fw / 2, fw / 2, pw)\n        y_array = np.linspace(fh / 2, -fh / 2, ph)\n        x_array = x_array.reshape((1, len(x_array)))\n        y_array = y_array.reshape((len(y_array), 1))\n        x_array = x_array.repeat(ph, axis=0)\n        y_array.repeat(pw, axis=1)  # TODO why not y_array = y_array.repeat(...)?\n        points_array[:, :, 0] = x_array\n        points_array[:, :, 1] = y_array\n        rgbs = np.apply_along_axis(self.pos_to_rgb, 2, points_array)\n        return Image.fromarray((rgbs * 255).astype(\"uint8\"))\n\n\n\n[docs]\n    def get_vectorized_rgba_gradient_function(\n        self,\n        start: float,\n        end: float,\n        colors: Iterable[ParsableManimColor],\n    ):\n        \"\"\"\n        Generates a gradient of rgbas as a numpy array\n\n        Parameters\n        ----------\n        start\n            start value used for inverse interpolation at :func:`~.inverse_interpolate`\n        end\n            end value used for inverse interpolation at :func:`~.inverse_interpolate`\n        colors\n            list of colors to generate the gradient\n\n        Returns\n        -------\n            function to generate the gradients as numpy arrays representing rgba values\n        \"\"\"\n        rgbs = np.array([color_to_rgb(c) for c in colors])\n\n        def func(values, opacity=1):\n            alphas = inverse_interpolate(start, end, np.array(values))\n            alphas = np.clip(alphas, 0, 1)\n            scaled_alphas = alphas * (len(rgbs) - 1)\n            indices = scaled_alphas.astype(int)\n            next_indices = np.clip(indices + 1, 0, len(rgbs) - 1)\n            inter_alphas = scaled_alphas % 1\n            inter_alphas = inter_alphas.repeat(3).reshape((len(indices), 3))\n            result = interpolate(rgbs[indices], rgbs[next_indices], inter_alphas)\n            result = np.concatenate(\n                (result, np.full([len(result), 1], opacity)),\n                axis=1,\n            )\n            return result\n\n        return func\n\n\n\n\n\n[docs]\nclass ArrowVectorField(VectorField):\n    \"\"\"A :class:`VectorField` represented by a set of change vectors.\n\n    Vector fields are always based on a function defining the :class:`~.Vector` at every position.\n    The values of this functions is displayed as a grid of vectors.\n    By default the color of each vector is determined by it's magnitude.\n    Other color schemes can be used however.\n\n    Parameters\n    ----------\n    func\n        The function defining the rate of change at every position of the vector field.\n    color\n        The color of the vector field. If set, position-specific coloring is disabled.\n    color_scheme\n        A function mapping a vector to a single value. This value gives the position in the color gradient defined using `min_color_scheme_value`, `max_color_scheme_value` and `colors`.\n    min_color_scheme_value\n        The value of the color_scheme function to be mapped to the first color in `colors`. Lower values also result in the first color of the gradient.\n    max_color_scheme_value\n        The value of the color_scheme function to be mapped to the last color in `colors`. Higher values also result in the last color of the gradient.\n    colors\n        The colors defining the color gradient of the vector field.\n    x_range\n        A sequence of x_min, x_max, delta_x\n    y_range\n        A sequence of y_min, y_max, delta_y\n    z_range\n        A sequence of z_min, z_max, delta_z\n    three_dimensions\n        Enables three_dimensions. Default set to False, automatically turns True if\n        z_range is not None.\n    length_func\n        The function determining the displayed size of the vectors. The actual size\n        of the vector is passed, the returned value will be used as display size for the\n        vector. By default this is used to cap the displayed size of vectors to reduce the clutter.\n    opacity\n        The opacity of the arrows.\n    vector_config\n        Additional arguments to be passed to the :class:`~.Vector` constructor\n    kwargs\n        Additional arguments to be passed to the :class:`~.VGroup` constructor\n\n    Examples\n    --------\n\n    .. manim:: BasicUsage\n        :save_last_frame:\n\n        class BasicUsage(Scene):\n            def construct(self):\n                func = lambda pos: ((pos[0] * UR + pos[1] * LEFT) - pos) / 3\n                self.add(ArrowVectorField(func))\n\n    .. manim:: SizingAndSpacing\n\n        class SizingAndSpacing(Scene):\n            def construct(self):\n                func = lambda pos: np.sin(pos[0] / 2) * UR + np.cos(pos[1] / 2) * LEFT\n                vf = ArrowVectorField(func, x_range=[-7, 7, 1])\n                self.add(vf)\n                self.wait()\n\n                length_func = lambda x: x / 3\n                vf2 = ArrowVectorField(func, x_range=[-7, 7, 1], length_func=length_func)\n                self.play(vf.animate.become(vf2))\n                self.wait()\n\n    .. manim:: Coloring\n        :save_last_frame:\n\n        class Coloring(Scene):\n            def construct(self):\n                func = lambda pos: pos - LEFT * 5\n                colors = [RED, YELLOW, BLUE, DARK_GRAY]\n                min_radius = Circle(radius=2, color=colors[0]).shift(LEFT * 5)\n                max_radius = Circle(radius=10, color=colors[-1]).shift(LEFT * 5)\n                vf = ArrowVectorField(\n                    func, min_color_scheme_value=2, max_color_scheme_value=10, colors=colors\n                )\n                self.add(vf, min_radius, max_radius)\n\n    \"\"\"\n\n    def __init__(\n        self,\n        func: Callable[[np.ndarray], np.ndarray],\n        color: ParsableManimColor | None = None,\n        color_scheme: Callable[[np.ndarray], float] | None = None,\n        min_color_scheme_value: float = 0,\n        max_color_scheme_value: float = 2,\n        colors: Sequence[ParsableManimColor] = DEFAULT_SCALAR_FIELD_COLORS,\n        # Determining Vector positions:\n        x_range: Sequence[float] = None,\n        y_range: Sequence[float] = None,\n        z_range: Sequence[float] = None,\n        three_dimensions: bool = False,  # Automatically True if z_range is set\n        # Takes in actual norm, spits out displayed norm\n        length_func: Callable[[float], float] = lambda norm: 0.45 * sigmoid(norm),\n        opacity: float = 1.0,\n        vector_config: dict | None = None,\n        **kwargs,\n    ):\n        self.x_range = x_range or [\n            floor(-config[\"frame_width\"] / 2),\n            ceil(config[\"frame_width\"] / 2),\n        ]\n        self.y_range = y_range or [\n            floor(-config[\"frame_height\"] / 2),\n            ceil(config[\"frame_height\"] / 2),\n        ]\n        self.ranges = [self.x_range, self.y_range]\n\n        if three_dimensions or z_range:\n            self.z_range = z_range or self.y_range.copy()\n            self.ranges += [self.z_range]\n        else:\n            self.ranges += [[0, 0]]\n\n        for i in range(len(self.ranges)):\n            if len(self.ranges[i]) == 2:\n                self.ranges[i] += [0.5]\n            self.ranges[i][1] += self.ranges[i][2]\n\n        self.x_range, self.y_range, self.z_range = self.ranges\n\n        super().__init__(\n            func,\n            color,\n            color_scheme,\n            min_color_scheme_value,\n            max_color_scheme_value,\n            colors,\n            **kwargs,\n        )\n\n        self.length_func = length_func\n        self.opacity = opacity\n        if vector_config is None:\n            vector_config = {}\n        self.vector_config = vector_config\n        self.func = func\n\n        x_range = np.arange(*self.x_range)\n        y_range = np.arange(*self.y_range)\n        z_range = np.arange(*self.z_range)\n        self.add(\n            *[\n                self.get_vector(x * RIGHT + y * UP + z * OUT)\n                for x, y, z in it.product(x_range, y_range, z_range)\n            ]\n        )\n        self.set_opacity(self.opacity)\n\n\n[docs]\n    def get_vector(self, point: np.ndarray):\n        \"\"\"Creates a vector in the vector field.\n\n        The created vector is based on the function of the vector field and is\n        rooted in the given point. Color and length fit the specifications of\n        this vector field.\n\n        Parameters\n        ----------\n        point\n            The root point of the vector.\n\n        \"\"\"\n        output = np.array(self.func(point))\n        norm = np.linalg.norm(output)\n        if norm != 0:\n            output *= self.length_func(norm) / norm\n        vect = Vector(output, **self.vector_config)\n        vect.shift(point)\n        if self.single_color:\n            vect.set_color(self.color)\n        else:\n            vect.set_color(self.pos_to_color(point))\n        return vect\n\n\n\n\n\n[docs]\nclass StreamLines(VectorField):\n    \"\"\"StreamLines represent the flow of a :class:`VectorField` using the trace of moving agents.\n\n    Vector fields are always based on a function defining the vector at every position.\n    The values of this functions is displayed by moving many agents along the vector field\n    and showing their trace.\n\n    Parameters\n    ----------\n    func\n        The function defining the rate of change at every position of the vector field.\n    color\n        The color of the vector field. If set, position-specific coloring is disabled.\n    color_scheme\n        A function mapping a vector to a single value. This value gives the position in the color gradient defined using `min_color_scheme_value`, `max_color_scheme_value` and `colors`.\n    min_color_scheme_value\n        The value of the color_scheme function to be mapped to the first color in `colors`. Lower values also result in the first color of the gradient.\n    max_color_scheme_value\n        The value of the color_scheme function to be mapped to the last color in `colors`. Higher values also result in the last color of the gradient.\n    colors\n        The colors defining the color gradient of the vector field.\n    x_range\n        A sequence of x_min, x_max, delta_x\n    y_range\n        A sequence of y_min, y_max, delta_y\n    z_range\n        A sequence of z_min, z_max, delta_z\n    three_dimensions\n        Enables three_dimensions. Default set to False, automatically turns True if\n        z_range is not None.\n    noise_factor\n        The amount by which the starting position of each agent is altered along each axis. Defaults to :code:`delta_y / 2` if not defined.\n    n_repeats\n        The number of agents generated at each starting point.\n    dt\n        The factor by which the distance an agent moves per step is stretched. Lower values result in a better approximation of the trajectories in the vector field.\n    virtual_time\n        The time the agents get to move in the vector field. Higher values therefore result in longer stream lines. However, this whole time gets simulated upon creation.\n    max_anchors_per_line\n        The maximum number of anchors per line. Lines with more anchors get reduced in complexity, not in length.\n    padding\n        The distance agents can move out of the generation area before being terminated.\n    stroke_width\n        The stroke with of the stream lines.\n    opacity\n        The opacity of the stream lines.\n\n    Examples\n    --------\n\n    .. manim:: BasicUsage\n        :save_last_frame:\n\n        class BasicUsage(Scene):\n            def construct(self):\n                func = lambda pos: ((pos[0] * UR + pos[1] * LEFT) - pos) / 3\n                self.add(StreamLines(func))\n\n    .. manim:: SpawningAndFlowingArea\n        :save_last_frame:\n\n        class SpawningAndFlowingArea(Scene):\n            def construct(self):\n                func = lambda pos: np.sin(pos[0]) * UR + np.cos(pos[1]) * LEFT + pos / 5\n                stream_lines = StreamLines(\n                    func, x_range=[-3, 3, 0.2], y_range=[-2, 2, 0.2], padding=1\n                )\n\n                spawning_area = Rectangle(width=6, height=4)\n                flowing_area = Rectangle(width=8, height=6)\n                labels = [Tex(\"Spawning Area\"), Tex(\"Flowing Area\").shift(DOWN * 2.5)]\n                for lbl in labels:\n                    lbl.add_background_rectangle(opacity=0.6, buff=0.05)\n\n                self.add(stream_lines, spawning_area, flowing_area, *labels)\n\n    \"\"\"\n\n    def __init__(\n        self,\n        func: Callable[[np.ndarray], np.ndarray],\n        color: ParsableManimColor | None = None,\n        color_scheme: Callable[[np.ndarray], float] | None = None,\n        min_color_scheme_value: float = 0,\n        max_color_scheme_value: float = 2,\n        colors: Sequence[ParsableManimColor] = DEFAULT_SCALAR_FIELD_COLORS,\n        # Determining stream line starting positions:\n        x_range: Sequence[float] = None,\n        y_range: Sequence[float] = None,\n        z_range: Sequence[float] = None,\n        three_dimensions: bool = False,\n        noise_factor: float | None = None,\n        n_repeats=1,\n        # Determining how lines are drawn\n        dt=0.05,\n        virtual_time=3,\n        max_anchors_per_line=100,\n        padding=3,\n        # Determining stream line appearance:\n        stroke_width=1,\n        opacity=1,\n        **kwargs,\n    ):\n        self.x_range = x_range or [\n            floor(-config[\"frame_width\"] / 2),\n            ceil(config[\"frame_width\"] / 2),\n        ]\n        self.y_range = y_range or [\n            floor(-config[\"frame_height\"] / 2),\n            ceil(config[\"frame_height\"] / 2),\n        ]\n        self.ranges = [self.x_range, self.y_range]\n\n        if three_dimensions or z_range:\n            self.z_range = z_range or self.y_range.copy()\n            self.ranges += [self.z_range]\n        else:\n            self.ranges += [[0, 0]]\n\n        for i in range(len(self.ranges)):\n            if len(self.ranges[i]) == 2:\n                self.ranges[i] += [0.5]\n            self.ranges[i][1] += self.ranges[i][2]\n\n        self.x_range, self.y_range, self.z_range = self.ranges\n\n        super().__init__(\n            func,\n            color,\n            color_scheme,\n            min_color_scheme_value,\n            max_color_scheme_value,\n            colors,\n            **kwargs,\n        )\n\n        self.noise_factor = (\n            noise_factor if noise_factor is not None else self.y_range[2] / 2\n        )\n        self.n_repeats = n_repeats\n        self.virtual_time = virtual_time\n        self.max_anchors_per_line = max_anchors_per_line\n        self.padding = padding\n        self.stroke_width = stroke_width\n\n        half_noise = self.noise_factor / 2\n        np.random.seed(0)\n        start_points = np.array(\n            [\n                (x - half_noise) * RIGHT\n                + (y - half_noise) * UP\n                + (z - half_noise) * OUT\n                + self.noise_factor * np.random.random(3)\n                for n in range(self.n_repeats)\n                for x in np.arange(*self.x_range)\n                for y in np.arange(*self.y_range)\n                for z in np.arange(*self.z_range)\n            ],\n        )\n\n        def outside_box(p):\n            return (\n                p[0] < self.x_range[0] - self.padding\n                or p[0] > self.x_range[1] + self.padding - self.x_range[2]\n                or p[1] < self.y_range[0] - self.padding\n                or p[1] > self.y_range[1] + self.padding - self.y_range[2]\n                or p[2] < self.z_range[0] - self.padding\n                or p[2] > self.z_range[1] + self.padding - self.z_range[2]\n            )\n\n        max_steps = ceil(virtual_time / dt) + 1\n        if not self.single_color:\n            self.background_img = self.get_colored_background_image()\n            if config[\"renderer\"] == RendererType.OPENGL:\n                self.values_to_rgbas = self.get_vectorized_rgba_gradient_function(\n                    min_color_scheme_value,\n                    max_color_scheme_value,\n                    colors,\n                )\n        for point in start_points:\n            points = [point]\n            for _ in range(max_steps):\n                last_point = points[-1]\n                new_point = last_point + dt * func(last_point)\n                if outside_box(new_point):\n                    break\n                points.append(new_point)\n            step = max_steps\n            if not step:\n                continue\n            line = get_vectorized_mobject_class()()\n            line.duration = step * dt\n            step = max(1, int(len(points) / self.max_anchors_per_line))\n            line.set_points_smoothly(points[::step])\n            if self.single_color:\n                line.set_stroke(\n                    color=self.color, width=self.stroke_width, opacity=opacity\n                )\n            else:\n                if config.renderer == RendererType.OPENGL:\n                    # scaled for compatibility with cairo\n                    line.set_stroke(width=self.stroke_width / 4.0)\n                    norms = np.array(\n                        [np.linalg.norm(self.func(point)) for point in line.points],\n                    )\n                    line.set_rgba_array_direct(\n                        self.values_to_rgbas(norms, opacity),\n                        name=\"stroke_rgba\",\n                    )\n                else:\n                    if np.any(self.z_range != np.array([0, 0.5, 0.5])):\n                        line.set_stroke(\n                            [self.pos_to_color(p) for p in line.get_anchors()],\n                        )\n                    else:\n                        line.color_using_background_image(self.background_img)\n                    line.set_stroke(width=self.stroke_width, opacity=opacity)\n            self.add(line)\n        self.stream_lines = [*self.submobjects]\n\n\n[docs]\n    def create(\n        self,\n        lag_ratio: float | None = None,\n        run_time: Callable[[float], float] | None = None,\n        **kwargs,\n    ) -> AnimationGroup:\n        \"\"\"The creation animation of the stream lines.\n\n        The stream lines appear in random order.\n\n        Parameters\n        ----------\n        lag_ratio\n            The lag ratio of the animation.\n            If undefined, it will be selected so that the total animation length is 1.5 times the run time of each stream line creation.\n        run_time\n            The run time of every single stream line creation. The runtime of the whole animation might be longer due to the `lag_ratio`.\n            If undefined, the virtual time of the stream lines is used as run time.\n\n        Returns\n        -------\n        :class:`~.AnimationGroup`\n            The creation animation of the stream lines.\n\n        Examples\n        --------\n\n        .. manim:: StreamLineCreation\n\n            class StreamLineCreation(Scene):\n                def construct(self):\n                    func = lambda pos: (pos[0] * UR + pos[1] * LEFT) - pos\n                    stream_lines = StreamLines(\n                        func,\n                        color=YELLOW,\n                        x_range=[-7, 7, 1],\n                        y_range=[-4, 4, 1],\n                        stroke_width=3,\n                        virtual_time=1,  # use shorter lines\n                        max_anchors_per_line=5,  # better performance with fewer anchors\n                    )\n                    self.play(stream_lines.create())  # uses virtual_time as run_time\n                    self.wait()\n\n        \"\"\"\n        if run_time is None:\n            run_time = self.virtual_time\n        if lag_ratio is None:\n            lag_ratio = run_time / 2 / len(self.submobjects)\n\n        animations = [\n            Create(line, run_time=run_time, **kwargs) for line in self.stream_lines\n        ]\n        random.shuffle(animations)\n        return AnimationGroup(*animations, lag_ratio=lag_ratio)\n\n\n\n[docs]\n    def start_animation(\n        self,\n        warm_up: bool = True,\n        flow_speed: float = 1,\n        time_width: float = 0.3,\n        rate_func: Callable[[float], float] = linear,\n        line_animation_class: type[ShowPassingFlash] = ShowPassingFlash,\n        **kwargs,\n    ) -> None:\n        \"\"\"Animates the stream lines using an updater.\n\n        The stream lines will continuously flow\n\n        Parameters\n        ----------\n        warm_up\n            If `True` the animation is initialized line by line. Otherwise it starts with all lines shown.\n        flow_speed\n            At `flow_speed=1` the distance the flow moves per second is equal to the magnitude of the vector field along its path. The speed value scales the speed of this flow.\n        time_width\n            The proportion of the stream line shown while being animated\n        rate_func\n            The rate function of each stream line flashing\n        line_animation_class\n            The animation class being used\n\n        Examples\n        --------\n\n        .. manim:: ContinuousMotion\n\n            class ContinuousMotion(Scene):\n                def construct(self):\n                    func = lambda pos: np.sin(pos[0] / 2) * UR + np.cos(pos[1] / 2) * LEFT\n                    stream_lines = StreamLines(func, stroke_width=3, max_anchors_per_line=30)\n                    self.add(stream_lines)\n                    stream_lines.start_animation(warm_up=False, flow_speed=1.5)\n                    self.wait(stream_lines.virtual_time / stream_lines.flow_speed)\n\n        \"\"\"\n        for line in self.stream_lines:\n            run_time = line.duration / flow_speed\n            line.anim = line_animation_class(\n                line,\n                run_time=run_time,\n                rate_func=rate_func,\n                time_width=time_width,\n                **kwargs,\n            )\n            line.anim.begin()\n            line.time = random.random() * self.virtual_time\n            if warm_up:\n                line.time *= -1\n            self.add(line.anim.mobject)\n\n        def updater(mob, dt):\n            for line in mob.stream_lines:\n                line.time += dt * flow_speed\n                if line.time >= self.virtual_time:\n                    line.time -= self.virtual_time\n                line.anim.interpolate(np.clip(line.time / line.anim.run_time, 0, 1))\n\n        self.add_updater(updater)\n        self.flow_animation = updater\n        self.flow_speed = flow_speed\n        self.time_width = time_width\n\n\n\n[docs]\n    def end_animation(self) -> AnimationGroup:\n        \"\"\"End the stream line animation smoothly.\n\n        Returns an animation resulting in fully displayed stream lines without a noticeable cut.\n\n        Returns\n        -------\n        :class:`~.AnimationGroup`\n            The animation fading out the running stream animation.\n\n        Raises\n        ------\n        ValueError\n            if no stream line animation is running\n\n        Examples\n        --------\n\n        .. manim:: EndAnimation\n\n            class EndAnimation(Scene):\n                def construct(self):\n                    func = lambda pos: np.sin(pos[0] / 2) * UR + np.cos(pos[1] / 2) * LEFT\n                    stream_lines = StreamLines(\n                        func, stroke_width=3, max_anchors_per_line=5, virtual_time=1, color=BLUE\n                    )\n                    self.add(stream_lines)\n                    stream_lines.start_animation(warm_up=False, flow_speed=1.5, time_width=0.5)\n                    self.wait(1)\n                    self.play(stream_lines.end_animation())\n\n        \"\"\"\n        if self.flow_animation is None:\n            raise ValueError(\"You have to start the animation before fading it out.\")\n\n        def hide_and_wait(mob, alpha):\n            if alpha == 0:\n                mob.set_stroke(opacity=0)\n            elif alpha == 1:\n                mob.set_stroke(opacity=1)\n\n        def finish_updater_cycle(line, alpha):\n            line.time += dt * self.flow_speed\n            line.anim.interpolate(min(line.time / line.anim.run_time, 1))\n            if alpha == 1:\n                self.remove(line.anim.mobject)\n                line.anim.finish()\n\n        max_run_time = self.virtual_time / self.flow_speed\n        creation_rate_func = ease_out_sine\n        creation_staring_speed = creation_rate_func(0.001) * 1000\n        creation_run_time = (\n            max_run_time / (1 + self.time_width) * creation_staring_speed\n        )\n        # creation_run_time is calculated so that the creation animation starts at the same speed\n        # as the regular line flash animation but eases out.\n\n        dt = 1 / config[\"frame_rate\"]\n        animations = []\n        self.remove_updater(self.flow_animation)\n        self.flow_animation = None\n\n        for line in self.stream_lines:\n            create = Create(\n                line,\n                run_time=creation_run_time,\n                rate_func=creation_rate_func,\n            )\n            if line.time <= 0:\n                animations.append(\n                    Succession(\n                        UpdateFromAlphaFunc(\n                            line,\n                            hide_and_wait,\n                            run_time=-line.time / self.flow_speed,\n                        ),\n                        create,\n                    ),\n                )\n                self.remove(line.anim.mobject)\n                line.anim.finish()\n            else:\n                remaining_time = max_run_time - line.time / self.flow_speed\n                animations.append(\n                    Succession(\n                        UpdateFromAlphaFunc(\n                            line,\n                            finish_updater_cycle,\n                            run_time=remaining_time,\n                        ),\n                        create,\n                    ),\n                )\n        return AnimationGroup(*animations)\n\n\n\n\n# TODO: Variant of StreamLines that is able to respond to changes in the vector field function", "code_sha1": "7f3f2c110ba64890a016f272d40cedebfd1be1e1"}
{"url": "https://docs.manim.community/en/stable/_modules/manim/scene/moving_camera_scene.html", "depth": 2, "instruction": "The scene features a camera that smoothly moves and zooms around various geometric shapes (a blue square and a yellow triangle) while they are displayed on screen. The camera transitions between the shapes, adjusting its width dynamically, and finally zooms out to encompass all objects, creating a visually engaging exploration of the scene.", "code": "\"\"\"A scene whose camera can be moved around.\n\n.. SEEALSO::\n\n    :mod:`.moving_camera`\n\n\nExamples\n--------\n\n.. manim:: ChangingCameraWidthAndRestore\n\n    class ChangingCameraWidthAndRestore(MovingCameraScene):\n        def construct(self):\n            text = Text(\"Hello World\").set_color(BLUE)\n            self.add(text)\n            self.camera.frame.save_state()\n            self.play(self.camera.frame.animate.set(width=text.width * 1.2))\n            self.wait(0.3)\n            self.play(Restore(self.camera.frame))\n\n\n.. manim:: MovingCameraCenter\n\n    class MovingCameraCenter(MovingCameraScene):\n        def construct(self):\n            s = Square(color=RED, fill_opacity=0.5).move_to(2 * LEFT)\n            t = Triangle(color=GREEN, fill_opacity=0.5).move_to(2 * RIGHT)\n            self.wait(0.3)\n            self.add(s, t)\n            self.play(self.camera.frame.animate.move_to(s))\n            self.wait(0.3)\n            self.play(self.camera.frame.animate.move_to(t))\n\n\n.. manim:: MovingAndZoomingCamera\n\n    class MovingAndZoomingCamera(MovingCameraScene):\n        def construct(self):\n            s = Square(color=BLUE, fill_opacity=0.5).move_to(2 * LEFT)\n            t = Triangle(color=YELLOW, fill_opacity=0.5).move_to(2 * RIGHT)\n            self.add(s, t)\n            self.play(self.camera.frame.animate.move_to(s).set(width=s.width*2))\n            self.wait(0.3)\n            self.play(self.camera.frame.animate.move_to(t).set(width=t.width*2))\n\n            self.play(self.camera.frame.animate.move_to(ORIGIN).set(width=14))\n\n.. manim:: MovingCameraOnGraph\n\n    class MovingCameraOnGraph(MovingCameraScene):\n        def construct(self):\n            self.camera.frame.save_state()\n\n            ax = Axes(x_range=[-1, 10], y_range=[-1, 10])\n            graph = ax.plot(lambda x: np.sin(x), color=WHITE, x_range=[0, 3 * PI])\n\n            dot_1 = Dot(ax.i2gp(graph.t_min, graph))\n            dot_2 = Dot(ax.i2gp(graph.t_max, graph))\n            self.add(ax, graph, dot_1, dot_2)\n\n            self.play(self.camera.frame.animate.scale(0.5).move_to(dot_1))\n            self.play(self.camera.frame.animate.move_to(dot_2))\n            self.play(Restore(self.camera.frame))\n            self.wait()\n\n.. manim:: SlidingMultipleScenes\n\n    class SlidingMultipleScenes(MovingCameraScene):\n        def construct(self):\n            def create_scene(number):\n                frame = Rectangle(width=16,height=9)\n                circ = Circle().shift(LEFT)\n                text = Tex(f\"This is Scene {str(number)}\").next_to(circ, RIGHT)\n                frame.add(circ,text)\n                return frame\n\n            group = VGroup(*(create_scene(i) for i in range(4))).arrange_in_grid(buff=4)\n            self.add(group)\n            self.camera.auto_zoom(group[0], animate=False)\n            for scene in group:\n                self.play(self.camera.auto_zoom(scene))\n                self.wait()\n\n            self.play(self.camera.auto_zoom(group, margin=2))\n\"\"\"\n\nfrom __future__ import annotations\n\n__all__ = [\"MovingCameraScene\"]\n\nfrom manim.animation.animation import Animation\n\nfrom ..camera.moving_camera import MovingCamera\nfrom ..scene.scene import Scene\nfrom ..utils.family import extract_mobject_family_members\nfrom ..utils.iterables import list_update\n\n\n\n[docs]\nclass MovingCameraScene(Scene):\n    \"\"\"\n    This is a Scene, with special configurations and properties that\n    make it suitable for cases where the camera must be moved around.\n\n    Note: Examples are included in the moving_camera_scene module\n    documentation, see below in the 'see also' section.\n\n    .. SEEALSO::\n\n        :mod:`.moving_camera_scene`\n        :class:`.MovingCamera`\n    \"\"\"\n\n    def __init__(self, camera_class=MovingCamera, **kwargs):\n        super().__init__(camera_class=camera_class, **kwargs)\n\n\n[docs]\n    def get_moving_mobjects(self, *animations: Animation):\n        \"\"\"\n        This method returns a list of all of the Mobjects in the Scene that\n        are moving, that are also in the animations passed.\n\n        Parameters\n        ----------\n        *animations\n            The Animations whose mobjects will be checked.\n        \"\"\"\n        moving_mobjects = super().get_moving_mobjects(*animations)\n        all_moving_mobjects = extract_mobject_family_members(moving_mobjects)\n        movement_indicators = self.renderer.camera.get_mobjects_indicating_movement()\n        for movement_indicator in movement_indicators:\n            if movement_indicator in all_moving_mobjects:\n                # When one of these is moving, the camera should\n                # consider all mobjects to be moving\n                return list_update(self.mobjects, moving_mobjects)\n        return moving_mobjects", "code_sha1": "ada619c70fedaed8562bb50fe4118ce2aa06bd51"}
{"url": "https://docs.manim.community/en/stable/_modules/manim/scene/section.html", "depth": 2, "instruction": "The code defines a `Section` class for managing segmented video content, including attributes for type, video path, name, and animation control. It provides methods to check if a section is empty, retrieve non-null movie files, and generate a metadata dictionary for video output. The `DefaultSectionType` enum categorizes section types for external applications.", "code": "\"\"\"building blocks of segmented video API\"\"\"\n\nfrom __future__ import annotations\n\nfrom enum import Enum\nfrom pathlib import Path\nfrom typing import Any\n\nfrom manim import get_video_metadata\n\n__all__ = [\"Section\", \"DefaultSectionType\"]\n\n\n\n[docs]\nclass DefaultSectionType(str, Enum):\n    \"\"\"The type of a section can be used for third party applications.\n    A presentation system could for example use the types to created loops.\n\n    Examples\n    --------\n    This class can be reimplemented for more types::\n\n        class PresentationSectionType(str, Enum):\n            # start, end, wait for continuation by user\n            NORMAL = \"presentation.normal\"\n            # start, end, immediately continue to next section\n            SKIP = \"presentation.skip\"\n            # start, end, restart, immediately continue to next section when continued by user\n            LOOP = \"presentation.loop\"\n            # start, end, restart, finish animation first when user continues\n            COMPLETE_LOOP = \"presentation.complete_loop\"\n    \"\"\"\n\n    NORMAL = \"default.normal\"\n\n\n\n\n[docs]\nclass Section:\n    r\"\"\"A :class:`.Scene` can be segmented into multiple Sections.\n    Refer to :doc:`the documentation</tutorials/output_and_config>` for more info.\n    It consists of multiple animations.\n\n    Attributes\n    ----------\n        type\\_\n            Can be used by a third party applications to classify different types of sections.\n        video\n            Path to video file with animations belonging to section relative to sections directory.\n            If ``None``, then the section will not be saved.\n        name\n            Human readable, non-unique name for this section.\n        skip_animations\n            Skip rendering the animations in this section when ``True``.\n        partial_movie_files\n            Animations belonging to this section.\n\n    See Also\n    --------\n    :class:`.DefaultSectionType`\n    :meth:`.CairoRenderer.update_skipping_status`\n    :meth:`.OpenGLRenderer.update_skipping_status`\n    \"\"\"\n\n    def __init__(self, type_: str, video: str | None, name: str, skip_animations: bool):\n        self.type_ = type_\n        # None when not to be saved -> still keeps section alive\n        self.video: str | None = video\n        self.name = name\n        self.skip_animations = skip_animations\n        self.partial_movie_files: list[str | None] = []\n\n\n[docs]\n    def is_empty(self) -> bool:\n        \"\"\"Check whether this section is empty.\n\n        Note that animations represented by ``None`` are also counted.\n        \"\"\"\n        return len(self.partial_movie_files) == 0\n\n\n\n[docs]\n    def get_clean_partial_movie_files(self) -> list[str]:\n        \"\"\"Return all partial movie files that are not ``None``.\"\"\"\n        return [el for el in self.partial_movie_files if el is not None]\n\n\n\n[docs]\n    def get_dict(self, sections_dir: Path) -> dict[str, Any]:\n        \"\"\"Get dictionary representation with metadata of output video.\n\n        The output from this function is used from every section to build the sections index file.\n        The output video must have been created in the ``sections_dir`` before executing this method.\n        This is the main part of the Segmented Video API.\n        \"\"\"\n        if self.video is None:\n            raise ValueError(\n                f\"Section '{self.name}' cannot be exported as dict, it does not have a video path assigned to it\"\n            )\n\n        video_metadata = get_video_metadata(sections_dir / self.video)\n        return dict(\n            {\n                \"name\": self.name,\n                \"type\": self.type_,\n                \"video\": self.video,\n            },\n            **video_metadata,\n        )\n\n\n    def __repr__(self):\n        return f\"<Section '{self.name}' stored in '{self.video}'>\"", "code_sha1": "0f06d88498b48fe9c73b3aa060b7858375792349"}
{"url": "https://docs.manim.community/en/stable/_modules/manim/scene/scene.html", "depth": 2, "instruction": "The code defines a `Scene` class in Manim, which serves as a canvas for animations, managing mobjects and their animations. It includes methods for adding, removing, and updating mobjects, as well as handling animations and rendering. The scene can be interacted with through mouse and keyboard events, allowing for dynamic adjustments during animation playback.", "code": "\"\"\"Basic canvas for animations.\"\"\"\n\nfrom __future__ import annotations\n\nfrom manim.utils.parameter_parsing import flatten_iterable_parameters\n\n__all__ = [\"Scene\"]\n\nimport copy\nimport datetime\nimport inspect\nimport platform\nimport random\nimport threading\nimport time\nimport types\nfrom queue import Queue\n\nimport srt\n\nfrom manim.scene.section import DefaultSectionType\n\ntry:\n    import dearpygui.dearpygui as dpg\n\n    dearpygui_imported = True\nexcept ImportError:\n    dearpygui_imported = False\nfrom typing import TYPE_CHECKING\n\nimport numpy as np\nfrom tqdm import tqdm\nfrom watchdog.events import FileSystemEventHandler\nfrom watchdog.observers import Observer\n\nfrom manim.mobject.mobject import Mobject\nfrom manim.mobject.opengl.opengl_mobject import OpenGLPoint\n\nfrom .. import config, logger\nfrom ..animation.animation import Animation, Wait, prepare_animation\nfrom ..camera.camera import Camera\nfrom ..constants import *\nfrom ..gui.gui import configure_pygui\nfrom ..renderer.cairo_renderer import CairoRenderer\nfrom ..renderer.opengl_renderer import OpenGLRenderer\nfrom ..renderer.shader import Object3D\nfrom ..utils import opengl, space_ops\nfrom ..utils.exceptions import EndSceneEarlyException, RerunSceneException\nfrom ..utils.family import extract_mobject_family_members\nfrom ..utils.family_ops import restructure_list_to_exclude_certain_family_members\nfrom ..utils.file_ops import open_media_file\nfrom ..utils.iterables import list_difference_update, list_update\n\nif TYPE_CHECKING:\n    from collections.abc import Sequence\n    from typing import Callable\n\n    from manim.mobject.mobject import _AnimationBuilder\n\n\n\n[docs]\nclass RerunSceneHandler(FileSystemEventHandler):\n    \"\"\"A class to handle rerunning a Scene after the input file is modified.\"\"\"\n\n    def __init__(self, queue):\n        super().__init__()\n        self.queue = queue\n\n\n[docs]\n    def on_modified(self, event):\n        self.queue.put((\"rerun_file\", [], {}))\n\n\n\n\n\n[docs]\nclass Scene:\n    \"\"\"A Scene is the canvas of your animation.\n\n    The primary role of :class:`Scene` is to provide the user with tools to manage\n    mobjects and animations.  Generally speaking, a manim script consists of a class\n    that derives from :class:`Scene` whose :meth:`Scene.construct` method is overridden\n    by the user's code.\n\n    Mobjects are displayed on screen by calling :meth:`Scene.add` and removed from\n    screen by calling :meth:`Scene.remove`.  All mobjects currently on screen are kept\n    in :attr:`Scene.mobjects`.  Animations are played by calling :meth:`Scene.play`.\n\n    A :class:`Scene` is rendered internally by calling :meth:`Scene.render`.  This in\n    turn calls :meth:`Scene.setup`, :meth:`Scene.construct`, and\n    :meth:`Scene.tear_down`, in that order.\n\n    It is not recommended to override the ``__init__`` method in user Scenes.  For code\n    that should be ran before a Scene is rendered, use :meth:`Scene.setup` instead.\n\n    Examples\n    --------\n    Override the :meth:`Scene.construct` method with your code.\n\n    .. code-block:: python\n\n        class MyScene(Scene):\n            def construct(self):\n                self.play(Write(Text(\"Hello World!\")))\n\n    \"\"\"\n\n    def __init__(\n        self,\n        renderer: CairoRenderer | OpenGLRenderer | None = None,\n        camera_class: type[Camera] = Camera,\n        always_update_mobjects: bool = False,\n        random_seed: int | None = None,\n        skip_animations: bool = False,\n    ) -> None:\n        self.camera_class = camera_class\n        self.always_update_mobjects = always_update_mobjects\n        self.random_seed = random_seed\n        self.skip_animations = skip_animations\n\n        self.animations = None\n        self.stop_condition = None\n        self.moving_mobjects = []\n        self.static_mobjects = []\n        self.time_progression = None\n        self.duration = None\n        self.last_t = None\n        self.queue = Queue()\n        self.skip_animation_preview = False\n        self.meshes = []\n        self.camera_target = ORIGIN\n        self.widgets = []\n        self.dearpygui_imported = dearpygui_imported\n        self.updaters = []\n        self.point_lights = []\n        self.ambient_light = None\n        self.key_to_function_map = {}\n        self.mouse_press_callbacks = []\n        self.interactive_mode = False\n\n        if config.renderer == RendererType.OPENGL:\n            # Items associated with interaction\n            self.mouse_point = OpenGLPoint()\n            self.mouse_drag_point = OpenGLPoint()\n            if renderer is None:\n                renderer = OpenGLRenderer()\n\n        if renderer is None:\n            self.renderer = CairoRenderer(\n                camera_class=self.camera_class,\n                skip_animations=self.skip_animations,\n            )\n        else:\n            self.renderer = renderer\n        self.renderer.init_scene(self)\n\n        self.mobjects = []\n        # TODO, remove need for foreground mobjects\n        self.foreground_mobjects = []\n        if self.random_seed is not None:\n            random.seed(self.random_seed)\n            np.random.seed(self.random_seed)\n\n    @property\n    def camera(self):\n        return self.renderer.camera\n\n    @property\n    def time(self) -> float:\n        \"\"\"The time since the start of the scene.\"\"\"\n        return self.renderer.time\n\n    def __deepcopy__(self, clone_from_id):\n        cls = self.__class__\n        result = cls.__new__(cls)\n        clone_from_id[id(self)] = result\n        for k, v in self.__dict__.items():\n            if k in [\"renderer\", \"time_progression\"]:\n                continue\n            if k == \"camera_class\":\n                setattr(result, k, v)\n            setattr(result, k, copy.deepcopy(v, clone_from_id))\n        result.mobject_updater_lists = []\n\n        # Update updaters\n        for mobject in self.mobjects:\n            cloned_updaters = []\n            for updater in mobject.updaters:\n                # Make the cloned updater use the cloned Mobjects as free variables\n                # rather than the original ones. Analyzing function bytecode with the\n                # dis module will help in understanding this.\n                # https://docs.python.org/3/library/dis.html\n                # TODO: Do the same for function calls recursively.\n                free_variable_map = inspect.getclosurevars(updater).nonlocals\n                cloned_co_freevars = []\n                cloned_closure = []\n                for free_variable_name in updater.__code__.co_freevars:\n                    free_variable_value = free_variable_map[free_variable_name]\n\n                    # If the referenced variable has not been cloned, raise.\n                    if id(free_variable_value) not in clone_from_id:\n                        raise Exception(\n                            f\"{free_variable_name} is referenced from an updater \"\n                            \"but is not an attribute of the Scene, which isn't \"\n                            \"allowed.\",\n                        )\n\n                    # Add the cloned object's name to the free variable list.\n                    cloned_co_freevars.append(free_variable_name)\n\n                    # Add a cell containing the cloned object's reference to the\n                    # closure list.\n                    cloned_closure.append(\n                        types.CellType(clone_from_id[id(free_variable_value)]),\n                    )\n\n                cloned_updater = types.FunctionType(\n                    updater.__code__.replace(co_freevars=tuple(cloned_co_freevars)),\n                    updater.__globals__,\n                    updater.__name__,\n                    updater.__defaults__,\n                    tuple(cloned_closure),\n                )\n                cloned_updaters.append(cloned_updater)\n            mobject_clone = clone_from_id[id(mobject)]\n            mobject_clone.updaters = cloned_updaters\n            if len(cloned_updaters) > 0:\n                result.mobject_updater_lists.append((mobject_clone, cloned_updaters))\n        return result\n\n\n[docs]\n    def render(self, preview: bool = False):\n        \"\"\"\n        Renders this Scene.\n\n        Parameters\n        ---------\n        preview\n            If true, opens scene in a file viewer.\n        \"\"\"\n        self.setup()\n        try:\n            self.construct()\n        except EndSceneEarlyException:\n            pass\n        except RerunSceneException:\n            self.remove(*self.mobjects)\n            self.renderer.clear_screen()\n            self.renderer.num_plays = 0\n            return True\n        self.tear_down()\n        # We have to reset these settings in case of multiple renders.\n        self.renderer.scene_finished(self)\n\n        # Show info only if animations are rendered or to get image\n        if (\n            self.renderer.num_plays\n            or config[\"format\"] == \"png\"\n            or config[\"save_last_frame\"]\n        ):\n            logger.info(\n                f\"Rendered {str(self)}\\nPlayed {self.renderer.num_plays} animations\",\n            )\n\n        # If preview open up the render after rendering.\n        if preview:\n            config[\"preview\"] = True\n\n        if config[\"preview\"] or config[\"show_in_file_browser\"]:\n            open_media_file(self.renderer.file_writer)\n\n\n\n[docs]\n    def setup(self):\n        \"\"\"\n        This is meant to be implemented by any scenes which\n        are commonly subclassed, and have some common setup\n        involved before the construct method is called.\n        \"\"\"\n        pass\n\n\n\n[docs]\n    def tear_down(self):\n        \"\"\"\n        This is meant to be implemented by any scenes which\n        are commonly subclassed, and have some common method\n        to be invoked before the scene ends.\n        \"\"\"\n        pass\n\n\n\n[docs]\n    def construct(self):\n        \"\"\"Add content to the Scene.\n\n        From within :meth:`Scene.construct`, display mobjects on screen by calling\n        :meth:`Scene.add` and remove them from screen by calling :meth:`Scene.remove`.\n        All mobjects currently on screen are kept in :attr:`Scene.mobjects`.  Play\n        animations by calling :meth:`Scene.play`.\n\n        Notes\n        -----\n        Initialization code should go in :meth:`Scene.setup`.  Termination code should\n        go in :meth:`Scene.tear_down`.\n\n        Examples\n        --------\n        A typical manim script includes a class derived from :class:`Scene` with an\n        overridden :meth:`Scene.construct` method:\n\n        .. code-block:: python\n\n            class MyScene(Scene):\n                def construct(self):\n                    self.play(Write(Text(\"Hello World!\")))\n\n        See Also\n        --------\n        :meth:`Scene.setup`\n        :meth:`Scene.render`\n        :meth:`Scene.tear_down`\n\n        \"\"\"\n        pass  # To be implemented in subclasses\n\n\n\n[docs]\n    def next_section(\n        self,\n        name: str = \"unnamed\",\n        section_type: str = DefaultSectionType.NORMAL,\n        skip_animations: bool = False,\n    ) -> None:\n        \"\"\"Create separation here; the last section gets finished and a new one gets created.\n        ``skip_animations`` skips the rendering of all animations in this section.\n        Refer to :doc:`the documentation</tutorials/output_and_config>` on how to use sections.\n        \"\"\"\n        self.renderer.file_writer.next_section(name, section_type, skip_animations)\n\n\n    def __str__(self):\n        return self.__class__.__name__\n\n\n[docs]\n    def get_attrs(self, *keys: str):\n        \"\"\"\n        Gets attributes of a scene given the attribute's identifier/name.\n\n        Parameters\n        ----------\n        *keys\n            Name(s) of the argument(s) to return the attribute of.\n\n        Returns\n        -------\n        list\n            List of attributes of the passed identifiers.\n        \"\"\"\n        return [getattr(self, key) for key in keys]\n\n\n\n[docs]\n    def update_mobjects(self, dt: float):\n        \"\"\"\n        Begins updating all mobjects in the Scene.\n\n        Parameters\n        ----------\n        dt\n            Change in time between updates. Defaults (mostly) to 1/frames_per_second\n        \"\"\"\n        for mobject in self.mobjects:\n            mobject.update(dt)\n\n\n    def update_meshes(self, dt):\n        for obj in self.meshes:\n            for mesh in obj.get_family():\n                mesh.update(dt)\n\n\n[docs]\n    def update_self(self, dt: float):\n        \"\"\"Run all scene updater functions.\n\n        Among all types of update functions (mobject updaters, mesh updaters,\n        scene updaters), scene update functions are called last.\n\n        Parameters\n        ----------\n        dt\n            Scene time since last update.\n\n        See Also\n        --------\n        :meth:`.Scene.add_updater`\n        :meth:`.Scene.remove_updater`\n        \"\"\"\n        for func in self.updaters:\n            func(dt)\n\n\n\n[docs]\n    def should_update_mobjects(self) -> bool:\n        \"\"\"\n        Returns True if the mobjects of this scene should be updated.\n\n        In particular, this checks whether\n\n        - the :attr:`always_update_mobjects` attribute of :class:`.Scene`\n          is set to ``True``,\n        - the :class:`.Scene` itself has time-based updaters attached,\n        - any mobject in this :class:`.Scene` has time-based updaters attached.\n\n        This is only called when a single Wait animation is played.\n        \"\"\"\n        wait_animation = self.animations[0]\n        if wait_animation.is_static_wait is None:\n            should_update = (\n                self.always_update_mobjects\n                or self.updaters\n                or wait_animation.stop_condition is not None\n                or any(\n                    mob.has_time_based_updater()\n                    for mob in self.get_mobject_family_members()\n                )\n            )\n            wait_animation.is_static_wait = not should_update\n        return not wait_animation.is_static_wait\n\n\n\n[docs]\n    def get_top_level_mobjects(self):\n        \"\"\"\n        Returns all mobjects which are not submobjects.\n\n        Returns\n        -------\n        list\n            List of top level mobjects.\n        \"\"\"\n        # Return only those which are not in the family\n        # of another mobject from the scene\n        families = [m.get_family() for m in self.mobjects]\n\n        def is_top_level(mobject):\n            num_families = sum((mobject in family) for family in families)\n            return num_families == 1\n\n        return list(filter(is_top_level, self.mobjects))\n\n\n\n[docs]\n    def get_mobject_family_members(self):\n        \"\"\"\n        Returns list of family-members of all mobjects in scene.\n        If a Circle() and a VGroup(Rectangle(),Triangle()) were added,\n        it returns not only the Circle(), Rectangle() and Triangle(), but\n        also the VGroup() object.\n\n        Returns\n        -------\n        list\n            List of mobject family members.\n        \"\"\"\n        if config.renderer == RendererType.OPENGL:\n            family_members = []\n            for mob in self.mobjects:\n                family_members.extend(mob.get_family())\n            return family_members\n        elif config.renderer == RendererType.CAIRO:\n            return extract_mobject_family_members(\n                self.mobjects,\n                use_z_index=self.renderer.camera.use_z_index,\n            )\n\n\n\n[docs]\n    def add(self, *mobjects: Mobject):\n        \"\"\"\n        Mobjects will be displayed, from background to\n        foreground in the order with which they are added.\n\n        Parameters\n        ---------\n        *mobjects\n            Mobjects to add.\n\n        Returns\n        -------\n        Scene\n            The same scene after adding the Mobjects in.\n\n        \"\"\"\n        if config.renderer == RendererType.OPENGL:\n            new_mobjects = []\n            new_meshes = []\n            for mobject_or_mesh in mobjects:\n                if isinstance(mobject_or_mesh, Object3D):\n                    new_meshes.append(mobject_or_mesh)\n                else:\n                    new_mobjects.append(mobject_or_mesh)\n            self.remove(*new_mobjects)\n            self.mobjects += new_mobjects\n            self.remove(*new_meshes)\n            self.meshes += new_meshes\n        elif config.renderer == RendererType.CAIRO:\n            mobjects = [*mobjects, *self.foreground_mobjects]\n            self.restructure_mobjects(to_remove=mobjects)\n            self.mobjects += mobjects\n            if self.moving_mobjects:\n                self.restructure_mobjects(\n                    to_remove=mobjects,\n                    mobject_list_name=\"moving_mobjects\",\n                )\n                self.moving_mobjects += mobjects\n        return self\n\n\n    def add_mobjects_from_animations(self, animations: list[Animation]) -> None:\n        curr_mobjects = self.get_mobject_family_members()\n        for animation in animations:\n            if animation.is_introducer():\n                continue\n            # Anything animated that's not already in the\n            # scene gets added to the scene\n            mob = animation.mobject\n            if mob is not None and mob not in curr_mobjects:\n                self.add(mob)\n                curr_mobjects += mob.get_family()\n\n\n[docs]\n    def remove(self, *mobjects: Mobject):\n        \"\"\"\n        Removes mobjects in the passed list of mobjects\n        from the scene and the foreground, by removing them\n        from \"mobjects\" and \"foreground_mobjects\"\n\n        Parameters\n        ----------\n        *mobjects\n            The mobjects to remove.\n        \"\"\"\n        if config.renderer == RendererType.OPENGL:\n            mobjects_to_remove = []\n            meshes_to_remove = set()\n            for mobject_or_mesh in mobjects:\n                if isinstance(mobject_or_mesh, Object3D):\n                    meshes_to_remove.add(mobject_or_mesh)\n                else:\n                    mobjects_to_remove.append(mobject_or_mesh)\n            self.mobjects = restructure_list_to_exclude_certain_family_members(\n                self.mobjects,\n                mobjects_to_remove,\n            )\n            self.meshes = list(\n                filter(lambda mesh: mesh not in set(meshes_to_remove), self.meshes),\n            )\n            return self\n        elif config.renderer == RendererType.CAIRO:\n            for list_name in \"mobjects\", \"foreground_mobjects\":\n                self.restructure_mobjects(mobjects, list_name, False)\n            return self\n\n\n\n[docs]\n    def replace(self, old_mobject: Mobject, new_mobject: Mobject) -> None:\n        \"\"\"Replace one mobject in the scene with another, preserving draw order.\n\n        If ``old_mobject`` is a submobject of some other Mobject (e.g. a\n        :class:`.Group`), the new_mobject will replace it inside the group,\n        without otherwise changing the parent mobject.\n\n        Parameters\n        ----------\n        old_mobject\n            The mobject to be replaced. Must be present in the scene.\n        new_mobject\n            A mobject which must not already be in the scene.\n\n        \"\"\"\n        if old_mobject is None or new_mobject is None:\n            raise ValueError(\"Specified mobjects cannot be None\")\n\n        def replace_in_list(\n            mobj_list: list[Mobject], old_m: Mobject, new_m: Mobject\n        ) -> bool:\n            # We use breadth-first search because some Mobjects get very deep and\n            # we expect top-level elements to be the most common targets for replace.\n            for i in range(0, len(mobj_list)):\n                # Is this the old mobject?\n                if mobj_list[i] == old_m:\n                    # If so, write the new object to the same spot and stop looking.\n                    mobj_list[i] = new_m\n                    return True\n            # Now check all the children of all these mobs.\n            for mob in mobj_list:  # noqa: SIM110\n                if replace_in_list(mob.submobjects, old_m, new_m):\n                    # If we found it in a submobject, stop looking.\n                    return True\n            # If we did not find the mobject in the mobject list or any submobjects,\n            # (or the list was empty), indicate we did not make the replacement.\n            return False\n\n        # Make use of short-circuiting conditionals to check mobjects and then\n        # foreground_mobjects\n        replaced = replace_in_list(\n            self.mobjects, old_mobject, new_mobject\n        ) or replace_in_list(self.foreground_mobjects, old_mobject, new_mobject)\n\n        if not replaced:\n            raise ValueError(f\"Could not find {old_mobject} in scene\")\n\n\n\n[docs]\n    def add_updater(self, func: Callable[[float], None]) -> None:\n        \"\"\"Add an update function to the scene.\n\n        The scene updater functions are run every frame,\n        and they are the last type of updaters to run.\n\n        .. WARNING::\n\n            When using the Cairo renderer, scene updaters that\n            modify mobjects are not detected in the same way\n            that mobject updaters are. To be more concrete,\n            a mobject only modified via a scene updater will\n            not necessarily be added to the list of *moving\n            mobjects* and thus might not be updated every frame.\n\n            TL;DR: Use mobject updaters to update mobjects.\n\n        Parameters\n        ----------\n        func\n            The updater function. It takes a float, which is the\n            time difference since the last update (usually equal\n            to the frame rate).\n\n        See also\n        --------\n        :meth:`.Scene.remove_updater`\n        :meth:`.Scene.update_self`\n        \"\"\"\n        self.updaters.append(func)\n\n\n\n[docs]\n    def remove_updater(self, func: Callable[[float], None]) -> None:\n        \"\"\"Remove an update function from the scene.\n\n        Parameters\n        ----------\n        func\n            The updater function to be removed.\n\n        See also\n        --------\n        :meth:`.Scene.add_updater`\n        :meth:`.Scene.update_self`\n        \"\"\"\n        self.updaters = [f for f in self.updaters if f is not func]\n\n\n\n[docs]\n    def restructure_mobjects(\n        self,\n        to_remove: Sequence[Mobject],\n        mobject_list_name: str = \"mobjects\",\n        extract_families: bool = True,\n    ):\n        \"\"\"\n        tl:wr\n            If your scene has a Group(), and you removed a mobject from the Group,\n            this dissolves the group and puts the rest of the mobjects directly\n            in self.mobjects or self.foreground_mobjects.\n\n        In cases where the scene contains a group, e.g. Group(m1, m2, m3), but one\n        of its submobjects is removed, e.g. scene.remove(m1), the list of mobjects\n        will be edited to contain other submobjects, but not m1, e.g. it will now\n        insert m2 and m3 to where the group once was.\n\n        Parameters\n        ----------\n        to_remove\n            The Mobject to remove.\n\n        mobject_list_name\n            The list of mobjects (\"mobjects\", \"foreground_mobjects\" etc) to remove from.\n\n        extract_families\n            Whether the mobject's families should be recursively extracted.\n\n        Returns\n        -------\n        Scene\n            The Scene mobject with restructured Mobjects.\n        \"\"\"\n        if extract_families:\n            to_remove = extract_mobject_family_members(\n                to_remove,\n                use_z_index=self.renderer.camera.use_z_index,\n            )\n        _list = getattr(self, mobject_list_name)\n        new_list = self.get_restructured_mobject_list(_list, to_remove)\n        setattr(self, mobject_list_name, new_list)\n        return self\n\n\n\n[docs]\n    def get_restructured_mobject_list(self, mobjects: list, to_remove: list):\n        \"\"\"\n        Given a list of mobjects and a list of mobjects to be removed, this\n        filters out the removable mobjects from the list of mobjects.\n\n        Parameters\n        ----------\n\n        mobjects\n            The Mobjects to check.\n\n        to_remove\n            The list of mobjects to remove.\n\n        Returns\n        -------\n        list\n            The list of mobjects with the mobjects to remove removed.\n        \"\"\"\n        new_mobjects = []\n\n        def add_safe_mobjects_from_list(list_to_examine, set_to_remove):\n            for mob in list_to_examine:\n                if mob in set_to_remove:\n                    continue\n                intersect = set_to_remove.intersection(mob.get_family())\n                if intersect:\n                    add_safe_mobjects_from_list(mob.submobjects, intersect)\n                else:\n                    new_mobjects.append(mob)\n\n        add_safe_mobjects_from_list(mobjects, set(to_remove))\n        return new_mobjects\n\n\n    # TODO, remove this, and calls to this\n\n[docs]\n    def add_foreground_mobjects(self, *mobjects: Mobject):\n        \"\"\"\n        Adds mobjects to the foreground, and internally to the list\n        foreground_mobjects, and mobjects.\n\n        Parameters\n        ----------\n        *mobjects\n            The Mobjects to add to the foreground.\n\n        Returns\n        ------\n        Scene\n            The Scene, with the foreground mobjects added.\n        \"\"\"\n        self.foreground_mobjects = list_update(self.foreground_mobjects, mobjects)\n        self.add(*mobjects)\n        return self\n\n\n\n[docs]\n    def add_foreground_mobject(self, mobject: Mobject):\n        \"\"\"\n        Adds a single mobject to the foreground, and internally to the list\n        foreground_mobjects, and mobjects.\n\n        Parameters\n        ----------\n        mobject\n            The Mobject to add to the foreground.\n\n        Returns\n        ------\n        Scene\n            The Scene, with the foreground mobject added.\n        \"\"\"\n        return self.add_foreground_mobjects(mobject)\n\n\n\n[docs]\n    def remove_foreground_mobjects(self, *to_remove: Mobject):\n        \"\"\"\n        Removes mobjects from the foreground, and internally from the list\n        foreground_mobjects.\n\n        Parameters\n        ----------\n        *to_remove\n            The mobject(s) to remove from the foreground.\n\n        Returns\n        ------\n        Scene\n            The Scene, with the foreground mobjects removed.\n        \"\"\"\n        self.restructure_mobjects(to_remove, \"foreground_mobjects\")\n        return self\n\n\n\n[docs]\n    def remove_foreground_mobject(self, mobject: Mobject):\n        \"\"\"\n        Removes a single mobject from the foreground, and internally from the list\n        foreground_mobjects.\n\n        Parameters\n        ----------\n        mobject\n            The mobject to remove from the foreground.\n\n        Returns\n        ------\n        Scene\n            The Scene, with the foreground mobject removed.\n        \"\"\"\n        return self.remove_foreground_mobjects(mobject)\n\n\n\n[docs]\n    def bring_to_front(self, *mobjects: Mobject):\n        \"\"\"\n        Adds the passed mobjects to the scene again,\n        pushing them to he front of the scene.\n\n        Parameters\n        ----------\n        *mobjects\n            The mobject(s) to bring to the front of the scene.\n\n        Returns\n        ------\n        Scene\n            The Scene, with the mobjects brought to the front\n            of the scene.\n        \"\"\"\n        self.add(*mobjects)\n        return self\n\n\n\n[docs]\n    def bring_to_back(self, *mobjects: Mobject):\n        \"\"\"\n        Removes the mobject from the scene and\n        adds them to the back of the scene.\n\n        Parameters\n        ----------\n        *mobjects\n            The mobject(s) to push to the back of the scene.\n\n        Returns\n        ------\n        Scene\n            The Scene, with the mobjects pushed to the back\n            of the scene.\n        \"\"\"\n        self.remove(*mobjects)\n        self.mobjects = list(mobjects) + self.mobjects\n        return self\n\n\n\n[docs]\n    def clear(self):\n        \"\"\"\n        Removes all mobjects present in self.mobjects\n        and self.foreground_mobjects from the scene.\n\n        Returns\n        ------\n        Scene\n            The Scene, with all of its mobjects in\n            self.mobjects and self.foreground_mobjects\n            removed.\n        \"\"\"\n        self.mobjects = []\n        self.foreground_mobjects = []\n        return self\n\n\n\n[docs]\n    def get_moving_mobjects(self, *animations: Animation):\n        \"\"\"\n        Gets all moving mobjects in the passed animation(s).\n\n        Parameters\n        ----------\n        *animations\n            The animations to check for moving mobjects.\n\n        Returns\n        ------\n        list\n            The list of mobjects that could be moving in\n            the Animation(s)\n        \"\"\"\n        # Go through mobjects from start to end, and\n        # as soon as there's one that needs updating of\n        # some kind per frame, return the list from that\n        # point forward.\n        animation_mobjects = [anim.mobject for anim in animations]\n        mobjects = self.get_mobject_family_members()\n        for i, mob in enumerate(mobjects):\n            update_possibilities = [\n                mob in animation_mobjects,\n                len(mob.get_family_updaters()) > 0,\n                mob in self.foreground_mobjects,\n            ]\n            if any(update_possibilities):\n                return mobjects[i:]\n        return []\n\n\n    def get_moving_and_static_mobjects(self, animations):\n        all_mobjects = list_update(self.mobjects, self.foreground_mobjects)\n        all_mobject_families = extract_mobject_family_members(\n            all_mobjects,\n            use_z_index=self.renderer.camera.use_z_index,\n            only_those_with_points=True,\n        )\n        moving_mobjects = self.get_moving_mobjects(*animations)\n        all_moving_mobject_families = extract_mobject_family_members(\n            moving_mobjects,\n            use_z_index=self.renderer.camera.use_z_index,\n        )\n        static_mobjects = list_difference_update(\n            all_mobject_families,\n            all_moving_mobject_families,\n        )\n        return all_moving_mobject_families, static_mobjects\n\n\n[docs]\n    def compile_animations(\n        self,\n        *args: Animation | Mobject | _AnimationBuilder,\n        **kwargs,\n    ):\n        \"\"\"\n        Creates _MethodAnimations from any _AnimationBuilders and updates animation\n        kwargs with kwargs passed to play().\n\n        Parameters\n        ----------\n        *args\n            Animations to be played.\n        **kwargs\n            Configuration for the call to play().\n\n        Returns\n        -------\n        Tuple[:class:`Animation`]\n            Animations to be played.\n        \"\"\"\n        animations = []\n        arg_anims = flatten_iterable_parameters(args)\n        # Allow passing a generator to self.play instead of comma separated arguments\n        for arg in arg_anims:\n            try:\n                animations.append(prepare_animation(arg))\n            except TypeError as e:\n                if inspect.ismethod(arg):\n                    raise TypeError(\n                        \"Passing Mobject methods to Scene.play is no longer\"\n                        \" supported. Use Mobject.animate instead.\",\n                    ) from e\n                else:\n                    raise TypeError(\n                        f\"Unexpected argument {arg} passed to Scene.play().\",\n                    ) from e\n\n        for animation in animations:\n            for k, v in kwargs.items():\n                setattr(animation, k, v)\n\n        return animations\n\n\n\n[docs]\n    def _get_animation_time_progression(\n        self, animations: list[Animation], duration: float\n    ):\n        \"\"\"\n        You will hardly use this when making your own animations.\n        This method is for Manim's internal use.\n\n        Uses :func:`~.get_time_progression` to obtain a\n        CommandLine ProgressBar whose ``fill_time`` is\n        dependent on the qualities of the passed Animation,\n\n        Parameters\n        ----------\n        animations\n            The list of animations to get\n            the time progression for.\n\n        duration\n            duration of wait time\n\n        Returns\n        -------\n        time_progression\n            The CommandLine Progress Bar.\n        \"\"\"\n        if len(animations) == 1 and isinstance(animations[0], Wait):\n            stop_condition = animations[0].stop_condition\n            if stop_condition is not None:\n                time_progression = self.get_time_progression(\n                    duration,\n                    f\"Waiting for {stop_condition.__name__}\",\n                    n_iterations=-1,  # So it doesn't show % progress\n                    override_skip_animations=True,\n                )\n            else:\n                time_progression = self.get_time_progression(\n                    duration,\n                    f\"Waiting {self.renderer.num_plays}\",\n                )\n        else:\n            time_progression = self.get_time_progression(\n                duration,\n                \"\".join(\n                    [\n                        f\"Animation {self.renderer.num_plays}: \",\n                        str(animations[0]),\n                        (\", etc.\" if len(animations) > 1 else \"\"),\n                    ],\n                ),\n            )\n        return time_progression\n\n\n\n[docs]\n    def get_time_progression(\n        self,\n        run_time: float,\n        description,\n        n_iterations: int | None = None,\n        override_skip_animations: bool = False,\n    ):\n        \"\"\"\n        You will hardly use this when making your own animations.\n        This method is for Manim's internal use.\n\n        Returns a CommandLine ProgressBar whose ``fill_time``\n        is dependent on the ``run_time`` of an animation,\n        the iterations to perform in that animation\n        and a bool saying whether or not to consider\n        the skipped animations.\n\n        Parameters\n        ----------\n        run_time\n            The ``run_time`` of the animation.\n\n        n_iterations\n            The number of iterations in the animation.\n\n        override_skip_animations\n            Whether or not to show skipped animations in the progress bar.\n\n        Returns\n        -------\n        time_progression\n            The CommandLine Progress Bar.\n        \"\"\"\n        if self.renderer.skip_animations and not override_skip_animations:\n            times = [run_time]\n        else:\n            step = 1 / config[\"frame_rate\"]\n            times = np.arange(0, run_time, step)\n        time_progression = tqdm(\n            times,\n            desc=description,\n            total=n_iterations,\n            leave=config[\"progress_bar\"] == \"leave\",\n            ascii=True if platform.system() == \"Windows\" else None,\n            disable=config[\"progress_bar\"] == \"none\",\n        )\n        return time_progression\n\n\n    @classmethod\n    def validate_run_time(\n        cls,\n        run_time: float,\n        method: Callable[[Any, ...], Any],\n        parameter_name: str = \"run_time\",\n    ) -> float:\n        method_name = f\"{cls.__name__}.{method.__name__}()\"\n        if run_time <= 0:\n            raise ValueError(\n                f\"{method_name} has a {parameter_name} of \"\n                f\"{run_time:g} <= 0 seconds which Manim cannot render. \"\n                f\"The {parameter_name} must be a positive number.\"\n            )\n\n        # config.frame_rate holds the number of frames per second\n        fps = config.frame_rate\n        seconds_per_frame = 1 / fps\n        if run_time < seconds_per_frame:\n            logger.warning(\n                f\"The original {parameter_name} of {method_name}, \"\n                f\"{run_time:g} seconds, is too short for the current frame \"\n                f\"rate of {fps:g} FPS. Rendering with the shortest possible \"\n                f\"{parameter_name} of {seconds_per_frame:g} seconds instead.\"\n            )\n            run_time = seconds_per_frame\n\n        return run_time\n\n\n[docs]\n    def get_run_time(self, animations: list[Animation]):\n        \"\"\"\n        Gets the total run time for a list of animations.\n\n        Parameters\n        ----------\n        animations\n            A list of the animations whose total\n            ``run_time`` is to be calculated.\n\n        Returns\n        -------\n        float\n            The total ``run_time`` of all of the animations in the list.\n        \"\"\"\n        run_time = max(animation.run_time for animation in animations)\n        run_time = self.validate_run_time(run_time, self.play, \"total run_time\")\n        return run_time\n\n\n\n[docs]\n    def play(\n        self,\n        *args: Animation | Mobject | _AnimationBuilder,\n        subcaption=None,\n        subcaption_duration=None,\n        subcaption_offset=0,\n        **kwargs,\n    ):\n        r\"\"\"Plays an animation in this scene.\n\n        Parameters\n        ----------\n\n        args\n            Animations to be played.\n        subcaption\n            The content of the external subcaption that should\n            be added during the animation.\n        subcaption_duration\n            The duration for which the specified subcaption is\n            added. If ``None`` (the default), the run time of the\n            animation is taken.\n        subcaption_offset\n            An offset (in seconds) for the start time of the\n            added subcaption.\n        kwargs\n            All other keywords are passed to the renderer.\n\n        \"\"\"\n        # If we are in interactive embedded mode, make sure this is running on the main thread (required for OpenGL)\n        if (\n            self.interactive_mode\n            and config.renderer == RendererType.OPENGL\n            and threading.current_thread().name != \"MainThread\"\n        ):\n            kwargs.update(\n                {\n                    \"subcaption\": subcaption,\n                    \"subcaption_duration\": subcaption_duration,\n                    \"subcaption_offset\": subcaption_offset,\n                }\n            )\n            self.queue.put(\n                (\n                    \"play\",\n                    args,\n                    kwargs,\n                )\n            )\n            return\n\n        start_time = self.time\n        self.renderer.play(self, *args, **kwargs)\n        run_time = self.time - start_time\n        if subcaption:\n            if subcaption_duration is None:\n                subcaption_duration = run_time\n            # The start of the subcaption needs to be offset by the\n            # run_time of the animation because it is added after\n            # the animation has already been played (and Scene.time\n            # has already been updated).\n            self.add_subcaption(\n                content=subcaption,\n                duration=subcaption_duration,\n                offset=-run_time + subcaption_offset,\n            )\n\n\n\n[docs]\n    def wait(\n        self,\n        duration: float = DEFAULT_WAIT_TIME,\n        stop_condition: Callable[[], bool] | None = None,\n        frozen_frame: bool | None = None,\n    ):\n        \"\"\"Plays a \"no operation\" animation.\n\n        Parameters\n        ----------\n        duration\n            The run time of the animation.\n        stop_condition\n            A function without positional arguments that is evaluated every time\n            a frame is rendered. The animation only stops when the return value\n            of the function is truthy, or when the time specified in ``duration``\n            passes.\n        frozen_frame\n            If True, updater functions are not evaluated, and the animation outputs\n            a frozen frame. If False, updater functions are called and frames\n            are rendered as usual. If None (the default), the scene tries to\n            determine whether or not the frame is frozen on its own.\n\n        See also\n        --------\n        :class:`.Wait`, :meth:`.should_mobjects_update`\n        \"\"\"\n        duration = self.validate_run_time(duration, self.wait, \"duration\")\n        self.play(\n            Wait(\n                run_time=duration,\n                stop_condition=stop_condition,\n                frozen_frame=frozen_frame,\n            )\n        )\n\n\n\n[docs]\n    def pause(self, duration: float = DEFAULT_WAIT_TIME):\n        \"\"\"Pauses the scene (i.e., displays a frozen frame).\n\n        This is an alias for :meth:`.wait` with ``frozen_frame``\n        set to ``True``.\n\n        Parameters\n        ----------\n        duration\n            The duration of the pause.\n\n        See also\n        --------\n        :meth:`.wait`, :class:`.Wait`\n        \"\"\"\n        duration = self.validate_run_time(duration, self.pause, \"duration\")\n        self.wait(duration=duration, frozen_frame=True)\n\n\n\n[docs]\n    def wait_until(self, stop_condition: Callable[[], bool], max_time: float = 60):\n        \"\"\"Wait until a condition is satisfied, up to a given maximum duration.\n\n        Parameters\n        ----------\n        stop_condition\n            A function with no arguments that determines whether or not the\n            scene should keep waiting.\n        max_time\n            The maximum wait time in seconds.\n        \"\"\"\n        max_time = self.validate_run_time(max_time, self.wait_until, \"max_time\")\n        self.wait(max_time, stop_condition=stop_condition)\n\n\n\n[docs]\n    def compile_animation_data(\n        self,\n        *animations: Animation | Mobject | _AnimationBuilder,\n        **play_kwargs,\n    ):\n        \"\"\"Given a list of animations, compile the corresponding\n        static and moving mobjects, and gather the animation durations.\n\n        This also begins the animations.\n\n        Parameters\n        ----------\n        animations\n            Animation or mobject with mobject method and params\n        play_kwargs\n            Named parameters affecting what was passed in ``animations``,\n            e.g. ``run_time``, ``lag_ratio`` and so on.\n\n        Returns\n        -------\n        self, None\n            None if there is nothing to play, or self otherwise.\n        \"\"\"\n        # NOTE TODO : returns statement of this method are wrong. It should return nothing, as it makes a little sense to get any information from this method.\n        # The return are kept to keep webgl renderer from breaking.\n        if len(animations) == 0:\n            raise ValueError(\"Called Scene.play with no animations\")\n\n        self.animations = self.compile_animations(*animations, **play_kwargs)\n        self.add_mobjects_from_animations(self.animations)\n\n        self.last_t = 0\n        self.stop_condition = None\n        self.moving_mobjects = []\n        self.static_mobjects = []\n\n        self.duration = self.get_run_time(self.animations)\n        if len(self.animations) == 1 and isinstance(self.animations[0], Wait):\n            if self.should_update_mobjects():\n                self.update_mobjects(dt=0)  # Any problems with this?\n                self.stop_condition = self.animations[0].stop_condition\n            else:\n                # Static image logic when the wait is static is done by the renderer, not here.\n                self.animations[0].is_static_wait = True\n                return None\n\n        return self\n\n\n\n[docs]\n    def begin_animations(self) -> None:\n        \"\"\"Start the animations of the scene.\"\"\"\n        for animation in self.animations:\n            animation._setup_scene(self)\n            animation.begin()\n\n        if config.renderer == RendererType.CAIRO:\n            # Paint all non-moving objects onto the screen, so they don't\n            # have to be rendered every frame\n            (\n                self.moving_mobjects,\n                self.static_mobjects,\n            ) = self.get_moving_and_static_mobjects(self.animations)\n\n\n\n[docs]\n    def is_current_animation_frozen_frame(self) -> bool:\n        \"\"\"Returns whether the current animation produces a static frame (generally a Wait).\"\"\"\n        return (\n            isinstance(self.animations[0], Wait)\n            and len(self.animations) == 1\n            and self.animations[0].is_static_wait\n        )\n\n\n\n[docs]\n    def play_internal(self, skip_rendering: bool = False):\n        \"\"\"\n        This method is used to prep the animations for rendering,\n        apply the arguments and parameters required to them,\n        render them, and write them to the video file.\n\n        Parameters\n        ----------\n        skip_rendering\n            Whether the rendering should be skipped, by default False\n        \"\"\"\n        self.duration = self.get_run_time(self.animations)\n        self.time_progression = self._get_animation_time_progression(\n            self.animations,\n            self.duration,\n        )\n        for t in self.time_progression:\n            self.update_to_time(t)\n            if not skip_rendering and not self.skip_animation_preview:\n                self.renderer.render(self, t, self.moving_mobjects)\n            if self.stop_condition is not None and self.stop_condition():\n                self.time_progression.close()\n                break\n\n        for animation in self.animations:\n            animation.finish()\n            animation.clean_up_from_scene(self)\n        if not self.renderer.skip_animations:\n            self.update_mobjects(0)\n        self.renderer.static_image = None\n        # Closing the progress bar at the end of the play.\n        self.time_progression.close()\n\n\n    def check_interactive_embed_is_valid(self):\n        if config[\"force_window\"]:\n            return True\n        if self.skip_animation_preview:\n            logger.warning(\n                \"Disabling interactive embed as 'skip_animation_preview' is enabled\",\n            )\n            return False\n        elif config[\"write_to_movie\"]:\n            logger.warning(\"Disabling interactive embed as 'write_to_movie' is enabled\")\n            return False\n        elif config[\"format\"]:\n            logger.warning(\n                \"Disabling interactive embed as '--format' is set as \"\n                + config[\"format\"],\n            )\n            return False\n        elif not self.renderer.window:\n            logger.warning(\"Disabling interactive embed as no window was created\")\n            return False\n        elif config.dry_run:\n            logger.warning(\"Disabling interactive embed as dry_run is enabled\")\n            return False\n        return True\n\n\n[docs]\n    def interactive_embed(self):\n        \"\"\"Like embed(), but allows for screen interaction.\"\"\"\n        if not self.check_interactive_embed_is_valid():\n            return\n        self.interactive_mode = True\n\n        def ipython(shell, namespace):\n            import manim.opengl\n\n            def load_module_into_namespace(module, namespace):\n                for name in dir(module):\n                    namespace[name] = getattr(module, name)\n\n            load_module_into_namespace(manim, namespace)\n            load_module_into_namespace(manim.opengl, namespace)\n\n            def embedded_rerun(*args, **kwargs):\n                self.queue.put((\"rerun_keyboard\", args, kwargs))\n                shell.exiter()\n\n            namespace[\"rerun\"] = embedded_rerun\n\n            shell(local_ns=namespace)\n            self.queue.put((\"exit_keyboard\", [], {}))\n\n        def get_embedded_method(method_name):\n            return lambda *args, **kwargs: self.queue.put((method_name, args, kwargs))\n\n        local_namespace = inspect.currentframe().f_back.f_locals\n        for method in (\"play\", \"wait\", \"add\", \"remove\"):\n            embedded_method = get_embedded_method(method)\n            # Allow for calling scene methods without prepending 'self.'.\n            local_namespace[method] = embedded_method\n\n        from sqlite3 import connect\n\n        from IPython.core.getipython import get_ipython\n        from IPython.terminal.embed import InteractiveShellEmbed\n        from traitlets.config import Config\n\n        cfg = Config()\n        cfg.TerminalInteractiveShell.confirm_exit = False\n        if get_ipython() is None:\n            shell = InteractiveShellEmbed.instance(config=cfg)\n        else:\n            shell = InteractiveShellEmbed(config=cfg)\n        hist = get_ipython().history_manager\n        hist.db = connect(hist.hist_file, check_same_thread=False)\n\n        keyboard_thread = threading.Thread(\n            target=ipython,\n            args=(shell, local_namespace),\n        )\n        # run as daemon to kill thread when main thread exits\n        if not shell.pt_app:\n            keyboard_thread.daemon = True\n        keyboard_thread.start()\n\n        if self.dearpygui_imported and config[\"enable_gui\"]:\n            if not dpg.is_dearpygui_running():\n                gui_thread = threading.Thread(\n                    target=configure_pygui,\n                    args=(self.renderer, self.widgets),\n                    kwargs={\"update\": False},\n                )\n                gui_thread.start()\n            else:\n                configure_pygui(self.renderer, self.widgets, update=True)\n\n        self.camera.model_matrix = self.camera.default_model_matrix\n\n        self.interact(shell, keyboard_thread)\n\n\n    def interact(self, shell, keyboard_thread):\n        event_handler = RerunSceneHandler(self.queue)\n        file_observer = Observer()\n        file_observer.schedule(event_handler, config[\"input_file\"], recursive=True)\n        file_observer.start()\n\n        self.quit_interaction = False\n        keyboard_thread_needs_join = shell.pt_app is not None\n        assert self.queue.qsize() == 0\n\n        last_time = time.time()\n        while not (self.renderer.window.is_closing or self.quit_interaction):\n            if not self.queue.empty():\n                tup = self.queue.get_nowait()\n                if tup[0].startswith(\"rerun\"):\n                    # Intentionally skip calling join() on the file thread to save time.\n                    if not tup[0].endswith(\"keyboard\"):\n                        if shell.pt_app:\n                            shell.pt_app.app.exit(exception=EOFError)\n                        file_observer.unschedule_all()\n                        raise RerunSceneException\n                    keyboard_thread.join()\n\n                    kwargs = tup[2]\n                    if \"from_animation_number\" in kwargs:\n                        config[\"from_animation_number\"] = kwargs[\n                            \"from_animation_number\"\n                        ]\n                    # # TODO: This option only makes sense if interactive_embed() is run at the\n                    # # end of a scene by default.\n                    # if \"upto_animation_number\" in kwargs:\n                    #     config[\"upto_animation_number\"] = kwargs[\n                    #         \"upto_animation_number\"\n                    #     ]\n\n                    keyboard_thread.join()\n                    file_observer.unschedule_all()\n                    raise RerunSceneException\n                elif tup[0].startswith(\"exit\"):\n                    # Intentionally skip calling join() on the file thread to save time.\n                    if not tup[0].endswith(\"keyboard\") and shell.pt_app:\n                        shell.pt_app.app.exit(exception=EOFError)\n                    keyboard_thread.join()\n                    # Remove exit_keyboard from the queue if necessary.\n                    while self.queue.qsize() > 0:\n                        self.queue.get()\n                    keyboard_thread_needs_join = False\n                    break\n                else:\n                    method, args, kwargs = tup\n                    getattr(self, method)(*args, **kwargs)\n            else:\n                self.renderer.animation_start_time = 0\n                dt = time.time() - last_time\n                last_time = time.time()\n                self.renderer.render(self, dt, self.moving_mobjects)\n                self.update_mobjects(dt)\n                self.update_meshes(dt)\n                self.update_self(dt)\n\n        # Join the keyboard thread if necessary.\n        if shell is not None and keyboard_thread_needs_join:\n            shell.pt_app.app.exit(exception=EOFError)\n            keyboard_thread.join()\n            # Remove exit_keyboard from the queue if necessary.\n            while self.queue.qsize() > 0:\n                self.queue.get()\n\n        file_observer.stop()\n        file_observer.join()\n\n        if self.dearpygui_imported and config[\"enable_gui\"]:\n            dpg.stop_dearpygui()\n\n        if self.renderer.window.is_closing:\n            self.renderer.window.destroy()\n\n    def embed(self):\n        if not config[\"preview\"]:\n            logger.warning(\"Called embed() while no preview window is available.\")\n            return\n        if config[\"write_to_movie\"]:\n            logger.warning(\"embed() is skipped while writing to a file.\")\n            return\n\n        self.renderer.animation_start_time = 0\n        self.renderer.render(self, -1, self.moving_mobjects)\n\n        # Configure IPython shell.\n        from IPython.terminal.embed import InteractiveShellEmbed\n\n        shell = InteractiveShellEmbed()\n\n        # Have the frame update after each command\n        shell.events.register(\n            \"post_run_cell\",\n            lambda *a, **kw: self.renderer.render(self, -1, self.moving_mobjects),\n        )\n\n        # Use the locals of the caller as the local namespace\n        # once embedded, and add a few custom shortcuts.\n        local_ns = inspect.currentframe().f_back.f_locals\n        # local_ns[\"touch\"] = self.interact\n        for method in (\n            \"play\",\n            \"wait\",\n            \"add\",\n            \"remove\",\n            \"interact\",\n            # \"clear\",\n            # \"save_state\",\n            # \"restore\",\n        ):\n            local_ns[method] = getattr(self, method)\n        shell(local_ns=local_ns, stack_depth=2)\n\n        # End scene when exiting an embed.\n        raise Exception(\"Exiting scene.\")\n\n    def update_to_time(self, t):\n        dt = t - self.last_t\n        self.last_t = t\n        for animation in self.animations:\n            animation.update_mobjects(dt)\n            alpha = t / animation.run_time\n            animation.interpolate(alpha)\n        self.update_mobjects(dt)\n        self.update_meshes(dt)\n        self.update_self(dt)\n\n\n[docs]\n    def add_subcaption(\n        self, content: str, duration: float = 1, offset: float = 0\n    ) -> None:\n        r\"\"\"Adds an entry in the corresponding subcaption file\n        at the current time stamp.\n\n        The current time stamp is obtained from ``Scene.time``.\n\n        Parameters\n        ----------\n\n        content\n            The subcaption content.\n        duration\n            The duration (in seconds) for which the subcaption is shown.\n        offset\n            This offset (in seconds) is added to the starting time stamp\n            of the subcaption.\n\n        Examples\n        --------\n\n        This example illustrates both possibilities for adding\n        subcaptions to Manimations::\n\n            class SubcaptionExample(Scene):\n                def construct(self):\n                    square = Square()\n                    circle = Circle()\n\n                    # first option: via the add_subcaption method\n                    self.add_subcaption(\"Hello square!\", duration=1)\n                    self.play(Create(square))\n\n                    # second option: within the call to Scene.play\n                    self.play(\n                        Transform(square, circle), subcaption=\"The square transforms.\"\n                    )\n\n        \"\"\"\n        subtitle = srt.Subtitle(\n            index=len(self.renderer.file_writer.subcaptions),\n            content=content,\n            start=datetime.timedelta(seconds=float(self.time + offset)),\n            end=datetime.timedelta(seconds=float(self.time + offset + duration)),\n        )\n        self.renderer.file_writer.subcaptions.append(subtitle)\n\n\n\n[docs]\n    def add_sound(\n        self,\n        sound_file: str,\n        time_offset: float = 0,\n        gain: float | None = None,\n        **kwargs,\n    ):\n        \"\"\"\n        This method is used to add a sound to the animation.\n\n        Parameters\n        ----------\n\n        sound_file\n            The path to the sound file.\n        time_offset\n            The offset in the sound file after which\n            the sound can be played.\n        gain\n            Amplification of the sound.\n\n        Examples\n        --------\n        .. manim:: SoundExample\n            :no_autoplay:\n\n            class SoundExample(Scene):\n                # Source of sound under Creative Commons 0 License. https://freesound.org/people/Druminfected/sounds/250551/\n                def construct(self):\n                    dot = Dot().set_color(GREEN)\n                    self.add_sound(\"click.wav\")\n                    self.add(dot)\n                    self.wait()\n                    self.add_sound(\"click.wav\")\n                    dot.set_color(BLUE)\n                    self.wait()\n                    self.add_sound(\"click.wav\")\n                    dot.set_color(RED)\n                    self.wait()\n\n        Download the resource for the previous example `here <https://github.com/ManimCommunity/manim/blob/main/docs/source/_static/click.wav>`_ .\n        \"\"\"\n        if self.renderer.skip_animations:\n            return\n        time = self.time + time_offset\n        self.renderer.file_writer.add_sound(sound_file, time, gain, **kwargs)\n\n\n    def on_mouse_motion(self, point, d_point):\n        self.mouse_point.move_to(point)\n        if SHIFT_VALUE in self.renderer.pressed_keys:\n            shift = -d_point\n            shift[0] *= self.camera.get_width() / 2\n            shift[1] *= self.camera.get_height() / 2\n            transform = self.camera.inverse_rotation_matrix\n            shift = np.dot(np.transpose(transform), shift)\n            self.camera.shift(shift)\n\n    def on_mouse_scroll(self, point, offset):\n        if not config.use_projection_stroke_shaders:\n            factor = 1 + np.arctan(-2.1 * offset[1])\n            self.camera.scale(factor, about_point=self.camera_target)\n        self.mouse_scroll_orbit_controls(point, offset)\n\n    def on_key_press(self, symbol, modifiers):\n        try:\n            char = chr(symbol)\n        except OverflowError:\n            logger.warning(\"The value of the pressed key is too large.\")\n            return\n\n        if char == \"r\":\n            self.camera.to_default_state()\n            self.camera_target = np.array([0, 0, 0], dtype=np.float32)\n        elif char == \"q\":\n            self.quit_interaction = True\n        else:\n            if char in self.key_to_function_map:\n                self.key_to_function_map[char]()\n\n    def on_key_release(self, symbol, modifiers):\n        pass\n\n    def on_mouse_drag(self, point, d_point, buttons, modifiers):\n        self.mouse_drag_point.move_to(point)\n        if buttons == 1:\n            self.camera.increment_theta(-d_point[0])\n            self.camera.increment_phi(d_point[1])\n        elif buttons == 4:\n            camera_x_axis = self.camera.model_matrix[:3, 0]\n            horizontal_shift_vector = -d_point[0] * camera_x_axis\n            vertical_shift_vector = -d_point[1] * np.cross(OUT, camera_x_axis)\n            total_shift_vector = horizontal_shift_vector + vertical_shift_vector\n            self.camera.shift(1.1 * total_shift_vector)\n\n        self.mouse_drag_orbit_controls(point, d_point, buttons, modifiers)\n\n    def mouse_scroll_orbit_controls(self, point, offset):\n        camera_to_target = self.camera_target - self.camera.get_position()\n        camera_to_target *= np.sign(offset[1])\n        shift_vector = 0.01 * camera_to_target\n        self.camera.model_matrix = (\n            opengl.translation_matrix(*shift_vector) @ self.camera.model_matrix\n        )\n\n    def mouse_drag_orbit_controls(self, point, d_point, buttons, modifiers):\n        # Left click drag.\n        if buttons == 1:\n            # Translate to target the origin and rotate around the z axis.\n            self.camera.model_matrix = (\n                opengl.rotation_matrix(z=-d_point[0])\n                @ opengl.translation_matrix(*-self.camera_target)\n                @ self.camera.model_matrix\n            )\n\n            # Rotation off of the z axis.\n            camera_position = self.camera.get_position()\n            camera_y_axis = self.camera.model_matrix[:3, 1]\n            axis_of_rotation = space_ops.normalize(\n                np.cross(camera_y_axis, camera_position),\n            )\n            rotation_matrix = space_ops.rotation_matrix(\n                d_point[1],\n                axis_of_rotation,\n                homogeneous=True,\n            )\n\n            maximum_polar_angle = self.camera.maximum_polar_angle\n            minimum_polar_angle = self.camera.minimum_polar_angle\n\n            potential_camera_model_matrix = rotation_matrix @ self.camera.model_matrix\n            potential_camera_location = potential_camera_model_matrix[:3, 3]\n            potential_camera_y_axis = potential_camera_model_matrix[:3, 1]\n            sign = (\n                np.sign(potential_camera_y_axis[2])\n                if potential_camera_y_axis[2] != 0\n                else 1\n            )\n            potential_polar_angle = sign * np.arccos(\n                potential_camera_location[2]\n                / np.linalg.norm(potential_camera_location),\n            )\n            if minimum_polar_angle <= potential_polar_angle <= maximum_polar_angle:\n                self.camera.model_matrix = potential_camera_model_matrix\n            else:\n                sign = np.sign(camera_y_axis[2]) if camera_y_axis[2] != 0 else 1\n                current_polar_angle = sign * np.arccos(\n                    camera_position[2] / np.linalg.norm(camera_position),\n                )\n                if potential_polar_angle > maximum_polar_angle:\n                    polar_angle_delta = maximum_polar_angle - current_polar_angle\n                else:\n                    polar_angle_delta = minimum_polar_angle - current_polar_angle\n                rotation_matrix = space_ops.rotation_matrix(\n                    polar_angle_delta,\n                    axis_of_rotation,\n                    homogeneous=True,\n                )\n                self.camera.model_matrix = rotation_matrix @ self.camera.model_matrix\n\n            # Translate to target the original target.\n            self.camera.model_matrix = (\n                opengl.translation_matrix(*self.camera_target)\n                @ self.camera.model_matrix\n            )\n        # Right click drag.\n        elif buttons == 4:\n            camera_x_axis = self.camera.model_matrix[:3, 0]\n            horizontal_shift_vector = -d_point[0] * camera_x_axis\n            vertical_shift_vector = -d_point[1] * np.cross(OUT, camera_x_axis)\n            total_shift_vector = horizontal_shift_vector + vertical_shift_vector\n\n            self.camera.model_matrix = (\n                opengl.translation_matrix(*total_shift_vector)\n                @ self.camera.model_matrix\n            )\n            self.camera_target += total_shift_vector\n\n    def set_key_function(self, char, func):\n        self.key_to_function_map[char] = func\n\n    def on_mouse_press(self, point, button, modifiers):\n        for func in self.mouse_press_callbacks:\n            func()", "code_sha1": "95584c019bf70923909ba0d123aee7a32b33a003"}
{"url": "https://docs.manim.community/en/stable/_modules/manim/scene/scene_file_writer.html", "depth": 2, "instruction": "The code defines a `SceneFileWriter` class that manages the writing of animations to video files using FFMPEG, handling audio segments, and organizing output directories for images and videos. It includes methods for initializing directories, combining partial movie files, and managing audio, ensuring efficient rendering and file management for animations created with Manim.", "code": "\"\"\"The interface between scenes and ffmpeg.\"\"\"\n\nfrom __future__ import annotations\n\n__all__ = [\"SceneFileWriter\"]\n\nimport json\nimport shutil\nfrom fractions import Fraction\nfrom pathlib import Path\nfrom queue import Queue\nfrom tempfile import NamedTemporaryFile\nfrom threading import Thread\nfrom typing import TYPE_CHECKING, Any\n\nimport av\nimport numpy as np\nimport srt\nfrom PIL import Image\nfrom pydub import AudioSegment\n\nfrom manim import __version__\nfrom manim.typing import PixelArray, StrPath\n\nfrom .. import config, logger\nfrom .._config.logger_utils import set_file_logger\nfrom ..constants import RendererType\nfrom ..utils.file_ops import (\n    add_extension_if_not_present,\n    add_version_before_extension,\n    guarantee_existence,\n    is_gif_format,\n    is_png_format,\n    modify_atime,\n    write_to_movie,\n)\nfrom ..utils.sounds import get_full_sound_file_path\nfrom .section import DefaultSectionType, Section\n\nif TYPE_CHECKING:\n    from manim.renderer.cairo_renderer import CairoRenderer\n    from manim.renderer.opengl_renderer import OpenGLRenderer\n\n\n\n[docs]\ndef to_av_frame_rate(fps):\n    epsilon1 = 1e-4\n    epsilon2 = 0.02\n\n    if isinstance(fps, int):\n        (num, denom) = (fps, 1)\n    elif abs(fps - round(fps)) < epsilon1:\n        (num, denom) = (round(fps), 1)\n    else:\n        denom = 1001\n        num = round(fps * denom / 1000) * 1000\n        if abs(fps - num / denom) >= epsilon2:\n            raise ValueError(\"invalid frame rate\")\n\n    return Fraction(num, denom)\n\n\n\n\n[docs]\ndef convert_audio(input_path: Path, output_path: Path, codec_name: str):\n    with (\n        av.open(input_path) as input_audio,\n        av.open(output_path, \"w\") as output_audio,\n    ):\n        input_audio_stream = input_audio.streams.audio[0]\n        output_audio_stream = output_audio.add_stream(codec_name)\n        for frame in input_audio.decode(input_audio_stream):\n            for packet in output_audio_stream.encode(frame):\n                output_audio.mux(packet)\n\n        for packet in output_audio_stream.encode():\n            output_audio.mux(packet)\n\n\n\n\n[docs]\nclass SceneFileWriter:\n    \"\"\"\n    SceneFileWriter is the object that actually writes the animations\n    played, into video files, using FFMPEG.\n    This is mostly for Manim's internal use. You will rarely, if ever,\n    have to use the methods for this class, unless tinkering with the very\n    fabric of Manim's reality.\n\n    Attributes\n    ----------\n        sections : list of :class:`.Section`\n            used to segment scene\n\n        sections_output_dir : :class:`pathlib.Path`\n            where are section videos stored\n\n        output_name : str\n            name of movie without extension and basis for section video names\n\n    Some useful attributes are:\n        \"write_to_movie\" (bool=False)\n            Whether or not to write the animations into a video file.\n        \"movie_file_extension\" (str=\".mp4\")\n            The file-type extension of the outputted video.\n        \"partial_movie_files\"\n            List of all the partial-movie files.\n\n    \"\"\"\n\n    force_output_as_scene_name = False\n\n    def __init__(\n        self,\n        renderer: CairoRenderer | OpenGLRenderer,\n        scene_name: StrPath,\n        **kwargs: Any,\n    ) -> None:\n        self.renderer = renderer\n        self.init_output_directories(scene_name)\n        self.init_audio()\n        self.frame_count = 0\n        self.partial_movie_files: list[str] = []\n        self.subcaptions: list[srt.Subtitle] = []\n        self.sections: list[Section] = []\n        # first section gets automatically created for convenience\n        # if you need the first section to be skipped, add a first section by hand, it will replace this one\n        self.next_section(\n            name=\"autocreated\", type_=DefaultSectionType.NORMAL, skip_animations=False\n        )\n\n\n[docs]\n    def init_output_directories(self, scene_name: StrPath) -> None:\n        \"\"\"Initialise output directories.\n\n        Notes\n        -----\n        The directories are read from ``config``, for example\n        ``config['media_dir']``.  If the target directories don't already\n        exist, they will be created.\n\n        \"\"\"\n        if config[\"dry_run\"]:  # in dry-run mode there is no output\n            return\n\n        module_name = config.get_dir(\"input_file\").stem if config[\"input_file\"] else \"\"\n\n        if SceneFileWriter.force_output_as_scene_name:\n            self.output_name = Path(scene_name)\n        elif config[\"output_file\"] and not config[\"write_all\"]:\n            self.output_name = config.get_dir(\"output_file\")\n        else:\n            self.output_name = Path(scene_name)\n\n        if config[\"media_dir\"]:\n            image_dir = guarantee_existence(\n                config.get_dir(\n                    \"images_dir\", module_name=module_name, scene_name=scene_name\n                ),\n            )\n            self.image_file_path = image_dir / add_extension_if_not_present(\n                self.output_name, \".png\"\n            )\n\n        if write_to_movie():\n            movie_dir = guarantee_existence(\n                config.get_dir(\n                    \"video_dir\", module_name=module_name, scene_name=scene_name\n                ),\n            )\n            self.movie_file_path = movie_dir / add_extension_if_not_present(\n                self.output_name, config[\"movie_file_extension\"]\n            )\n\n            # TODO: /dev/null would be good in case sections_output_dir is used without being set (doesn't work on Windows), everyone likes defensive programming, right?\n            self.sections_output_dir = Path(\"\")\n            if config.save_sections:\n                self.sections_output_dir = guarantee_existence(\n                    config.get_dir(\n                        \"sections_dir\", module_name=module_name, scene_name=scene_name\n                    )\n                )\n\n            if is_gif_format():\n                self.gif_file_path = add_extension_if_not_present(\n                    self.output_name, \".gif\"\n                )\n\n                if not config[\"output_file\"]:\n                    self.gif_file_path = add_version_before_extension(\n                        self.gif_file_path\n                    )\n\n                self.gif_file_path = movie_dir / self.gif_file_path\n\n            self.partial_movie_directory = guarantee_existence(\n                config.get_dir(\n                    \"partial_movie_dir\",\n                    scene_name=scene_name,\n                    module_name=module_name,\n                ),\n            )\n\n            if config[\"log_to_file\"]:\n                log_dir = guarantee_existence(config.get_dir(\"log_dir\"))\n                set_file_logger(\n                    scene_name=scene_name, module_name=module_name, log_dir=log_dir\n                )\n\n\n\n[docs]\n    def finish_last_section(self) -> None:\n        \"\"\"Delete current section if it is empty.\"\"\"\n        if len(self.sections) and self.sections[-1].is_empty():\n            self.sections.pop()\n\n\n\n[docs]\n    def next_section(self, name: str, type_: str, skip_animations: bool) -> None:\n        \"\"\"Create segmentation cut here.\"\"\"\n        self.finish_last_section()\n\n        # images don't support sections\n        section_video: str | None = None\n        # don't save when None\n        if (\n            not config.dry_run\n            and write_to_movie()\n            and config.save_sections\n            and not skip_animations\n        ):\n            # relative to index file\n            section_video = f\"{self.output_name}_{len(self.sections):04}_{name}{config.movie_file_extension}\"\n\n        self.sections.append(\n            Section(\n                type_,\n                section_video,\n                name,\n                skip_animations,\n            ),\n        )\n\n\n\n[docs]\n    def add_partial_movie_file(self, hash_animation: str):\n        \"\"\"Adds a new partial movie file path to `scene.partial_movie_files` and current section from a hash.\n        This method will compute the path from the hash. In addition to that it adds the new animation to the current section.\n\n        Parameters\n        ----------\n        hash_animation\n            Hash of the animation.\n        \"\"\"\n        if not hasattr(self, \"partial_movie_directory\") or not write_to_movie():\n            return\n\n        # None has to be added to partial_movie_files to keep the right index with scene.num_plays.\n        # i.e if an animation is skipped, scene.num_plays is still incremented and we add an element to partial_movie_file be even with num_plays.\n        if hash_animation is None:\n            self.partial_movie_files.append(None)\n            self.sections[-1].partial_movie_files.append(None)\n        else:\n            new_partial_movie_file = str(\n                self.partial_movie_directory\n                / f\"{hash_animation}{config['movie_file_extension']}\"\n            )\n            self.partial_movie_files.append(new_partial_movie_file)\n            self.sections[-1].partial_movie_files.append(new_partial_movie_file)\n\n\n\n[docs]\n    def get_resolution_directory(self):\n        \"\"\"Get the name of the resolution directory directly containing\n        the video file.\n\n        This method gets the name of the directory that immediately contains the\n        video file. This name is ``<height_in_pixels_of_video>p<frame_rate>``.\n        For example, if you are rendering an 854x480 px animation at 15fps,\n        the name of the directory that immediately contains the video,  file\n        will be ``480p15``.\n\n        The file structure should look something like::\n\n            MEDIA_DIR\n                |--Tex\n                |--texts\n                |--videos\n                |--<name_of_file_containing_scene>\n                    |--<height_in_pixels_of_video>p<frame_rate>\n                        |--<scene_name>.mp4\n\n        Returns\n        -------\n        :class:`str`\n            The name of the directory.\n        \"\"\"\n        pixel_height = config[\"pixel_height\"]\n        frame_rate = config[\"frame_rate\"]\n        return f\"{pixel_height}p{frame_rate}\"\n\n\n    # Sound\n\n[docs]\n    def init_audio(self):\n        \"\"\"Preps the writer for adding audio to the movie.\"\"\"\n        self.includes_sound = False\n\n\n\n[docs]\n    def create_audio_segment(self):\n        \"\"\"Creates an empty, silent, Audio Segment.\"\"\"\n        self.audio_segment = AudioSegment.silent()\n\n\n\n[docs]\n    def add_audio_segment(\n        self,\n        new_segment: AudioSegment,\n        time: float | None = None,\n        gain_to_background: float | None = None,\n    ):\n        \"\"\"\n        This method adds an audio segment from an\n        AudioSegment type object and suitable parameters.\n\n        Parameters\n        ----------\n        new_segment\n            The audio segment to add\n\n        time\n            the timestamp at which the\n            sound should be added.\n\n        gain_to_background\n            The gain of the segment from the background.\n        \"\"\"\n        if not self.includes_sound:\n            self.includes_sound = True\n            self.create_audio_segment()\n        segment = self.audio_segment\n        curr_end = segment.duration_seconds\n        if time is None:\n            time = curr_end\n        if time < 0:\n            raise ValueError(\"Adding sound at timestamp < 0\")\n\n        new_end = time + new_segment.duration_seconds\n        diff = new_end - curr_end\n        if diff > 0:\n            segment = segment.append(\n                AudioSegment.silent(int(np.ceil(diff * 1000))),\n                crossfade=0,\n            )\n        self.audio_segment = segment.overlay(\n            new_segment,\n            position=int(1000 * time),\n            gain_during_overlay=gain_to_background,\n        )\n\n\n\n[docs]\n    def add_sound(\n        self,\n        sound_file: str,\n        time: float | None = None,\n        gain: float | None = None,\n        **kwargs,\n    ):\n        \"\"\"\n        This method adds an audio segment from a sound file.\n\n        Parameters\n        ----------\n        sound_file\n            The path to the sound file.\n\n        time\n            The timestamp at which the audio should be added.\n\n        gain\n            The gain of the given audio segment.\n\n        **kwargs\n            This method uses add_audio_segment, so any keyword arguments\n            used there can be referenced here.\n\n        \"\"\"\n        file_path = get_full_sound_file_path(sound_file)\n        # we assume files with .wav / .raw suffix are actually\n        # .wav and .raw files, respectively.\n        if file_path.suffix not in (\".wav\", \".raw\"):\n            # we need to pass delete=False to work on Windows\n            # TODO: figure out a way to cache the wav file generated (benchmark needed)\n            with NamedTemporaryFile(suffix=\".wav\", delete=False) as wav_file_path:\n                convert_audio(file_path, wav_file_path, \"pcm_s16le\")\n                new_segment = AudioSegment.from_file(wav_file_path.name)\n                logger.info(f\"Automatically converted {file_path} to .wav\")\n            Path(wav_file_path.name).unlink()\n        else:\n            new_segment = AudioSegment.from_file(file_path)\n\n        if gain:\n            new_segment = new_segment.apply_gain(gain)\n        self.add_audio_segment(new_segment, time, **kwargs)\n\n\n    # Writers\n\n[docs]\n    def begin_animation(\n        self, allow_write: bool = False, file_path: StrPath | None = None\n    ) -> None:\n        \"\"\"\n        Used internally by manim to stream the animation to FFMPEG for\n        displaying or writing to a file.\n\n        Parameters\n        ----------\n        allow_write\n            Whether or not to write to a video file.\n        \"\"\"\n        if write_to_movie() and allow_write:\n            self.open_partial_movie_stream(file_path=file_path)\n\n\n\n[docs]\n    def end_animation(self, allow_write: bool = False) -> None:\n        \"\"\"\n        Internally used by Manim to stop streaming to\n        FFMPEG gracefully.\n\n        Parameters\n        ----------\n        allow_write\n            Whether or not to write to a video file.\n        \"\"\"\n        if write_to_movie() and allow_write:\n            self.close_partial_movie_stream()\n\n\n\n[docs]\n    def listen_and_write(self):\n        \"\"\"For internal use only: blocks until new frame is available on the queue.\"\"\"\n        while True:\n            num_frames, frame_data = self.queue.get()\n            if frame_data is None:\n                break\n\n            self.encode_and_write_frame(frame_data, num_frames)\n\n\n\n[docs]\n    def encode_and_write_frame(self, frame: PixelArray, num_frames: int) -> None:\n        \"\"\"\n        For internal use only: takes a given frame in ``np.ndarray`` format and\n        write it to the stream\n        \"\"\"\n        for _ in range(num_frames):\n            # Notes: precomputing reusing packets does not work!\n            # I.e., you cannot do `packets = encode(...)`\n            # and reuse it, as it seems that `mux(...)`\n            # consumes the packet.\n            # The same issue applies for `av_frame`,\n            # reusing it renders weird-looking frames.\n            av_frame = av.VideoFrame.from_ndarray(frame, format=\"rgba\")\n            for packet in self.video_stream.encode(av_frame):\n                self.video_container.mux(packet)\n\n\n\n[docs]\n    def write_frame(\n        self, frame_or_renderer: np.ndarray | OpenGLRenderer, num_frames: int = 1\n    ):\n        \"\"\"\n        Used internally by Manim to write a frame to\n        the FFMPEG input buffer.\n\n        Parameters\n        ----------\n        frame_or_renderer\n            Pixel array of the frame.\n        num_frames\n            The number of times to write frame.\n        \"\"\"\n        if write_to_movie():\n            frame: np.ndarray = (\n                frame_or_renderer.get_frame()\n                if config.renderer == RendererType.OPENGL\n                else frame_or_renderer\n            )\n\n            msg = (num_frames, frame)\n            self.queue.put(msg)\n\n        if is_png_format() and not config[\"dry_run\"]:\n            image: Image = (\n                frame_or_renderer.get_image()\n                if config.renderer == RendererType.OPENGL\n                else Image.fromarray(frame_or_renderer)\n            )\n            target_dir = self.image_file_path.parent / self.image_file_path.stem\n            extension = self.image_file_path.suffix\n            self.output_image(\n                image,\n                target_dir,\n                extension,\n                config[\"zero_pad\"],\n            )\n\n\n    def output_image(self, image: Image.Image, target_dir, ext, zero_pad: bool):\n        if zero_pad:\n            image.save(f\"{target_dir}{str(self.frame_count).zfill(zero_pad)}{ext}\")\n        else:\n            image.save(f\"{target_dir}{self.frame_count}{ext}\")\n        self.frame_count += 1\n\n\n[docs]\n    def save_final_image(self, image: np.ndarray):\n        \"\"\"\n        The name is a misnomer. This method saves the image\n        passed to it as an in the default image directory.\n\n        Parameters\n        ----------\n        image\n            The pixel array of the image to save.\n        \"\"\"\n        if config[\"dry_run\"]:\n            return\n        if not config[\"output_file\"]:\n            self.image_file_path = add_version_before_extension(self.image_file_path)\n\n        image.save(self.image_file_path)\n        self.print_file_ready_message(self.image_file_path)\n\n\n\n[docs]\n    def finish(self) -> None:\n        \"\"\"\n        Finishes writing to the FFMPEG buffer or writing images\n        to output directory.\n        Combines the partial movie files into the\n        whole scene.\n        If save_last_frame is True, saves the last\n        frame in the default image directory.\n        \"\"\"\n        if write_to_movie():\n            self.combine_to_movie()\n            if config.save_sections:\n                self.combine_to_section_videos()\n            if config[\"flush_cache\"]:\n                self.flush_cache_directory()\n            else:\n                self.clean_cache()\n        elif is_png_format() and not config[\"dry_run\"]:\n            target_dir = self.image_file_path.parent / self.image_file_path.stem\n            logger.info(\"\\n%i images ready at %s\\n\", self.frame_count, str(target_dir))\n        if self.subcaptions:\n            self.write_subcaption_file()\n\n\n\n[docs]\n    def open_partial_movie_stream(self, file_path=None) -> None:\n        \"\"\"Open a container holding a video stream.\n\n        This is used internally by Manim initialize the container holding\n        the video stream of a partial movie file.\n        \"\"\"\n        if file_path is None:\n            file_path = self.partial_movie_files[self.renderer.num_plays]\n        self.partial_movie_file_path = file_path\n\n        fps = to_av_frame_rate(config.frame_rate)\n\n        partial_movie_file_codec = \"libx264\"\n        partial_movie_file_pix_fmt = \"yuv420p\"\n        av_options = {\n            \"an\": \"1\",  # ffmpeg: -an, no audio\n            \"crf\": \"23\",  # ffmpeg: -crf, constant rate factor (improved bitrate)\n        }\n\n        if config.movie_file_extension == \".webm\":\n            partial_movie_file_codec = \"libvpx-vp9\"\n            av_options[\"-auto-alt-ref\"] = \"1\"\n            if config.transparent:\n                partial_movie_file_pix_fmt = \"yuva420p\"\n\n        elif config.transparent:\n            partial_movie_file_codec = \"qtrle\"\n            partial_movie_file_pix_fmt = \"argb\"\n\n        with av.open(file_path, mode=\"w\") as video_container:\n            stream = video_container.add_stream(\n                partial_movie_file_codec,\n                rate=fps,\n                options=av_options,\n            )\n            stream.pix_fmt = partial_movie_file_pix_fmt\n            stream.width = config.pixel_width\n            stream.height = config.pixel_height\n\n            self.video_container = video_container\n            self.video_stream = stream\n\n            self.queue: Queue[tuple[int, PixelArray | None]] = Queue()\n            self.writer_thread = Thread(target=self.listen_and_write, args=())\n            self.writer_thread.start()\n\n\n\n[docs]\n    def close_partial_movie_stream(self) -> None:\n        \"\"\"Close the currently opened video container.\n\n        Used internally by Manim to first flush the remaining packages\n        in the video stream holding a partial file, and then close\n        the corresponding container.\n        \"\"\"\n        self.queue.put((-1, None))\n        self.writer_thread.join()\n\n        for packet in self.video_stream.encode():\n            self.video_container.mux(packet)\n\n        self.video_container.close()\n\n        logger.info(\n            f\"Animation {self.renderer.num_plays} : Partial movie file written in %(path)s\",\n            {\"path\": f\"'{self.partial_movie_file_path}'\"},\n        )\n\n\n\n[docs]\n    def is_already_cached(self, hash_invocation: str):\n        \"\"\"Will check if a file named with `hash_invocation` exists.\n\n        Parameters\n        ----------\n        hash_invocation\n            The hash corresponding to an invocation to either `scene.play` or `scene.wait`.\n\n        Returns\n        -------\n        :class:`bool`\n            Whether the file exists.\n        \"\"\"\n        if not hasattr(self, \"partial_movie_directory\") or not write_to_movie():\n            return False\n        path = (\n            self.partial_movie_directory\n            / f\"{hash_invocation}{config['movie_file_extension']}\"\n        )\n        return path.exists()\n\n\n    def combine_files(\n        self,\n        input_files: list[str],\n        output_file: Path,\n        create_gif=False,\n        includes_sound=False,\n    ):\n        file_list = self.partial_movie_directory / \"partial_movie_file_list.txt\"\n        logger.debug(\n            f\"Partial movie files to combine ({len(input_files)} files): %(p)s\",\n            {\"p\": input_files[:5]},\n        )\n        with file_list.open(\"w\", encoding=\"utf-8\") as fp:\n            fp.write(\"# This file is used internally by FFMPEG.\\n\")\n            for pf_path in input_files:\n                pf_path = Path(pf_path).as_posix()\n                fp.write(f\"file 'file:{pf_path}'\\n\")\n\n        av_options = {\n            \"safe\": \"0\",  # needed to read files\n        }\n\n        if not includes_sound:\n            av_options[\"an\"] = \"1\"\n\n        partial_movies_input = av.open(\n            str(file_list), options=av_options, format=\"concat\"\n        )\n        partial_movies_stream = partial_movies_input.streams.video[0]\n        output_container = av.open(str(output_file), mode=\"w\")\n        output_container.metadata[\"comment\"] = (\n            f\"Rendered with Manim Community v{__version__}\"\n        )\n        output_stream = output_container.add_stream(\n            codec_name=\"gif\" if create_gif else None,\n            template=partial_movies_stream if not create_gif else None,\n        )\n        if config.transparent and config.movie_file_extension == \".webm\":\n            output_stream.pix_fmt = \"yuva420p\"\n        if create_gif:\n            \"\"\"\n            The following solution was largely inspired from this comment\n            https://github.com/imageio/imageio/issues/995#issuecomment-1580533018,\n            and the following code\n            https://github.com/imageio/imageio/blob/65d79140018bb7c64c0692ea72cb4093e8d632a0/imageio/plugins/pyav.py#L927-L996.\n            \"\"\"\n            output_stream.pix_fmt = \"rgb8\"\n            if config.transparent:\n                output_stream.pix_fmt = \"pal8\"\n            output_stream.width = config.pixel_width\n            output_stream.height = config.pixel_height\n            output_stream.rate = to_av_frame_rate(config.frame_rate)\n            graph = av.filter.Graph()\n            input_buffer = graph.add_buffer(template=partial_movies_stream)\n            split = graph.add(\"split\")\n            palettegen = graph.add(\"palettegen\", \"stats_mode=diff\")\n            paletteuse = graph.add(\n                \"paletteuse\", \"dither=bayer:bayer_scale=5:diff_mode=rectangle\"\n            )\n            output_sink = graph.add(\"buffersink\")\n\n            input_buffer.link_to(split)\n            split.link_to(palettegen, 0, 0)  # 1st input of split -> input of palettegen\n            split.link_to(paletteuse, 1, 0)  # 2nd output of split -> 1st input\n            palettegen.link_to(paletteuse, 0, 1)  # output of palettegen -> 2nd input\n            paletteuse.link_to(output_sink)\n\n            graph.configure()\n\n            for frame in partial_movies_input.decode(video=0):\n                graph.push(frame)\n\n            graph.push(None)  # EOF: https://github.com/PyAV-Org/PyAV/issues/886.\n\n            frames_written = 0\n            while True:\n                try:\n                    frame = graph.pull()\n                    if output_stream.codec_context.time_base is not None:\n                        frame.time_base = output_stream.codec_context.time_base\n                    frame.pts = frames_written\n                    frames_written += 1\n                    output_container.mux(output_stream.encode(frame))\n                except av.error.EOFError:\n                    break\n\n            for packet in output_stream.encode():\n                output_container.mux(packet)\n\n        else:\n            for packet in partial_movies_input.demux(partial_movies_stream):\n                # We need to skip the \"flushing\" packets that `demux` generates.\n                if packet.dts is None:\n                    continue\n\n                packet.dts = None  # This seems to be needed, as dts from consecutive\n                # files may not be monotically increasing, so we let libav compute it.\n\n                # We need to assign the packet to the new stream.\n                packet.stream = output_stream\n                output_container.mux(packet)\n\n        partial_movies_input.close()\n        output_container.close()\n\n\n[docs]\n    def combine_to_movie(self):\n        \"\"\"Used internally by Manim to combine the separate\n        partial movie files that make up a Scene into a single\n        video file for that Scene.\n        \"\"\"\n        partial_movie_files = [el for el in self.partial_movie_files if el is not None]\n        # NOTE: Here we should do a check and raise an exception if partial\n        # movie file is empty.  We can't, as a lot of stuff (in particular, in\n        # tests) use scene initialization, and this error would be raised as\n        # it's just an empty scene initialized.\n\n        # determine output path\n        movie_file_path = self.movie_file_path\n        if is_gif_format():\n            movie_file_path = self.gif_file_path\n\n        if len(partial_movie_files) == 0:  # Prevent calling concat on empty list\n            logger.info(\"No animations are contained in this scene.\")\n            return\n\n        logger.info(\"Combining to Movie file.\")\n        self.combine_files(\n            partial_movie_files,\n            movie_file_path,\n            is_gif_format(),\n            self.includes_sound,\n        )\n\n        # handle sound\n        if self.includes_sound and config.format != \"gif\":\n            sound_file_path = movie_file_path.with_suffix(\".wav\")\n            # Makes sure sound file length will match video file\n            self.add_audio_segment(AudioSegment.silent(0))\n            self.audio_segment.export(\n                sound_file_path,\n                format=\"wav\",\n                bitrate=\"312k\",\n            )\n            # Audio added to a VP9 encoded (webm) video file needs\n            # to be encoded as vorbis or opus. Directly exporting\n            # self.audio_segment with such a codec works in principle,\n            # but tries to call ffmpeg via its CLI -- which we want\n            # to avoid. This is why we need to do the conversion\n            # manually.\n            if config.movie_file_extension == \".webm\":\n                ogg_sound_file_path = sound_file_path.with_suffix(\".ogg\")\n                convert_audio(sound_file_path, ogg_sound_file_path, \"libvorbis\")\n                sound_file_path = ogg_sound_file_path\n            elif config.movie_file_extension == \".mp4\":\n                # Similarly, pyav may reject wav audio in an .mp4 file;\n                # convert to AAC.\n                aac_sound_file_path = sound_file_path.with_suffix(\".aac\")\n                convert_audio(sound_file_path, aac_sound_file_path, \"aac\")\n                sound_file_path = aac_sound_file_path\n\n            temp_file_path = movie_file_path.with_name(\n                f\"{movie_file_path.stem}_temp{movie_file_path.suffix}\"\n            )\n            av_options = {\n                \"shortest\": \"1\",\n                \"metadata\": f\"comment=Rendered with Manim Community v{__version__}\",\n            }\n\n            with (\n                av.open(movie_file_path) as video_input,\n                av.open(sound_file_path) as audio_input,\n            ):\n                video_stream = video_input.streams.video[0]\n                audio_stream = audio_input.streams.audio[0]\n                output_container = av.open(\n                    str(temp_file_path), mode=\"w\", options=av_options\n                )\n                output_video_stream = output_container.add_stream(template=video_stream)\n                output_audio_stream = output_container.add_stream(template=audio_stream)\n\n                for packet in video_input.demux(video_stream):\n                    # We need to skip the \"flushing\" packets that `demux` generates.\n                    if packet.dts is None:\n                        continue\n\n                    # We need to assign the packet to the new stream.\n                    packet.stream = output_video_stream\n                    output_container.mux(packet)\n\n                for packet in audio_input.demux(audio_stream):\n                    # We need to skip the \"flushing\" packets that `demux` generates.\n                    if packet.dts is None:\n                        continue\n\n                    # We need to assign the packet to the new stream.\n                    packet.stream = output_audio_stream\n                    output_container.mux(packet)\n\n                output_container.close()\n\n            shutil.move(str(temp_file_path), str(movie_file_path))\n            sound_file_path.unlink()\n\n        self.print_file_ready_message(str(movie_file_path))\n        if write_to_movie():\n            for file_path in partial_movie_files:\n                # We have to modify the accessed time so if we have to clean the cache we remove the one used the longest.\n                modify_atime(file_path)\n\n\n\n[docs]\n    def combine_to_section_videos(self) -> None:\n        \"\"\"Concatenate partial movie files for each section.\"\"\"\n        self.finish_last_section()\n        sections_index: list[dict[str, Any]] = []\n        for section in self.sections:\n            # only if section does want to be saved\n            if section.video is not None:\n                logger.info(f\"Combining partial files for section '{section.name}'\")\n                self.combine_files(\n                    section.get_clean_partial_movie_files(),\n                    self.sections_output_dir / section.video,\n                )\n                sections_index.append(section.get_dict(self.sections_output_dir))\n        with (self.sections_output_dir / f\"{self.output_name}.json\").open(\"w\") as file:\n            json.dump(sections_index, file, indent=4)\n\n\n\n[docs]\n    def clean_cache(self):\n        \"\"\"Will clean the cache by removing the oldest partial_movie_files.\"\"\"\n        cached_partial_movies = [\n            (self.partial_movie_directory / file_name)\n            for file_name in self.partial_movie_directory.iterdir()\n            if file_name != \"partial_movie_file_list.txt\"\n        ]\n        if len(cached_partial_movies) > config[\"max_files_cached\"]:\n            number_files_to_delete = (\n                len(cached_partial_movies) - config[\"max_files_cached\"]\n            )\n            oldest_files_to_delete = sorted(\n                cached_partial_movies,\n                key=lambda path: path.stat().st_atime,\n            )[:number_files_to_delete]\n            for file_to_delete in oldest_files_to_delete:\n                file_to_delete.unlink()\n            logger.info(\n                f\"The partial movie directory is full (> {config['max_files_cached']} files). Therefore, manim has removed the {number_files_to_delete} oldest file(s).\"\n                \" You can change this behaviour by changing max_files_cached in config.\",\n            )\n\n\n\n[docs]\n    def flush_cache_directory(self):\n        \"\"\"Delete all the cached partial movie files\"\"\"\n        cached_partial_movies = [\n            self.partial_movie_directory / file_name\n            for file_name in self.partial_movie_directory.iterdir()\n            if file_name != \"partial_movie_file_list.txt\"\n        ]\n        for f in cached_partial_movies:\n            f.unlink()\n        logger.info(\n            f\"Cache flushed. {len(cached_partial_movies)} file(s) deleted in %(par_dir)s.\",\n            {\"par_dir\": self.partial_movie_directory},\n        )\n\n\n\n[docs]\n    def write_subcaption_file(self):\n        \"\"\"Writes the subcaption file.\"\"\"\n        if config.output_file is None:\n            return\n        subcaption_file = Path(config.output_file).with_suffix(\".srt\")\n        subcaption_file.write_text(srt.compose(self.subcaptions), encoding=\"utf-8\")\n        logger.info(f\"Subcaption file has been written as {subcaption_file}\")\n\n\n\n[docs]\n    def print_file_ready_message(self, file_path):\n        \"\"\"Prints the \"File Ready\" message to STDOUT.\"\"\"\n        config[\"output_file\"] = file_path\n        logger.info(\"\\nFile ready at %(file_path)s\\n\", {\"file_path\": f\"'{file_path}'\"})", "code_sha1": "c8bfc37326a3a7f5d23111272762f02c2423c2fa"}
{"url": "https://docs.manim.community/en/stable/_modules/manim/scene/three_d_scene.html", "depth": 2, "instruction": "The code defines a `ThreeDScene` class for rendering 3D objects with customizable camera settings, including ambient rotation and movement animations. It features methods for setting camera orientation, adding fixed orientation mobjects, and managing 3D axes and spheres, allowing for dynamic visualizations in a three-dimensional space.", "code": "\"\"\"A scene suitable for rendering three-dimensional objects and animations.\"\"\"\n\nfrom __future__ import annotations\n\n__all__ = [\"ThreeDScene\", \"SpecialThreeDScene\"]\n\n\nimport warnings\nfrom collections.abc import Iterable, Sequence\n\nimport numpy as np\n\nfrom manim.mobject.geometry.line import Line\nfrom manim.mobject.graphing.coordinate_systems import ThreeDAxes\nfrom manim.mobject.opengl.opengl_mobject import OpenGLMobject\nfrom manim.mobject.three_d.three_dimensions import Sphere\nfrom manim.mobject.value_tracker import ValueTracker\n\nfrom .. import config\nfrom ..animation.animation import Animation\nfrom ..animation.transform import Transform\nfrom ..camera.three_d_camera import ThreeDCamera\nfrom ..constants import DEGREES, RendererType\nfrom ..mobject.mobject import Mobject\nfrom ..mobject.types.vectorized_mobject import VectorizedPoint, VGroup\nfrom ..renderer.opengl_renderer import OpenGLCamera\nfrom ..scene.scene import Scene\nfrom ..utils.config_ops import merge_dicts_recursively\n\n\n\n[docs]\nclass ThreeDScene(Scene):\n    \"\"\"\n    This is a Scene, with special configurations and properties that\n    make it suitable for Three Dimensional Scenes.\n    \"\"\"\n\n    def __init__(\n        self,\n        camera_class=ThreeDCamera,\n        ambient_camera_rotation=None,\n        default_angled_camera_orientation_kwargs=None,\n        **kwargs,\n    ):\n        self.ambient_camera_rotation = ambient_camera_rotation\n        if default_angled_camera_orientation_kwargs is None:\n            default_angled_camera_orientation_kwargs = {\n                \"phi\": 70 * DEGREES,\n                \"theta\": -135 * DEGREES,\n            }\n        self.default_angled_camera_orientation_kwargs = (\n            default_angled_camera_orientation_kwargs\n        )\n        super().__init__(camera_class=camera_class, **kwargs)\n\n\n[docs]\n    def set_camera_orientation(\n        self,\n        phi: float | None = None,\n        theta: float | None = None,\n        gamma: float | None = None,\n        zoom: float | None = None,\n        focal_distance: float | None = None,\n        frame_center: Mobject | Sequence[float] | None = None,\n        **kwargs,\n    ):\n        \"\"\"\n        This method sets the orientation of the camera in the scene.\n\n        Parameters\n        ----------\n        phi\n            The polar angle i.e the angle between Z_AXIS and Camera through ORIGIN in radians.\n\n        theta\n            The azimuthal angle i.e the angle that spins the camera around the Z_AXIS.\n\n        focal_distance\n            The focal_distance of the Camera.\n\n        gamma\n            The rotation of the camera about the vector from the ORIGIN to the Camera.\n\n        zoom\n            The zoom factor of the scene.\n\n        frame_center\n            The new center of the camera frame in cartesian coordinates.\n\n        \"\"\"\n        if phi is not None:\n            self.renderer.camera.set_phi(phi)\n        if theta is not None:\n            self.renderer.camera.set_theta(theta)\n        if focal_distance is not None:\n            self.renderer.camera.set_focal_distance(focal_distance)\n        if gamma is not None:\n            self.renderer.camera.set_gamma(gamma)\n        if zoom is not None:\n            self.renderer.camera.set_zoom(zoom)\n        if frame_center is not None:\n            self.renderer.camera._frame_center.move_to(frame_center)\n\n\n\n[docs]\n    def begin_ambient_camera_rotation(self, rate: float = 0.02, about: str = \"theta\"):\n        \"\"\"\n        This method begins an ambient rotation of the camera about the Z_AXIS,\n        in the anticlockwise direction\n\n        Parameters\n        ----------\n        rate\n            The rate at which the camera should rotate about the Z_AXIS.\n            Negative rate means clockwise rotation.\n        about\n            one of 3 options: [\"theta\", \"phi\", \"gamma\"]. defaults to theta.\n        \"\"\"\n        # TODO, use a ValueTracker for rate, so that it\n        # can begin and end smoothly\n        about: str = about.lower()\n        try:\n            if config.renderer == RendererType.CAIRO:\n                trackers = {\n                    \"theta\": self.camera.theta_tracker,\n                    \"phi\": self.camera.phi_tracker,\n                    \"gamma\": self.camera.gamma_tracker,\n                }\n                x: ValueTracker = trackers[about]\n                x.add_updater(lambda m, dt: x.increment_value(rate * dt))\n                self.add(x)\n            elif config.renderer == RendererType.OPENGL:\n                cam: OpenGLCamera = self.camera\n                methods = {\n                    \"theta\": cam.increment_theta,\n                    \"phi\": cam.increment_phi,\n                    \"gamma\": cam.increment_gamma,\n                }\n                cam.add_updater(lambda m, dt: methods[about](rate * dt))\n                self.add(self.camera)\n        except Exception as e:\n            raise ValueError(\"Invalid ambient rotation angle.\") from e\n\n\n\n[docs]\n    def stop_ambient_camera_rotation(self, about=\"theta\"):\n        \"\"\"This method stops all ambient camera rotation.\"\"\"\n        about: str = about.lower()\n        try:\n            if config.renderer == RendererType.CAIRO:\n                trackers = {\n                    \"theta\": self.camera.theta_tracker,\n                    \"phi\": self.camera.phi_tracker,\n                    \"gamma\": self.camera.gamma_tracker,\n                }\n                x: ValueTracker = trackers[about]\n                x.clear_updaters()\n                self.remove(x)\n            elif config.renderer == RendererType.OPENGL:\n                self.camera.clear_updaters()\n        except Exception as e:\n            raise ValueError(\"Invalid ambient rotation angle.\") from e\n\n\n\n[docs]\n    def begin_3dillusion_camera_rotation(\n        self,\n        rate: float = 1,\n        origin_phi: float | None = None,\n        origin_theta: float | None = None,\n    ):\n        \"\"\"\n        This method creates a 3D camera rotation illusion around\n        the current camera orientation.\n\n        Parameters\n        ----------\n        rate\n            The rate at which the camera rotation illusion should operate.\n        origin_phi\n            The polar angle the camera should move around. Defaults\n            to the current phi angle.\n        origin_theta\n            The azimutal angle the camera should move around. Defaults\n            to the current theta angle.\n        \"\"\"\n        if origin_theta is None:\n            origin_theta = self.renderer.camera.theta_tracker.get_value()\n        if origin_phi is None:\n            origin_phi = self.renderer.camera.phi_tracker.get_value()\n\n        val_tracker_theta = ValueTracker(0)\n\n        def update_theta(m, dt):\n            val_tracker_theta.increment_value(dt * rate)\n            val_for_left_right = 0.2 * np.sin(val_tracker_theta.get_value())\n            return m.set_value(origin_theta + val_for_left_right)\n\n        self.renderer.camera.theta_tracker.add_updater(update_theta)\n        self.add(self.renderer.camera.theta_tracker)\n\n        val_tracker_phi = ValueTracker(0)\n\n        def update_phi(m, dt):\n            val_tracker_phi.increment_value(dt * rate)\n            val_for_up_down = 0.1 * np.cos(val_tracker_phi.get_value()) - 0.1\n            return m.set_value(origin_phi + val_for_up_down)\n\n        self.renderer.camera.phi_tracker.add_updater(update_phi)\n        self.add(self.renderer.camera.phi_tracker)\n\n\n\n[docs]\n    def stop_3dillusion_camera_rotation(self):\n        \"\"\"This method stops all illusion camera rotations.\"\"\"\n        self.renderer.camera.theta_tracker.clear_updaters()\n        self.remove(self.renderer.camera.theta_tracker)\n        self.renderer.camera.phi_tracker.clear_updaters()\n        self.remove(self.renderer.camera.phi_tracker)\n\n\n\n[docs]\n    def move_camera(\n        self,\n        phi: float | None = None,\n        theta: float | None = None,\n        gamma: float | None = None,\n        zoom: float | None = None,\n        focal_distance: float | None = None,\n        frame_center: Mobject | Sequence[float] | None = None,\n        added_anims: Iterable[Animation] = [],\n        **kwargs,\n    ):\n        \"\"\"\n        This method animates the movement of the camera\n        to the given spherical coordinates.\n\n        Parameters\n        ----------\n        phi\n            The polar angle i.e the angle between Z_AXIS and Camera through ORIGIN in radians.\n\n        theta\n            The azimuthal angle i.e the angle that spins the camera around the Z_AXIS.\n\n        focal_distance\n            The radial focal_distance between ORIGIN and Camera.\n\n        gamma\n            The rotation of the camera about the vector from the ORIGIN to the Camera.\n\n        zoom\n            The zoom factor of the camera.\n\n        frame_center\n            The new center of the camera frame in cartesian coordinates.\n\n        added_anims\n            Any other animations to be played at the same time.\n\n        \"\"\"\n        anims = []\n\n        if config.renderer == RendererType.CAIRO:\n            self.camera: ThreeDCamera\n            value_tracker_pairs = [\n                (phi, self.camera.phi_tracker),\n                (theta, self.camera.theta_tracker),\n                (focal_distance, self.camera.focal_distance_tracker),\n                (gamma, self.camera.gamma_tracker),\n                (zoom, self.camera.zoom_tracker),\n            ]\n            for value, tracker in value_tracker_pairs:\n                if value is not None:\n                    anims.append(tracker.animate.set_value(value))\n            if frame_center is not None:\n                anims.append(self.camera._frame_center.animate.move_to(frame_center))\n        elif config.renderer == RendererType.OPENGL:\n            cam: OpenGLCamera = self.camera\n            cam2 = cam.copy()\n            methods = {\n                \"theta\": cam2.set_theta,\n                \"phi\": cam2.set_phi,\n                \"gamma\": cam2.set_gamma,\n                \"zoom\": cam2.scale,\n                \"frame_center\": cam2.move_to,\n            }\n            if frame_center is not None:\n                if isinstance(frame_center, OpenGLMobject):\n                    frame_center = frame_center.get_center()\n                frame_center = list(frame_center)\n\n            zoom_value = None\n            if zoom is not None:\n                zoom_value = config.frame_height / (zoom * cam.height)\n\n            for value, method in [\n                [theta, \"theta\"],\n                [phi, \"phi\"],\n                [gamma, \"gamma\"],\n                [zoom_value, \"zoom\"],\n                [frame_center, \"frame_center\"],\n            ]:\n                if value is not None:\n                    methods[method](value)\n\n            if focal_distance is not None:\n                warnings.warn(\n                    \"focal distance of OpenGLCamera can not be adjusted.\",\n                    stacklevel=2,\n                )\n\n            anims += [Transform(cam, cam2)]\n\n        self.play(*anims + added_anims, **kwargs)\n\n        # These lines are added to improve performance. If manim thinks that frame_center is moving,\n        # it is required to redraw every object. These lines remove frame_center from the Scene once\n        # its animation is done, ensuring that manim does not think that it is moving. Since the\n        # frame_center is never actually drawn, this shouldn't break anything.\n        if frame_center is not None and config.renderer == RendererType.CAIRO:\n            self.remove(self.camera._frame_center)\n\n\n\n[docs]\n    def get_moving_mobjects(self, *animations: Animation):\n        \"\"\"\n        This method returns a list of all of the Mobjects in the Scene that\n        are moving, that are also in the animations passed.\n\n        Parameters\n        ----------\n        *animations\n            The animations whose mobjects will be checked.\n        \"\"\"\n        moving_mobjects = super().get_moving_mobjects(*animations)\n        camera_mobjects = self.renderer.camera.get_value_trackers() + [\n            self.renderer.camera._frame_center,\n        ]\n        if any(cm in moving_mobjects for cm in camera_mobjects):\n            return self.mobjects\n        return moving_mobjects\n\n\n\n[docs]\n    def add_fixed_orientation_mobjects(self, *mobjects: Mobject, **kwargs):\n        \"\"\"\n        This method is used to prevent the rotation and tilting\n        of mobjects as the camera moves around. The mobject can\n        still move in the x,y,z directions, but will always be\n        at the angle (relative to the camera) that it was at\n        when it was passed through this method.)\n\n        Parameters\n        ----------\n        *mobjects\n            The Mobject(s) whose orientation must be fixed.\n\n        **kwargs\n            Some valid kwargs are\n                use_static_center_func : bool\n                center_func : function\n        \"\"\"\n        if config.renderer == RendererType.CAIRO:\n            self.add(*mobjects)\n            self.renderer.camera.add_fixed_orientation_mobjects(*mobjects, **kwargs)\n        elif config.renderer == RendererType.OPENGL:\n            for mob in mobjects:\n                mob: OpenGLMobject\n                mob.fix_orientation()\n                self.add(mob)\n\n\n\n[docs]\n    def add_fixed_in_frame_mobjects(self, *mobjects: Mobject):\n        \"\"\"\n        This method is used to prevent the rotation and movement\n        of mobjects as the camera moves around. The mobject is\n        essentially overlaid, and is not impacted by the camera's\n        movement in any way.\n\n        Parameters\n        ----------\n        *mobjects\n            The Mobjects whose orientation must be fixed.\n        \"\"\"\n        if config.renderer == RendererType.CAIRO:\n            self.add(*mobjects)\n            self.camera: ThreeDCamera\n            self.camera.add_fixed_in_frame_mobjects(*mobjects)\n        elif config.renderer == RendererType.OPENGL:\n            for mob in mobjects:\n                mob: OpenGLMobject\n                mob.fix_in_frame()\n                self.add(mob)\n\n\n\n[docs]\n    def remove_fixed_orientation_mobjects(self, *mobjects: Mobject):\n        \"\"\"\n        This method \"unfixes\" the orientation of the mobjects\n        passed, meaning they will no longer be at the same angle\n        relative to the camera. This only makes sense if the\n        mobject was passed through add_fixed_orientation_mobjects first.\n\n        Parameters\n        ----------\n        *mobjects\n            The Mobjects whose orientation must be unfixed.\n        \"\"\"\n        if config.renderer == RendererType.CAIRO:\n            self.renderer.camera.remove_fixed_orientation_mobjects(*mobjects)\n        elif config.renderer == RendererType.OPENGL:\n            for mob in mobjects:\n                mob: OpenGLMobject\n                mob.unfix_orientation()\n                self.remove(mob)\n\n\n\n[docs]\n    def remove_fixed_in_frame_mobjects(self, *mobjects: Mobject):\n        \"\"\"\n         This method undoes what add_fixed_in_frame_mobjects does.\n         It allows the mobject to be affected by the movement of\n         the camera.\n\n        Parameters\n        ----------\n        *mobjects\n            The Mobjects whose position and orientation must be unfixed.\n        \"\"\"\n        if config.renderer == RendererType.CAIRO:\n            self.renderer.camera.remove_fixed_in_frame_mobjects(*mobjects)\n        elif config.renderer == RendererType.OPENGL:\n            for mob in mobjects:\n                mob: OpenGLMobject\n                mob.unfix_from_frame()\n                self.remove(mob)\n\n\n    ##\n\n[docs]\n    def set_to_default_angled_camera_orientation(self, **kwargs):\n        \"\"\"\n        This method sets the default_angled_camera_orientation to the\n        keyword arguments passed, and sets the camera to that orientation.\n\n        Parameters\n        ----------\n        **kwargs\n            Some recognised kwargs are phi, theta, focal_distance, gamma,\n            which have the same meaning as the parameters in set_camera_orientation.\n        \"\"\"\n        config = dict(\n            self.default_camera_orientation_kwargs,\n        )  # Where doe this come from?\n        config.update(kwargs)\n        self.set_camera_orientation(**config)\n\n\n\n\n\n[docs]\nclass SpecialThreeDScene(ThreeDScene):\n    \"\"\"An extension of :class:`ThreeDScene` with more settings.\n\n    It has some extra configuration for axes, spheres,\n    and an override for low quality rendering. Further key differences\n    are:\n\n    * The camera shades applicable 3DMobjects by default,\n      except if rendering in low quality.\n    * Some default params for Spheres and Axes have been added.\n\n    \"\"\"\n\n    def __init__(\n        self,\n        cut_axes_at_radius=True,\n        camera_config={\"should_apply_shading\": True, \"exponential_projection\": True},\n        three_d_axes_config={\n            \"num_axis_pieces\": 1,\n            \"axis_config\": {\n                \"unit_size\": 2,\n                \"tick_frequency\": 1,\n                \"numbers_with_elongated_ticks\": [0, 1, 2],\n                \"stroke_width\": 2,\n            },\n        },\n        sphere_config={\"radius\": 2, \"resolution\": (24, 48)},\n        default_angled_camera_position={\n            \"phi\": 70 * DEGREES,\n            \"theta\": -110 * DEGREES,\n        },\n        # When scene is extracted with -l flag, this\n        # configuration will override the above configuration.\n        low_quality_config={\n            \"camera_config\": {\"should_apply_shading\": False},\n            \"three_d_axes_config\": {\"num_axis_pieces\": 1},\n            \"sphere_config\": {\"resolution\": (12, 24)},\n        },\n        **kwargs,\n    ):\n        self.cut_axes_at_radius = cut_axes_at_radius\n        self.camera_config = camera_config\n        self.three_d_axes_config = three_d_axes_config\n        self.sphere_config = sphere_config\n        self.default_angled_camera_position = default_angled_camera_position\n        self.low_quality_config = low_quality_config\n        if self.renderer.camera_config[\"pixel_width\"] == config[\"pixel_width\"]:\n            _config = {}\n        else:\n            _config = self.low_quality_config\n        _config = merge_dicts_recursively(_config, kwargs)\n        super().__init__(**_config)\n\n\n[docs]\n    def get_axes(self):\n        \"\"\"Return a set of 3D axes.\n\n        Returns\n        -------\n        :class:`.ThreeDAxes`\n            A set of 3D axes.\n        \"\"\"\n        axes = ThreeDAxes(**self.three_d_axes_config)\n        for axis in axes:\n            if self.cut_axes_at_radius:\n                p0 = axis.get_start()\n                p1 = axis.number_to_point(-1)\n                p2 = axis.number_to_point(1)\n                p3 = axis.get_end()\n                new_pieces = VGroup(Line(p0, p1), Line(p1, p2), Line(p2, p3))\n                for piece in new_pieces:\n                    piece.shade_in_3d = True\n                new_pieces.match_style(axis.pieces)\n                axis.pieces.submobjects = new_pieces.submobjects\n            for tick in axis.tick_marks:\n                tick.add(VectorizedPoint(1.5 * tick.get_center()))\n        return axes\n\n\n\n[docs]\n    def get_sphere(self, **kwargs):\n        \"\"\"\n        Returns a sphere with the passed keyword arguments as properties.\n\n        Parameters\n        ----------\n        **kwargs\n            Any valid parameter of :class:`~.Sphere` or :class:`~.Surface`.\n\n        Returns\n        -------\n        :class:`~.Sphere`\n            The sphere object.\n        \"\"\"\n        config = merge_dicts_recursively(self.sphere_config, kwargs)\n        return Sphere(**config)\n\n\n\n[docs]\n    def get_default_camera_position(self):\n        \"\"\"\n        Returns the default_angled_camera position.\n\n        Returns\n        -------\n        dict\n            Dictionary of phi, theta, focal_distance, and gamma.\n        \"\"\"\n        return self.default_angled_camera_position\n\n\n\n[docs]\n    def set_camera_to_default_position(self):\n        \"\"\"Sets the camera to its default position.\"\"\"\n        self.set_camera_orientation(**self.default_angled_camera_position)", "code_sha1": "b8cc8e719b39600d04ac6747458ff9d0c4bfb790"}
{"url": "https://docs.manim.community/en/stable/_modules/manim/scene/vector_space_scene.html", "depth": 2, "instruction": "The scene displays a 2D coordinate system with a grid and axes, featuring two colored basis vectors (green and yellow) and their labels. It animates the addition of a vector represented by a yellow arrow, showing its components with dashed lines and a matrix label. The background fades while the foreground elements remain visible.", "code": "\"\"\"A scene suitable for vector spaces.\"\"\"\n\nfrom __future__ import annotations\n\n__all__ = [\"VectorScene\", \"LinearTransformationScene\"]\n\nfrom typing import Callable\n\nimport numpy as np\n\nfrom manim.mobject.geometry.arc import Dot\nfrom manim.mobject.geometry.line import Arrow, Line, Vector\nfrom manim.mobject.geometry.polygram import Rectangle\nfrom manim.mobject.graphing.coordinate_systems import Axes, NumberPlane\nfrom manim.mobject.opengl.opengl_mobject import OpenGLMobject\nfrom manim.mobject.text.tex_mobject import MathTex, Tex\nfrom manim.utils.config_ops import update_dict_recursively\n\nfrom .. import config\nfrom ..animation.animation import Animation\nfrom ..animation.creation import Create, Write\nfrom ..animation.fading import FadeOut\nfrom ..animation.growing import GrowArrow\nfrom ..animation.transform import ApplyFunction, ApplyPointwiseFunction, Transform\nfrom ..constants import *\nfrom ..mobject.matrix import Matrix\nfrom ..mobject.mobject import Mobject\nfrom ..mobject.types.vectorized_mobject import VGroup, VMobject\nfrom ..scene.scene import Scene\nfrom ..utils.color import (\n    BLACK,\n    BLUE_D,\n    GREEN_C,\n    GREY,\n    RED_C,\n    WHITE,\n    YELLOW,\n    ManimColor,\n    ParsableManimColor,\n)\nfrom ..utils.rate_functions import rush_from, rush_into\nfrom ..utils.space_ops import angle_of_vector\n\nX_COLOR = GREEN_C\nY_COLOR = RED_C\nZ_COLOR = BLUE_D\n\n\n# TODO: Much of this scene type seems dependent on the coordinate system chosen.\n# That is, being centered at the origin with grid units corresponding to the\n# arbitrary space units.  Change it!\n#\n# Also, methods I would have thought of as getters, like coords_to_vector, are\n# actually doing a lot of animating.\n\n[docs]\nclass VectorScene(Scene):\n    def __init__(self, basis_vector_stroke_width=6, **kwargs):\n        super().__init__(**kwargs)\n        self.basis_vector_stroke_width = basis_vector_stroke_width\n\n\n[docs]\n    def add_plane(self, animate: bool = False, **kwargs):\n        \"\"\"\n        Adds a NumberPlane object to the background.\n\n        Parameters\n        ----------\n        animate\n            Whether or not to animate the addition of the plane via Create.\n        **kwargs\n            Any valid keyword arguments accepted by NumberPlane.\n\n        Returns\n        -------\n        NumberPlane\n            The NumberPlane object.\n        \"\"\"\n        plane = NumberPlane(**kwargs)\n        if animate:\n            self.play(Create(plane, lag_ratio=0.5))\n        self.add(plane)\n        return plane\n\n\n\n[docs]\n    def add_axes(self, animate: bool = False, color: bool = WHITE, **kwargs):\n        \"\"\"\n        Adds a pair of Axes to the Scene.\n\n        Parameters\n        ----------\n        animate\n            Whether or not to animate the addition of the axes through Create.\n        color\n            The color of the axes. Defaults to WHITE.\n        \"\"\"\n        axes = Axes(color=color, axis_config={\"unit_size\": 1})\n        if animate:\n            self.play(Create(axes))\n        self.add(axes)\n        return axes\n\n\n\n[docs]\n    def lock_in_faded_grid(self, dimness: float = 0.7, axes_dimness: float = 0.5):\n        \"\"\"\n        This method freezes the NumberPlane and Axes that were already\n        in the background, and adds new, manipulatable ones to the foreground.\n\n        Parameters\n        ----------\n        dimness\n            The required dimness of the NumberPlane\n\n        axes_dimness\n            The required dimness of the Axes.\n        \"\"\"\n        plane = self.add_plane()\n        axes = plane.get_axes()\n        plane.fade(dimness)\n        axes.set_color(WHITE)\n        axes.fade(axes_dimness)\n        self.add(axes)\n\n        self.renderer.update_frame()\n        self.renderer.camera = Camera(self.renderer.get_frame())\n        self.clear()\n\n\n\n[docs]\n    def get_vector(self, numerical_vector: np.ndarray | list | tuple, **kwargs):\n        \"\"\"\n        Returns an arrow on the Plane given an input numerical vector.\n\n        Parameters\n        ----------\n        numerical_vector\n            The Vector to plot.\n        **kwargs\n            Any valid keyword argument of Arrow.\n\n        Returns\n        -------\n        Arrow\n            The Arrow representing the Vector.\n        \"\"\"\n        return Arrow(\n            self.plane.coords_to_point(0, 0),\n            self.plane.coords_to_point(*numerical_vector[:2]),\n            buff=0,\n            **kwargs,\n        )\n\n\n\n[docs]\n    def add_vector(\n        self,\n        vector: Arrow | list | tuple | np.ndarray,\n        color: str = YELLOW,\n        animate: bool = True,\n        **kwargs,\n    ):\n        \"\"\"\n        Returns the Vector after adding it to the Plane.\n\n        Parameters\n        ----------\n        vector\n            It can be a pre-made graphical vector, or the\n            coordinates of one.\n\n        color\n            The string of the hex color of the vector.\n            This is only taken into consideration if\n            'vector' is not an Arrow. Defaults to YELLOW.\n\n        animate\n            Whether or not to animate the addition of the vector\n            by using GrowArrow\n\n        **kwargs\n            Any valid keyword argument of Arrow.\n            These are only considered if vector is not\n            an Arrow.\n\n        Returns\n        -------\n        Arrow\n            The arrow representing the vector.\n        \"\"\"\n        if not isinstance(vector, Arrow):\n            vector = Vector(vector, color=color, **kwargs)\n        if animate:\n            self.play(GrowArrow(vector))\n        self.add(vector)\n        return vector\n\n\n\n[docs]\n    def write_vector_coordinates(self, vector: Arrow, **kwargs):\n        \"\"\"\n        Returns a column matrix indicating the vector coordinates,\n        after writing them to the screen.\n\n        Parameters\n        ----------\n        vector\n            The arrow representing the vector.\n\n        **kwargs\n            Any valid keyword arguments of :meth:`~.Vector.coordinate_label`:\n\n        Returns\n        -------\n        :class:`.Matrix`\n            The column matrix representing the vector.\n        \"\"\"\n        coords = vector.coordinate_label(**kwargs)\n        self.play(Write(coords))\n        return coords\n\n\n\n[docs]\n    def get_basis_vectors(self, i_hat_color: str = X_COLOR, j_hat_color: str = Y_COLOR):\n        \"\"\"\n        Returns a VGroup of the Basis Vectors (1,0) and (0,1)\n\n        Parameters\n        ----------\n        i_hat_color\n            The hex colour to use for the basis vector in the x direction\n\n        j_hat_color\n            The hex colour to use for the basis vector in the y direction\n\n        Returns\n        -------\n        VGroup\n            VGroup of the Vector Mobjects representing the basis vectors.\n        \"\"\"\n        return VGroup(\n            *(\n                Vector(vect, color=color, stroke_width=self.basis_vector_stroke_width)\n                for vect, color in [([1, 0], i_hat_color), ([0, 1], j_hat_color)]\n            )\n        )\n\n\n\n[docs]\n    def get_basis_vector_labels(self, **kwargs):\n        \"\"\"\n        Returns naming labels for the basis vectors.\n\n        Parameters\n        ----------\n        **kwargs\n            Any valid keyword arguments of get_vector_label:\n                vector,\n                label (str,MathTex)\n                at_tip (bool=False),\n                direction (str=\"left\"),\n                rotate (bool),\n                color (str),\n                label_scale_factor=VECTOR_LABEL_SCALE_FACTOR (int, float),\n        \"\"\"\n        i_hat, j_hat = self.get_basis_vectors()\n        return VGroup(\n            *(\n                self.get_vector_label(\n                    vect, label, color=color, label_scale_factor=1, **kwargs\n                )\n                for vect, label, color in [\n                    (i_hat, \"\\\\hat{\\\\imath}\", X_COLOR),\n                    (j_hat, \"\\\\hat{\\\\jmath}\", Y_COLOR),\n                ]\n            )\n        )\n\n\n\n[docs]\n    def get_vector_label(\n        self,\n        vector: Vector,\n        label,\n        at_tip: bool = False,\n        direction: str = \"left\",\n        rotate: bool = False,\n        color: str | None = None,\n        label_scale_factor: float = LARGE_BUFF - 0.2,\n    ):\n        \"\"\"\n        Returns naming labels for the passed vector.\n\n        Parameters\n        ----------\n        vector\n            Vector Object for which to get the label.\n\n        at_tip\n            Whether or not to place the label at the tip of the vector.\n\n        direction\n            If the label should be on the \"left\" or right of the vector.\n        rotate\n            Whether or not to rotate it to align it with the vector.\n        color\n            The color to give the label.\n        label_scale_factor\n            How much to scale the label by.\n\n        Returns\n        -------\n        MathTex\n            The MathTex of the label.\n        \"\"\"\n        if not isinstance(label, MathTex):\n            if len(label) == 1:\n                label = \"\\\\vec{\\\\textbf{%s}}\" % label  # noqa: UP031\n            label = MathTex(label)\n            if color is None:\n                color = vector.get_color()\n            label.set_color(color)\n        label.scale(label_scale_factor)\n        label.add_background_rectangle()\n\n        if at_tip:\n            vect = vector.get_vector()\n            vect /= np.linalg.norm(vect)\n            label.next_to(vector.get_end(), vect, buff=SMALL_BUFF)\n        else:\n            angle = vector.get_angle()\n            if not rotate:\n                label.rotate(-angle, about_point=ORIGIN)\n            if direction == \"left\":\n                label.shift(-label.get_bottom() + 0.1 * UP)\n            else:\n                label.shift(-label.get_top() + 0.1 * DOWN)\n            label.rotate(angle, about_point=ORIGIN)\n            label.shift((vector.get_end() - vector.get_start()) / 2)\n        return label\n\n\n\n[docs]\n    def label_vector(\n        self, vector: Vector, label: MathTex | str, animate: bool = True, **kwargs\n    ):\n        \"\"\"\n        Shortcut method for creating, and animating the addition of\n        a label for the vector.\n\n        Parameters\n        ----------\n        vector\n            The vector for which the label must be added.\n\n        label\n            The MathTex/string of the label.\n\n        animate\n            Whether or not to animate the labelling w/ Write\n\n        **kwargs\n            Any valid keyword argument of get_vector_label\n\n        Returns\n        -------\n        :class:`~.MathTex`\n            The MathTex of the label.\n        \"\"\"\n        label = self.get_vector_label(vector, label, **kwargs)\n        if animate:\n            self.play(Write(label, run_time=1))\n        self.add(label)\n        return label\n\n\n    def position_x_coordinate(\n        self,\n        x_coord,\n        x_line,\n        vector,\n    ):  # TODO Write DocStrings for this.\n        x_coord.next_to(x_line, -np.sign(vector[1]) * UP)\n        x_coord.set_color(X_COLOR)\n        return x_coord\n\n    def position_y_coordinate(\n        self,\n        y_coord,\n        y_line,\n        vector,\n    ):  # TODO Write DocStrings for this.\n        y_coord.next_to(y_line, np.sign(vector[0]) * RIGHT)\n        y_coord.set_color(Y_COLOR)\n        return y_coord\n\n\n[docs]\n    def coords_to_vector(\n        self,\n        vector: np.ndarray | list | tuple,\n        coords_start: np.ndarray | list | tuple = 2 * RIGHT + 2 * UP,\n        clean_up: bool = True,\n    ):\n        \"\"\"\n        This method writes the vector as a column matrix (henceforth called the label),\n        takes the values in it one by one, and form the corresponding\n        lines that make up the x and y components of the vector. Then, an\n        Vector() based vector is created between the lines on the Screen.\n\n        Parameters\n        ----------\n        vector\n            The vector to show.\n\n        coords_start\n            The starting point of the location of\n            the label of the vector that shows it\n            numerically.\n            Defaults to 2 * RIGHT + 2 * UP or (2,2)\n\n        clean_up\n            Whether or not to remove whatever\n            this method did after it's done.\n\n        \"\"\"\n        starting_mobjects = list(self.mobjects)\n        array = Matrix(vector)\n        array.shift(coords_start)\n        arrow = Vector(vector)\n        x_line = Line(ORIGIN, vector[0] * RIGHT)\n        y_line = Line(x_line.get_end(), arrow.get_end())\n        x_line.set_color(X_COLOR)\n        y_line.set_color(Y_COLOR)\n        x_coord, y_coord = array.get_mob_matrix().flatten()\n\n        self.play(Write(array, run_time=1))\n        self.wait()\n        self.play(\n            ApplyFunction(\n                lambda x: self.position_x_coordinate(x, x_line, vector),\n                x_coord,\n            ),\n        )\n        self.play(Create(x_line))\n        animations = [\n            ApplyFunction(\n                lambda y: self.position_y_coordinate(y, y_line, vector),\n                y_coord,\n            ),\n            FadeOut(array.get_brackets()),\n        ]\n        self.play(*animations)\n        y_coord, _ = (anim.mobject for anim in animations)\n        self.play(Create(y_line))\n        self.play(Create(arrow))\n        self.wait()\n        if clean_up:\n            self.clear()\n            self.add(*starting_mobjects)\n\n\n\n[docs]\n    def vector_to_coords(\n        self,\n        vector: np.ndarray | list | tuple,\n        integer_labels: bool = True,\n        clean_up: bool = True,\n    ):\n        \"\"\"\n        This method displays vector as a Vector() based vector, and then shows\n        the corresponding lines that make up the x and y components of the vector.\n        Then, a column matrix (henceforth called the label) is created near the\n        head of the Vector.\n\n        Parameters\n        ----------\n        vector\n            The vector to show.\n\n        integer_labels\n            Whether or not to round the value displayed.\n            in the vector's label to the nearest integer\n\n        clean_up\n            Whether or not to remove whatever\n            this method did after it's done.\n\n        \"\"\"\n        starting_mobjects = list(self.mobjects)\n        show_creation = False\n        if isinstance(vector, Arrow):\n            arrow = vector\n            vector = arrow.get_end()[:2]\n        else:\n            arrow = Vector(vector)\n            show_creation = True\n        array = arrow.coordinate_label(integer_labels=integer_labels)\n        x_line = Line(ORIGIN, vector[0] * RIGHT)\n        y_line = Line(x_line.get_end(), arrow.get_end())\n        x_line.set_color(X_COLOR)\n        y_line.set_color(Y_COLOR)\n        x_coord, y_coord = array.get_entries()\n        x_coord_start = self.position_x_coordinate(x_coord.copy(), x_line, vector)\n        y_coord_start = self.position_y_coordinate(y_coord.copy(), y_line, vector)\n        brackets = array.get_brackets()\n\n        if show_creation:\n            self.play(Create(arrow))\n        self.play(Create(x_line), Write(x_coord_start), run_time=1)\n        self.play(Create(y_line), Write(y_coord_start), run_time=1)\n        self.wait()\n        self.play(\n            Transform(x_coord_start, x_coord, lag_ratio=0),\n            Transform(y_coord_start, y_coord, lag_ratio=0),\n            Write(brackets, run_time=1),\n        )\n        self.wait()\n\n        self.remove(x_coord_start, y_coord_start, brackets)\n        self.add(array)\n        if clean_up:\n            self.clear()\n            self.add(*starting_mobjects)\n        return array, x_line, y_line\n\n\n\n[docs]\n    def show_ghost_movement(self, vector: Arrow | list | tuple | np.ndarray):\n        \"\"\"\n        This method plays an animation that partially shows the entire plane moving\n        in the direction of a particular vector. This is useful when you wish to\n        convey the idea of mentally moving the entire plane in a direction, without\n        actually moving the plane.\n\n        Parameters\n        ----------\n        vector\n            The vector which indicates the direction of movement.\n        \"\"\"\n        if isinstance(vector, Arrow):\n            vector = vector.get_end() - vector.get_start()\n        elif len(vector) == 2:\n            vector = np.append(np.array(vector), 0.0)\n        x_max = int(config[\"frame_x_radius\"] + abs(vector[0]))\n        y_max = int(config[\"frame_y_radius\"] + abs(vector[1]))\n        dots = VMobject(\n            *(\n                Dot(x * RIGHT + y * UP)\n                for x in range(-x_max, x_max)\n                for y in range(-y_max, y_max)\n            )\n        )\n        dots.set_fill(BLACK, opacity=0)\n        dots_halfway = dots.copy().shift(vector / 2).set_fill(WHITE, 1)\n        dots_end = dots.copy().shift(vector)\n\n        self.play(Transform(dots, dots_halfway, rate_func=rush_into))\n        self.play(Transform(dots, dots_end, rate_func=rush_from))\n        self.remove(dots)\n\n\n\n\n\n[docs]\nclass LinearTransformationScene(VectorScene):\n    \"\"\"\n    This scene contains special methods that make it\n    especially suitable for showing linear transformations.\n\n    Parameters\n    ----------\n    include_background_plane\n        Whether or not to include the background plane in the scene.\n    include_foreground_plane\n        Whether or not to include the foreground plane in the scene.\n    background_plane_kwargs\n        Parameters to be passed to :class:`NumberPlane` to adjust the background plane.\n    foreground_plane_kwargs\n        Parameters to be passed to :class:`NumberPlane` to adjust the foreground plane.\n    show_coordinates\n        Whether or not to include the coordinates for the background plane.\n    show_basis_vectors\n        Whether to show the basis x_axis -> ``i_hat`` and y_axis -> ``j_hat`` vectors.\n    basis_vector_stroke_width\n        The ``stroke_width`` of the basis vectors.\n    i_hat_color\n        The color of the ``i_hat`` vector.\n    j_hat_color\n        The color of the ``j_hat`` vector.\n    leave_ghost_vectors\n        Indicates the previous position of the basis vectors following a transformation.\n\n    Examples\n    -------\n\n    .. manim:: LinearTransformationSceneExample\n\n        class LinearTransformationSceneExample(LinearTransformationScene):\n            def __init__(self, **kwargs):\n                LinearTransformationScene.__init__(\n                    self,\n                    show_coordinates=True,\n                    leave_ghost_vectors=True,\n                    **kwargs\n                )\n\n            def construct(self):\n                matrix = [[1, 1], [0, 1]]\n                self.apply_matrix(matrix)\n                self.wait()\n    \"\"\"\n\n    def __init__(\n        self,\n        include_background_plane: bool = True,\n        include_foreground_plane: bool = True,\n        background_plane_kwargs: dict | None = None,\n        foreground_plane_kwargs: dict | None = None,\n        show_coordinates: bool = False,\n        show_basis_vectors: bool = True,\n        basis_vector_stroke_width: float = 6,\n        i_hat_color: ParsableManimColor = X_COLOR,\n        j_hat_color: ParsableManimColor = Y_COLOR,\n        leave_ghost_vectors: bool = False,\n        **kwargs,\n    ):\n        super().__init__(**kwargs)\n\n        self.include_background_plane = include_background_plane\n        self.include_foreground_plane = include_foreground_plane\n        self.show_coordinates = show_coordinates\n        self.show_basis_vectors = show_basis_vectors\n        self.basis_vector_stroke_width = basis_vector_stroke_width\n        self.i_hat_color = ManimColor(i_hat_color)\n        self.j_hat_color = ManimColor(j_hat_color)\n        self.leave_ghost_vectors = leave_ghost_vectors\n        self.background_plane_kwargs = {\n            \"color\": GREY,\n            \"axis_config\": {\n                \"color\": GREY,\n            },\n            \"background_line_style\": {\n                \"stroke_color\": GREY,\n                \"stroke_width\": 1,\n            },\n        }\n\n        self.ghost_vectors = VGroup()\n\n        self.foreground_plane_kwargs = {\n            \"x_range\": np.array([-config[\"frame_width\"], config[\"frame_width\"], 1.0]),\n            \"y_range\": np.array([-config[\"frame_width\"], config[\"frame_width\"], 1.0]),\n            \"faded_line_ratio\": 1,\n        }\n\n        self.update_default_configs(\n            (self.foreground_plane_kwargs, self.background_plane_kwargs),\n            (foreground_plane_kwargs, background_plane_kwargs),\n        )\n\n    @staticmethod\n    def update_default_configs(default_configs, passed_configs):\n        for default_config, passed_config in zip(default_configs, passed_configs):\n            if passed_config is not None:\n                update_dict_recursively(default_config, passed_config)\n\n\n[docs]\n    def setup(self):\n        # The has_already_setup attr is to not break all the old Scenes\n        if hasattr(self, \"has_already_setup\"):\n            return\n        self.has_already_setup = True\n        self.background_mobjects = []\n        self.foreground_mobjects = []\n        self.transformable_mobjects = []\n        self.moving_vectors = []\n        self.transformable_labels = []\n        self.moving_mobjects = []\n\n        self.background_plane = NumberPlane(**self.background_plane_kwargs)\n\n        if self.show_coordinates:\n            self.background_plane.add_coordinates()\n        if self.include_background_plane:\n            self.add_background_mobject(self.background_plane)\n        if self.include_foreground_plane:\n            self.plane = NumberPlane(**self.foreground_plane_kwargs)\n            self.add_transformable_mobject(self.plane)\n        if self.show_basis_vectors:\n            self.basis_vectors = self.get_basis_vectors(\n                i_hat_color=self.i_hat_color,\n                j_hat_color=self.j_hat_color,\n            )\n            self.moving_vectors += list(self.basis_vectors)\n            self.i_hat, self.j_hat = self.basis_vectors\n            self.add(self.basis_vectors)\n\n\n\n[docs]\n    def add_special_mobjects(self, mob_list: list, *mobs_to_add: Mobject):\n        \"\"\"\n        Adds mobjects to a separate list that can be tracked,\n        if these mobjects have some extra importance.\n\n        Parameters\n        ----------\n        mob_list\n            The special list to which you want to add\n            these mobjects.\n\n        *mobs_to_add\n            The mobjects to add.\n\n        \"\"\"\n        for mobject in mobs_to_add:\n            if mobject not in mob_list:\n                mob_list.append(mobject)\n                self.add(mobject)\n\n\n\n[docs]\n    def add_background_mobject(self, *mobjects: Mobject):\n        \"\"\"\n        Adds the mobjects to the special list\n        self.background_mobjects.\n\n        Parameters\n        ----------\n        *mobjects\n            The mobjects to add to the list.\n        \"\"\"\n        self.add_special_mobjects(self.background_mobjects, *mobjects)\n\n\n    # TODO, this conflicts with Scene.add_fore\n\n[docs]\n    def add_foreground_mobject(self, *mobjects: Mobject):\n        \"\"\"\n        Adds the mobjects to the special list\n        self.foreground_mobjects.\n\n        Parameters\n        ----------\n        *mobjects\n            The mobjects to add to the list\n        \"\"\"\n        self.add_special_mobjects(self.foreground_mobjects, *mobjects)\n\n\n\n[docs]\n    def add_transformable_mobject(self, *mobjects: Mobject):\n        \"\"\"\n        Adds the mobjects to the special list\n        self.transformable_mobjects.\n\n        Parameters\n        ----------\n        *mobjects\n            The mobjects to add to the list.\n        \"\"\"\n        self.add_special_mobjects(self.transformable_mobjects, *mobjects)\n\n\n\n[docs]\n    def add_moving_mobject(\n        self, mobject: Mobject, target_mobject: Mobject | None = None\n    ):\n        \"\"\"\n        Adds the mobject to the special list\n        self.moving_mobject, and adds a property\n        to the mobject called mobject.target, which\n        keeps track of what the mobject will move to\n        or become etc.\n\n        Parameters\n        ----------\n        mobject\n            The mobjects to add to the list\n\n        target_mobject\n            What the moving_mobject goes to, etc.\n        \"\"\"\n        mobject.target = target_mobject\n        self.add_special_mobjects(self.moving_mobjects, mobject)\n\n\n\n[docs]\n    def get_ghost_vectors(self) -> VGroup:\n        \"\"\"\n        Returns all ghost vectors ever added to ``self``. Each element is a ``VGroup`` of\n        two ghost vectors.\n        \"\"\"\n        return self.ghost_vectors\n\n\n\n[docs]\n    def get_unit_square(\n        self, color: str = YELLOW, opacity: float = 0.3, stroke_width: float = 3\n    ):\n        \"\"\"\n        Returns a unit square for the current NumberPlane.\n\n        Parameters\n        ----------\n        color\n            The string of the hex color code of the color wanted.\n\n        opacity\n            The opacity of the square\n\n        stroke_width\n            The stroke_width in pixels of the border of the square\n\n        Returns\n        -------\n        Square\n        \"\"\"\n        square = self.square = Rectangle(\n            color=color,\n            width=self.plane.get_x_unit_size(),\n            height=self.plane.get_y_unit_size(),\n            stroke_color=color,\n            stroke_width=stroke_width,\n            fill_color=color,\n            fill_opacity=opacity,\n        )\n        square.move_to(self.plane.coords_to_point(0, 0), DL)\n        return square\n\n\n\n[docs]\n    def add_unit_square(self, animate: bool = False, **kwargs):\n        \"\"\"\n        Adds a unit square to the scene via\n        self.get_unit_square.\n\n        Parameters\n        ----------\n        animate\n            Whether or not to animate the addition\n            with DrawBorderThenFill.\n        **kwargs\n            Any valid keyword arguments of\n            self.get_unit_square()\n\n        Returns\n        -------\n        Square\n            The unit square.\n        \"\"\"\n        square = self.get_unit_square(**kwargs)\n        if animate:\n            self.play(\n                DrawBorderThenFill(square),\n                Animation(Group(*self.moving_vectors)),\n            )\n        self.add_transformable_mobject(square)\n        self.bring_to_front(*self.moving_vectors)\n        self.square = square\n        return self\n\n\n\n[docs]\n    def add_vector(\n        self, vector: Arrow | list | tuple | np.ndarray, color: str = YELLOW, **kwargs\n    ):\n        \"\"\"\n        Adds a vector to the scene, and puts it in the special\n        list self.moving_vectors.\n\n        Parameters\n        ----------\n        vector\n            It can be a pre-made graphical vector, or the\n            coordinates of one.\n\n        color\n            The string of the hex color of the vector.\n            This is only taken into consideration if\n            'vector' is not an Arrow. Defaults to YELLOW.\n\n        **kwargs\n            Any valid keyword argument of VectorScene.add_vector.\n\n        Returns\n        -------\n        Arrow\n            The arrow representing the vector.\n        \"\"\"\n        vector = super().add_vector(vector, color=color, **kwargs)\n        self.moving_vectors.append(vector)\n        return vector\n\n\n\n[docs]\n    def write_vector_coordinates(self, vector: Arrow, **kwargs):\n        \"\"\"\n        Returns a column matrix indicating the vector coordinates,\n        after writing them to the screen, and adding them to the\n        special list self.foreground_mobjects\n\n        Parameters\n        ----------\n        vector\n            The arrow representing the vector.\n\n        **kwargs\n            Any valid keyword arguments of VectorScene.write_vector_coordinates\n\n        Returns\n        -------\n        Matrix\n            The column matrix representing the vector.\n        \"\"\"\n        coords = super().write_vector_coordinates(vector, **kwargs)\n        self.add_foreground_mobject(coords)\n        return coords\n\n\n\n[docs]\n    def add_transformable_label(\n        self,\n        vector: Vector,\n        label: MathTex | str,\n        transformation_name: str | MathTex = \"L\",\n        new_label: str | MathTex | None = None,\n        **kwargs,\n    ):\n        \"\"\"\n        Method for creating, and animating the addition of\n        a transformable label for the vector.\n\n        Parameters\n        ----------\n        vector\n            The vector for which the label must be added.\n\n        label\n            The MathTex/string of the label.\n\n        transformation_name\n            The name to give the transformation as a label.\n\n        new_label\n            What the label should display after a Linear Transformation\n\n        **kwargs\n            Any valid keyword argument of get_vector_label\n\n        Returns\n        -------\n        :class:`~.MathTex`\n            The MathTex of the label.\n        \"\"\"\n        label_mob = self.label_vector(vector, label, **kwargs)\n        if new_label:\n            label_mob.target_text = new_label\n        else:\n            label_mob.target_text = (\n                f\"{transformation_name}({label_mob.get_tex_string()})\"\n            )\n        label_mob.vector = vector\n        label_mob.kwargs = kwargs\n        if \"animate\" in label_mob.kwargs:\n            label_mob.kwargs.pop(\"animate\")\n        self.transformable_labels.append(label_mob)\n        return label_mob\n\n\n\n[docs]\n    def add_title(\n        self,\n        title: str | MathTex | Tex,\n        scale_factor: float = 1.5,\n        animate: bool = False,\n    ):\n        \"\"\"\n        Adds a title, after scaling it, adding a background rectangle,\n        moving it to the top and adding it to foreground_mobjects adding\n        it as a local variable of self. Returns the Scene.\n\n        Parameters\n        ----------\n        title\n            What the title should be.\n\n        scale_factor\n            How much the title should be scaled by.\n\n        animate\n            Whether or not to animate the addition.\n\n        Returns\n        -------\n        LinearTransformationScene\n            The scene with the title added to it.\n        \"\"\"\n        if not isinstance(title, (Mobject, OpenGLMobject)):\n            title = Tex(title).scale(scale_factor)\n        title.to_edge(UP)\n        title.add_background_rectangle()\n        if animate:\n            self.play(Write(title))\n        self.add_foreground_mobject(title)\n        self.title = title\n        return self\n\n\n\n[docs]\n    def get_matrix_transformation(self, matrix: np.ndarray | list | tuple):\n        \"\"\"\n        Returns a function corresponding to the linear\n        transformation represented by the matrix passed.\n\n        Parameters\n        ----------\n        matrix\n            The matrix.\n        \"\"\"\n        return self.get_transposed_matrix_transformation(np.array(matrix).T)\n\n\n\n[docs]\n    def get_transposed_matrix_transformation(\n        self, transposed_matrix: np.ndarray | list | tuple\n    ):\n        \"\"\"\n        Returns a function corresponding to the linear\n        transformation represented by the transposed\n        matrix passed.\n\n        Parameters\n        ----------\n        transposed_matrix\n            The matrix.\n        \"\"\"\n        transposed_matrix = np.array(transposed_matrix)\n        if transposed_matrix.shape == (2, 2):\n            new_matrix = np.identity(3)\n            new_matrix[:2, :2] = transposed_matrix\n            transposed_matrix = new_matrix\n        elif transposed_matrix.shape != (3, 3):\n            raise ValueError(\"Matrix has bad dimensions\")\n        return lambda point: np.dot(point, transposed_matrix)\n\n\n\n[docs]\n    def get_piece_movement(self, pieces: list | tuple | np.ndarray):\n        \"\"\"\n        This method returns an animation that moves an arbitrary\n        mobject in \"pieces\" to its corresponding .target value.\n        If self.leave_ghost_vectors is True, ghosts of the original\n        positions/mobjects are left on screen\n\n        Parameters\n        ----------\n        pieces\n            The pieces for which the movement must be shown.\n\n        Returns\n        -------\n        Animation\n            The animation of the movement.\n        \"\"\"\n        v_pieces = [piece for piece in pieces if isinstance(piece, VMobject)]\n        start = VGroup(*v_pieces)\n        target = VGroup(*(mob.target for mob in v_pieces))\n\n        # don't add empty VGroups\n        if self.leave_ghost_vectors and start.submobjects:\n            # start.copy() gives a VGroup of Vectors\n            self.ghost_vectors.add(start.copy().fade(0.7))\n            self.add(self.ghost_vectors[-1])\n        return Transform(start, target, lag_ratio=0)\n\n\n\n[docs]\n    def get_moving_mobject_movement(self, func: Callable[[np.ndarray], np.ndarray]):\n        \"\"\"\n        This method returns an animation that moves a mobject\n        in \"self.moving_mobjects\"  to its corresponding .target value.\n        func is a function that determines where the .target goes.\n\n        Parameters\n        ----------\n\n        func\n            The function that determines where the .target of\n            the moving mobject goes.\n\n        Returns\n        -------\n        Animation\n            The animation of the movement.\n        \"\"\"\n        for m in self.moving_mobjects:\n            if m.target is None:\n                m.target = m.copy()\n            target_point = func(m.get_center())\n            m.target.move_to(target_point)\n        return self.get_piece_movement(self.moving_mobjects)\n\n\n\n[docs]\n    def get_vector_movement(self, func: Callable[[np.ndarray], np.ndarray]):\n        \"\"\"\n        This method returns an animation that moves a mobject\n        in \"self.moving_vectors\"  to its corresponding .target value.\n        func is a function that determines where the .target goes.\n\n        Parameters\n        ----------\n\n        func\n            The function that determines where the .target of\n            the moving mobject goes.\n\n        Returns\n        -------\n        Animation\n            The animation of the movement.\n        \"\"\"\n        for v in self.moving_vectors:\n            v.target = Vector(func(v.get_end()), color=v.get_color())\n            norm = np.linalg.norm(v.target.get_end())\n            if norm < 0.1:\n                v.target.get_tip().scale(norm)\n        return self.get_piece_movement(self.moving_vectors)\n\n\n\n[docs]\n    def get_transformable_label_movement(self):\n        \"\"\"\n        This method returns an animation that moves all labels\n        in \"self.transformable_labels\" to its corresponding .target .\n\n        Returns\n        -------\n        Animation\n            The animation of the movement.\n        \"\"\"\n        for label in self.transformable_labels:\n            label.target = self.get_vector_label(\n                label.vector.target, label.target_text, **label.kwargs\n            )\n        return self.get_piece_movement(self.transformable_labels)\n\n\n\n[docs]\n    def apply_matrix(self, matrix: np.ndarray | list | tuple, **kwargs):\n        \"\"\"\n        Applies the transformation represented by the\n        given matrix to the number plane, and each vector/similar\n        mobject on it.\n\n        Parameters\n        ----------\n        matrix\n            The matrix.\n        **kwargs\n            Any valid keyword argument of self.apply_transposed_matrix()\n        \"\"\"\n        self.apply_transposed_matrix(np.array(matrix).T, **kwargs)\n\n\n\n[docs]\n    def apply_inverse(self, matrix: np.ndarray | list | tuple, **kwargs):\n        \"\"\"\n        This method applies the linear transformation\n        represented by the inverse of the passed matrix\n        to the number plane, and each vector/similar mobject on it.\n\n        Parameters\n        ----------\n        matrix\n            The matrix whose inverse is to be applied.\n        **kwargs\n            Any valid keyword argument of self.apply_matrix()\n        \"\"\"\n        self.apply_matrix(np.linalg.inv(matrix), **kwargs)\n\n\n\n[docs]\n    def apply_transposed_matrix(\n        self, transposed_matrix: np.ndarray | list | tuple, **kwargs\n    ):\n        \"\"\"\n        Applies the transformation represented by the\n        given transposed matrix to the number plane,\n        and each vector/similar mobject on it.\n\n        Parameters\n        ----------\n        transposed_matrix\n            The matrix.\n        **kwargs\n            Any valid keyword argument of self.apply_function()\n        \"\"\"\n        func = self.get_transposed_matrix_transformation(transposed_matrix)\n        if \"path_arc\" not in kwargs:\n            net_rotation = np.mean(\n                [angle_of_vector(func(RIGHT)), angle_of_vector(func(UP)) - np.pi / 2],\n            )\n            kwargs[\"path_arc\"] = net_rotation\n        self.apply_function(func, **kwargs)\n\n\n\n[docs]\n    def apply_inverse_transpose(self, t_matrix: np.ndarray | list | tuple, **kwargs):\n        \"\"\"\n        Applies the inverse of the transformation represented\n        by the given transposed matrix to the number plane and each\n        vector/similar mobject on it.\n\n        Parameters\n        ----------\n        t_matrix\n            The matrix.\n        **kwargs\n            Any valid keyword argument of self.apply_transposed_matrix()\n        \"\"\"\n        t_inv = np.linalg.inv(np.array(t_matrix).T).T\n        self.apply_transposed_matrix(t_inv, **kwargs)\n\n\n\n[docs]\n    def apply_nonlinear_transformation(\n        self, function: Callable[[np.ndarray], np.ndarray], **kwargs\n    ):\n        \"\"\"\n        Applies the non-linear transformation represented\n        by the given function to the number plane and each\n        vector/similar mobject on it.\n\n        Parameters\n        ----------\n        function\n            The function.\n        **kwargs\n            Any valid keyword argument of self.apply_function()\n        \"\"\"\n        self.plane.prepare_for_nonlinear_transform()\n        self.apply_function(function, **kwargs)\n\n\n\n[docs]\n    def apply_function(\n        self,\n        function: Callable[[np.ndarray], np.ndarray],\n        added_anims: list = [],\n        **kwargs,\n    ):\n        \"\"\"\n        Applies the given function to each of the mobjects in\n        self.transformable_mobjects, and plays the animation showing\n        this.\n\n        Parameters\n        ----------\n        function\n            The function that affects each point\n            of each mobject in self.transformable_mobjects.\n\n        added_anims\n            Any other animations that need to be played\n            simultaneously with this.\n\n        **kwargs\n            Any valid keyword argument of a self.play() call.\n        \"\"\"\n        if \"run_time\" not in kwargs:\n            kwargs[\"run_time\"] = 3\n        anims = (\n            [\n                ApplyPointwiseFunction(function, t_mob)\n                for t_mob in self.transformable_mobjects\n            ]\n            + [\n                self.get_vector_movement(function),\n                self.get_transformable_label_movement(),\n                self.get_moving_mobject_movement(function),\n            ]\n            + [Animation(f_mob) for f_mob in self.foreground_mobjects]\n            + added_anims\n        )\n        self.play(*anims, **kwargs)", "code_sha1": "57afdbe72bbf6846f31d4927c80ac19164471295"}
{"url": "https://docs.manim.community/en/stable/_modules/manim/scene/zoomed_scene.html", "depth": 2, "instruction": "A green dot and a small circle appear on the screen. After a brief pause, the scene zooms in on the dot, which then shifts left slightly. The zoomed camera frame scales up and shifts down, emphasizing the dot's movement within the zoomed view.", "code": "\"\"\"A scene supporting zooming in on a specified section.\n\n\nExamples\n--------\n\n.. manim:: UseZoomedScene\n\n    class UseZoomedScene(ZoomedScene):\n        def construct(self):\n            dot = Dot().set_color(GREEN)\n            self.add(dot)\n            self.wait(1)\n            self.activate_zooming(animate=False)\n            self.wait(1)\n            self.play(dot.animate.shift(LEFT))\n\n.. manim:: ChangingZoomScale\n\n    class ChangingZoomScale(ZoomedScene):\n        def __init__(self, **kwargs):\n            ZoomedScene.__init__(\n                self,\n                zoom_factor=0.3,\n                zoomed_display_height=1,\n                zoomed_display_width=3,\n                image_frame_stroke_width=20,\n                zoomed_camera_config={\n                    \"default_frame_stroke_width\": 3,\n                },\n                **kwargs\n            )\n\n        def construct(self):\n            dot = Dot().set_color(GREEN)\n            sq = Circle(fill_opacity=1, radius=0.2).next_to(dot, RIGHT)\n            self.add(dot, sq)\n            self.wait(1)\n            self.activate_zooming(animate=False)\n            self.wait(1)\n            self.play(dot.animate.shift(LEFT * 0.3))\n\n            self.play(self.zoomed_camera.frame.animate.scale(4))\n            self.play(self.zoomed_camera.frame.animate.shift(0.5 * DOWN))\n\n\"\"\"\n\nfrom __future__ import annotations\n\n__all__ = [\"ZoomedScene\"]\n\n\nfrom ..animation.transform import ApplyMethod\nfrom ..camera.moving_camera import MovingCamera\nfrom ..camera.multi_camera import MultiCamera\nfrom ..constants import *\nfrom ..mobject.types.image_mobject import ImageMobjectFromCamera\nfrom ..scene.moving_camera_scene import MovingCameraScene\n\n# Note, any scenes from old videos using ZoomedScene will almost certainly\n# break, as it was restructured.\n\n\n\n[docs]\nclass ZoomedScene(MovingCameraScene):\n    \"\"\"\n    This is a Scene with special configurations made for when\n    a particular part of the scene must be zoomed in on and displayed\n    separately.\n    \"\"\"\n\n    def __init__(\n        self,\n        camera_class=MultiCamera,\n        zoomed_display_height=3,\n        zoomed_display_width=3,\n        zoomed_display_center=None,\n        zoomed_display_corner=UP + RIGHT,\n        zoomed_display_corner_buff=DEFAULT_MOBJECT_TO_EDGE_BUFFER,\n        zoomed_camera_config={\n            \"default_frame_stroke_width\": 2,\n            \"background_opacity\": 1,\n        },\n        zoomed_camera_image_mobject_config={},\n        zoomed_camera_frame_starting_position=ORIGIN,\n        zoom_factor=0.15,\n        image_frame_stroke_width=3,\n        zoom_activated=False,\n        **kwargs,\n    ):\n        self.zoomed_display_height = zoomed_display_height\n        self.zoomed_display_width = zoomed_display_width\n        self.zoomed_display_center = zoomed_display_center\n        self.zoomed_display_corner = zoomed_display_corner\n        self.zoomed_display_corner_buff = zoomed_display_corner_buff\n        self.zoomed_camera_config = zoomed_camera_config\n        self.zoomed_camera_image_mobject_config = zoomed_camera_image_mobject_config\n        self.zoomed_camera_frame_starting_position = (\n            zoomed_camera_frame_starting_position\n        )\n        self.zoom_factor = zoom_factor\n        self.image_frame_stroke_width = image_frame_stroke_width\n        self.zoom_activated = zoom_activated\n        super().__init__(camera_class=camera_class, **kwargs)\n\n\n[docs]\n    def setup(self):\n        \"\"\"\n        This method is used internally by Manim to\n        setup the scene for proper use.\n        \"\"\"\n        super().setup()\n        # Initialize camera and display\n        zoomed_camera = MovingCamera(**self.zoomed_camera_config)\n        zoomed_display = ImageMobjectFromCamera(\n            zoomed_camera, **self.zoomed_camera_image_mobject_config\n        )\n        zoomed_display.add_display_frame()\n        for mob in zoomed_camera.frame, zoomed_display:\n            mob.stretch_to_fit_height(self.zoomed_display_height)\n            mob.stretch_to_fit_width(self.zoomed_display_width)\n        zoomed_camera.frame.scale(self.zoom_factor)\n\n        # Position camera and display\n        zoomed_camera.frame.move_to(self.zoomed_camera_frame_starting_position)\n        if self.zoomed_display_center is not None:\n            zoomed_display.move_to(self.zoomed_display_center)\n        else:\n            zoomed_display.to_corner(\n                self.zoomed_display_corner,\n                buff=self.zoomed_display_corner_buff,\n            )\n\n        self.zoomed_camera = zoomed_camera\n        self.zoomed_display = zoomed_display\n\n\n\n[docs]\n    def activate_zooming(self, animate: bool = False):\n        \"\"\"\n        This method is used to activate the zooming for\n        the zoomed_camera.\n\n        Parameters\n        ----------\n        animate\n            Whether or not to animate the activation\n            of the zoomed camera.\n        \"\"\"\n        self.zoom_activated = True\n        self.renderer.camera.add_image_mobject_from_camera(self.zoomed_display)\n        if animate:\n            self.play(self.get_zoom_in_animation())\n            self.play(self.get_zoomed_display_pop_out_animation())\n        self.add_foreground_mobjects(\n            self.zoomed_camera.frame,\n            self.zoomed_display,\n        )\n\n\n\n[docs]\n    def get_zoom_in_animation(self, run_time: float = 2, **kwargs):\n        \"\"\"\n        Returns the animation of camera zooming in.\n\n        Parameters\n        ----------\n        run_time\n            The run_time of the animation of the camera zooming in.\n        **kwargs\n            Any valid keyword arguments of ApplyMethod()\n\n        Returns\n        -------\n        ApplyMethod\n            The animation of the camera zooming in.\n        \"\"\"\n        frame = self.zoomed_camera.frame\n        full_frame_height = self.camera.frame_height\n        full_frame_width = self.camera.frame_width\n        frame.save_state()\n        frame.stretch_to_fit_width(full_frame_width)\n        frame.stretch_to_fit_height(full_frame_height)\n        frame.center()\n        frame.set_stroke(width=0)\n        return ApplyMethod(frame.restore, run_time=run_time, **kwargs)\n\n\n\n[docs]\n    def get_zoomed_display_pop_out_animation(self, **kwargs):\n        \"\"\"\n        This is the animation of the popping out of the\n        mini-display that shows the content of the zoomed\n        camera.\n\n        Returns\n        -------\n        ApplyMethod\n            The Animation of the Zoomed Display popping out.\n        \"\"\"\n        display = self.zoomed_display\n        display.save_state()\n        display.replace(self.zoomed_camera.frame, stretch=True)\n        return ApplyMethod(display.restore)\n\n\n\n[docs]\n    def get_zoom_factor(self):\n        \"\"\"\n        Returns the Zoom factor of the Zoomed camera.\n        Defined as the ratio between the height of the\n        zoomed camera and the height of the zoomed mini\n        display.\n        Returns\n        -------\n        float\n            The zoom factor.\n        \"\"\"\n        return self.zoomed_camera.frame.height / self.zoomed_display.height", "code_sha1": "8d6fd94c78964490840f61a363b361d06eb99cc9"}
{"url": "https://docs.manim.community/en/stable/_modules/manim/utils/bezier.html", "depth": 2, "instruction": "The code provides utility functions for manipulating Bézier curves, including creating, splitting, and interpolating them. It defines various mathematical operations and properties related to Bézier curves, such as determining if a point lies on a curve, calculating control points for smooth transitions, and handling both open and closed curves.", "code": "\"\"\"Utility functions related to Bézier curves.\"\"\"\n\nfrom __future__ import annotations\n\n__all__ = [\n    \"bezier\",\n    \"partial_bezier_points\",\n    \"split_bezier\",\n    \"subdivide_bezier\",\n    \"bezier_remap\",\n    \"interpolate\",\n    \"integer_interpolate\",\n    \"mid\",\n    \"inverse_interpolate\",\n    \"match_interpolate\",\n    \"get_smooth_cubic_bezier_handle_points\",\n    \"is_closed\",\n    \"proportions_along_bezier_curve_for_point\",\n    \"point_lies_on_bezier\",\n]\n\n\nfrom collections.abc import Sequence\nfrom functools import reduce\nfrom typing import TYPE_CHECKING, Callable, overload\n\nimport numpy as np\n\nfrom manim.utils.simple_functions import choose\n\nif TYPE_CHECKING:\n    from manim.typing import (\n        BezierPoints,\n        BezierPoints_Array,\n        BezierPointsLike,\n        BezierPointsLike_Array,\n        ColVector,\n        MatrixMN,\n        Point3D,\n        Point3D_Array,\n        Point3DLike,\n        Point3DLike_Array,\n        QuadraticBezierPath,\n        QuadraticSpline,\n        Spline,\n    )\n\n# l is a commonly used name in linear algebra\n# ruff: noqa: E741\n\n\n@overload\ndef bezier(\n    points: BezierPointsLike,\n) -> Callable[[float | ColVector], Point3D | Point3D_Array]: ...\n\n\n@overload\ndef bezier(\n    points: Sequence[Point3DLike_Array],\n) -> Callable[[float | ColVector], Point3D_Array]: ...\n\n\n\n[docs]\ndef bezier(\n    points: Point3D_Array | Sequence[Point3D_Array],\n) -> Callable[[float | ColVector], Point3D_Array]:\n    \"\"\"Classic implementation of a Bézier curve.\n\n    Parameters\n    ----------\n    points\n        :math:`(d+1, 3)`-shaped array of :math:`d+1` control points defining a single Bézier\n        curve of degree :math:`d`. Alternatively, for vectorization purposes, ``points`` can\n        also be a :math:`(d+1, M, 3)`-shaped sequence of :math:`d+1` arrays of :math:`M`\n        control points each, which define `M` Bézier curves instead.\n\n    Returns\n    -------\n    bezier_func : :class:`typing.Callable` [[:class:`float` | :class:`~.ColVector`], :class:`~.Point3D` | :class:`~.Point3D_Array`]\n        Function describing the Bézier curve. The behaviour of this function depends on\n        the shape of ``points``:\n\n            *   If ``points`` was a :math:`(d+1, 3)` array representing a single Bézier curve,\n                then ``bezier_func`` can receive either:\n\n                *   a :class:`float` ``t``, in which case it returns a\n                    single :math:`(1, 3)`-shaped :class:`~.Point3D` representing the evaluation\n                    of the Bézier at ``t``, or\n                *   an :math:`(n, 1)`-shaped :class:`~.ColVector`\n                    containing :math:`n` values to evaluate the Bézier curve at, returning instead\n                    an :math:`(n, 3)`-shaped :class:`~.Point3D_Array` containing the points\n                    resulting from evaluating the Bézier at each of the :math:`n` values.\n                .. warning::\n                    If passing a vector of :math:`t`-values to ``bezier_func``, it **must**\n                    be a column vector/matrix of shape :math:`(n, 1)`. Passing an 1D array of\n                    shape :math:`(n,)` is not supported and **will result in undefined behaviour**.\n\n            *   If ``points`` was a :math:`(d+1, M, 3)` array describing :math:`M` Bézier curves,\n                then ``bezier_func`` can receive either:\n\n                *   a :class:`float` ``t``, in which case it returns an\n                    :math:`(M, 3)`-shaped :class:`~.Point3D_Array` representing the evaluation\n                    of the :math:`M` Bézier curves at the same value ``t``, or\n                *   an :math:`(M, 1)`-shaped\n                    :class:`~.ColVector` containing :math:`M` values, such that the :math:`i`-th\n                    Bézier curve defined by ``points`` is evaluated at the corresponding :math:`i`-th\n                    value in ``t``, returning again an :math:`(M, 3)`-shaped :class:`~.Point3D_Array`\n                    containing those :math:`M` evaluations.\n                .. warning::\n                    Unlike the previous case, if you pass a :class:`~.ColVector` to ``bezier_func``,\n                    it **must** contain exactly :math:`M` values, each value for each of the :math:`M`\n                    Bézier curves defined by ``points``. Any array of shape other than :math:`(M, 1)`\n                    **will result in undefined behaviour**.\n    \"\"\"\n    P = np.asarray(points)\n    degree = P.shape[0] - 1\n\n    if degree == 0:\n\n        def zero_bezier(t: float | ColVector) -> Point3D | Point3D_Array:\n            return np.ones_like(t) * P[0]\n\n        return zero_bezier\n\n    if degree == 1:\n\n        def linear_bezier(t: float | ColVector) -> Point3D | Point3D_Array:\n            return P[0] + t * (P[1] - P[0])\n\n        return linear_bezier\n\n    if degree == 2:\n\n        def quadratic_bezier(t: float | ColVector) -> Point3D | Point3D_Array:\n            t2 = t * t\n            mt = 1 - t\n            mt2 = mt * mt\n            return mt2 * P[0] + 2 * t * mt * P[1] + t2 * P[2]\n\n        return quadratic_bezier\n\n    if degree == 3:\n\n        def cubic_bezier(t: float | ColVector) -> Point3D | Point3D_Array:\n            t2 = t * t\n            t3 = t2 * t\n            mt = 1 - t\n            mt2 = mt * mt\n            mt3 = mt2 * mt\n            return mt3 * P[0] + 3 * t * mt2 * P[1] + 3 * t2 * mt * P[2] + t3 * P[3]\n\n        return cubic_bezier\n\n    def nth_grade_bezier(t: float | ColVector) -> Point3D | Point3D_Array:\n        is_scalar = not isinstance(t, np.ndarray)\n        if is_scalar:\n            B = np.empty((1, *P.shape))\n        else:\n            assert isinstance(t, np.ndarray)\n            t = t.reshape(-1, *[1 for dim in P.shape])\n            B = np.empty((t.shape[0], *P.shape))\n        B[:] = P\n\n        for i in range(degree):\n            # After the i-th iteration (i in [0, ..., d-1]) there are evaluations at t\n            # of (d-i) Bezier curves of grade (i+1), stored in the first d-i slots of B\n            B[:, : degree - i] += t * (B[:, 1 : degree - i + 1] - B[:, : degree - i])\n\n        # In the end, there shall be the evaluation at t of a single Bezier curve of\n        # grade d, stored in the first slot of B\n        if is_scalar:\n            val: Point3D = B[0, 0]\n            return val\n        return B[:, 0]\n\n    return nth_grade_bezier\n\n\n\n\n[docs]\ndef partial_bezier_points(points: BezierPointsLike, a: float, b: float) -> BezierPoints:\n    r\"\"\"Given an array of ``points`` which define a Bézier curve, and two numbers :math:`a, b`\n    such that :math:`0 \\le a < b \\le 1`, return an array of the same size, which describes the\n    portion of the original Bézier curve on the interval :math:`[a, b]`.\n\n    :func:`partial_bezier_points` is conceptually equivalent to calling :func:`split_bezier`\n    twice and discarding unused Bézier curves, but this is more efficient and doesn't waste\n    computations.\n\n    .. seealso::\n        See :func:`split_bezier` for an explanation on how to split Bézier curves.\n\n    .. note::\n        To find the portion of a Bézier curve with :math:`t` between :math:`a` and :math:`b`:\n\n        1.  Split the curve at :math:`t = a` and extract its 2nd subcurve.\n        2.  We cannot evaluate the new subcurve at :math:`t = b` because its range of values for :math:`t` is different.\n            To find the correct value, we need to transform the interval :math:`[a, 1]` into :math:`[0, 1]`\n            by first subtracting :math:`a` to get :math:`[0, 1-a]` and then dividing by :math:`1-a`. Thus, our new\n            value must be :math:`t = \\frac{b - a}{1 - a}`. Define :math:`u = \\frac{b - a}{1 - a}`.\n        3.  Split the subcurve at :math:`t = u` and extract its 1st subcurve.\n\n        The final portion is a linear combination of points, and thus the process can be\n        summarized as a linear transformation by some matrix in terms of :math:`a` and :math:`b`.\n        This matrix is given explicitly for Bézier curves up to degree 3, which are often used in Manim.\n        For higher degrees, the algorithm described previously is used.\n\n        For the case of a quadratic Bézier curve:\n\n        * Step 1:\n\n        .. math::\n            H'_1\n            =\n            \\begin{pmatrix}\n                (1-a)^2 & 2(1-a)a & a^2 \\\\\n                0 & (1-a) & a \\\\\n                0 & 0 & 1\n            \\end{pmatrix}\n            \\begin{pmatrix}\n                p_0 \\\\\n                p_1 \\\\\n                p_2\n            \\end{pmatrix}\n\n        * Step 2:\n\n        .. math::\n            H''_0\n            &=\n            \\begin{pmatrix}\n                1 & 0 & 0 \\\\\n                (1-u) & u & 0\\\\\n                (1-u)^2 & 2(1-u)u & u^2\n            \\end{pmatrix}\n            H'_1\n            \\\\\n            &\n            \\\\\n            &=\n            \\begin{pmatrix}\n                1 & 0 & 0 \\\\\n                (1-u) & u & 0\\\\\n                (1-u)^2 & 2(1-u)u & u^2\n            \\end{pmatrix}\n            \\begin{pmatrix}\n                (1-a)^2 & 2(1-a)a & a^2 \\\\\n                0 & (1-a) & a \\\\\n                0 & 0 & 1\n            \\end{pmatrix}\n            \\begin{pmatrix}\n                p_0 \\\\\n                p_1 \\\\\n                p_2\n            \\end{pmatrix}\n            \\\\\n            &\n            \\\\\n            &=\n            \\begin{pmatrix}\n                (1-a)^2 & 2(1-a)a & a^2 \\\\\n                (1-a)(1-b) & a(1-b) + (1-a)b & ab \\\\\n                (1-b)^2 & 2(1-b)b & b^2\n            \\end{pmatrix}\n            \\begin{pmatrix}\n                p_0 \\\\\n                p_1 \\\\\n                p_2\n            \\end{pmatrix}\n\n        from where one can define a :math:`(3, 3)` matrix :math:`P_2` which, when applied over\n        the array of ``points``, will return the desired partial quadratic Bézier curve:\n\n        .. math::\n            P_2\n            =\n            \\begin{pmatrix}\n                (1-a)^2 & 2(1-a)a & a^2 \\\\\n                (1-a)(1-b) & a(1-b) + (1-a)b & ab \\\\\n                (1-b)^2 & 2(1-b)b & b^2\n            \\end{pmatrix}\n\n        Similarly, for the cubic Bézier curve case, one can define the following\n        :math:`(4, 4)` matrix :math:`P_3`:\n\n        .. math::\n            P_3\n            =\n            \\begin{pmatrix}\n                (1-a)^3 & 3(1-a)^2a & 3(1-a)a^2 & a^3 \\\\\n                (1-a)^2(1-b) & 2(1-a)a(1-b) + (1-a)^2b & a^2(1-b) + 2(1-a)ab & a^2b \\\\\n                (1-a)(1-b)^2 & a(1-b)^2 + 2(1-a)(1-b)b & 2a(1-b)b + (1-a)b^2 & ab^2 \\\\\n                (1-b)^3 & 3(1-b)^2b & 3(1-b)b^2 & b^3\n            \\end{pmatrix}\n\n    Parameters\n    ----------\n    points\n        set of points defining the bezier curve.\n    a\n        lower bound of the desired partial bezier curve.\n    b\n        upper bound of the desired partial bezier curve.\n\n    Returns\n    -------\n    :class:`~.BezierPoints`\n        An array containing the control points defining the partial Bézier curve.\n    \"\"\"\n    # Border cases\n    if a == 1:\n        arr = np.array(points)\n        arr[:] = arr[-1]\n        return arr\n    if b == 0:\n        arr = np.array(points)\n        arr[:] = arr[0]\n        return arr\n\n    points = np.asarray(points)\n    degree = points.shape[0] - 1\n\n    if degree == 3:\n        ma, mb = 1 - a, 1 - b\n        a2, b2, ma2, mb2 = a * a, b * b, ma * ma, mb * mb\n        a3, b3, ma3, mb3 = a2 * a, b2 * b, ma2 * ma, mb2 * mb\n\n        portion_matrix = np.array(\n            [\n                [ma3, 3 * ma2 * a, 3 * ma * a2, a3],\n                [ma2 * mb, 2 * ma * a * mb + ma2 * b, a2 * mb + 2 * ma * a * b, a2 * b],\n                [ma * mb2, a * mb2 + 2 * ma * mb * b, 2 * a * mb * b + ma * b2, a * b2],\n                [mb3, 3 * mb2 * b, 3 * mb * b2, b3],\n            ]\n        )\n        return portion_matrix @ points\n\n    if degree == 2:\n        ma, mb = 1 - a, 1 - b\n\n        portion_matrix = np.array(\n            [\n                [ma * ma, 2 * a * ma, a * a],\n                [ma * mb, a * mb + ma * b, a * b],\n                [mb * mb, 2 * b * mb, b * b],\n            ]\n        )\n        return portion_matrix @ points\n\n    if degree == 1:\n        direction = points[1] - points[0]\n        return np.array(\n            [\n                points[0] + a * direction,\n                points[0] + b * direction,\n            ]\n        )\n\n    if degree == 0:\n        return points\n\n    # Fallback case for nth degree Béziers\n    # It is convenient that np.array copies points\n    arr = np.array(points, dtype=float)\n    N = arr.shape[0]\n\n    # Current state for an example Bézier curve C0 = [P0, P1, P2, P3]:\n    # arr = [P0, P1, P2, P3]\n    if a != 0:\n        for i in range(1, N):\n            # 1st iter: arr = [L0(a), L1(a), L2(a), P3]\n            # 2nd iter: arr = [Q0(a), Q1(a), L2(a), P3]\n            # 3rd iter: arr = [C0(a), Q1(a), L2(a), P3]\n            arr[: N - i] += a * (arr[1 : N - i + 1] - arr[: N - i])\n\n    # For faster calculations we shall define mu = 1 - u = (1 - b) / (1 - a).\n    # This is because:\n    # L0'(u) = P0' + u(P1' - P0')\n    #        = (1-u)P0' + uP1'\n    #        = muP0' + (1-mu)P1'\n    #        = P1' + mu(P0' - P1)\n    # In this way, one can do something similar to the first loop.\n    #\n    # Current state:\n    # arr = [C0(a), Q1(a), L2(a), P3]\n    #     = [P0', P1', P2', P3']\n    if b != 1:\n        mu = (1 - b) / (1 - a)\n        for i in range(1, N):\n            # 1st iter: arr = [P0', L0'(u), L1'(u), L2'(u)]\n            # 2nd iter: arr = [P0', L0'(u), Q0'(u), Q1'(u)]\n            # 3rd iter: arr = [P0', L0'(u), Q0'(u), C0'(u)]\n            arr[i:] += mu * (arr[i - 1 : -1] - arr[i:])\n\n    return arr\n\n\n\n\n[docs]\ndef split_bezier(points: BezierPointsLike, t: float) -> Spline:\n    r\"\"\"Split a Bézier curve at argument ``t`` into two curves.\n\n    .. note::\n\n        .. seealso::\n            `A Primer on Bézier Curves #10: Splitting curves. Pomax. <https://pomax.github.io/bezierinfo/#splitting>`_\n\n        As an example for a cubic Bézier curve, let :math:`p_0, p_1, p_2, p_3` be the points\n        needed for the curve :math:`C_0 = [p_0, \\ p_1, \\ p_2, \\ p_3]`.\n\n        Define the 3 linear Béziers :math:`L_0, L_1, L_2` as interpolations of :math:`p_0, p_1, p_2, p_3`:\n\n        .. math::\n            L_0(t) &= p_0 + t(p_1 - p_0) \\\\\n            L_1(t) &= p_1 + t(p_2 - p_1) \\\\\n            L_2(t) &= p_2 + t(p_3 - p_2)\n\n        Define the 2 quadratic Béziers :math:`Q_0, Q_1` as interpolations of :math:`L_0, L_1, L_2`:\n\n        .. math::\n            Q_0(t) &= L_0(t) + t(L_1(t) - L_0(t)) \\\\\n            Q_1(t) &= L_1(t) + t(L_2(t) - L_1(t))\n\n        Then :math:`C_0` is the following interpolation of :math:`Q_0` and :math:`Q_1`:\n\n        .. math::\n            C_0(t) = Q_0(t) + t(Q_1(t) - Q_0(t))\n\n        Evaluating :math:`C_0` at a value :math:`t=t'` splits :math:`C_0` into two cubic Béziers :math:`H_0`\n        and :math:`H_1`, defined by some of the points we calculated earlier:\n\n        .. math::\n            H_0 &= [p_0, &\\ L_0(t'), &\\ Q_0(t'), &\\ C_0(t') &] \\\\\n            H_1 &= [p_0(t'), &\\ Q_1(t'), &\\ L_2(t'), &\\ p_3 &]\n\n        As the resulting curves are obtained from linear combinations of ``points``, everything can\n        be encoded into a matrix for efficiency, which is done for Bézier curves of degree up to 3.\n\n        .. seealso::\n            `A Primer on Bézier Curves #11: Splitting curves using matrices. Pomax. <https://pomax.github.io/bezierinfo/#matrixsplit>`_\n\n        For the simpler case of a quadratic Bézier curve:\n\n        .. math::\n            H_0\n            &=\n            \\begin{pmatrix}\n                p_0 \\\\\n                (1-t) p_0 + t p_1 \\\\\n                (1-t)^2 p_0 + 2(1-t)t p_1 + t^2 p_2 \\\\\n            \\end{pmatrix}\n            &=\n            \\begin{pmatrix}\n                1 & 0 & 0 \\\\\n                (1-t) & t & 0\\\\\n                (1-t)^2 & 2(1-t)t & t^2\n            \\end{pmatrix}\n            \\begin{pmatrix}\n                p_0 \\\\\n                p_1 \\\\\n                p_2\n            \\end{pmatrix}\n            \\\\\n            &\n            \\\\\n            H_1\n            &=\n            \\begin{pmatrix}\n                (1-t)^2 p_0 + 2(1-t)t p_1 + t^2 p_2 \\\\\n                (1-t) p_1 + t p_2 \\\\\n                p_2\n            \\end{pmatrix}\n            &=\n            \\begin{pmatrix}\n                (1-t)^2 & 2(1-t)t & t^2 \\\\\n                0 & (1-t) & t \\\\\n                0 & 0 & 1\n            \\end{pmatrix}\n            \\begin{pmatrix}\n                p_0 \\\\\n                p_1 \\\\\n                p_2\n            \\end{pmatrix}\n\n        from where one can define a :math:`(6, 3)` split matrix :math:`S_2` which can multiply\n        the array of ``points`` to compute the return value:\n\n        .. math::\n            S_2\n            &=\n            \\begin{pmatrix}\n                1 & 0 & 0 \\\\\n                (1-t) & t & 0 \\\\\n                (1-t)^2 & 2(1-t)t & t^2 \\\\\n                (1-t)^2 & 2(1-t)t & t^2 \\\\\n                0 & (1-t) & t \\\\\n                0 & 0 & 1\n            \\end{pmatrix}\n            \\\\\n            &\n            \\\\\n            S_2 P\n            &=\n            \\begin{pmatrix}\n                1 & 0 & 0 \\\\\n                (1-t) & t & 0 \\\\\n                (1-t)^2 & 2(1-t)t & t^2 \\\\\n                (1-t)^2 & 2(1-t)t & t^2 \\\\\n                0 & (1-t) & t \\\\\n                0 & 0 & 1\n            \\end{pmatrix}\n            \\begin{pmatrix}\n                p_0 \\\\\n                p_1 \\\\\n                p_2\n            \\end{pmatrix}\n            =\n            \\begin{pmatrix}\n                \\vert \\\\\n                H_0 \\\\\n                \\vert \\\\\n                \\vert \\\\\n                H_1 \\\\\n                \\vert\n            \\end{pmatrix}\n\n        For the previous example with a cubic Bézier curve:\n\n        .. math::\n            H_0\n            &=\n            \\begin{pmatrix}\n                p_0 \\\\\n                (1-t) p_0 + t p_1 \\\\\n                (1-t)^2 p_0 + 2(1-t)t p_1 + t^2 p_2 \\\\\n                (1-t)^3 p_0 + 3(1-t)^2 t p_1 + 3(1-t)t^2 p_2 + t^3 p_3\n            \\end{pmatrix}\n            &=\n            \\begin{pmatrix}\n                1 & 0 & 0 & 0 \\\\\n                (1-t) & t & 0 & 0 \\\\\n                (1-t)^2 & 2(1-t)t & t^2 & 0 \\\\\n                (1-t)^3 & 3(1-t)^2 t & 3(1-t)t^2 & t^3\n            \\end{pmatrix}\n            \\begin{pmatrix}\n                p_0 \\\\\n                p_1 \\\\\n                p_2 \\\\\n                p_3\n            \\end{pmatrix}\n            \\\\\n            &\n            \\\\\n            H_1\n            &=\n            \\begin{pmatrix}\n                (1-t)^3 p_0 + 3(1-t)^2 t p_1 + 3(1-t)t^2 p_2 + t^3 p_3 \\\\\n                (1-t)^2 p_1 + 2(1-t)t p_2 + t^2 p_3 \\\\\n                (1-t) p_2 + t p_3 \\\\\n                p_3\n            \\end{pmatrix}\n            &=\n            \\begin{pmatrix}\n                (1-t)^3 & 3(1-t)^2 t & 3(1-t)t^2 & t^3 \\\\\n                0 & (1-t)^2 & 2(1-t)t & t^2 \\\\\n                0 & 0 & (1-t) & t \\\\\n                0 & 0 & 0 & 1\n            \\end{pmatrix}\n            \\begin{pmatrix}\n                p_0 \\\\\n                p_1 \\\\\n                p_2 \\\\\n                p_3\n            \\end{pmatrix}\n\n        from where one can define a :math:`(8, 4)` split matrix :math:`S_3` which can multiply\n        the array of ``points`` to compute the return value:\n\n        .. math::\n            S_3\n            &=\n            \\begin{pmatrix}\n                1 & 0 & 0 & 0 \\\\\n                (1-t) & t & 0 & 0 \\\\\n                (1-t)^2 & 2(1-t)t & t^2 & 0 \\\\\n                (1-t)^3 & 3(1-t)^2 t & 3(1-t)t^2 & t^3 \\\\\n                (1-t)^3 & 3(1-t)^2 t & 3(1-t)t^2 & t^3 \\\\\n                0 & (1-t)^2 & 2(1-t)t & t^2 \\\\\n                0 & 0 & (1-t) & t \\\\\n                0 & 0 & 0 & 1\n            \\end{pmatrix}\n            \\\\\n            &\n            \\\\\n            S_3 P\n            &=\n            \\begin{pmatrix}\n                1 & 0 & 0 & 0 \\\\\n                (1-t) & t & 0 & 0 \\\\\n                (1-t)^2 & 2(1-t)t & t^2 & 0 \\\\\n                (1-t)^3 & 3(1-t)^2 t & 3(1-t)t^2 & t^3 \\\\\n                (1-t)^3 & 3(1-t)^2 t & 3(1-t)t^2 & t^3 \\\\\n                0 & (1-t)^2 & 2(1-t)t & t^2 \\\\\n                0 & 0 & (1-t) & t \\\\\n                0 & 0 & 0 & 1\n            \\end{pmatrix}\n            \\begin{pmatrix}\n                p_0 \\\\\n                p_1 \\\\\n                p_2 \\\\\n                p_3\n            \\end{pmatrix}\n            =\n            \\begin{pmatrix}\n                \\vert \\\\\n                H_0 \\\\\n                \\vert \\\\\n                \\vert \\\\\n                H_1 \\\\\n                \\vert\n            \\end{pmatrix}\n\n    Parameters\n    ----------\n    points\n        The control points of the Bézier curve.\n\n    t\n        The ``t``-value at which to split the Bézier curve.\n\n    Returns\n    -------\n    :class:`~.Point3D_Array`\n        An array containing the control points defining the two Bézier curves.\n    \"\"\"\n    points = np.asarray(points)\n    N, dim = points.shape\n    degree = N - 1\n\n    if degree == 3:\n        mt = 1 - t\n        mt2 = mt * mt\n        mt3 = mt2 * mt\n        t2 = t * t\n        t3 = t2 * t\n        two_mt_t = 2 * mt * t\n        three_mt2_t = 3 * mt2 * t\n        three_mt_t2 = 3 * mt * t2\n\n        # Split matrix S3 explained in the docstring\n        split_matrix = np.array(\n            [\n                [1, 0, 0, 0],\n                [mt, t, 0, 0],\n                [mt2, two_mt_t, t2, 0],\n                [mt3, three_mt2_t, three_mt_t2, t3],\n                [mt3, three_mt2_t, three_mt_t2, t3],\n                [0, mt2, two_mt_t, t2],\n                [0, 0, mt, t],\n                [0, 0, 0, 1],\n            ]\n        )\n\n        return split_matrix @ points\n\n    if degree == 2:\n        mt = 1 - t\n        mt2 = mt * mt\n        t2 = t * t\n        two_tmt = 2 * t * mt\n\n        # Split matrix S2 explained in the docstring\n        split_matrix = np.array(\n            [\n                [1, 0, 0],\n                [mt, t, 0],\n                [mt2, two_tmt, t2],\n                [mt2, two_tmt, t2],\n                [0, mt, t],\n                [0, 0, 1],\n            ]\n        )\n\n        return split_matrix @ points\n\n    if degree == 1:\n        middle = points[0] + t * (points[1] - points[0])\n        return np.array([points[0], middle, middle, points[1]])\n\n    if degree == 0:\n        return np.array([points[0], points[0]])\n\n    # Fallback case for nth degree Béziers\n    arr = np.empty((2, N, dim))\n    arr[1] = points\n    arr[0, 0] = points[0]\n\n    # Example for a cubic Bézier\n    # arr[0] = [P0 .. .. ..]\n    # arr[1] = [P0 P1 P2 P3]\n    for i in range(1, N):\n        # 1st iter: arr[1] = [L0 L1 L2 P3]\n        # 2nd iter: arr[1] = [Q0 Q1 L2 P3]\n        # 3rd iter: arr[1] = [C0 Q1 L2 P3]\n        arr[1, : N - i] += t * (arr[1, 1 : N - i + 1] - arr[1, : N - i])\n        # 1st iter: arr[0] = [P0 L0 .. ..]\n        # 2nd iter: arr[0] = [P0 L0 Q0 ..]\n        # 3rd iter: arr[0] = [P0 L0 Q0 C0]\n        arr[0, i] = arr[1, 0]\n\n    return arr.reshape(2 * N, dim)\n\n\n\n# Memos explained in subdivide_bezier docstring\nSUBDIVISION_MATRICES: list[dict[int, MatrixMN]] = [{} for i in range(4)]\n\n\ndef _get_subdivision_matrix(n_points: int, n_divisions: int) -> MatrixMN:\n    \"\"\"Gets the matrix which subdivides a Bézier curve of\n    ``n_points`` control points into ``n_divisions`` parts.\n\n    Auxiliary function for :func:`subdivide_bezier`. See its\n    docstrings for an explanation of the matrix build process.\n\n    Parameters\n    ----------\n    n_points\n        The number of control points of the Bézier curve to\n        subdivide. This function only handles up to 4 points.\n    n_divisions\n        The number of parts to subdivide the Bézier curve into.\n\n    Returns\n    -------\n    MatrixMN\n        The matrix which, upon multiplying the control points of the\n        Bézier curve, subdivides it into ``n_divisions`` parts.\n    \"\"\"\n    if n_points not in (1, 2, 3, 4):\n        raise NotImplementedError(\n            \"This function does not support subdividing Bézier \"\n            \"curves with 0 or more than 4 control points.\"\n        )\n\n    subdivision_matrix = SUBDIVISION_MATRICES[n_points - 1].get(n_divisions, None)\n    if subdivision_matrix is not None:\n        return subdivision_matrix\n\n    subdivision_matrix = np.empty((n_points * n_divisions, n_points))\n\n    # Cubic Bézier\n    if n_points == 4:\n        for i in range(n_divisions):\n            i2 = i * i\n            i3 = i2 * i\n            ip1 = i + 1\n            ip12 = ip1 * ip1\n            ip13 = ip12 * ip1\n            nmi = n_divisions - i\n            nmi2 = nmi * nmi\n            nmi3 = nmi2 * nmi\n            nmim1 = nmi - 1\n            nmim12 = nmim1 * nmim1\n            nmim13 = nmim12 * nmim1\n\n            subdivision_matrix[4 * i : 4 * (i + 1)] = np.array(\n                [\n                    [\n                        nmi3,\n                        3 * nmi2 * i,\n                        3 * nmi * i2,\n                        i3,\n                    ],\n                    [\n                        nmi2 * nmim1,\n                        2 * nmi * nmim1 * i + nmi2 * ip1,\n                        nmim1 * i2 + 2 * nmi * i * ip1,\n                        i2 * ip1,\n                    ],\n                    [\n                        nmi * nmim12,\n                        nmim12 * i + 2 * nmi * nmim1 * ip1,\n                        2 * nmim1 * i * ip1 + nmi * ip12,\n                        i * ip12,\n                    ],\n                    [\n                        nmim13,\n                        3 * nmim12 * ip1,\n                        3 * nmim1 * ip12,\n                        ip13,\n                    ],\n                ]\n            )\n        subdivision_matrix /= n_divisions * n_divisions * n_divisions\n\n    # Quadratic Bézier\n    elif n_points == 3:\n        for i in range(n_divisions):\n            ip1 = i + 1\n            nmi = n_divisions - i\n            nmim1 = nmi - 1\n            subdivision_matrix[3 * i : 3 * (i + 1)] = np.array(\n                [\n                    [nmi * nmi, 2 * i * nmi, i * i],\n                    [nmi * nmim1, i * nmim1 + ip1 * nmi, i * ip1],\n                    [nmim1 * nmim1, 2 * ip1 * nmim1, ip1 * ip1],\n                ]\n            )\n        subdivision_matrix /= n_divisions * n_divisions\n\n    # Linear Bézier (straight line)\n    elif n_points == 2:\n        aux_range = np.arange(n_divisions + 1)\n        subdivision_matrix[::2, 1] = aux_range[:-1]\n        subdivision_matrix[1::2, 1] = aux_range[1:]\n        subdivision_matrix[:, 0] = subdivision_matrix[::-1, 1]\n        subdivision_matrix /= n_divisions\n\n    # Zero-degree Bézier (single point)\n    elif n_points == 1:\n        subdivision_matrix[:] = 1\n\n    SUBDIVISION_MATRICES[n_points - 1][n_divisions] = subdivision_matrix\n    return subdivision_matrix\n\n\n\n[docs]\ndef subdivide_bezier(points: BezierPointsLike, n_divisions: int) -> Spline:\n    r\"\"\"Subdivide a Bézier curve into :math:`n` subcurves which have the same shape.\n\n    The points at which the curve is split are located at the\n    arguments :math:`t = \\frac{i}{n}`, for :math:`i \\in \\{1, ..., n-1\\}`.\n\n    .. seealso::\n\n        * See :func:`split_bezier` for an explanation on how to split Bézier curves.\n        * See :func:`partial_bezier_points` for an extra understanding of this function.\n\n\n    .. note::\n        The resulting subcurves can be expressed as linear combinations of\n        ``points``, which can be encoded in a single matrix that is precalculated\n        for 2nd and 3rd degree Bézier curves.\n\n        As an example for a quadratic Bézier curve: taking inspiration from the\n        explanation in :func:`partial_bezier_points`, where the following matrix\n        :math:`P_2` was defined to extract the portion of a quadratic Bézier\n        curve for :math:`t \\in [a, b]`:\n\n        .. math::\n            P_2\n            =\n            \\begin{pmatrix}\n                (1-a)^2 & 2(1-a)a & a^2 \\\\\n                (1-a)(1-b) & a(1-b) + (1-a)b & ab \\\\\n                (1-b)^2 & 2(1-b)b & b^2\n            \\end{pmatrix}\n\n        the plan is to replace :math:`[a, b]` with\n        :math:`\\left[ \\frac{i-1}{n}, \\frac{i}{n} \\right], \\ \\forall i \\in \\{1, ..., n\\}`.\n\n        As an example for :math:`n = 2` divisions, construct :math:`P_1` for\n        the interval :math:`\\left[ 0, \\frac{1}{2} \\right]`, and :math:`P_2` for the\n        interval :math:`\\left[ \\frac{1}{2}, 1 \\right]`:\n\n        .. math::\n            P_1\n            =\n            \\begin{pmatrix}\n                1 & 0 & 0 \\\\\n                0.5 & 0.5 & 0 \\\\\n                0.25 & 0.5 & 0.25\n            \\end{pmatrix}\n            ,\n            \\quad\n            P_2\n            =\n            \\begin{pmatrix}\n                0.25 & 0.5 & 0.25 \\\\\n                0 & 0.5 & 0.5 \\\\\n                0 & 0 & 1\n            \\end{pmatrix}\n\n        Therefore, the following :math:`(6, 3)` subdivision matrix :math:`D_2` can be\n        constructed, which will subdivide an array of ``points`` into 2 parts:\n\n        .. math::\n            D_2\n            =\n            \\begin{pmatrix}\n                M_1 \\\\\n                M_2\n            \\end{pmatrix}\n            =\n            \\begin{pmatrix}\n                1 & 0 & 0 \\\\\n                0.5 & 0.5 & 0 \\\\\n                0.25 & 0.5 & 0.25 \\\\\n                0.25 & 0.5 & 0.25 \\\\\n                0 & 0.5 & 0.5 \\\\\n                0 & 0 & 1\n            \\end{pmatrix}\n\n        For quadratic and cubic Bézier curves, the subdivision matrices are memoized for\n        efficiency. For higher degree curves, an iterative algorithm inspired by the\n        one from :func:`split_bezier` is used instead.\n\n    .. image:: /_static/bezier_subdivision_example.png\n\n    Parameters\n    ----------\n    points\n        The control points of the Bézier curve.\n\n    n_divisions\n        The number of curves to subdivide the Bézier curve into\n\n    Returns\n    -------\n    :class:`~.Spline`\n        An array containing the points defining the new :math:`n` subcurves.\n    \"\"\"\n    if n_divisions == 1:\n        return points\n\n    points = np.asarray(points)\n    N, dim = points.shape\n\n    if N <= 4:\n        subdivision_matrix = _get_subdivision_matrix(N, n_divisions)\n        return subdivision_matrix @ points\n\n    # Fallback case for an nth degree Bézier: successive splitting\n    beziers = np.empty((n_divisions, N, dim))\n    beziers[-1] = points\n    for curve_num in range(n_divisions - 1, 0, -1):\n        curr = beziers[curve_num]\n        prev = beziers[curve_num - 1]\n        prev[0] = curr[0]\n        a = (n_divisions - curve_num) / (n_divisions - curve_num + 1)\n        # Current state for an example cubic Bézier curve:\n        # prev = [P0 .. .. ..]\n        # curr = [P0 P1 P2 P3]\n        for i in range(1, N):\n            # 1st iter: curr = [L0 L1 L2 P3]\n            # 2nd iter: curr = [Q0 Q1 L2 P3]\n            # 3rd iter: curr = [C0 Q1 L2 P3]\n            curr[: N - i] += a * (curr[1 : N - i + 1] - curr[: N - i])\n            # 1st iter: prev = [P0 L0 .. ..]\n            # 2nd iter: prev = [P0 L0 Q0 ..]\n            # 3rd iter: prev = [P0 L0 Q0 C0]\n            prev[i] = curr[0]\n\n    return beziers.reshape(n_divisions * N, dim)\n\n\n\n\n[docs]\ndef bezier_remap(\n    bezier_tuples: BezierPointsLike_Array,\n    new_number_of_curves: int,\n) -> BezierPoints_Array:\n    \"\"\"Subdivides each curve in ``bezier_tuples`` into as many parts as necessary, until the final number of\n    curves reaches a desired amount, ``new_number_of_curves``.\n\n    Parameters\n    ----------\n    bezier_tuples\n        An array of multiple Bézier curves of degree :math:`d` to be remapped. The shape of this array\n        must be ``(current_number_of_curves, nppc, dim)``, where:\n\n        *   ``current_number_of_curves`` is the current amount of curves in the array ``bezier_tuples``,\n        *   ``nppc`` is the amount of points per curve, such that their degree is ``nppc-1``, and\n        *   ``dim`` is the dimension of the points, usually :math:`3`.\n\n    new_number_of_curves\n        The number of curves that the output will contain. This needs to be higher than the current number.\n\n    Returns\n    -------\n    :class:`~.BezierPoints_Array`\n        The new array of shape ``(new_number_of_curves, nppc, dim)``,\n        containing the new Bézier curves after the remap.\n    \"\"\"\n    bezier_tuples = np.asarray(bezier_tuples)\n    current_number_of_curves, nppc, dim = bezier_tuples.shape\n    # This is an array with values ranging from 0\n    # up to curr_num_curves,  with repeats such that\n    # its total length is target_num_curves.  For example,\n    # with curr_num_curves = 10, target_num_curves = 15, this\n    # would be [0, 0, 1, 2, 2, 3, 4, 4, 5, 6, 6, 7, 8, 8, 9].\n    repeat_indices = (\n        np.arange(new_number_of_curves, dtype=\"i\") * current_number_of_curves\n    ) // new_number_of_curves\n\n    # If the nth term of this list is k, it means\n    # that the nth curve of our path should be split\n    # into k pieces.\n    # In the above example our array had the following elements\n    # [0, 0, 1, 2, 2, 3, 4, 4, 5, 6, 6, 7, 8, 8, 9]\n    # We have two 0s, one 1, two 2s and so on.\n    # The split factors array would hence be:\n    # [2, 1, 2, 1, 2, 1, 2, 1, 2, 1]\n    split_factors = np.zeros(current_number_of_curves, dtype=\"i\")\n    np.add.at(split_factors, repeat_indices, 1)\n\n    new_tuples = np.empty((new_number_of_curves, nppc, dim))\n    index = 0\n    for curve, sf in zip(bezier_tuples, split_factors):\n        new_tuples[index : index + sf] = subdivide_bezier(curve, sf).reshape(\n            sf, nppc, dim\n        )\n        index += sf\n\n    return new_tuples\n\n\n\n# Linear interpolation variants\n\n\n@overload\ndef interpolate(start: float, end: float, alpha: float) -> float: ...\n\n\n@overload\ndef interpolate(start: float, end: float, alpha: ColVector) -> ColVector: ...\n\n\n@overload\ndef interpolate(start: Point3D, end: Point3D, alpha: float) -> Point3D: ...\n\n\n@overload\ndef interpolate(start: Point3D, end: Point3D, alpha: ColVector) -> Point3D_Array: ...\n\n\n\n[docs]\ndef interpolate(\n    start: float | Point3D,\n    end: float | Point3D,\n    alpha: float | ColVector,\n) -> float | ColVector | Point3D | Point3D_Array:\n    \"\"\"Linearly interpolates between two values ``start`` and ``end``.\n\n    Parameters\n    ----------\n    start\n        The start of the range.\n    end\n        The end of the range.\n    alpha\n        A float between 0 and 1, or an :math:`(n, 1)` column vector containing\n        :math:`n` floats between 0 and 1 to interpolate in a vectorized fashion.\n\n    Returns\n    -------\n    :class:`float` | :class:`~.ColVector` | :class:`~.Point3D` | :class:`~.Point3D_Array`\n        The result of the linear interpolation.\n\n        *   If ``start`` and ``end`` are of type :class:`float`, and:\n\n            * ``alpha`` is also a :class:`float`, the return is simply another :class:`float`.\n            * ``alpha`` is a :class:`~.ColVector`, the return is another :class:`~.ColVector`.\n\n        *   If ``start`` and ``end`` are of type :class:`~.Point3D`, and:\n\n            * ``alpha`` is a :class:`float`, the return is another :class:`~.Point3D`.\n            * ``alpha`` is a :class:`~.ColVector`, the return is a :class:`~.Point3D_Array`.\n    \"\"\"\n    return (1 - alpha) * start + alpha * end\n\n\n\n\n[docs]\ndef integer_interpolate(\n    start: float,\n    end: float,\n    alpha: float,\n) -> tuple[int, float]:\n    \"\"\"\n    This is a variant of interpolate that returns an integer and the residual\n\n    Parameters\n    ----------\n    start\n        The start of the range\n    end\n        The end of the range\n    alpha\n        a float between 0 and 1.\n\n    Returns\n    -------\n    tuple[int, float]\n        This returns an integer between start and end (inclusive) representing\n        appropriate interpolation between them, along with a\n        \"residue\" representing a new proportion between the\n        returned integer and the next one of the\n        list.\n\n    Example\n    -------\n\n    .. code-block:: pycon\ninteger, residue = integer_interpolate(start=0, end=10, alpha=0.46)\nnp.allclose((integer, residue), (4, 0.6))\n        True\n    \"\"\"\n    if alpha >= 1:\n        return (int(end - 1), 1.0)\n    if alpha <= 0:\n        return (int(start), 0)\n    value = int(interpolate(start, end, alpha))\n    residue = ((end - start) * alpha) % 1\n    return (value, residue)\n\n\n\n@overload\ndef mid(start: float, end: float) -> float: ...\n\n\n@overload\ndef mid(start: Point3D, end: Point3D) -> Point3D: ...\n\n\n\n[docs]\ndef mid(start: float | Point3D, end: float | Point3D) -> float | Point3D:\n    \"\"\"Returns the midpoint between two values.\n\n    Parameters\n    ----------\n    start\n        The first value\n    end\n        The second value\n\n    Returns\n    -------\n        The midpoint between the two values\n    \"\"\"\n    return (start + end) / 2.0\n\n\n\n@overload\ndef inverse_interpolate(start: float, end: float, value: float) -> float: ...\n\n\n@overload\ndef inverse_interpolate(start: float, end: float, value: Point3D) -> Point3D: ...\n\n\n@overload\ndef inverse_interpolate(start: Point3D, end: Point3D, value: Point3D) -> Point3D: ...\n\n\n\n[docs]\ndef inverse_interpolate(\n    start: float | Point3D,\n    end: float | Point3D,\n    value: float | Point3D,\n) -> float | Point3D:\n    \"\"\"Perform inverse interpolation to determine the alpha\n    values that would produce the specified ``value``\n    given the ``start`` and ``end`` values or points.\n\n    Parameters\n    ----------\n    start\n        The start value or point of the interpolation.\n    end\n        The end value or point of the interpolation.\n    value\n        The value or point for which the alpha value\n        should be determined.\n\n    Returns\n    -------\n        The alpha values producing the given input\n        when interpolating between ``start`` and ``end``.\n\n    Example\n    -------\n\n    .. code-block:: pycon\ninverse_interpolate(start=2, end=6, value=4)\n        np.float64(0.5)\nstart = np.array([1, 2, 1])\nend = np.array([7, 8, 11])\nvalue = np.array([4, 5, 5])\ninverse_interpolate(start, end, value)\n        array([0.5, 0.5, 0.4])\n    \"\"\"\n    return np.true_divide(value - start, end - start)\n\n\n\n@overload\ndef match_interpolate(\n    new_start: float,\n    new_end: float,\n    old_start: float,\n    old_end: float,\n    old_value: float,\n) -> float: ...\n\n\n@overload\ndef match_interpolate(\n    new_start: float,\n    new_end: float,\n    old_start: float,\n    old_end: float,\n    old_value: Point3D,\n) -> Point3D: ...\n\n\n\n[docs]\ndef match_interpolate(\n    new_start: float,\n    new_end: float,\n    old_start: float,\n    old_end: float,\n    old_value: float | Point3D,\n) -> float | Point3D:\n    \"\"\"Interpolate a value from an old range to a new range.\n\n    Parameters\n    ----------\n    new_start\n        The start of the new range.\n    new_end\n        The end of the new range.\n    old_start\n        The start of the old range.\n    old_end\n        The end of the old range.\n    old_value\n        The value within the old range whose corresponding\n        value in the new range (with the same alpha value)\n        is desired.\n\n    Returns\n    -------\n        The interpolated value within the new range.\n\n    Examples\n    --------\nmatch_interpolate(0, 100, 10, 20, 15)\n    np.float64(50.0)\n    \"\"\"\n    old_alpha = inverse_interpolate(old_start, old_end, old_value)\n    return interpolate(\n        new_start,\n        new_end,\n        old_alpha,\n    )\n\n\n\n# Figuring out which Bézier curves most smoothly connect a sequence of points\n\n[docs]\ndef get_smooth_cubic_bezier_handle_points(\n    anchors: Point3DLike_Array,\n) -> tuple[Point3D_Array, Point3D_Array]:\n    \"\"\"Given an array of anchors for a cubic spline (array of connected cubic\n    Bézier curves), compute the 1st and 2nd handle for every curve, so that\n    the resulting spline is smooth.\n\n    Parameters\n    ----------\n    anchors\n        Anchors of a cubic spline.\n\n    Returns\n    -------\n    :class:`tuple` [:class:`~.Point3D_Array`, :class:`~.Point3D_Array`]\n        A tuple of two arrays: one containing the 1st handle for every curve in\n        the cubic spline, and the other containing the 2nd handles.\n    \"\"\"\n    anchors = np.asarray(anchors)\n    n_anchors = anchors.shape[0]\n\n    # If there's a single anchor, there's no Bézier curve.\n    # Return empty arrays.\n    if n_anchors == 1:\n        dim = anchors.shape[1]\n        return np.zeros((0, dim)), np.zeros((0, dim))\n\n    # If there are only two anchors (thus only one pair of handles),\n    # they can only be an interpolation of these two anchors with alphas\n    # 1/3 and 2/3, which will draw a straight line between the anchors.\n    if n_anchors == 2:\n        val = interpolate(anchors[0], anchors[1], np.array([[1 / 3], [2 / 3]]))\n        return (val[0], val[1])\n\n    # Handle different cases depending on whether the points form a closed\n    # curve or not\n    curve_is_closed = is_closed(anchors)\n    if curve_is_closed:\n        return get_smooth_closed_cubic_bezier_handle_points(anchors)\n    else:\n        return get_smooth_open_cubic_bezier_handle_points(anchors)\n\n\n\nCP_CLOSED_MEMO = np.array([1 / 3])\nUP_CLOSED_MEMO = np.array([1 / 3])\n\n\n\n[docs]\ndef get_smooth_closed_cubic_bezier_handle_points(\n    anchors: Point3DLike_Array,\n) -> tuple[Point3D_Array, Point3D_Array]:\n    r\"\"\"Special case of :func:`get_smooth_cubic_bezier_handle_points`,\n    when the ``anchors`` form a closed loop.\n\n    .. note::\n        A system of equations must be solved to get the first handles of\n        every Bézier curve (referred to as :math:`H_1`).\n        Then :math:`H_2` (the second handles) can be obtained separately.\n\n        .. seealso::\n            The equations were obtained from:\n\n            * `Conditions on control points for continuous curvature. (2016). Jaco Stuifbergen. <http://www.jacos.nl/jacos_html/spline/theory/theory_2.html>`_\n\n        In general, if there are :math:`N+1` anchors, there will be :math:`N` Bézier curves\n        and thus :math:`N` pairs of handles to find. We must solve the following\n        system of equations for the 1st handles (example for :math:`N = 5`):\n\n        .. math::\n            \\begin{pmatrix}\n                4 & 1 & 0 & 0 & 1 \\\\\n                1 & 4 & 1 & 0 & 0 \\\\\n                0 & 1 & 4 & 1 & 0 \\\\\n                0 & 0 & 1 & 4 & 1 \\\\\n                1 & 0 & 0 & 1 & 4\n            \\end{pmatrix}\n            \\begin{pmatrix}\n                H_{1,0} \\\\\n                H_{1,1} \\\\\n                H_{1,2} \\\\\n                H_{1,3} \\\\\n                H_{1,4}\n            \\end{pmatrix}\n            =\n            \\begin{pmatrix}\n                4A_0 + 2A_1 \\\\\n                4A_1 + 2A_2 \\\\\n                4A_2 + 2A_3 \\\\\n                4A_3 + 2A_4 \\\\\n                4A_4 + 2A_5\n            \\end{pmatrix}\n\n        which will be expressed as :math:`RH_1 = D`.\n\n        :math:`R` is almost a tridiagonal matrix, so we could use Thomas' algorithm.\n\n        .. seealso::\n            `Tridiagonal matrix algorithm. Wikipedia. <https://en.wikipedia.org/wiki/Tridiagonal_matrix_algorithm>`_\n\n        However, :math:`R` has ones at the opposite corners. A solution to this is\n        the first decomposition proposed in the link below, with :math:`\\alpha = 1`:\n\n        .. seealso::\n            `Tridiagonal matrix algorithm # Variants. Wikipedia. <https://en.wikipedia.org/wiki/Tridiagonal_matrix_algorithm#Variants>`_\n\n        .. math::\n            R\n            =\n            \\begin{pmatrix}\n                4 & 1 & 0 & 0 & 1 \\\\\n                1 & 4 & 1 & 0 & 0 \\\\\n                0 & 1 & 4 & 1 & 0 \\\\\n                0 & 0 & 1 & 4 & 1 \\\\\n                1 & 0 & 0 & 1 & 4\n            \\end{pmatrix}\n            &=\n            \\begin{pmatrix}\n                3 & 1 & 0 & 0 & 0 \\\\\n                1 & 4 & 1 & 0 & 0 \\\\\n                0 & 1 & 4 & 1 & 0 \\\\\n                0 & 0 & 1 & 4 & 1 \\\\\n                0 & 0 & 0 & 1 & 3\n            \\end{pmatrix}\n            +\n            \\begin{pmatrix}\n                1 & 0 & 0 & 0 & 1 \\\\\n                0 & 0 & 0 & 0 & 0 \\\\\n                0 & 0 & 0 & 0 & 0 \\\\\n                0 & 0 & 0 & 0 & 0 \\\\\n                1 & 0 & 0 & 0 & 1\n            \\end{pmatrix}\n            \\\\\n            &\n            \\\\\n            &=\n            \\begin{pmatrix}\n                3 & 1 & 0 & 0 & 0 \\\\\n                1 & 4 & 1 & 0 & 0 \\\\\n                0 & 1 & 4 & 1 & 0 \\\\\n                0 & 0 & 1 & 4 & 1 \\\\\n                0 & 0 & 0 & 1 & 3\n            \\end{pmatrix}\n            +\n            \\begin{pmatrix}\n                1 \\\\\n                0 \\\\\n                0 \\\\\n                0 \\\\\n                1\n            \\end{pmatrix}\n            \\begin{pmatrix}\n                1 & 0 & 0 & 0 & 1\n            \\end{pmatrix}\n            \\\\\n            &\n            \\\\\n            &=\n            T + uv^t\n\n        We decompose :math:`R = T + uv^t`, where :math:`T` is a tridiagonal matrix, and\n        :math:`u, v` are :math:`N`-D vectors such that :math:`u_0 = u_{N-1} = v_0 = v_{N-1} = 1`,\n        and :math:`u_i = v_i = 0, \\forall i \\in \\{1, ..., N-2\\}`.\n\n        Thus:\n\n        .. math::\n            RH_1 &= D \\\\\n            \\Rightarrow (T + uv^t)H_1 &= D\n\n        If we find a vector :math:`q` such that :math:`Tq = u`:\n\n        .. math::\n            \\Rightarrow (T + Tqv^t)H_1 &= D \\\\\n            \\Rightarrow T(I + qv^t)H_1 &= D \\\\\n            \\Rightarrow H_1 &= (I + qv^t)^{-1} T^{-1} D\n\n        According to Sherman-Morrison's formula:\n\n        .. seealso::\n            `Sherman-Morrison's formula. Wikipedia. <https://en.wikipedia.org/wiki/Sherman%E2%80%93Morrison_formula>`_\n\n        .. math::\n            (I + qv^t)^{-1} = I - \\frac{1}{1 + v^tq} qv^t\n\n        If we find :math:`Y = T^{-1} D`, or in other words, if we solve for\n        :math:`Y` in :math:`TY = D`:\n\n        .. math::\n            H_1 &= (I + qv^t)^{-1} T^{-1} D \\\\\n            &= (I + qv^t)^{-1} Y \\\\\n            &= (I - \\frac{1}{1 + v^tq} qv^t) Y \\\\\n            &= Y - \\frac{1}{1 + v^tq} qv^tY\n\n        Therefore, we must solve for :math:`q` and :math:`Y` in :math:`Tq = u` and :math:`TY = D`.\n        As :math:`T` is now tridiagonal, we shall use Thomas' algorithm.\n\n        Define:\n\n        *   :math:`a = [a_0, \\ a_1, \\ ..., \\ a_{N-2}]` as :math:`T`'s lower diagonal of :math:`N-1` elements,\n            such that :math:`a_0 = a_1 = ... = a_{N-2} = 1`, so this diagonal is filled with ones;\n        *   :math:`b = [b_0, \\ b_1, \\ ..., \\ b_{N-2}, \\ b_{N-1}]` as :math:`T`'s main diagonal of :math:`N` elements,\n            such that :math:`b_0 = b_{N-1} = 3`, and :math:`b_1 = b_2 = ... = b_{N-2} = 4`;\n        *   :math:`c = [c_0, \\ c_1, \\ ..., \\ c_{N-2}]` as :math:`T`'s upper diagonal of :math:`N-1` elements,\n            such that :math:`c_0 = c_1 = ... = c_{N-2} = 1`: this diagonal is also filled with ones.\n\n        If, according to Thomas' algorithm, we define:\n\n        .. math::\n            c'_0 &= \\frac{c_0}{b_0} & \\\\\n            c'_i &= \\frac{c_i}{b_i - a_{i-1} c'_{i-1}}, & \\quad \\forall i \\in \\{1, ..., N-2\\} \\\\\n            & & \\\\\n            u'_0 &= \\frac{u_0}{b_0} & \\\\\n            u'_i &= \\frac{u_i - a_{i-1} u'_{i-1}}{b_i - a_{i-1} c'_{i-1}}, & \\quad \\forall i \\in \\{1, ..., N-1\\} \\\\\n            & & \\\\\n            D'_0 &= \\frac{1}{b_0} D_0 & \\\\\n            D'_i &= \\frac{1}{b_i - a_{i-1} c'_{i-1}} (D_i - a_{i-1} D'_{i-1}), & \\quad \\forall i \\in \\{1, ..., N-1\\}\n\n        Then:\n\n        .. math::\n            c'_0     &= \\frac{1}{3} & \\\\\n            c'_i     &= \\frac{1}{4 - c'_{i-1}}, & \\quad \\forall i \\in \\{1, ..., N-2\\} \\\\\n            & & \\\\\n            u'_0     &= \\frac{1}{3} & \\\\\n            u'_i     &= \\frac{-u'_{i-1}}{4 - c'_{i-1}} = -c'_i u'_{i-1}, & \\quad \\forall i \\in \\{1, ..., N-2\\} \\\\\n            u'_{N-1} &= \\frac{1 - u'_{N-2}}{3 - c'_{N-2}} & \\\\\n            & & \\\\\n            D'_0     &= \\frac{1}{3} (4A_0 + 2A_1) & \\\\\n            D'_i     &= \\frac{1}{4 - c'_{i-1}} (4A_i + 2A_{i+1} - D'_{i-1}) & \\\\\n            &= c_i (4A_i + 2A_{i+1} - D'_{i-1}), & \\quad \\forall i \\in \\{1, ..., N-2\\} \\\\\n            D'_{N-1} &= \\frac{1}{3 - c'_{N-2}} (4A_{N-1} + 2A_N - D'_{N-2}) &\n\n        Finally, we can do Backward Substitution to find :math:`q` and :math:`Y`:\n\n        .. math::\n            q_{N-1} &= u'_{N-1} & \\\\\n            q_i     &= u'_{i} - c'_i q_{i+1}, & \\quad \\forall i \\in \\{0, ..., N-2\\} \\\\\n            & & \\\\\n            Y_{N-1} &= D'_{N-1} & \\\\\n            Y_i     &= D'_i - c'_i Y_{i+1},   & \\quad \\forall i \\in \\{0, ..., N-2\\}\n\n        With those values, we can finally calculate :math:`H_1 = Y - \\frac{1}{1 + v^tq} qv^tY`.\n        Given that :math:`v_0 = v_{N-1} = 1`, and :math:`v_1 = v_2 = ... = v_{N-2} = 0`, its dot products\n        with :math:`q` and :math:`Y` are respectively :math:`v^tq = q_0 + q_{N-1}` and\n        :math:`v^tY = Y_0 + Y_{N-1}`. Thus:\n\n        .. math::\n            H_1 = Y - \\frac{1}{1 + q_0 + q_{N-1}} q(Y_0 + Y_{N-1})\n\n        Once we have :math:`H_1`, we can get :math:`H_2` (the array of second handles) as follows:\n\n        .. math::\n            H_{2, i}   &= 2A_{i+1} - H_{1, i+1}, & \\quad \\forall i \\in \\{0, ..., N-2\\} \\\\\n            H_{2, N-1} &= 2A_0 - H_{1, 0} &\n\n        Because the matrix :math:`R` always follows the same pattern (and thus :math:`T, u, v` as well),\n        we can define a memo list for :math:`c'` and :math:`u'` to avoid recalculation. We cannot\n        memoize :math:`D` and :math:`Y`, however, because they are always different matrices. We\n        cannot make a memo for :math:`q` either, but we can calculate it faster because :math:`u'`\n        can be memoized.\n\n    Parameters\n    ----------\n    anchors\n        Anchors of a closed cubic spline.\n\n    Returns\n    -------\n    :class:`tuple` [:class:`~.Point3D_Array`, :class:`~.Point3D_Array`]\n        A tuple of two arrays: one containing the 1st handle for every curve in\n        the closed cubic spline, and the other containing the 2nd handles.\n    \"\"\"\n    global CP_CLOSED_MEMO\n    global UP_CLOSED_MEMO\n\n    A = np.asarray(anchors)\n    N = A.shape[0] - 1\n    dim = A.shape[1]\n\n    # Calculate cp (c prime) and up (u prime) with help from\n    # CP_CLOSED_MEMO and UP_CLOSED_MEMO.\n    len_memo = CP_CLOSED_MEMO.size\n    if len_memo < N - 1:\n        cp = np.empty(N - 1)\n        up = np.empty(N - 1)\n        cp[:len_memo] = CP_CLOSED_MEMO\n        up[:len_memo] = UP_CLOSED_MEMO\n        # Forward Substitution 1\n        # Calculate up (at the same time we calculate cp).\n        for i in range(len_memo, N - 1):\n            cp[i] = 1 / (4 - cp[i - 1])\n            up[i] = -cp[i] * up[i - 1]\n        CP_CLOSED_MEMO = cp\n        UP_CLOSED_MEMO = up\n    else:\n        cp = CP_CLOSED_MEMO[: N - 1]\n        up = UP_CLOSED_MEMO[: N - 1]\n\n    # The last element of u' is different\n    cp_last_division = 1 / (3 - cp[N - 2])\n    up_last = cp_last_division * (1 - up[N - 2])\n\n    # Backward Substitution 1\n    # Calculate q.\n    q = np.empty((N, dim))\n    q[N - 1] = up_last\n    for i in range(N - 2, -1, -1):\n        q[i] = up[i] - cp[i] * q[i + 1]\n\n    # Forward Substitution 2\n    # Calculate Dp (D prime).\n    Dp = np.empty((N, dim))\n    AUX = 4 * A[:N] + 2 * A[1:]  # Vectorize the sum for efficiency.\n    Dp[0] = AUX[0] / 3\n    for i in range(1, N - 1):\n        Dp[i] = cp[i] * (AUX[i] - Dp[i - 1])\n    Dp[N - 1] = cp_last_division * (AUX[N - 1] - Dp[N - 2])\n\n    # Backward Substitution\n    # Calculate Y, which is defined as a view of Dp for efficiency\n    # and semantic convenience at the same time.\n    Y = Dp\n    # Y[N-1] = Dp[N-1] (redundant)\n    for i in range(N - 2, -1, -1):\n        Y[i] = Dp[i] - cp[i] * Y[i + 1]\n\n    # Calculate H1.\n    H1 = Y - 1 / (1 + q[0] + q[N - 1]) * q * (Y[0] + Y[N - 1])\n\n    # Calculate H2.\n    H2 = np.empty((N, dim))\n    H2[0 : N - 1] = 2 * A[1:N] - H1[1:N]\n    H2[N - 1] = 2 * A[N] - H1[0]\n\n    return H1, H2\n\n\n\nCP_OPEN_MEMO = np.array([0.5])\n\n\n\n[docs]\ndef get_smooth_open_cubic_bezier_handle_points(\n    anchors: Point3DLike_Array,\n) -> tuple[Point3D_Array, Point3D_Array]:\n    r\"\"\"Special case of :func:`get_smooth_cubic_bezier_handle_points`,\n    when the ``anchors`` do not form a closed loop.\n\n    .. note::\n        A system of equations must be solved to get the first handles of\n        every Bèzier curve (referred to as :math:`H_1`).\n        Then :math:`H_2` (the second handles) can be obtained separately.\n\n        .. seealso::\n            The equations were obtained from:\n\n            * `Smooth Bézier Spline Through Prescribed Points. (2012). Particle in Cell Consulting LLC. <https://www.particleincell.com/2012/bezier-splines/>`_\n            * `Conditions on control points for continuous curvature. (2016). Jaco Stuifbergen. <http://www.jacos.nl/jacos_html/spline/theory/theory_2.html>`_\n\n        .. warning::\n            The equations in the first webpage have some typos which were corrected in the comments.\n\n        In general, if there are :math:`N+1` anchors, there will be :math:`N` Bézier curves\n        and thus :math:`N` pairs of handles to find. We must solve the following\n        system of equations for the 1st handles (example for :math:`N = 5`):\n\n        .. math::\n            \\begin{pmatrix}\n                2 & 1 & 0 & 0 & 0 \\\\\n                1 & 4 & 1 & 0 & 0 \\\\\n                0 & 1 & 4 & 1 & 0 \\\\\n                0 & 0 & 1 & 4 & 1 \\\\\n                0 & 0 & 0 & 2 & 7\n            \\end{pmatrix}\n            \\begin{pmatrix}\n                H_{1,0} \\\\\n                H_{1,1} \\\\\n                H_{1,2} \\\\\n                H_{1,3} \\\\\n                H_{1,4}\n            \\end{pmatrix}\n            =\n            \\begin{pmatrix}\n                A_0 + 2A_1 \\\\\n                4A_1 + 2A_2 \\\\\n                4A_2 + 2A_3 \\\\\n                4A_3 + 2A_4 \\\\\n                8A_4 + A_5\n            \\end{pmatrix}\n\n        which will be expressed as :math:`TH_1 = D`.\n        :math:`T` is a tridiagonal matrix, so the system can be solved in :math:`O(N)`\n        operations. Here we shall use Thomas' algorithm or the tridiagonal matrix\n        algorithm.\n\n        .. seealso::\n            `Tridiagonal matrix algorithm. Wikipedia. <https://en.wikipedia.org/wiki/Tridiagonal_matrix_algorithm>`_\n\n        Define:\n\n        *   :math:`a = [a_0, \\ a_1, \\ ..., \\ a_{N-2}]` as :math:`T`'s lower diagonal of :math:`N-1` elements,\n            such that :math:`a_0 = a_1 = ... = a_{N-3} = 1`, and :math:`a_{N-2} = 2`;\n        *   :math:`b = [b_0, \\ b_1, \\ ..., \\ b_{N-2}, \\ b_{N-1}]` as :math:`T`'s main diagonal of :math:`N` elements,\n            such that :math:`b_0 = 2`, :math:`b_1 = b_2 = ... = b_{N-2} = 4`, and :math:`b_{N-1} = 7`;\n        *   :math:`c = [c_0, \\ c_1, \\ ..., \\ c_{N-2}]` as :math:`T`'s upper diagonal of :math:`{N-1}` elements,\n            such that :math:`c_0 = c_1 = ... = c_{N-2} = 1`: this diagonal is filled with ones.\n\n        If, according to Thomas' algorithm, we define:\n\n        .. math::\n            c'_0 &= \\frac{c_0}{b_0} & \\\\\n            c'_i &= \\frac{c_i}{b_i - a_{i-1} c'_{i-1}}, & \\quad \\forall i \\in \\{1, ..., N-2\\} \\\\\n            & & \\\\\n            D'_0 &= \\frac{1}{b_0} D_0 & \\\\\n            D'_i &= \\frac{1}{b_i - a_{i-1} c'{i-1}} (D_i - a_{i-1} D'_{i-1}), & \\quad \\forall i \\in \\{1, ..., N-1\\}\n\n        Then:\n\n        .. math::\n            c'_0     &= 0.5 & \\\\\n            c'_i     &= \\frac{1}{4 - c'_{i-1}}, & \\quad \\forall i \\in \\{1, ..., N-2\\} \\\\\n            & & \\\\\n            D'_0     &= 0.5A_0 + A_1 & \\\\\n            D'_i     &= \\frac{1}{4 - c'_{i-1}} (4A_i + 2A_{i+1} - D'_{i-1}) & \\\\\n            &= c_i (4A_i + 2A_{i+1} - D'_{i-1}), & \\quad \\forall i \\in \\{1, ..., N-2\\} \\\\\n            D'_{N-1} &= \\frac{1}{7 - 2c'_{N-2}} (8A_{N-1} + A_N - 2D'_{N-2}) &\n\n        Finally, we can do Backward Substitution to find :math:`H_1`:\n\n        .. math::\n            H_{1, N-1} &= D'_{N-1} & \\\\\n            H_{1, i}   &= D'_i - c'_i H_{1, i+1}, & \\quad \\forall i \\in \\{0, ..., N-2\\}\n\n        Once we have :math:`H_1`, we can get :math:`H_2` (the array of second handles) as follows:\n\n        .. math::\n            H_{2, i}   &= 2A_{i+1} - H_{1, i+1}, & \\quad \\forall i \\in \\{0, ..., N-2\\} \\\\\n            H_{2, N-1} &= 0.5A_N   + 0.5H_{1, N-1} &\n\n        As the matrix :math:`T` always follows the same pattern, we can define a memo list\n        for :math:`c'` to avoid recalculation. We cannot do the same for :math:`D`, however,\n        because it is always a different matrix.\n\n    Parameters\n    ----------\n    anchors\n        Anchors of an open cubic spline.\n\n    Returns\n    -------\n    :class:`tuple` [:class:`~.Point3D_Array`, :class:`~.Point3D_Array`]\n        A tuple of two arrays: one containing the 1st handle for every curve in\n        the open cubic spline, and the other containing the 2nd handles.\n    \"\"\"\n    global CP_OPEN_MEMO\n\n    A = np.asarray(anchors)\n    N = A.shape[0] - 1\n    dim = A.shape[1]\n\n    # Calculate cp (c prime) with help from CP_OPEN_MEMO.\n    len_memo = CP_OPEN_MEMO.size\n    if len_memo < N - 1:\n        cp = np.empty(N - 1)\n        cp[:len_memo] = CP_OPEN_MEMO\n        for i in range(len_memo, N - 1):\n            cp[i] = 1 / (4 - cp[i - 1])\n        CP_OPEN_MEMO = cp\n    else:\n        cp = CP_OPEN_MEMO[: N - 1]\n\n    # Calculate Dp (D prime).\n    Dp = np.empty((N, dim))\n    Dp[0] = 0.5 * A[0] + A[1]\n    AUX = 4 * A[1 : N - 1] + 2 * A[2:N]  # Vectorize the sum for efficiency.\n    for i in range(1, N - 1):\n        Dp[i] = cp[i] * (AUX[i - 1] - Dp[i - 1])\n    Dp[N - 1] = (1 / (7 - 2 * cp[N - 2])) * (8 * A[N - 1] + A[N] - 2 * Dp[N - 2])\n\n    # Backward Substitution.\n    # H1 (array of the first handles) is defined as a view of Dp for efficiency\n    # and semantic convenience at the same time.\n    H1 = Dp\n    # H1[N-1] = Dp[N-1] (redundant)\n    for i in range(N - 2, -1, -1):\n        H1[i] = Dp[i] - cp[i] * H1[i + 1]\n\n    # Calculate H2.\n    H2 = np.empty((N, dim))\n    H2[0 : N - 1] = 2 * A[1:N] - H1[1:N]\n    H2[N - 1] = 0.5 * (A[N] + H1[N - 1])\n\n    return H1, H2\n\n\n\n@overload\ndef get_quadratic_approximation_of_cubic(\n    a0: Point3DLike, h0: Point3DLike, h1: Point3DLike, a1: Point3DLike\n) -> QuadraticSpline: ...\n\n\n@overload\ndef get_quadratic_approximation_of_cubic(\n    a0: Point3DLike_Array,\n    h0: Point3DLike_Array,\n    h1: Point3DLike_Array,\n    a1: Point3DLike_Array,\n) -> QuadraticBezierPath: ...\n\n\n\n[docs]\ndef get_quadratic_approximation_of_cubic(\n    a0: Point3D | Point3D_Array,\n    h0: Point3D | Point3D_Array,\n    h1: Point3D | Point3D_Array,\n    a1: Point3D | Point3D_Array,\n) -> QuadraticSpline | QuadraticBezierPath:\n    r\"\"\"If ``a0``, ``h0``, ``h1`` and ``a1`` are the control points of a cubic\n    Bézier curve, approximate the curve with two quadratic Bézier curves and\n    return an array of 6 points, where the first 3 points represent the first\n    quadratic curve and the last 3 represent the second one.\n\n    Otherwise, if ``a0``, ``h0``, ``h1`` and ``a1`` are _arrays_ of :math:`N`\n    points representing :math:`N` cubic Bézier curves, return an array of\n    :math:`6N` points where each group of :math:`6` consecutive points\n    approximates each of the :math:`N` curves in a similar way as above.\n\n    .. note::\n        If the cubic spline given by the original cubic Bézier curves is\n        smooth, this algorithm will generate a quadratic spline which is also\n        smooth.\n\n        If a cubic Bézier is given by\n\n        .. math::\n            C(t) = (1-t)^3 A_0 + 3(1-t)^2 t H_0 + 3(1-t)t^2 H_1 + t^3 A_1\n\n        where :math:`A_0`, :math:`H_0`, :math:`H_1` and :math:`A_1` are its\n        control points, then this algorithm should generate two quadratic\n        Béziers given by\n\n        .. math::\n            Q_0(t) &= (1-t)^2 A_0 + 2(1-t)t M_0 + t^2 K \\\\\n            Q_1(t) &= (1-t)^2 K + 2(1-t)t M_1 + t^2 A_1\n\n        where :math:`M_0` and :math:`M_1` are the respective handles to be\n        found for both curves, and :math:`K` is the end anchor of the 1st curve\n        and the start anchor of the 2nd, which must also be found.\n\n        To solve for :math:`M_0`, :math:`M_1` and :math:`K`, three conditions\n        can be imposed:\n\n        1.  :math:`Q_0'(0) = \\frac{1}{2}C'(0)`. The derivative of the first\n            quadratic curve at :math:`t = 0` should be proportional to that of\n            the original cubic curve, also at :math:`t = 0`. Because the cubic\n            curve is split into two parts, it is necessary to divide this by\n            two: the speed of a point travelling through the curve should be\n            half of the original. This gives:\n\n            .. math::\n                Q_0'(0) &= \\frac{1}{2}C'(0) \\\\\n                2(M_0 - A_0) &= \\frac{3}{2}(H_0 - A_0) \\\\\n                2M_0 - 2A_0 &= \\frac{3}{2}H_0 - \\frac{3}{2}A_0 \\\\\n                2M_0 &= \\frac{3}{2}H_0 + \\frac{1}{2}A_0 \\\\\n                M_0 &= \\frac{1}{4}(3H_0 + A_0)\n\n        2.  :math:`Q_1'(1) = \\frac{1}{2}C'(1)`. The derivative of the second\n            quadratic curve at :math:`t = 1` should be half of that of the\n            original cubic curve for the same reasons as above, also at\n            :math:`t = 1`. This gives:\n\n            .. math::\n                Q_1'(1) &= \\frac{1}{2}C'(1) \\\\\n                2(A_1 - M_1) &= \\frac{3}{2}(A_1 - H_1) \\\\\n                2A_1 - 2M_1 &= \\frac{3}{2}A_1 - \\frac{3}{2}H_1 \\\\\n                -2M_1 &= -\\frac{1}{2}A_1 - \\frac{3}{2}H_1 \\\\\n                M_1 &= \\frac{1}{4}(3H_1 + A_1)\n\n        3.  :math:`Q_0'(1) = Q_1'(0)`. The derivatives of both quadratic curves\n            should match at the point :math:`K`, in order for the final spline\n            to be smooth. This gives:\n\n            .. math::\n                Q_0'(1) &= Q_1'(0) \\\\\n                2(K - M_0) &= 2(M_1 - K) \\\\\n                2K - 2M_0 &= 2M_1 - 2K \\\\\n                4K &= 2M_0 + 2M_1 \\\\\n                K &= \\frac{1}{2}(M_0 + M_1)\n\n        This is sufficient to find proper control points for the quadratic\n        Bézier curves.\n\n    Parameters\n    ----------\n    a0\n        The start anchor of a single cubic Bézier curve, or an array of\n        :math:`N` start anchors for :math:`N` curves.\n    h0\n        The first handle of a single cubic Bézier curve, or an array of\n        :math:`N` first handles for :math:`N` curves.\n    h1\n        The second handle of a single cubic Bézier curve, or an array of\n        :math:`N` second handles for :math:`N` curves.\n    a1\n        The end anchor of a single cubic Bézier curve, or an array of\n        :math:`N` end anchors for :math:`N` curves.\n\n    Returns\n    -------\n    result\n        An array containing either 6 points for 2 quadratic Bézier curves\n        approximating the original cubic curve, or :math:`6N` points for\n        :math:`2N` quadratic curves approximating :math:`N` cubic curves.\n\n    Raises\n    ------\n    ValueError\n        If ``a0``, ``h0``, ``h1`` and ``a1`` have different dimensions, or\n        if their number of dimensions is not 1 or 2.\n    \"\"\"\n    a0c = np.asarray(a0)\n    h0c = np.asarray(h0)\n    h1c = np.asarray(h1)\n    a1c = np.asarray(a1)\n\n    if all(arr.ndim == 1 for arr in (a0c, h0c, h1c, a1c)):\n        num_curves, dim = 1, a0c.shape[0]\n    elif all(arr.ndim == 2 for arr in (a0c, h0c, h1c, a1c)):\n        num_curves, dim = a0c.shape\n    else:\n        raise ValueError(\"All arguments must be Point3D or Point3D_Array.\")\n\n    m0 = 0.25 * (3 * h0c + a0c)\n    m1 = 0.25 * (3 * h1c + a1c)\n    k = 0.5 * (m0 + m1)\n\n    result = np.empty((6 * num_curves, dim))\n    result[0::6] = a0c\n    result[1::6] = m0\n    result[2::6] = k\n    result[3::6] = k\n    result[4::6] = m1\n    result[5::6] = a1c\n    return result\n\n\n\n\n[docs]\ndef is_closed(points: Point3D_Array) -> bool:\n    \"\"\"Returns ``True`` if the spline given by ``points`` is closed, by\n    checking if its first and last points are close to each other, or``False``\n    otherwise.\n\n    .. note::\n\n        This function reimplements :meth:`np.allclose`, because repeated\n        calling of :meth:`np.allclose` for only 2 points is inefficient.\n\n    Parameters\n    ----------\n    points\n        An array of points defining a spline.\n\n    Returns\n    -------\n    :class:`bool`\n        Whether the first and last points of the array are close enough or not\n        to be considered the same, thus considering the defined spline as\n        closed.\n\n    Examples\n    --------\n    .. code-block:: pycon\nimport numpy as np\nfrom manim import is_closed\nis_closed(\n    np.array(\n        [\n            [0, 0, 0],\n            [1, 2, 3],\n            [3, 2, 1],\n            [0, 0, 0],\n        ]\n    )\n)\n        True\nis_closed(\n    np.array(\n        [\n            [0, 0, 0],\n            [1, 2, 3],\n            [3, 2, 1],\n            [1e-10, 1e-10, 1e-10],\n        ]\n    )\n)\n        True\nis_closed(\n    np.array(\n        [\n            [0, 0, 0],\n            [1, 2, 3],\n            [3, 2, 1],\n            [1e-2, 1e-2, 1e-2],\n        ]\n    )\n)\n        False\n    \"\"\"\n    start, end = points[0], points[-1]\n    rtol = 1e-5\n    atol = 1e-8\n    tolerance = atol + rtol * start\n    if abs(end[0] - start[0]) > tolerance[0]:\n        return False\n    if abs(end[1] - start[1]) > tolerance[1]:\n        return False\n    return bool(abs(end[2] - start[2]) <= tolerance[2])\n\n\n\n\n[docs]\ndef proportions_along_bezier_curve_for_point(\n    point: Point3DLike,\n    control_points: BezierPointsLike,\n    round_to: float = 1e-6,\n) -> MatrixMN:\n    \"\"\"Obtains the proportion along the bezier curve corresponding to a given point\n    given the bezier curve's control points.\n\n    The bezier polynomial is constructed using the coordinates of the given point\n    as well as the bezier curve's control points. On solving the polynomial for each dimension,\n    if there are roots common to every dimension, those roots give the proportion along the\n    curve the point is at. If there are no real roots, the point does not lie on the curve.\n\n    Parameters\n    ----------\n    point\n        The Cartesian Coordinates of the point whose parameter\n        should be obtained.\n    control_points\n        The Cartesian Coordinates of the ordered control\n        points of the bezier curve on which the point may\n        or may not lie.\n    round_to\n        A float whose number of decimal places all values\n        such as coordinates of points will be rounded.\n\n    Returns\n    -------\n        np.ndarray[float]\n            List containing possible parameters (the proportions along the bezier curve)\n            for the given point on the given bezier curve.\n            This usually only contains one or zero elements, but if the\n            point is, say, at the beginning/end of a closed loop, may return\n            a list with more than 1 value, corresponding to the beginning and\n            end etc. of the loop.\n\n    Raises\n    ------\n    :class:`ValueError`\n        When ``point`` and the control points have different shapes.\n    \"\"\"\n    # Method taken from\n    # http://polymathprogrammer.com/2012/04/03/does-point-lie-on-bezier-curve/\n\n    if not all(np.shape(point) == np.shape(c_p) for c_p in control_points):\n        raise ValueError(\n            f\"Point {point} and Control Points {control_points} have different shapes.\",\n        )\n\n    control_points = np.array(control_points)\n    n = len(control_points) - 1\n\n    roots = []\n    for dim, coord in enumerate(point):\n        control_coords = control_points[:, dim]\n        terms = []\n        for term_power in range(n, -1, -1):\n            outercoeff = choose(n, term_power)\n            term = []\n            sign = 1\n            for subterm_num in range(term_power, -1, -1):\n                innercoeff = choose(term_power, subterm_num) * sign\n                subterm = innercoeff * control_coords[subterm_num]\n                if term_power == 0:\n                    subterm -= coord\n                term.append(subterm)\n                sign *= -1\n            terms.append(outercoeff * sum(np.array(term)))\n        if all(term == 0 for term in terms):\n            # Then both Bezier curve and Point lie on the same plane.\n            # Roots will be none, but in this specific instance, we don't need to consider that.\n            continue\n        bezier_polynom = np.polynomial.Polynomial(terms[::-1])\n        polynom_roots = bezier_polynom.roots()\n        if len(polynom_roots) > 0:\n            polynom_roots = np.around(polynom_roots, int(np.log10(1 / round_to)))\n        roots.append(polynom_roots)\n\n    roots = [[root for root in rootlist if root.imag == 0] for rootlist in roots]\n    # Get common roots\n    # arg-type: ignore\n    roots = reduce(np.intersect1d, roots)\n    result = np.asarray([r.real for r in roots if 0 <= r.real <= 1])\n    return result\n\n\n\n\n[docs]\ndef point_lies_on_bezier(\n    point: Point3DLike,\n    control_points: BezierPointsLike,\n    round_to: float = 1e-6,\n) -> bool:\n    \"\"\"Checks if a given point lies on the bezier curves with the given control points.\n\n    This is done by solving the bezier polynomial with the point as the constant term; if\n    any real roots exist, the point lies on the bezier curve.\n\n    Parameters\n    ----------\n    point\n        The Cartesian Coordinates of the point to check.\n    control_points\n        The Cartesian Coordinates of the ordered control\n        points of the bezier curve on which the point may\n        or may not lie.\n    round_to\n        A float whose number of decimal places all values\n        such as coordinates of points will be rounded.\n\n    Returns\n    -------\n    bool\n        Whether the point lies on the curve.\n    \"\"\"\n    roots = proportions_along_bezier_curve_for_point(point, control_points, round_to)\n\n    return len(roots) > 0", "code_sha1": "ad9ad456053d0f10e1e7e23cb12cc1e75f79e5bb"}
{"url": "https://docs.manim.community/en/stable/_modules/manim/utils/color/core.html", "depth": 2, "instruction": "The code defines a `ManimColor` class for color representation in Manim, supporting various formats (RGB, RGBA, hex). It includes methods for color conversion, interpolation, and manipulation (e.g., darker, lighter). The class ensures consistent internal representation using NumPy arrays, allowing for operations like blending and contrasting colors.", "code": "\"\"\"Manim's (internal) color data structure and some utilities for color conversion.\n\nThis module contains the implementation of :class:`.ManimColor`, the data structure\ninternally used to represent colors.\n\nThe preferred way of using these colors is by importing their constants from Manim:\n\n.. code-block:: pycon\nfrom manim import RED, GREEN, BLUE\nprint(RED)\n    #FC6255\n\nNote that this way uses the name of the colors in UPPERCASE.\n\n.. note::\n\n    The colors with a ``_C`` suffix have an alias equal to the colorname without a\n    letter. For example, ``GREEN = GREEN_C``.\n\n===================\nCustom Color Spaces\n===================\n\nHello, dear visitor. You seem to be interested in implementing a custom color class for\na color space we don't currently support.\n\nThe current system is using a few indirections for ensuring a consistent behavior with\nall other color types in Manim.\n\nTo implement a custom color space, you must subclass :class:`ManimColor` and implement\nthree important methods:\n\n  - :attr:`~.ManimColor._internal_value`: a ``@property`` implemented on\n    :class:`ManimColor` with the goal of keeping a consistent internal representation\n    which can be referenced by other functions in :class:`ManimColor`. This property acts\n    as a proxy to whatever representation you need in your class.\n\n      - The getter should always return a NumPy array in the format ``[r,g,b,a]``, in\n        accordance with the type :class:`ManimColorInternal`.\n\n      - The setter should always accept a value in the format ``[r,g,b,a]`` which can be\n        converted to whatever attributes you need.\n\n  - :attr:`~ManimColor._internal_space`: a read-only ``@property`` implemented on\n    :class:`ManimColor` with the goal of providing a useful representation which can be\n    used by operators, interpolation and color transform functions.\n\n    The only constraints on this value are:\n\n      - It must be a NumPy array.\n\n      - The last value must be the opacity in a range ``0.0`` to ``1.0``.\n\n    Additionally, your ``__init__`` must support this format as an initialization value\n    without additional parameters to ensure correct functionality of all other methods in\n    :class:`ManimColor`.\n\n  - :meth:`~ManimColor._from_internal`: a ``@classmethod`` which converts an\n    ``[r,g,b,a]`` value into suitable parameters for your ``__init__`` method and calls\n    the ``cls`` parameter.\n\"\"\"\n\nfrom __future__ import annotations\n\nimport colorsys\n\n# logger = _config.logger\nimport random\nimport re\nfrom collections.abc import Sequence\nfrom typing import TypeVar, Union, overload\n\nimport numpy as np\nimport numpy.typing as npt\nfrom typing_extensions import Self, TypeAlias, TypeIs, override\n\nfrom manim.typing import (\n    HSL_Array_Float,\n    HSL_Tuple_Float,\n    HSV_Array_Float,\n    HSV_Tuple_Float,\n    HSVA_Array_Float,\n    HSVA_Tuple_Float,\n    ManimColorDType,\n    ManimColorInternal,\n    ManimFloat,\n    Point3D,\n    RGB_Array_Float,\n    RGB_Array_Int,\n    RGB_Tuple_Float,\n    RGB_Tuple_Int,\n    RGBA_Array_Float,\n    RGBA_Array_Int,\n    RGBA_Tuple_Float,\n    RGBA_Tuple_Int,\n    Vector3D,\n)\n\nfrom ...utils.space_ops import normalize\n\n# import manim._config as _config\n\nre_hex = re.compile(\"((?<=#)|(?<=0x))[A-F0-9]{3,8}\", re.IGNORECASE)\n\n\n\n[docs]\nclass ManimColor:\n    \"\"\"Internal representation of a color.\n\n    The :class:`ManimColor` class is the main class for the representation of a color.\n    Its internal representation is an array of 4 floats corresponding to a ``[r,g,b,a]``\n    value where ``r,g,b,a`` can be between 0.0 and 1.0.\n\n    This is done in order to reduce the amount of color inconsistencies by constantly\n    casting between integers and floats which introduces errors.\n\n    The class can accept any value of type :class:`ParsableManimColor` i.e.\n\n    ``ManimColor, int, str, RGB_Tuple_Int, RGB_Tuple_Float, RGBA_Tuple_Int, RGBA_Tuple_Float, RGB_Array_Int,\n    RGB_Array_Float, RGBA_Array_Int, RGBA_Array_Float``\n\n    :class:`ManimColor` itself only accepts singular values and will directly interpret\n    them into a single color if possible. Be careful when passing strings to\n    :class:`ManimColor`: it can create a big overhead for the color processing.\n\n    If you want to parse a list of colors, use the :meth:`parse` method, which assumes\n    that you're going to pass a list of colors so that arrays will not be interpreted as\n    a single color.\n\n    .. warning::\n        If you pass an array of numbers to :meth:`parse`, it will interpret the\n        ``r,g,b,a`` numbers in that array as colors: Instead of the expected\n        singular color, you will get an array with 4 colors.\n\n    For conversion behaviors, see the ``_internal`` functions for further documentation.\n\n    You can create a :class:`ManimColor` instance via its classmethods. See the\n    respective methods for more info.\n\n    .. code-block:: python\n\n        mycolor = ManimColor.from_rgb((0, 1, 0.4, 0.5))\n        myothercolor = ManimColor.from_rgb((153, 255, 255))\n\n    You can also convert between different color spaces:\n\n    .. code-block:: python\n\n        mycolor_hex = mycolor.to_hex()\n        myoriginalcolor = ManimColor.from_hex(mycolor_hex).to_hsv()\n\n    Parameters\n    ----------\n    value\n        Some representation of a color (e.g., a string or\n        a suitable tuple). The default ``None`` is ``BLACK``.\n    alpha\n        The opacity of the color. By default, colors are\n        fully opaque (value 1.0).\n    \"\"\"\n\n    def __init__(\n        self,\n        value: ParsableManimColor | None,\n        alpha: float = 1.0,\n    ) -> None:\n        if value is None:\n            self._internal_value = np.array((0, 0, 0, alpha), dtype=ManimColorDType)\n        elif isinstance(value, ManimColor):\n            # logger.info(\n            #     \"ManimColor was passed another ManimColor. This is probably not what \"\n            #     \"you want. Created a copy of the passed ManimColor instead.\"\n            # )\n            self._internal_value = value._internal_value\n        elif isinstance(value, int):\n            self._internal_value = ManimColor._internal_from_integer(value, alpha)\n        elif isinstance(value, str):\n            result = re_hex.search(value)\n            if result is not None:\n                self._internal_value = ManimColor._internal_from_hex_string(\n                    result.group(), alpha\n                )\n            else:\n                # This is not expected to be called on module initialization time\n                # It can be horribly slow to convert a string to a color because\n                # it has to access the dictionary of colors and find the right color\n                self._internal_value = ManimColor._internal_from_string(value, alpha)\n        elif isinstance(value, (list, tuple, np.ndarray)):\n            length = len(value)\n            if all(isinstance(x, float) for x in value):\n                if length == 3:\n                    self._internal_value = ManimColor._internal_from_rgb(value, alpha)  # type: ignore[arg-type]\n                elif length == 4:\n                    self._internal_value = ManimColor._internal_from_rgba(value)  # type: ignore[arg-type]\n                else:\n                    raise ValueError(\n                        f\"ManimColor only accepts lists/tuples/arrays of length 3 or 4, not {length}\"\n                    )\n            else:\n                if length == 3:\n                    self._internal_value = ManimColor._internal_from_int_rgb(\n                        value,  # type: ignore[arg-type]\n                        alpha,\n                    )\n                elif length == 4:\n                    self._internal_value = ManimColor._internal_from_int_rgba(value)  # type: ignore[arg-type]\n                else:\n                    raise ValueError(\n                        f\"ManimColor only accepts lists/tuples/arrays of length 3 or 4, not {length}\"\n                    )\n        elif hasattr(value, \"get_hex\") and callable(value.get_hex):\n            result = re_hex.search(value.get_hex())\n            if result is None:\n                raise ValueError(f\"Failed to parse a color from {value}\")\n            self._internal_value = ManimColor._internal_from_hex_string(\n                result.group(), alpha\n            )\n        else:\n            # logger.error(f\"Invalid color value: {value}\")\n            raise TypeError(\n                \"ManimColor only accepts int, str, list[int, int, int], \"\n                \"list[int, int, int, int], list[float, float, float], \"\n                f\"list[float, float, float, float], not {type(value)}\"\n            )\n\n    @property\n    def _internal_space(self) -> npt.NDArray[ManimFloat]:\n        \"\"\"This is a readonly property which is a custom representation for color space\n        operations. It is used for operators and can be used when implementing a custom\n        color space.\n        \"\"\"\n        return self._internal_value\n\n    @property\n    def _internal_value(self) -> ManimColorInternal:\n        \"\"\"Return the internal value of the current Manim color ``[r,g,b,a]`` float\n        array.\n\n        Returns\n        -------\n        ManimColorInternal\n            Internal color representation.\n        \"\"\"\n        return self.__value\n\n    @_internal_value.setter\n    def _internal_value(self, value: ManimColorInternal) -> None:\n        \"\"\"Overwrite the internal color value of this :class:`ManimColor`.\n\n        Parameters\n        ----------\n        value\n            The value which will overwrite the current color.\n\n        Raises\n        ------\n        TypeError\n            If an invalid array is passed.\n        \"\"\"\n        if not isinstance(value, np.ndarray):\n            raise TypeError(\"Value must be a NumPy array.\")\n        if value.shape[0] != 4:\n            raise TypeError(\"Array must have exactly 4 values.\")\n        self.__value: ManimColorInternal = value\n\n\n[docs]\n    @classmethod\n    def _construct_from_space(\n        cls,\n        _space: npt.NDArray[ManimFloat]\n        | tuple[float, float, float]\n        | tuple[float, float, float, float],\n    ) -> Self:\n        \"\"\"This function is used as a proxy for constructing a color with an internal\n        value. This can be used by subclasses to hook into the construction of new\n        objects using the internal value format.\n        \"\"\"\n        return cls(_space)\n\n\n    @staticmethod\n    def _internal_from_integer(value: int, alpha: float) -> ManimColorInternal:\n        return np.asarray(\n            (\n                ((value >> 16) & 0xFF) / 255,\n                ((value >> 8) & 0xFF) / 255,\n                ((value >> 0) & 0xFF) / 255,\n                alpha,\n            ),\n            dtype=ManimColorDType,\n        )\n\n\n[docs]\n    @staticmethod\n    def _internal_from_hex_string(hex_: str, alpha: float) -> ManimColorInternal:\n        \"\"\"Internal function for converting a hex string into the internal representation\n        of a :class:`ManimColor`.\n\n        .. warning::\n            This does not accept any prefixes like # or similar in front of the hex string.\n            This is just intended for the raw hex part.\n\n        *For internal use only*\n\n        Parameters\n        ----------\n        hex\n            Hex string to be parsed.\n        alpha\n            Alpha value used for the color, if the color is only 3 bytes long. Otherwise,\n            if the color is 4 bytes long, this parameter will not be used.\n\n        Returns\n        -------\n        ManimColorInternal\n            Internal color representation\n        \"\"\"\n        if len(hex_) in (3, 4):\n            hex_ = \"\".join([x * 2 for x in hex_])\n        if len(hex_) == 6:\n            hex_ += \"FF\"\n        elif len(hex_) == 8:\n            alpha = (int(hex_, 16) & 0xFF) / 255\n        else:\n            raise ValueError(\n                \"Hex colors must be specified with either 0x or # as prefix and contain 6 or 8 hexadecimal numbers\"\n            )\n        tmp = int(hex_, 16)\n        return np.asarray(\n            (\n                ((tmp >> 24) & 0xFF) / 255,\n                ((tmp >> 16) & 0xFF) / 255,\n                ((tmp >> 8) & 0xFF) / 255,\n                alpha,\n            ),\n            dtype=ManimColorDType,\n        )\n\n\n\n[docs]\n    @staticmethod\n    def _internal_from_int_rgb(\n        rgb: RGB_Tuple_Int, alpha: float = 1.0\n    ) -> ManimColorInternal:\n        \"\"\"Internal function for converting an RGB tuple of integers into the internal\n        representation of a :class:`ManimColor`.\n\n        *For internal use only*\n\n        Parameters\n        ----------\n        rgb\n            Integer RGB tuple to be parsed\n        alpha\n            Optional alpha value. Default is 1.0.\n\n        Returns\n        -------\n        ManimColorInternal\n            Internal color representation.\n        \"\"\"\n        value: np.ndarray = np.asarray(rgb, dtype=ManimColorDType).copy() / 255\n        value.resize(4, refcheck=False)\n        value[3] = alpha\n        return value\n\n\n\n[docs]\n    @staticmethod\n    def _internal_from_rgb(\n        rgb: RGB_Tuple_Float, alpha: float = 1.0\n    ) -> ManimColorInternal:\n        \"\"\"Internal function for converting a rgb tuple of floats into the internal\n        representation of a :class:`ManimColor`.\n\n        *For internal use only*\n\n        Parameters\n        ----------\n        rgb\n            Float RGB tuple to be parsed.\n        alpha\n            Optional alpha value. Default is 1.0.\n\n        Returns\n        -------\n        ManimColorInternal\n            Internal color representation.\n        \"\"\"\n        value: np.ndarray = np.asarray(rgb, dtype=ManimColorDType).copy()\n        value.resize(4, refcheck=False)\n        value[3] = alpha\n        return value\n\n\n\n[docs]\n    @staticmethod\n    def _internal_from_int_rgba(rgba: RGBA_Tuple_Int) -> ManimColorInternal:\n        \"\"\"Internal function for converting an RGBA tuple of integers into the internal\n        representation of a :class:`ManimColor`.\n\n        *For internal use only*\n\n        Parameters\n        ----------\n        rgba\n            Int RGBA tuple to be parsed.\n\n        Returns\n        -------\n        ManimColorInternal\n            Internal color representation.\n        \"\"\"\n        return np.asarray(rgba, dtype=ManimColorDType) / 255\n\n\n\n[docs]\n    @staticmethod\n    def _internal_from_rgba(rgba: RGBA_Tuple_Float) -> ManimColorInternal:\n        \"\"\"Internal function for converting an RGBA tuple of floats into the internal\n        representation of a :class:`ManimColor`.\n\n        *For internal use only*\n\n        Parameters\n        ----------\n        rgba\n            Int RGBA tuple to be parsed.\n\n        Returns\n        -------\n        ManimColorInternal\n            Internal color representation.\n        \"\"\"\n        return np.asarray(rgba, dtype=ManimColorDType)\n\n\n\n[docs]\n    @staticmethod\n    def _internal_from_string(name: str, alpha: float) -> ManimColorInternal:\n        \"\"\"Internal function for converting a string into the internal representation of\n        a :class:`ManimColor`. This is not used for hex strings: please refer to\n        :meth:`_internal_from_hex` for this functionality.\n\n        *For internal use only*\n\n        Parameters\n        ----------\n        name\n            The color name to be parsed into a color. Refer to the different color\n            modules in the documentation page to find the corresponding color names.\n\n        Returns\n        -------\n        ManimColorInternal\n            Internal color representation.\n\n        Raises\n        ------\n        ValueError\n            If the color name is not present in Manim.\n        \"\"\"\n        from . import _all_color_dict\n\n        if tmp := _all_color_dict.get(name.upper()):\n            tmp._internal_value[3] = alpha\n            return tmp._internal_value.copy()\n        else:\n            raise ValueError(f\"Color {name} not found\")\n\n\n\n[docs]\n    def to_integer(self) -> int:\n        \"\"\"Convert the current :class:`ManimColor` into an integer.\n\n        .. warning::\n            This will return only the RGB part of the color.\n\n        Returns\n        -------\n        int\n            Integer representation of the color.\n        \"\"\"\n        tmp = (self._internal_value[:3] * 255).astype(dtype=np.byte).tobytes()\n        return int.from_bytes(tmp, \"big\")\n\n\n\n[docs]\n    def to_rgb(self) -> RGB_Array_Float:\n        \"\"\"Convert the current :class:`ManimColor` into an RGB array of floats.\n\n        Returns\n        -------\n        RGB_Array_Float\n            RGB array of 3 floats from 0.0 to 1.0.\n        \"\"\"\n        return self._internal_value[:3]\n\n\n\n[docs]\n    def to_int_rgb(self) -> RGB_Array_Int:\n        \"\"\"Convert the current :class:`ManimColor` into an RGB array of integers.\n\n        Returns\n        -------\n        RGB_Array_Int\n            RGB array of 3 integers from 0 to 255.\n        \"\"\"\n        return (self._internal_value[:3] * 255).astype(int)\n\n\n\n[docs]\n    def to_rgba(self) -> RGBA_Array_Float:\n        \"\"\"Convert the current :class:`ManimColor` into an RGBA array of floats.\n\n        Returns\n        -------\n        RGBA_Array_Float\n            RGBA array of 4 floats from 0.0 to 1.0.\n        \"\"\"\n        return self._internal_value\n\n\n\n[docs]\n    def to_int_rgba(self) -> RGBA_Array_Int:\n        \"\"\"Convert the current ManimColor into an RGBA array of integers.\n\n\n        Returns\n        -------\n        RGBA_Array_Int\n            RGBA array of 4 integers from 0 to 255.\n        \"\"\"\n        return (self._internal_value * 255).astype(int)\n\n\n\n[docs]\n    def to_rgba_with_alpha(self, alpha: float) -> RGBA_Array_Float:\n        \"\"\"Convert the current :class:`ManimColor` into an RGBA array of floats. This is\n        similar to :meth:`to_rgba`, but you can change the alpha value.\n\n        Parameters\n        ----------\n        alpha\n            Alpha value to be used in the return value.\n\n        Returns\n        -------\n        RGBA_Array_Float\n            RGBA array of 4 floats from 0.0 to 1.0.\n        \"\"\"\n        return np.fromiter((*self._internal_value[:3], alpha), dtype=ManimColorDType)\n\n\n\n[docs]\n    def to_int_rgba_with_alpha(self, alpha: float) -> RGBA_Array_Int:\n        \"\"\"Convert the current :class:`ManimColor` into an RGBA array of integers. This\n        is similar to :meth:`to_int_rgba`, but you can change the alpha value.\n\n        Parameters\n        ----------\n        alpha\n            Alpha value to be used for the return value. Pass a float between 0.0 and\n            1.0: it will automatically be scaled to an integer between 0 and 255.\n\n        Returns\n        -------\n        RGBA_Array_Int\n            RGBA array of 4 integers from 0 to 255.\n        \"\"\"\n        tmp = self._internal_value * 255\n        tmp[3] = alpha * 255\n        return tmp.astype(int)\n\n\n\n[docs]\n    def to_hex(self, with_alpha: bool = False) -> str:\n        \"\"\"Convert the :class:`ManimColor` to a hexadecimal representation of the color.\n\n        Parameters\n        ----------\n        with_alpha\n            If ``True``, append 2 extra characters to the hex string which represent the\n            alpha value of the color between 0 and 255. Default is ``False``.\n\n        Returns\n        -------\n        str\n            A hex string starting with a ``#``, with either 6 or 8 nibbles depending on\n            the ``with_alpha`` parameter. By default, it has 6 nibbles, i.e. ``#XXXXXX``.\n        \"\"\"\n        tmp = (\n            f\"#{int(self._internal_value[0] * 255):02X}\"\n            f\"{int(self._internal_value[1] * 255):02X}\"\n            f\"{int(self._internal_value[2] * 255):02X}\"\n        )\n        if with_alpha:\n            tmp += f\"{int(self._internal_value[3] * 255):02X}\"\n        return tmp\n\n\n\n[docs]\n    def to_hsv(self) -> HSV_Array_Float:\n        \"\"\"Convert the :class:`ManimColor` to an HSV array.\n\n        .. note::\n           Be careful: this returns an array in the form ``[h, s, v]``, where the\n           elements are floats. This might be confusing, because RGB can also be an array\n           of floats. You might want to annotate the usage of this function in your code\n           by typing your HSV array variables as :class:`HSV_Array_Float` in order to\n           differentiate them from RGB arrays.\n\n        Returns\n        -------\n        HSV_Array_Float\n            An HSV array of 3 floats from 0.0 to 1.0.\n        \"\"\"\n        return np.array(colorsys.rgb_to_hsv(*self.to_rgb()))\n\n\n\n[docs]\n    def to_hsl(self) -> HSL_Array_Float:\n        \"\"\"Convert the :class:`ManimColor` to an HSL array.\n\n        .. note::\n           Be careful: this returns an array in the form ``[h, s, l]``, where the\n           elements are floats. This might be confusing, because RGB can also be an array\n           of floats. You might want to annotate the usage of this function in your code\n           by typing your HSL array variables as :class:`HSL_Array_Float` in order to\n           differentiate them from RGB arrays.\n\n        Returns\n        -------\n        HSL_Array_Float\n            An HSL array of 3 floats from 0.0 to 1.0.\n        \"\"\"\n        return np.array(colorsys.rgb_to_hls(*self.to_rgb()))\n\n\n\n[docs]\n    def invert(self, with_alpha: bool = False) -> Self:\n        \"\"\"Return a new, linearly inverted version of this :class:`ManimColor` (no\n        inplace changes).\n\n        Parameters\n        ----------\n        with_alpha\n            If ``True``, the alpha value will be inverted too. Default is ``False``.\n\n            .. note::\n                Setting ``with_alpha=True`` can result in unintended behavior where\n                objects are not displayed because their new alpha value is suddenly 0 or\n                very low.\n\n        Returns\n        -------\n        ManimColor\n            The linearly inverted :class:`ManimColor`.\n        \"\"\"\n        if with_alpha:\n            return self._construct_from_space(1.0 - self._internal_space)\n        else:\n            alpha = self._internal_space[3]\n            new = 1.0 - self._internal_space\n            new[-1] = alpha\n            return self._construct_from_space(new)\n\n\n\n[docs]\n    def interpolate(self, other: Self, alpha: float) -> Self:\n        \"\"\"Interpolate between the current and the given :class:`ManimColor`, and return\n        the result.\n\n        Parameters\n        ----------\n        other\n            The other :class:`ManimColor` to be used for interpolation.\n        alpha\n            A point on the line in RGBA colorspace connecting the two colors, i.e. the\n            interpolation point. 0.0 corresponds to the current :class:`ManimColor` and\n            1.0 corresponds to the other :class:`ManimColor`.\n\n        Returns\n        -------\n        ManimColor\n            The interpolated :class:`ManimColor`.\n        \"\"\"\n        return self._construct_from_space(\n            self._internal_space * (1 - alpha) + other._internal_space * alpha\n        )\n\n\n\n[docs]\n    def darker(self, blend: float = 0.2) -> Self:\n        \"\"\"Return a new color that is darker than the current color, i.e.\n        interpolated with ``BLACK``. The opacity is unchanged.\n\n        Parameters\n        ----------\n        blend\n            The blend ratio for the interpolation, from 0.0 (the current color\n            unchanged) to 1.0 (pure black). Default is 0.2, which results in a\n            slightly darker color.\n\n        Returns\n        -------\n        ManimColor\n            The darker :class:`ManimColor`.\n\n        See Also\n        --------\n        :meth:`lighter`\n        \"\"\"\n        from manim.utils.color.manim_colors import BLACK\n\n        alpha = self._internal_space[3]\n        black = self._from_internal(BLACK._internal_value)\n        return self.interpolate(black, blend).opacity(alpha)\n\n\n\n[docs]\n    def lighter(self, blend: float = 0.2) -> Self:\n        \"\"\"Return a new color that is lighter than the current color, i.e.\n        interpolated with ``WHITE``. The opacity is unchanged.\n\n        Parameters\n        ----------\n        blend\n            The blend ratio for the interpolation, from 0.0 (the current color\n            unchanged) to 1.0 (pure white). Default is 0.2, which results in a\n            slightly lighter color.\n\n        Returns\n        -------\n        ManimColor\n            The lighter :class:`ManimColor`.\n\n        See Also\n        --------\n        :meth:`darker`\n        \"\"\"\n        from manim.utils.color.manim_colors import WHITE\n\n        alpha = self._internal_space[3]\n        white = self._from_internal(WHITE._internal_value)\n        return self.interpolate(white, blend).opacity(alpha)\n\n\n\n[docs]\n    def contrasting(\n        self,\n        threshold: float = 0.5,\n        light: Self | None = None,\n        dark: Self | None = None,\n    ) -> Self:\n        \"\"\"Return one of two colors, light or dark (by default white or black),\n        that contrasts with the current color (depending on its luminance).\n        This is typically used to set text in a contrasting color that ensures\n        it is readable against a background of the current color.\n\n        Parameters\n        ----------\n        threshold\n            The luminance threshold which dictates whether the current color is\n            considered light or dark (and thus whether to return the dark or\n            light color, respectively). Default is 0.5.\n        light\n            The light color to return if the current color is considered dark.\n            Default is ``None``: in this case, pure ``WHITE`` will be returned.\n        dark\n            The dark color to return if the current color is considered light,\n            Default is ``None``: in this case, pure ``BLACK`` will be returned.\n\n        Returns\n        -------\n        ManimColor\n            The contrasting :class:`ManimColor`.\n        \"\"\"\n        from manim.utils.color.manim_colors import BLACK, WHITE\n\n        luminance, _, _ = colorsys.rgb_to_yiq(*self.to_rgb())\n        if luminance < threshold:\n            if light is not None:\n                return light\n            return self._from_internal(WHITE._internal_value)\n        else:\n            if dark is not None:\n                return dark\n            return self._from_internal(BLACK._internal_value)\n\n\n\n[docs]\n    def opacity(self, opacity: float) -> Self:\n        \"\"\"Create a new :class:`ManimColor` with the given opacity and the same color\n        values as before.\n\n        Parameters\n        ----------\n        opacity\n            The new opacity value to be used.\n\n        Returns\n        -------\n        ManimColor\n            The new :class:`ManimColor` with the same color values and the new opacity.\n        \"\"\"\n        tmp = self._internal_space.copy()\n        tmp[-1] = opacity\n        return self._construct_from_space(tmp)\n\n\n\n[docs]\n    def into(self, class_type: type[ManimColorT]) -> ManimColorT:\n        \"\"\"Convert the current color into a different colorspace given by ``class_type``,\n        without changing the :attr:`_internal_value`.\n\n        Parameters\n        ----------\n        class_type\n            The class that is used for conversion. It must be a subclass of\n            :class:`ManimColor` which respects the specification HSV, RGBA, ...\n\n        Returns\n        -------\n        ManimColorT\n            A new color object of type ``class_type`` and the same\n            :attr:`_internal_value` as the original color.\n        \"\"\"\n        return class_type._from_internal(self._internal_value)\n\n\n\n[docs]\n    @classmethod\n    def _from_internal(cls, value: ManimColorInternal) -> Self:\n        \"\"\"This method is intended to be overwritten by custom color space classes\n        which are subtypes of :class:`ManimColor`.\n\n        The method constructs a new object of the given class by transforming the value\n        in the internal format ``[r,g,b,a]`` into a format which the constructor of the\n        custom class can understand. Look at :class:`.HSV` for an example.\n        \"\"\"\n        return cls(value)\n\n\n\n[docs]\n    @classmethod\n    def from_rgb(\n        cls,\n        rgb: RGB_Array_Float | RGB_Tuple_Float | RGB_Array_Int | RGB_Tuple_Int,\n        alpha: float = 1.0,\n    ) -> Self:\n        \"\"\"Create a ManimColor from an RGB array. Automagically decides which type it\n        is: ``int`` or ``float``.\n\n        .. warning::\n            Please make sure that your elements are not floats if you want integers. A\n            ``5.0`` will result in the input being interpreted as if it was an RGB float\n            array with the value ``5.0`` and not the integer ``5``.\n\n\n        Parameters\n        ----------\n        rgb\n            Any iterable of 3 floats or 3 integers.\n        alpha\n            Alpha value to be used in the color. Default is 1.0.\n\n        Returns\n        -------\n        ManimColor\n            The :class:`ManimColor` which corresponds to the given ``rgb``.\n        \"\"\"\n        return cls._from_internal(ManimColor(rgb, alpha)._internal_value)\n\n\n\n[docs]\n    @classmethod\n    def from_rgba(\n        cls, rgba: RGBA_Array_Float | RGBA_Tuple_Float | RGBA_Array_Int | RGBA_Tuple_Int\n    ) -> Self:\n        \"\"\"Create a ManimColor from an RGBA Array. Automagically decides which type it\n        is: ``int`` or ``float``.\n\n        .. warning::\n            Please make sure that your elements are not floats if you want integers. A\n            ``5.0`` will result in the input being interpreted as if it was a float RGB\n            array with the float ``5.0`` and not the integer ``5``.\n\n        Parameters\n        ----------\n        rgba\n            Any iterable of 4 floats or 4 integers.\n\n        Returns\n        -------\n        ManimColor\n            The :class:`ManimColor` corresponding to the given ``rgba``.\n        \"\"\"\n        return cls(rgba)\n\n\n\n[docs]\n    @classmethod\n    def from_hex(cls, hex_str: str, alpha: float = 1.0) -> Self:\n        \"\"\"Create a :class:`ManimColor` from a hex string.\n\n        Parameters\n        ----------\n        hex_str\n            The hex string to be converted.  The allowed prefixes for this string are\n            ``#`` and ``0x``. Currently, this method only supports 6 nibbles, i.e. only\n            strings in the format ``#XXXXXX`` or ``0xXXXXXX``.\n        alpha\n            Alpha value to be used for the hex string. Default is 1.0.\n\n        Returns\n        -------\n        ManimColor\n            The :class:`ManimColor` represented by the hex string.\n        \"\"\"\n        return cls._from_internal(ManimColor(hex_str, alpha)._internal_value)\n\n\n\n[docs]\n    @classmethod\n    def from_hsv(\n        cls, hsv: HSV_Array_Float | HSV_Tuple_Float, alpha: float = 1.0\n    ) -> Self:\n        \"\"\"Create a :class:`ManimColor` from an HSV array.\n\n        Parameters\n        ----------\n        hsv\n            Any iterable containing 3 floats from 0.0 to 1.0.\n        alpha\n            The alpha value to be used. Default is 1.0.\n\n        Returns\n        -------\n        ManimColor\n            The :class:`ManimColor` with the corresponding RGB values to the given HSV\n            array.\n        \"\"\"\n        rgb = colorsys.hsv_to_rgb(*hsv)\n        return cls._from_internal(ManimColor(rgb, alpha)._internal_value)\n\n\n\n[docs]\n    @classmethod\n    def from_hsl(\n        cls, hsl: HSL_Array_Float | HSL_Tuple_Float, alpha: float = 1.0\n    ) -> Self:\n        \"\"\"Create a :class:`ManimColor` from an HSL array.\n\n        Parameters\n        ----------\n        hsl\n            Any iterable containing 3 floats from 0.0 to 1.0.\n        alpha\n            The alpha value to be used. Default is 1.0.\n\n        Returns\n        -------\n        ManimColor\n            The :class:`ManimColor` with the corresponding RGB values to the given HSL\n            array.\n        \"\"\"\n        rgb = colorsys.hls_to_rgb(*hsl)\n        return cls._from_internal(ManimColor(rgb, alpha)._internal_value)\n\n\n    @overload\n    @classmethod\n    def parse(\n        cls,\n        color: ParsableManimColor | None,\n        alpha: float = ...,\n    ) -> Self: ...\n\n    @overload\n    @classmethod\n    def parse(\n        cls,\n        color: Sequence[ParsableManimColor],\n        alpha: float = ...,\n    ) -> list[Self]: ...\n\n\n[docs]\n    @classmethod\n    def parse(\n        cls,\n        color: ParsableManimColor | Sequence[ParsableManimColor] | None,\n        alpha: float = 1.0,\n    ) -> Self | list[Self]:\n        \"\"\"Parse one color as a :class:`ManimColor` or a sequence of colors as a list of\n        :class:`ManimColor`'s.\n\n        Parameters\n        ----------\n        color\n            The color or list of colors to parse. Note that this function can not accept\n            tuples: it will assume that you mean ``Sequence[ParsableManimColor]`` and will\n            return a ``list[ManimColor]``.\n        alpha\n            The alpha (opacity) value to use for the passed color(s).\n\n        Returns\n        -------\n        ManimColor | list[ManimColor]\n            Either a list of colors or a singular color, depending on the input.\n        \"\"\"\n\n        def is_sequence(\n            color: ParsableManimColor | Sequence[ParsableManimColor] | None,\n        ) -> TypeIs[Sequence[ParsableManimColor]]:\n            return isinstance(color, (list, tuple))\n\n        if is_sequence(color):\n            return [\n                cls._from_internal(ManimColor(c, alpha)._internal_value) for c in color\n            ]\n        else:\n            return cls._from_internal(ManimColor(color, alpha)._internal_value)\n\n\n\n[docs]\n    @staticmethod\n    def gradient(\n        colors: list[ManimColor], length: int\n    ) -> ManimColor | list[ManimColor]:\n        \"\"\"This method is currently not implemented. Refer to :func:`color_gradient` for\n        a working implementation for now.\n        \"\"\"\n        # TODO: implement proper gradient, research good implementation for this or look at 3b1b implementation\n        raise NotImplementedError\n\n\n    def __repr__(self) -> str:\n        return f\"{self.__class__.__name__}('{self.to_hex()}')\"\n\n    def __str__(self) -> str:\n        return f\"{self.to_hex()}\"\n\n    def __eq__(self, other: object) -> bool:\n        if not isinstance(other, ManimColor):\n            raise TypeError(\n                f\"Cannot compare {self.__class__.__name__} with {other.__class__.__name__}\"\n            )\n        are_equal: bool = np.allclose(self._internal_value, other._internal_value)\n        return are_equal\n\n    def __add__(self, other: int | float | Self) -> Self:\n        if isinstance(other, (int, float)):\n            return self._construct_from_space(self._internal_space + other)\n        else:\n            return self._construct_from_space(\n                self._internal_space + other._internal_space\n            )\n\n    def __radd__(self, other: int | float | Self) -> Self:\n        return self + other\n\n    def __sub__(self, other: int | float | Self) -> Self:\n        if isinstance(other, (int, float)):\n            return self._construct_from_space(self._internal_space - other)\n        else:\n            return self._construct_from_space(\n                self._internal_space - other._internal_space\n            )\n\n    def __rsub__(self, other: int | float | Self) -> Self:\n        return self - other\n\n    def __mul__(self, other: int | float | Self) -> Self:\n        if isinstance(other, (int, float)):\n            return self._construct_from_space(self._internal_space * other)\n        else:\n            return self._construct_from_space(\n                self._internal_space * other._internal_space\n            )\n\n    def __rmul__(self, other: int | float | Self) -> Self:\n        return self * other\n\n    def __truediv__(self, other: int | float | Self) -> Self:\n        if isinstance(other, (int, float)):\n            return self._construct_from_space(self._internal_space / other)\n        else:\n            return self._construct_from_space(\n                self._internal_space / other._internal_space\n            )\n\n    def __rtruediv__(self, other: int | float | Self) -> Self:\n        return self / other\n\n    def __floordiv__(self, other: int | float | Self) -> Self:\n        if isinstance(other, (int, float)):\n            return self._construct_from_space(self._internal_space // other)\n        else:\n            return self._construct_from_space(\n                self._internal_space // other._internal_space\n            )\n\n    def __rfloordiv__(self, other: int | float | Self) -> Self:\n        return self // other\n\n    def __mod__(self, other: int | float | Self) -> Self:\n        if isinstance(other, (int, float)):\n            return self._construct_from_space(self._internal_space % other)\n        else:\n            return self._construct_from_space(\n                self._internal_space % other._internal_space\n            )\n\n    def __rmod__(self, other: int | float | Self) -> Self:\n        return self % other\n\n    def __pow__(self, other: int | float | Self) -> Self:\n        if isinstance(other, (int, float)):\n            return self._construct_from_space(self._internal_space**other)\n        else:\n            return self._construct_from_space(\n                self._internal_space**other._internal_space\n            )\n\n    def __rpow__(self, other: int | float | Self) -> Self:\n        return self**other\n\n    def __invert__(self) -> Self:\n        return self.invert()\n\n    def __int__(self) -> int:\n        return self.to_integer()\n\n    def __getitem__(self, index: int) -> float:\n        item: float = self._internal_space[index]\n        return item\n\n    def __and__(self, other: Self) -> Self:\n        return self._construct_from_space(\n            self._internal_from_integer(self.to_integer() & int(other), 1.0)\n        )\n\n    def __or__(self, other: Self) -> Self:\n        return self._construct_from_space(\n            self._internal_from_integer(self.to_integer() | int(other), 1.0)\n        )\n\n    def __xor__(self, other: Self) -> Self:\n        return self._construct_from_space(\n            self._internal_from_integer(self.to_integer() ^ int(other), 1.0)\n        )\n\n    def __hash__(self) -> int:\n        return hash(self.to_hex(with_alpha=True))\n\n\n\nRGBA = ManimColor\n\"\"\"RGBA Color Space\"\"\"\n\n\n\n[docs]\nclass HSV(ManimColor):\n    \"\"\"HSV Color Space\"\"\"\n\n    def __init__(\n        self,\n        hsv: HSV_Array_Float | HSV_Tuple_Float | HSVA_Array_Float | HSVA_Tuple_Float,\n        alpha: float = 1.0,\n    ) -> None:\n        super().__init__(None)\n        self.__hsv: HSVA_Array_Float\n        if len(hsv) == 3:\n            self.__hsv = np.asarray((*hsv, alpha))\n        elif len(hsv) == 4:\n            self.__hsv = np.asarray(hsv)\n        else:\n            raise ValueError(\"HSV Color must be an array of 3 values\")\n\n\n[docs]\n    @classmethod\n    @override\n    def _from_internal(cls, value: ManimColorInternal) -> Self:\n        hsv = colorsys.rgb_to_hsv(*value[:3])\n        hsva = [*hsv, value[-1]]\n        return cls(np.array(hsva))\n\n\n    @property\n    def hue(self) -> float:\n        hue: float = self.__hsv[0]\n        return hue\n\n    @hue.setter\n    def hue(self, hue: float) -> None:\n        self.__hsv[0] = hue\n\n    @property\n    def saturation(self) -> float:\n        saturation: float = self.__hsv[1]\n        return saturation\n\n    @saturation.setter\n    def saturation(self, saturation: float) -> None:\n        self.__hsv[1] = saturation\n\n    @property\n    def value(self) -> float:\n        value: float = self.__hsv[2]\n        return value\n\n    @value.setter\n    def value(self, value: float) -> None:\n        self.__hsv[2] = value\n\n    @property\n    def h(self) -> float:\n        hue: float = self.__hsv[0]\n        return hue\n\n    @h.setter\n    def h(self, hue: float) -> None:\n        self.__hsv[0] = hue\n\n    @property\n    def s(self) -> float:\n        saturation: float = self.__hsv[1]\n        return saturation\n\n    @s.setter\n    def s(self, saturation: float) -> None:\n        self.__hsv[1] = saturation\n\n    @property\n    def v(self) -> float:\n        value: float = self.__hsv[2]\n        return value\n\n    @v.setter\n    def v(self, value: float) -> None:\n        self.__hsv[2] = value\n\n    @property\n    def _internal_space(self) -> npt.NDArray:\n        return self.__hsv\n\n    @property\n    def _internal_value(self) -> ManimColorInternal:\n        \"\"\"Return the internal value of the current :class:`ManimColor` as an\n        ``[r,g,b,a]`` float array.\n\n        Returns\n        -------\n        ManimColorInternal\n            Internal color representation.\n        \"\"\"\n        return np.array(\n            [\n                *colorsys.hsv_to_rgb(self.__hsv[0], self.__hsv[1], self.__hsv[2]),\n                self.__alpha,\n            ],\n            dtype=ManimColorDType,\n        )\n\n    @_internal_value.setter\n    def _internal_value(self, value: ManimColorInternal) -> None:\n        \"\"\"Overwrite the internal color value of this :class:`ManimColor`.\n\n        Parameters\n        ----------\n        value\n            The value which will overwrite the current color.\n\n        Raises\n        ------\n        TypeError\n            If an invalid array is passed.\n        \"\"\"\n        if not isinstance(value, np.ndarray):\n            raise TypeError(\"Value must be a NumPy array.\")\n        if value.shape[0] != 4:\n            raise TypeError(\"Array must have exactly 4 values.\")\n        tmp = colorsys.rgb_to_hsv(value[0], value[1], value[2])\n        self.__hsv = np.array(tmp)\n        self.__alpha = value[3]\n\n\n\nParsableManimColor: TypeAlias = Union[\n    ManimColor,\n    int,\n    str,\n    RGB_Tuple_Int,\n    RGB_Tuple_Float,\n    RGBA_Tuple_Int,\n    RGBA_Tuple_Float,\n    RGB_Array_Int,\n    RGB_Array_Float,\n    RGBA_Array_Int,\n    RGBA_Array_Float,\n]\n\"\"\"`ParsableManimColor` represents all the types which can be parsed\nto a :class:`ManimColor` in Manim.\n\"\"\"\n\n\nManimColorT = TypeVar(\"ManimColorT\", bound=ManimColor)\n\n\n\n[docs]\ndef color_to_rgb(color: ParsableManimColor) -> RGB_Array_Float:\n    \"\"\"Helper function for use in functional style programming.\n    Refer to :meth:`ManimColor.to_rgb`.\n\n    Parameters\n    ----------\n    color\n        A color to convert to an RGB float array.\n\n    Returns\n    -------\n    RGB_Array_Float\n        The corresponding RGB float array.\n    \"\"\"\n    return ManimColor(color).to_rgb()\n\n\n\n\n[docs]\ndef color_to_rgba(color: ParsableManimColor, alpha: float = 1.0) -> RGBA_Array_Float:\n    \"\"\"Helper function for use in functional style programming. Refer to\n    :meth:`ManimColor.to_rgba_with_alpha`.\n\n    Parameters\n    ----------\n    color\n        A color to convert to an RGBA float array.\n    alpha\n        An alpha value between 0.0 and 1.0 to be used as opacity in the color. Default is\n        1.0.\n\n    Returns\n    -------\n    RGBA_Array_Float\n        The corresponding RGBA float array.\n    \"\"\"\n    return ManimColor(color).to_rgba_with_alpha(alpha)\n\n\n\n\n[docs]\ndef color_to_int_rgb(color: ParsableManimColor) -> RGB_Array_Int:\n    \"\"\"Helper function for use in functional style programming. Refer to\n    :meth:`ManimColor.to_int_rgb`.\n\n    Parameters\n    ----------\n    color\n        A color to convert to an RGB integer array.\n\n    Returns\n    -------\n    RGB_Array_Int\n        The corresponding RGB integer array.\n    \"\"\"\n    return ManimColor(color).to_int_rgb()\n\n\n\n\n[docs]\ndef color_to_int_rgba(color: ParsableManimColor, alpha: float = 1.0) -> RGBA_Array_Int:\n    \"\"\"Helper function for use in functional style programming. Refer to\n    :meth:`ManimColor.to_int_rgba_with_alpha`.\n\n    Parameters\n    ----------\n    color\n        A color to convert to an RGBA integer array.\n    alpha\n        An alpha value between 0.0 and 1.0 to be used as opacity in the color. Default is\n        1.0.\n\n    Returns\n    -------\n    RGBA_Array_Int\n        The corresponding RGBA integer array.\n    \"\"\"\n    return ManimColor(color).to_int_rgba_with_alpha(alpha)\n\n\n\n\n[docs]\ndef rgb_to_color(\n    rgb: RGB_Array_Float | RGB_Tuple_Float | RGB_Array_Int | RGB_Tuple_Int,\n) -> ManimColor:\n    \"\"\"Helper function for use in functional style programming. Refer to\n    :meth:`ManimColor.from_rgb`.\n\n    Parameters\n    ----------\n    rgb\n        A 3 element iterable.\n\n    Returns\n    -------\n    ManimColor\n        A ManimColor with the corresponding value.\n    \"\"\"\n    return ManimColor.from_rgb(rgb)\n\n\n\n\n[docs]\ndef rgba_to_color(\n    rgba: RGBA_Array_Float | RGBA_Tuple_Float | RGBA_Array_Int | RGBA_Tuple_Int,\n) -> ManimColor:\n    \"\"\"Helper function for use in functional style programming. Refer to\n    :meth:`ManimColor.from_rgba`.\n\n    Parameters\n    ----------\n    rgba\n        A 4 element iterable.\n\n    Returns\n    -------\n    ManimColor\n        A ManimColor with the corresponding value\n    \"\"\"\n    return ManimColor.from_rgba(rgba)\n\n\n\n\n[docs]\ndef rgb_to_hex(\n    rgb: RGB_Array_Float | RGB_Tuple_Float | RGB_Array_Int | RGB_Tuple_Int,\n) -> str:\n    \"\"\"Helper function for use in functional style programming. Refer to\n    :meth:`ManimColor.from_rgb` and :meth:`ManimColor.to_hex`.\n\n    Parameters\n    ----------\n    rgb\n        A 3 element iterable.\n\n    Returns\n    -------\n    str\n        A hex representation of the color.\n    \"\"\"\n    return ManimColor.from_rgb(rgb).to_hex()\n\n\n\n\n[docs]\ndef hex_to_rgb(hex_code: str) -> RGB_Array_Float:\n    \"\"\"Helper function for use in functional style programming. Refer to\n    :meth:`ManimColor.to_rgb`.\n\n    Parameters\n    ----------\n    hex_code\n        A hex string representing a color.\n\n    Returns\n    -------\n    RGB_Array_Float\n        An RGB array representing the color.\n    \"\"\"\n    return ManimColor(hex_code).to_rgb()\n\n\n\n\n[docs]\ndef invert_color(color: ManimColorT) -> ManimColorT:\n    \"\"\"Helper function for use in functional style programming. Refer to\n    :meth:`ManimColor.invert`\n\n    Parameters\n    ----------\n    color\n        The :class:`ManimColor` to invert.\n\n    Returns\n    -------\n    ManimColor\n        The linearly inverted :class:`ManimColor`.\n    \"\"\"\n    return color.invert()\n\n\n\n\n[docs]\ndef color_gradient(\n    reference_colors: Sequence[ParsableManimColor],\n    length_of_output: int,\n) -> list[ManimColor] | ManimColor:\n    \"\"\"Create a list of colors interpolated between the input array of colors with a\n    specific number of colors.\n\n    Parameters\n    ----------\n    reference_colors\n        The colors to be interpolated between or spread apart.\n    length_of_output\n        The number of colors that the output should have, ideally more than the input.\n\n    Returns\n    -------\n    list[ManimColor] | ManimColor\n        A :class:`ManimColor` or a list of interpolated :class:`ManimColor`'s.\n    \"\"\"\n    if length_of_output == 0:\n        return ManimColor(reference_colors[0])\n    if len(reference_colors) == 1:\n        return [ManimColor(reference_colors[0])] * length_of_output\n    rgbs = [color_to_rgb(color) for color in reference_colors]\n    alphas = np.linspace(0, (len(rgbs) - 1), length_of_output)\n    floors = alphas.astype(\"int\")\n    alphas_mod1 = alphas % 1\n    # End edge case\n    alphas_mod1[-1] = 1\n    floors[-1] = len(rgbs) - 2\n    return [\n        rgb_to_color((rgbs[i] * (1 - alpha)) + (rgbs[i + 1] * alpha))\n        for i, alpha in zip(floors, alphas_mod1)\n    ]\n\n\n\n\n[docs]\ndef interpolate_color(\n    color1: ManimColorT, color2: ManimColorT, alpha: float\n) -> ManimColorT:\n    \"\"\"Standalone function to interpolate two ManimColors and get the result. Refer to\n    :meth:`ManimColor.interpolate`.\n\n    Parameters\n    ----------\n    color1\n        The first :class:`ManimColor`.\n    color2\n        The second :class:`ManimColor`.\n    alpha\n        The alpha value determining the point of interpolation between the colors.\n\n    Returns\n    -------\n    ManimColor\n        The interpolated ManimColor.\n    \"\"\"\n    return color1.interpolate(color2, alpha)\n\n\n\n\n[docs]\ndef average_color(*colors: ParsableManimColor) -> ManimColor:\n    \"\"\"Determine the average color between the given parameters.\n\n    .. note::\n        This operation does not consider the alphas (opacities) of the colors. The\n        generated color has an alpha or opacity of 1.0.\n\n    Returns\n    -------\n    ManimColor\n        The average color of the input.\n    \"\"\"\n    rgbs = np.array([color_to_rgb(color) for color in colors])\n    mean_rgb = np.apply_along_axis(np.mean, 0, rgbs)\n    return rgb_to_color(mean_rgb)\n\n\n\n\n[docs]\ndef random_bright_color() -> ManimColor:\n    \"\"\"Return a random bright color: a random color averaged with ``WHITE``.\n\n    .. warning::\n        This operation is very expensive. Please keep in mind the performance loss.\n\n    Returns\n    -------\n    ManimColor\n        A random bright :class:`ManimColor`.\n    \"\"\"\n    curr_rgb = color_to_rgb(random_color())\n    new_rgb = 0.5 * (curr_rgb + np.ones(3))\n    return ManimColor(new_rgb)\n\n\n\n\n[docs]\ndef random_color() -> ManimColor:\n    \"\"\"Return a random :class:`ManimColor`.\n\n    .. warning::\n        This operation is very expensive. Please keep in mind the performance loss.\n\n    Returns\n    -------\n    ManimColor\n        A random :class:`ManimColor`.\n    \"\"\"\n    import manim.utils.color.manim_colors as manim_colors\n\n    return random.choice(manim_colors._all_manim_colors)\n\n\n\n\n[docs]\ndef get_shaded_rgb(\n    rgb: RGB_Array_Float,\n    point: Point3D,\n    unit_normal_vect: Vector3D,\n    light_source: Point3D,\n) -> RGB_Array_Float:\n    \"\"\"Add light or shadow to the ``rgb`` color of some surface which is located at a\n    given ``point`` in space and facing in the direction of ``unit_normal_vect``,\n    depending on whether the surface is facing a ``light_source`` or away from it.\n\n    Parameters\n    ----------\n    rgb\n        An RGB array of floats.\n    point\n        The location of the colored surface.\n    unit_normal_vect\n        The direction in which the colored surface is facing.\n    light_source\n        The location of a light source which might illuminate the surface.\n\n    Returns\n    -------\n    RGB_Array_Float\n        The color with added light or shadow, depending on the direction of the colored\n        surface.\n    \"\"\"\n    to_sun = normalize(light_source - point)\n    light = 0.5 * np.dot(unit_normal_vect, to_sun) ** 3\n    if light < 0:\n        light *= 0.5\n    shaded_rgb: RGB_Array_Float = rgb + light\n    return shaded_rgb\n\n\n\n__all__ = [\n    \"ManimColor\",\n    \"ManimColorDType\",\n    \"ParsableManimColor\",\n    \"color_to_rgb\",\n    \"color_to_rgba\",\n    \"color_to_int_rgb\",\n    \"color_to_int_rgba\",\n    \"rgb_to_color\",\n    \"rgba_to_color\",\n    \"rgb_to_hex\",\n    \"hex_to_rgb\",\n    \"invert_color\",\n    \"color_gradient\",\n    \"interpolate_color\",\n    \"average_color\",\n    \"random_bright_color\",\n    \"random_color\",\n    \"get_shaded_rgb\",\n    \"HSV\",\n    \"RGBA\",\n]", "code_sha1": "29fa9857b858e0bd8b14e9aa6ffe256bdaa256a3"}
{"url": "https://docs.manim.community/en/stable/_modules/manim/constants.html", "depth": 2, "instruction": "The code defines constants and enumerations for use in Manim, including messages, font styles, geometric directions, video qualities, and rendering types. It does not produce any visual output or animations.", "code": "\"\"\"Constant definitions.\"\"\"\n\nfrom __future__ import annotations\n\nfrom enum import Enum\nfrom typing import TypedDict\n\nimport numpy as np\nfrom cloup import Context\nfrom PIL.Image import Resampling\n\nfrom manim.typing import Vector3D\n\n__all__ = [\n    \"SCENE_NOT_FOUND_MESSAGE\",\n    \"CHOOSE_NUMBER_MESSAGE\",\n    \"INVALID_NUMBER_MESSAGE\",\n    \"NO_SCENE_MESSAGE\",\n    \"NORMAL\",\n    \"ITALIC\",\n    \"OBLIQUE\",\n    \"BOLD\",\n    \"THIN\",\n    \"ULTRALIGHT\",\n    \"LIGHT\",\n    \"SEMILIGHT\",\n    \"BOOK\",\n    \"MEDIUM\",\n    \"SEMIBOLD\",\n    \"ULTRABOLD\",\n    \"HEAVY\",\n    \"ULTRAHEAVY\",\n    \"RESAMPLING_ALGORITHMS\",\n    \"ORIGIN\",\n    \"UP\",\n    \"DOWN\",\n    \"RIGHT\",\n    \"LEFT\",\n    \"IN\",\n    \"OUT\",\n    \"X_AXIS\",\n    \"Y_AXIS\",\n    \"Z_AXIS\",\n    \"UL\",\n    \"UR\",\n    \"DL\",\n    \"DR\",\n    \"START_X\",\n    \"START_Y\",\n    \"DEFAULT_DOT_RADIUS\",\n    \"DEFAULT_SMALL_DOT_RADIUS\",\n    \"DEFAULT_DASH_LENGTH\",\n    \"DEFAULT_ARROW_TIP_LENGTH\",\n    \"SMALL_BUFF\",\n    \"MED_SMALL_BUFF\",\n    \"MED_LARGE_BUFF\",\n    \"LARGE_BUFF\",\n    \"DEFAULT_MOBJECT_TO_EDGE_BUFFER\",\n    \"DEFAULT_MOBJECT_TO_MOBJECT_BUFFER\",\n    \"DEFAULT_POINTWISE_FUNCTION_RUN_TIME\",\n    \"DEFAULT_WAIT_TIME\",\n    \"DEFAULT_POINT_DENSITY_2D\",\n    \"DEFAULT_POINT_DENSITY_1D\",\n    \"DEFAULT_STROKE_WIDTH\",\n    \"DEFAULT_FONT_SIZE\",\n    \"SCALE_FACTOR_PER_FONT_POINT\",\n    \"PI\",\n    \"TAU\",\n    \"DEGREES\",\n    \"QUALITIES\",\n    \"DEFAULT_QUALITY\",\n    \"EPILOG\",\n    \"CONTEXT_SETTINGS\",\n    \"SHIFT_VALUE\",\n    \"CTRL_VALUE\",\n    \"RendererType\",\n    \"LineJointType\",\n    \"CapStyleType\",\n]\n# Messages\n\nSCENE_NOT_FOUND_MESSAGE = \"\"\"\n   {} is not in the script\n\"\"\"\nCHOOSE_NUMBER_MESSAGE = \"\"\"\nChoose number corresponding to desired scene/arguments.\n(Use comma separated list for multiple entries)\nChoice(s): \"\"\"\nINVALID_NUMBER_MESSAGE = \"Invalid scene numbers have been specified. Aborting.\"\nNO_SCENE_MESSAGE = \"\"\"\n   There are no scenes inside that module\n\"\"\"\n\n# Pango stuff\nNORMAL = \"NORMAL\"\nITALIC = \"ITALIC\"\nOBLIQUE = \"OBLIQUE\"\nBOLD = \"BOLD\"\n# Only for Pango from below\nTHIN = \"THIN\"\nULTRALIGHT = \"ULTRALIGHT\"\nLIGHT = \"LIGHT\"\nSEMILIGHT = \"SEMILIGHT\"\nBOOK = \"BOOK\"\nMEDIUM = \"MEDIUM\"\nSEMIBOLD = \"SEMIBOLD\"\nULTRABOLD = \"ULTRABOLD\"\nHEAVY = \"HEAVY\"\nULTRAHEAVY = \"ULTRAHEAVY\"\n\nRESAMPLING_ALGORITHMS = {\n    \"nearest\": Resampling.NEAREST,\n    \"none\": Resampling.NEAREST,\n    \"lanczos\": Resampling.LANCZOS,\n    \"antialias\": Resampling.LANCZOS,\n    \"bilinear\": Resampling.BILINEAR,\n    \"linear\": Resampling.BILINEAR,\n    \"bicubic\": Resampling.BICUBIC,\n    \"cubic\": Resampling.BICUBIC,\n    \"box\": Resampling.BOX,\n    \"hamming\": Resampling.HAMMING,\n}\n\n# Geometry: directions\nORIGIN: Vector3D = np.array((0.0, 0.0, 0.0))\n\"\"\"The center of the coordinate system.\"\"\"\n\nUP: Vector3D = np.array((0.0, 1.0, 0.0))\n\"\"\"One unit step in the positive Y direction.\"\"\"\n\nDOWN: Vector3D = np.array((0.0, -1.0, 0.0))\n\"\"\"One unit step in the negative Y direction.\"\"\"\n\nRIGHT: Vector3D = np.array((1.0, 0.0, 0.0))\n\"\"\"One unit step in the positive X direction.\"\"\"\n\nLEFT: Vector3D = np.array((-1.0, 0.0, 0.0))\n\"\"\"One unit step in the negative X direction.\"\"\"\n\nIN: Vector3D = np.array((0.0, 0.0, -1.0))\n\"\"\"One unit step in the negative Z direction.\"\"\"\n\nOUT: Vector3D = np.array((0.0, 0.0, 1.0))\n\"\"\"One unit step in the positive Z direction.\"\"\"\n\n# Geometry: axes\nX_AXIS: Vector3D = np.array((1.0, 0.0, 0.0))\nY_AXIS: Vector3D = np.array((0.0, 1.0, 0.0))\nZ_AXIS: Vector3D = np.array((0.0, 0.0, 1.0))\n\n# Geometry: useful abbreviations for diagonals\nUL: Vector3D = UP + LEFT\n\"\"\"One step up plus one step left.\"\"\"\n\nUR: Vector3D = UP + RIGHT\n\"\"\"One step up plus one step right.\"\"\"\n\nDL: Vector3D = DOWN + LEFT\n\"\"\"One step down plus one step left.\"\"\"\n\nDR: Vector3D = DOWN + RIGHT\n\"\"\"One step down plus one step right.\"\"\"\n\n# Geometry\nSTART_X = 30\nSTART_Y = 20\nDEFAULT_DOT_RADIUS = 0.08\nDEFAULT_SMALL_DOT_RADIUS = 0.04\nDEFAULT_DASH_LENGTH = 0.05\nDEFAULT_ARROW_TIP_LENGTH = 0.35\n\n# Default buffers (padding)\nSMALL_BUFF = 0.1\nMED_SMALL_BUFF = 0.25\nMED_LARGE_BUFF = 0.5\nLARGE_BUFF = 1\nDEFAULT_MOBJECT_TO_EDGE_BUFFER = MED_LARGE_BUFF\nDEFAULT_MOBJECT_TO_MOBJECT_BUFFER = MED_SMALL_BUFF\n\n# Times in seconds\nDEFAULT_POINTWISE_FUNCTION_RUN_TIME = 3.0\nDEFAULT_WAIT_TIME = 1.0\n\n# Misc\nDEFAULT_POINT_DENSITY_2D = 25\nDEFAULT_POINT_DENSITY_1D = 10\nDEFAULT_STROKE_WIDTH = 4\nDEFAULT_FONT_SIZE = 48\nSCALE_FACTOR_PER_FONT_POINT = 1 / 960\n\n# Mathematical constants\nPI = np.pi\n\"\"\"The ratio of the circumference of a circle to its diameter.\"\"\"\n\nTAU = 2 * PI\n\"\"\"The ratio of the circumference of a circle to its radius.\"\"\"\n\nDEGREES = TAU / 360\n\"\"\"The exchange rate between radians and degrees.\"\"\"\n\n\n\n[docs]\nclass QualityDict(TypedDict):\n    flag: str | None\n    pixel_height: int\n    pixel_width: int\n    frame_rate: int\n\n\n\n# Video qualities\nQUALITIES: dict[str, QualityDict] = {\n    \"fourk_quality\": {\n        \"flag\": \"k\",\n        \"pixel_height\": 2160,\n        \"pixel_width\": 3840,\n        \"frame_rate\": 60,\n    },\n    \"production_quality\": {\n        \"flag\": \"p\",\n        \"pixel_height\": 1440,\n        \"pixel_width\": 2560,\n        \"frame_rate\": 60,\n    },\n    \"high_quality\": {\n        \"flag\": \"h\",\n        \"pixel_height\": 1080,\n        \"pixel_width\": 1920,\n        \"frame_rate\": 60,\n    },\n    \"medium_quality\": {\n        \"flag\": \"m\",\n        \"pixel_height\": 720,\n        \"pixel_width\": 1280,\n        \"frame_rate\": 30,\n    },\n    \"low_quality\": {\n        \"flag\": \"l\",\n        \"pixel_height\": 480,\n        \"pixel_width\": 854,\n        \"frame_rate\": 15,\n    },\n    \"example_quality\": {\n        \"flag\": None,\n        \"pixel_height\": 480,\n        \"pixel_width\": 854,\n        \"frame_rate\": 30,\n    },\n}\n\nDEFAULT_QUALITY = \"high_quality\"\n\nEPILOG = \"Made with <3 by Manim Community developers.\"\nSHIFT_VALUE = 65505\nCTRL_VALUE = 65507\n\nCONTEXT_SETTINGS = Context.settings(\n    align_option_groups=True,\n    align_sections=True,\n    show_constraints=True,\n)\n\n\n\n[docs]\nclass RendererType(Enum):\n    \"\"\"An enumeration of all renderer types that can be assigned to\n    the ``config.renderer`` attribute.\n\n    Manim's configuration allows assigning string values to the renderer\n    setting, the values are then replaced by the corresponding enum object.\n    In other words, you can run::\n\n        config.renderer = \"opengl\"\n\n    and checking the renderer afterwards reveals that the attribute has\n    assumed the value::\n\n        <RendererType.OPENGL: 'opengl'>\n    \"\"\"\n\n    CAIRO = \"cairo\"  #: A renderer based on the cairo backend.\n    OPENGL = \"opengl\"  #: An OpenGL-based renderer.\n\n\n\n\n[docs]\nclass LineJointType(Enum):\n    \"\"\"Collection of available line joint types.\n\n    See the example below for a visual illustration of the different\n    joint types.\n\n    Examples\n    --------\n\n    .. manim:: LineJointVariants\n        :save_last_frame:\n\n        class LineJointVariants(Scene):\n            def construct(self):\n                mob = VMobject(stroke_width=20, color=GREEN).set_points_as_corners([\n                    np.array([-2, 0, 0]),\n                    np.array([0, 0, 0]),\n                    np.array([-2, 1, 0]),\n                ])\n                lines = VGroup(*[mob.copy() for _ in range(len(LineJointType))])\n                for line, joint_type in zip(lines, LineJointType):\n                    line.joint_type = joint_type\n\n                lines.arrange(RIGHT, buff=1)\n                self.add(lines)\n                for line in lines:\n                    label = Text(line.joint_type.name).next_to(line, DOWN)\n                    self.add(label)\n    \"\"\"\n\n    AUTO = 0\n    ROUND = 1\n    BEVEL = 2\n    MITER = 3\n\n\n\n\n[docs]\nclass CapStyleType(Enum):\n    \"\"\"Collection of available cap styles.\n\n    See the example below for a visual illustration of the different\n    cap styles.\n\n    Examples\n    --------\n\n    .. manim:: CapStyleVariants\n        :save_last_frame:\n\n        class CapStyleVariants(Scene):\n            def construct(self):\n                arcs = VGroup(*[\n                    Arc(\n                        radius=1,\n                        start_angle=0,\n                        angle=TAU / 4,\n                        stroke_width=20,\n                        color=GREEN,\n                        cap_style=cap_style,\n                    )\n                    for cap_style in CapStyleType\n                ])\n                arcs.arrange(RIGHT, buff=1)\n                self.add(arcs)\n                for arc in arcs:\n                    label = Text(arc.cap_style.name, font_size=24).next_to(arc, DOWN)\n                    self.add(label)\n    \"\"\"\n\n    AUTO = 0\n    ROUND = 1\n    BUTT = 2\n    SQUARE = 3", "code_sha1": "2997f0fac92519af8ec9828e7d0e9bbc352741ba"}
{"url": "https://docs.manim.community/en/stable/_modules/manim/utils/debug.html", "depth": 2, "instruction": "The code defines a function that generates index labels for submobjects of a given Mobject, creating a VGroup of Integer labels positioned at each submobject's location, with customizable height, stroke width, and color. The labels are visually outlined and serve as a debugging aid to identify submobjects in complex scenes.", "code": "\"\"\"Debugging utilities.\"\"\"\n\nfrom __future__ import annotations\n\n__all__ = [\"print_family\", \"index_labels\"]\n\n\nfrom typing import Any\n\nfrom manim.mobject.mobject import Mobject\nfrom manim.mobject.text.numbers import Integer\nfrom manim.utils.color import ManimColor\n\nfrom ..mobject.types.vectorized_mobject import VGroup\nfrom .color import BLACK\n\n\n\n[docs]\ndef print_family(mobject: Mobject, n_tabs: int = 0) -> None:\n    \"\"\"For debugging purposes\"\"\"\n    print(\"\\t\" * n_tabs, mobject, id(mobject))\n    for submob in mobject.submobjects:\n        print_family(submob, n_tabs + 1)\n\n\n\n\n[docs]\ndef index_labels(\n    mobject: Mobject,\n    label_height: float = 0.15,\n    background_stroke_width: float = 5,\n    background_stroke_color: ManimColor = BLACK,\n    **kwargs: Any,\n) -> VGroup:\n    r\"\"\"Returns a :class:`~.VGroup` of :class:`~.Integer` mobjects\n    that shows the index of each submobject.\n\n    Useful for working with parts of complicated mobjects.\n\n    Parameters\n    ----------\n    mobject\n        The mobject that will have its submobjects labelled.\n    label_height\n        The height of the labels, by default 0.15.\n    background_stroke_width\n        The stroke width of the outline of the labels, by default 5.\n    background_stroke_color\n        The stroke color of the outline of labels.\n    kwargs\n        Additional parameters to be passed into the :class`~.Integer`\n        mobjects used to construct the labels.\n\n    Examples\n    --------\n    .. manim:: IndexLabelsExample\n        :save_last_frame:\n\n        class IndexLabelsExample(Scene):\n            def construct(self):\n                text = MathTex(\n                    \"\\\\frac{d}{dx}f(x)g(x)=\",\n                    \"f(x)\\\\frac{d}{dx}g(x)\",\n                    \"+\",\n                    \"g(x)\\\\frac{d}{dx}f(x)\",\n                )\n\n                #index the fist term in the MathTex mob\n                indices = index_labels(text[0])\n\n                text[0][1].set_color(PURPLE_B)\n                text[0][8:12].set_color(DARK_BLUE)\n\n                self.add(text, indices)\n    \"\"\"\n    labels = VGroup()\n    for n, submob in enumerate(mobject):\n        label = Integer(n, **kwargs)\n        label.set_stroke(\n            background_stroke_color, background_stroke_width, background=True\n        )\n        label.height = label_height\n        label.move_to(submob)\n        labels.add(label)\n    return labels", "code_sha1": "804bad1eb57d004d099d6af75eff7f8eba27791a"}
{"url": "https://docs.manim.community/en/stable/_modules/manim/utils/docbuild/autocolor_directive.html", "depth": 2, "instruction": "The code generates a structured HTML table displaying color names and their corresponding RGB hex codes from a specified Manim color module. Each color is represented with a colored background and contrasting text, arranged in two columns, centered on the page. The table includes a header row for clarity.", "code": "\"\"\"A directive for documenting colors in Manim.\"\"\"\n\nfrom __future__ import annotations\n\nimport inspect\nfrom typing import TYPE_CHECKING\n\nfrom docutils import nodes\nfrom docutils.parsers.rst import Directive\n\nfrom manim import ManimColor\n\nif TYPE_CHECKING:\n    from sphinx.application import Sphinx\n\n__all__ = [\"ManimColorModuleDocumenter\"]\n\n\n\n[docs]\ndef setup(app: Sphinx) -> None:\n    app.add_directive(\"automanimcolormodule\", ManimColorModuleDocumenter)\n\n\n\n\n[docs]\nclass ManimColorModuleDocumenter(Directive):\n    objtype = \"automanimcolormodule\"\n    required_arguments = 1\n    has_content = True\n\n    def add_directive_header(self, sig: str) -> None:\n        # TODO: The Directive class has no method named\n        # add_directive_header.\n        super().add_directive_header(sig)  # type: ignore[misc]\n\n    def run(self) -> list[nodes.Element]:\n        module_name = self.arguments[0]\n        try:\n            import importlib\n\n            module = importlib.import_module(module_name)\n        except ImportError:\n            return [\n                nodes.error(\n                    None,  # type: ignore[arg-type]\n                    nodes.paragraph(text=f\"Failed to import module '{module_name}'\"),\n                )\n            ]\n\n        # Number of Colors displayed in one row\n        num_color_cols = 2\n        table = nodes.table(align=\"center\")\n\n        tgroup = nodes.tgroup(cols=num_color_cols * 2)\n        table += tgroup\n        for _ in range(num_color_cols * 2):\n            tgroup += nodes.colspec(colwidth=1)\n\n        # Create header rows for the table\n        thead = nodes.thead()\n        header_row = nodes.row()\n        for _ in range(num_color_cols):\n            header_col1 = nodes.paragraph(text=\"Color Name\")\n            header_col2 = nodes.paragraph(text=\"RGB Hex Code\")\n            header_row += nodes.entry(\"\", header_col1)\n            header_row += nodes.entry(\"\", header_col2)\n        thead += header_row\n        tgroup += thead\n\n        color_elements = []\n        for member_name, member_obj in inspect.getmembers(module):\n            if isinstance(member_obj, ManimColor):\n                r, g, b = member_obj.to_rgb()\n                luminance = 0.2126 * r + 0.7152 * g + 0.0722 * b\n\n                # Choose the font color based on the background luminance\n                font_color = \"black\" if luminance > 0.5 else \"white\"\n\n                color_elements.append((member_name, member_obj.to_hex(), font_color))\n\n        tbody = nodes.tbody()\n\n        for base_i in range(0, len(color_elements), num_color_cols):\n            row = nodes.row()\n            for member_name, hex_code, font_color in color_elements[\n                base_i : base_i + num_color_cols\n            ]:\n                col1 = nodes.literal(text=member_name)\n                col2 = nodes.raw(\n                    \"\",\n                    f'<div style=\"background-color:{hex_code};padding: 0.25rem 0;border-radius:8px;margin: 0.5rem 0.2rem\"><code style=\"color:{font_color};\">{hex_code}</code></div>',\n                    format=\"html\",\n                )\n                row += nodes.entry(\"\", col1)\n                row += nodes.entry(\"\", col2)\n            tbody += row\n        tgroup += tbody\n\n        return [table]", "code_sha1": "19a9979af16ebf6d592314e4a0d6b68af8abf3b4"}
{"url": "https://docs.manim.community/en/stable/_modules/manim/utils/docbuild/manim_directive.html", "depth": 2, "instruction": "The code defines a Sphinx directive that allows embedding Manim-rendered videos in documentation. It generates a video or image output based on specified options, including autoplay and quality settings, and displays source code and references. The visual result includes a video player or image centered in the documentation, with optional source code and reference blocks below.", "code": "r\"\"\"\nA directive for including Manim videos in a Sphinx document\n===========================================================\n\nWhen rendering the HTML documentation, the ``.. manim::`` directive\nimplemented here allows to include rendered videos.\n\nIts basic usage that allows processing **inline content**\nlooks as follows::\n\n    .. manim:: MyScene\n\n        class MyScene(Scene):\n            def construct(self):\n\n\nIt is required to pass the name of the class representing the\nscene to be rendered to the directive.\n\nAs a second application, the directive can also be used to\nrender scenes that are defined within doctests, for example::\n\n    .. manim:: DirectiveDoctestExample\n        :ref_classes: Dot\nfrom manim import Create, Dot, RED, Scene\ndot = Dot(color=RED)\ndot.color\n        ManimColor('#FC6255')\nclass DirectiveDoctestExample(Scene):\n    def construct(self):\n        self.play(Create(dot))\n\n\nOptions\n-------\n\nOptions can be passed as follows::\n\n    .. manim:: <Class name>\n        :<option name>: <value>\n\nThe following configuration options are supported by the\ndirective:\n\n    hide_source\n        If this flag is present without argument,\n        the source code is not displayed above the rendered video.\n\n    no_autoplay\n        If this flag is present without argument,\n        the video will not autoplay.\n\n    quality : {'low', 'medium', 'high', 'fourk'}\n        Controls render quality of the video, in analogy to\n        the corresponding command line flags.\n\n    save_as_gif\n        If this flag is present without argument,\n        the scene is rendered as a gif.\n\n    save_last_frame\n        If this flag is present without argument,\n        an image representing the last frame of the scene will\n        be rendered and displayed, instead of a video.\n\n    ref_classes\n        A list of classes, separated by spaces, that is\n        rendered in a reference block after the source code.\n\n    ref_functions\n        A list of functions, separated by spaces,\n        that is rendered in a reference block after the source code.\n\n    ref_methods\n        A list of methods, separated by spaces,\n        that is rendered in a reference block after the source code.\n\n\"\"\"\n\nfrom __future__ import annotations\n\nimport csv\nimport itertools as it\nimport re\nimport shutil\nimport sys\nimport textwrap\nfrom pathlib import Path\nfrom timeit import timeit\nfrom typing import TYPE_CHECKING, Any, TypedDict\n\nimport jinja2\nfrom docutils import nodes\nfrom docutils.parsers.rst import Directive, directives\nfrom docutils.statemachine import StringList\n\nfrom manim import QUALITIES\nfrom manim import __version__ as manim_version\n\nif TYPE_CHECKING:\n    from sphinx.application import Sphinx\n\n\n__all__ = [\"ManimDirective\"]\n\n\nclassnamedict: dict[str, int] = {}\n\n\n\n[docs]\nclass SetupMetadata(TypedDict):\n    parallel_read_safe: bool\n    parallel_write_safe: bool\n\n\n\n\n[docs]\nclass SkipManimNode(nodes.Admonition, nodes.Element):\n    \"\"\"Auxiliary node class that is used when the ``skip-manim`` tag is present\n    or ``.pot`` files are being built.\n\n    Skips rendering the manim directive and outputs a placeholder instead.\n    \"\"\"\n\n    pass\n\n\n\n\n[docs]\ndef visit(self: SkipManimNode, node: nodes.Element, name: str = \"\") -> None:\n    # TODO: Parent classes don't have a visit_admonition() method.\n    self.visit_admonition(node, name)  # type: ignore[attr-defined]\n    if not isinstance(node[0], nodes.title):\n        node.insert(0, nodes.title(\"skip-manim\", \"Example Placeholder\"))\n\n\n\n\n[docs]\ndef depart(self: SkipManimNode, node: nodes.Element) -> None:\n    # TODO: Parent classes don't have a depart_admonition() method.\n    self.depart_admonition(node)  # type: ignore[attr-defined]\n\n\n\n\n[docs]\ndef process_name_list(option_input: str, reference_type: str) -> list[str]:\n    r\"\"\"Reformats a string of space separated class names\n    as a list of strings containing valid Sphinx references.\n\n    Tests\n    -----\n\n    ::\nprocess_name_list(\"Tex TexTemplate\", \"class\")\n        [':class:`~.Tex`', ':class:`~.TexTemplate`']\nprocess_name_list(\"Scene.play Mobject.rotate\", \"func\")\n        [':func:`~.Scene.play`', ':func:`~.Mobject.rotate`']\n    \"\"\"\n    return [f\":{reference_type}:`~.{name}`\" for name in option_input.split()]\n\n\n\n\n[docs]\nclass ManimDirective(Directive):\n    r\"\"\"The manim directive, rendering videos while building\n    the documentation.\n\n    See the module docstring for documentation.\n    \"\"\"\n\n    has_content = True\n    required_arguments = 1\n    optional_arguments = 0\n    option_spec = {\n        \"hide_source\": bool,\n        \"no_autoplay\": bool,\n        \"quality\": lambda arg: directives.choice(\n            arg,\n            (\"low\", \"medium\", \"high\", \"fourk\"),\n        ),\n        \"save_as_gif\": bool,\n        \"save_last_frame\": bool,\n        \"ref_modules\": lambda arg: process_name_list(arg, \"mod\"),\n        \"ref_classes\": lambda arg: process_name_list(arg, \"class\"),\n        \"ref_functions\": lambda arg: process_name_list(arg, \"func\"),\n        \"ref_methods\": lambda arg: process_name_list(arg, \"meth\"),\n    }\n    final_argument_whitespace = True\n\n    def run(self) -> list[nodes.Element]:\n        # Rendering is skipped if the tag skip-manim is present,\n        # or if we are making the pot-files\n        should_skip = (\n            \"skip-manim\" in self.state.document.settings.env.app.builder.tags\n            or self.state.document.settings.env.app.builder.name == \"gettext\"\n        )\n        if should_skip:\n            clsname = self.arguments[0]\n            node = SkipManimNode()\n            self.state.nested_parse(\n                StringList(\n                    [\n                        f\"Placeholder block for ``{clsname}``.\",\n                        \"\",\n                        \".. code-block:: python\",\n                        \"\",\n                    ]\n                    + [\"    \" + line for line in self.content]\n                    + [\n                        \"\",\n                        \".. raw:: html\",\n                        \"\",\n                        f'    <pre data-manim-binder data-manim-classname=\"{clsname}\">',\n                    ]\n                    + [\"    \" + line for line in self.content]\n                    + [\"    </pre>\"],\n                ),\n                self.content_offset,\n                node,\n            )\n            return [node]\n\n        from manim import config, tempconfig\n\n        global classnamedict\n\n        clsname = self.arguments[0]\n        if clsname not in classnamedict:\n            classnamedict[clsname] = 1\n        else:\n            classnamedict[clsname] += 1\n\n        hide_source = \"hide_source\" in self.options\n        no_autoplay = \"no_autoplay\" in self.options\n        save_as_gif = \"save_as_gif\" in self.options\n        save_last_frame = \"save_last_frame\" in self.options\n        assert not (save_as_gif and save_last_frame)\n\n        ref_content = (\n            self.options.get(\"ref_modules\", [])\n            + self.options.get(\"ref_classes\", [])\n            + self.options.get(\"ref_functions\", [])\n            + self.options.get(\"ref_methods\", [])\n        )\n        ref_block = \"References: \" + \" \".join(ref_content) if ref_content else \"\"\n\n        if \"quality\" in self.options:\n            quality = f\"{self.options['quality']}_quality\"\n        else:\n            quality = \"example_quality\"\n        frame_rate = QUALITIES[quality][\"frame_rate\"]\n        pixel_height = QUALITIES[quality][\"pixel_height\"]\n        pixel_width = QUALITIES[quality][\"pixel_width\"]\n\n        state_machine = self.state_machine\n        document = state_machine.document\n\n        source_file_name = Path(document.attributes[\"source\"])\n        source_rel_name = source_file_name.relative_to(setup.confdir)  # type: ignore[attr-defined]\n        source_rel_dir = source_rel_name.parents[0]\n        dest_dir = Path(setup.app.builder.outdir, source_rel_dir).absolute()  # type: ignore[attr-defined]\n        if not dest_dir.exists():\n            dest_dir.mkdir(parents=True, exist_ok=True)\n\n        source_block_in = [\n            \".. code-block:: python\",\n            \"\",\n            \"    from manim import *\\n\",\n            *(\"    \" + line for line in self.content),\n            \"\",\n            \".. raw:: html\",\n            \"\",\n            f'    <pre data-manim-binder data-manim-classname=\"{clsname}\">',\n            *(\"    \" + line for line in self.content),\n            \"\",\n            \"    </pre>\",\n        ]\n        source_block = \"\\n\".join(source_block_in)\n\n        config.media_dir = (Path(setup.confdir) / \"media\").absolute()  # type: ignore[attr-defined,assignment]\n        config.images_dir = \"{media_dir}/images\"\n        config.video_dir = \"{media_dir}/videos/{quality}\"\n        output_file = f\"{clsname}-{classnamedict[clsname]}\"\n        config.assets_dir = Path(\"_static\")  # type: ignore[assignment]\n        config.progress_bar = \"none\"\n        config.verbosity = \"WARNING\"\n\n        example_config = {\n            \"frame_rate\": frame_rate,\n            \"no_autoplay\": no_autoplay,\n            \"pixel_height\": pixel_height,\n            \"pixel_width\": pixel_width,\n            \"save_last_frame\": save_last_frame,\n            \"write_to_movie\": not save_last_frame,\n            \"output_file\": output_file,\n        }\n        if save_last_frame:\n            example_config[\"format\"] = None\n        if save_as_gif:\n            example_config[\"format\"] = \"gif\"\n\n        user_code = list(self.content)\n        if user_code[0].startswith(\">>> \"):  # check whether block comes from doctest\n            user_code = [\n                line[4:] for line in user_code if line.startswith((\">>> \", \"... \"))\n            ]\n\n        code = [\n            \"from manim import *\",\n            *user_code,\n            f\"{clsname}().render()\",\n        ]\n\n        try:\n            with tempconfig(example_config):\n                run_time = timeit(lambda: exec(\"\\n\".join(code), globals()), number=1)\n                video_dir = config.get_dir(\"video_dir\")\n                images_dir = config.get_dir(\"images_dir\")\n        except Exception as e:\n            raise RuntimeError(f\"Error while rendering example {clsname}\") from e\n\n        _write_rendering_stats(\n            clsname,\n            run_time,\n            self.state.document.settings.env.docname,\n        )\n\n        # copy video file to output directory\n        if not (save_as_gif or save_last_frame):\n            filename = f\"{output_file}.mp4\"\n            filesrc = video_dir / filename\n            destfile = Path(dest_dir, filename)\n            shutil.copyfile(filesrc, destfile)\n        elif save_as_gif:\n            filename = f\"{output_file}.gif\"\n            filesrc = video_dir / filename\n        elif save_last_frame:\n            filename = f\"{output_file}.png\"\n            filesrc = images_dir / filename\n        else:\n            raise ValueError(\"Invalid combination of render flags received.\")\n        rendered_template = jinja2.Template(TEMPLATE).render(\n            clsname=clsname,\n            clsname_lowercase=clsname.lower(),\n            hide_source=hide_source,\n            filesrc_rel=Path(filesrc).relative_to(setup.confdir).as_posix(),  # type: ignore[attr-defined]\n            no_autoplay=no_autoplay,\n            output_file=output_file,\n            save_last_frame=save_last_frame,\n            save_as_gif=save_as_gif,\n            source_block=source_block,\n            ref_block=ref_block,\n        )\n        state_machine.insert_input(\n            rendered_template.split(\"\\n\"),\n            source=document.attributes[\"source\"],\n        )\n\n        return []\n\n\n\nrendering_times_file_path = Path(\"../rendering_times.csv\")\n\n\ndef _write_rendering_stats(scene_name: str, run_time: float, file_name: str) -> None:\n    with rendering_times_file_path.open(\"a\") as file:\n        csv.writer(file).writerow(\n            [\n                re.sub(r\"^(reference\\/)|(manim\\.)\", \"\", file_name),\n                scene_name,\n                f\"{run_time:.3f}\",\n            ],\n        )\n\n\ndef _log_rendering_times(*args: tuple[Any]) -> None:\n    if rendering_times_file_path.exists():\n        with rendering_times_file_path.open() as file:\n            data = list(csv.reader(file))\n        if len(data) == 0:\n            sys.exit()\n\n        print(\"\\nRendering Summary\\n-----------------\\n\")\n\n        # filter out empty lists caused by csv reader\n        data = [row for row in data if row]\n\n        max_file_length = max(len(row[0]) for row in data)\n        for key, group_iter in it.groupby(data, key=lambda row: row[0]):\n            key = key.ljust(max_file_length + 1, \".\")\n            group = list(group_iter)\n            if len(group) == 1:\n                row = group[0]\n                print(f\"{key}{row[2].rjust(7, '.')}s {row[1]}\")\n                continue\n            time_sum = sum(float(row[2]) for row in group)\n            print(\n                f\"{key}{f'{time_sum:.3f}'.rjust(7, '.')}s  => {len(group)} EXAMPLES\",\n            )\n            for row in group:\n                print(f\"{' ' * max_file_length} {row[2].rjust(7)}s {row[1]}\")\n        print(\"\")\n\n\ndef _delete_rendering_times(*args: tuple[Any]) -> None:\n    if rendering_times_file_path.exists():\n        rendering_times_file_path.unlink()\n\n\n\n[docs]\ndef setup(app: Sphinx) -> SetupMetadata:\n    app.add_node(SkipManimNode, html=(visit, depart))\n\n    setup.app = app  # type: ignore[attr-defined]\n    setup.config = app.config  # type: ignore[attr-defined]\n    setup.confdir = app.confdir  # type: ignore[attr-defined]\n\n    app.add_directive(\"manim\", ManimDirective)\n\n    app.connect(\"builder-inited\", _delete_rendering_times)\n    app.connect(\"build-finished\", _log_rendering_times)\n\n    app.add_js_file(\"manim-binder.min.js\")\n    app.add_js_file(\n        None,\n        body=textwrap.dedent(\n            f\"\"\"\\\n                window.initManimBinder({{branch: \"v{manim_version}\"}})\n            \"\"\"\n        ).strip(),\n    )\n\n    metadata: SetupMetadata = {\n        \"parallel_read_safe\": False,\n        \"parallel_write_safe\": True,\n    }\n    return metadata\n\n\n\nTEMPLATE = r\"\"\"\n{% if not hide_source %}\n.. raw:: html\n\n    <div id=\"{{ clsname_lowercase }}\" class=\"admonition admonition-manim-example\">\n    <p class=\"admonition-title\">Example: {{ clsname }} <a class=\"headerlink\" href=\"#{{ clsname_lowercase }}\">¶</a></p>\n\n{% endif %}\n\n{% if not (save_as_gif or save_last_frame) %}\n.. raw:: html\n\n    <video\n        class=\"manim-video\"\n        controls\n        loop\n        {{ '' if no_autoplay else 'autoplay' }}\n        src=\"./{{ output_file }}.mp4\">\n    </video>\n\n{% elif save_as_gif %}\n.. image:: /{{ filesrc_rel }}\n    :align: center\n\n{% elif save_last_frame %}\n.. image:: /{{ filesrc_rel }}\n    :align: center\n\n{% endif %}\n{% if not hide_source %}\n{{ source_block }}\n\n{{ ref_block }}\n\n.. raw:: html\n\n    </div>\n\n{% endif %}\n\"\"\"", "code_sha1": "28345ec1e5f268484c2095c37507e40749a76c8d"}
{"url": "https://docs.manim.community/en/stable/_modules/manim/utils/ipython_magic.html", "depth": 2, "instruction": "The code defines a Jupyter magic command for rendering Manim scenes, allowing users to execute animations directly in Jupyter notebooks. It handles scene execution, file management, and displays rendered images or videos with customizable properties like width and embedding options. The output is dynamically generated based on the scene defined in the notebook cell.", "code": "\"\"\"Utilities for using Manim with IPython (in particular: Jupyter notebooks)\"\"\"\n\nfrom __future__ import annotations\n\nimport mimetypes\nimport shutil\nfrom datetime import datetime\nfrom pathlib import Path\nfrom typing import Any\n\nfrom manim import config, logger, tempconfig\nfrom manim.__main__ import main\nfrom manim.renderer.shader import shader_program_cache\n\nfrom ..constants import RendererType\n\n__all__ = [\"ManimMagic\"]\n\ntry:\n    from IPython import get_ipython\n    from IPython.core.interactiveshell import InteractiveShell\n    from IPython.core.magic import (\n        Magics,\n        line_cell_magic,\n        magics_class,\n        needs_local_scope,\n    )\n    from IPython.display import Image, Video, display\nexcept ImportError:\n    pass\nelse:\n\n\n[docs]\n    @magics_class\n    class ManimMagic(Magics):\n        def __init__(self, shell: InteractiveShell) -> None:\n            super().__init__(shell)\n            self.rendered_files: dict[Path, Path] = {}\n\n\n[docs]\n        @needs_local_scope\n        @line_cell_magic\n        def manim(\n            self,\n            line: str,\n            cell: str | None = None,\n            local_ns: dict[str, Any] | None = None,\n        ) -> None:\n            r\"\"\"Render Manim scenes contained in IPython cells.\n            Works as a line or cell magic.\n\n            .. hint::\n\n                This line and cell magic works best when used in a JupyterLab\n                environment: while all of the functionality is available for\n                classic Jupyter notebooks as well, it is possible that videos\n                sometimes don't update on repeated execution of the same cell\n                if the scene name stays the same.\n\n                This problem does not occur when using JupyterLab.\n\n            Please refer to `<https://jupyter.org/>`_ for more information about JupyterLab\n            and Jupyter notebooks.\n\n            Usage in line mode::\n\n                %manim [CLI options] MyAwesomeScene\n\n            Usage in cell mode::\n\n                %%manim [CLI options] MyAwesomeScene\n\n                class MyAweseomeScene(Scene):\n                    def construct(self):\n\n\n            Run ``%manim --help`` and ``%manim render --help`` for possible command line interface options.\n\n            .. note::\n\n                The maximal width of the rendered videos that are displayed in the notebook can be\n                configured via the ``media_width`` configuration option. The default is set to ``25vw``,\n                which is 25% of your current viewport width. To allow the output to become as large\n                as possible, set ``config.media_width = \"100%\"``.\n\n                The ``media_embed`` option will embed the image/video output in the notebook. This is\n                generally undesirable as it makes the notebooks very large, but is required on some\n                platforms (notably Google's CoLab, where it is automatically enabled unless suppressed\n                by ``config.embed = False``) and needed in cases when the notebook (or converted HTML\n                file) will be moved relative to the video locations. Use-cases include building\n                documentation with Sphinx and JupyterBook. See also the :mod:`manim directive for Sphinx\n                <manim.utils.docbuild.manim_directive>`.\n\n            Examples\n            --------\n\n            First make sure to put ``import manim``, or even ``from manim import *``\n            in a cell and evaluate it. Then, a typical Jupyter notebook cell for Manim\n            could look as follows::\n\n                %%manim -v WARNING --disable_caching -qm BannerExample\n\n                config.media_width = \"75%\"\n                config.media_embed = True\n\n                class BannerExample(Scene):\n                    def construct(self):\n                        self.camera.background_color = \"#ece6e2\"\n                        banner_large = ManimBanner(dark_theme=False).scale(0.7)\n                        self.play(banner_large.create())\n                        self.play(banner_large.expand())\n\n            Evaluating this cell will render and display the ``BannerExample`` scene defined in the body of the cell.\n\n            .. note::\n\n                In case you want to hide the red box containing the output progress bar, the ``progress_bar`` config\n                option should be set to ``None``. This can also be done by passing ``--progress_bar None`` as a\n                CLI flag.\n\n            \"\"\"\n            if cell:\n                exec(cell, local_ns)\n\n            args = line.split()\n            if not len(args) or \"-h\" in args or \"--help\" in args or \"--version\" in args:\n                main(args, standalone_mode=False, prog_name=\"manim\")\n                return\n\n            modified_args = self.add_additional_args(args)\n            args = main(modified_args, standalone_mode=False, prog_name=\"manim\")\n            assert isinstance(local_ns, dict)\n            with tempconfig(local_ns.get(\"config\", {})):\n                config.digest_args(args)  # type: ignore[arg-type]\n\n                renderer = None\n                if config.renderer == RendererType.OPENGL:\n                    from manim.renderer.opengl_renderer import OpenGLRenderer\n\n                    renderer = OpenGLRenderer()\n\n                try:\n                    SceneClass = local_ns[config[\"scene_names\"][0]]\n                    scene = SceneClass(renderer=renderer)\n                    scene.render()\n                finally:\n                    # Shader cache becomes invalid as the context is destroyed\n                    shader_program_cache.clear()\n\n                    # Close OpenGL window here instead of waiting for the main thread to\n                    # finish causing the window to stay open and freeze\n                    if renderer is not None and renderer.window is not None:\n                        renderer.window.close()\n\n                if config[\"output_file\"] is None:\n                    logger.info(\"No output file produced\")\n                    return\n\n                local_path = Path(config[\"output_file\"]).relative_to(Path.cwd())\n                tmpfile = (\n                    Path(config[\"media_dir\"])\n                    / \"jupyter\"\n                    / f\"{_generate_file_name()}{local_path.suffix}\"\n                )\n\n                if local_path in self.rendered_files:\n                    self.rendered_files[local_path].unlink()\n                self.rendered_files[local_path] = tmpfile\n                tmpfile.parent.mkdir(parents=True, exist_ok=True)\n                shutil.copy(local_path, tmpfile)\n\n                file_type = mimetypes.guess_type(config[\"output_file\"])[0]\n                assert isinstance(file_type, str)\n                embed = config[\"media_embed\"]\n                if not embed:\n                    # videos need to be embedded when running in google colab.\n                    # do this automatically in case config.media_embed has not been\n                    # set explicitly.\n                    embed = \"google.colab\" in str(get_ipython())\n\n                if file_type.startswith(\"image\"):\n                    result = Image(filename=config[\"output_file\"])\n                else:\n                    result = Video(\n                        tmpfile,\n                        html_attributes=f'controls autoplay loop style=\"max-width: {config[\"media_width\"]};\"',\n                        embed=embed,\n                    )\n\n                display(result)\n\n\n        def add_additional_args(self, args: list[str]) -> list[str]:\n            additional_args = [\"--jupyter\"]\n            # Use webm to support transparency\n            if \"-t\" in args and \"--format\" not in args:\n                additional_args += [\"--format\", \"webm\"]\n            return additional_args + args[:-1] + [\"\"] + [args[-1]]\n\n\n\ndef _generate_file_name() -> str:\n    val: str = (\n        config[\"scene_names\"][0] + \"@\" + datetime.now().strftime(\"%Y-%m-%d@%H-%M-%S\")\n    )\n    return val", "code_sha1": "c081fb428fca13068f9319a7a16c7f26b03439f3"}
{"url": "https://docs.manim.community/en/stable/_modules/manim/utils/paths.html", "depth": 2, "instruction": "Three colored dots (red, green, blue) move from the left to the right in a smooth spiral path, traced by their movement. The animation lasts 5 seconds, with a wait before and after the transformation. The dots leave a colored trace as they move, enhancing the visual effect.", "code": "\"\"\"Functions determining transformation paths between sets of points.\"\"\"\n\nfrom __future__ import annotations\n\n__all__ = [\n    \"straight_path\",\n    \"path_along_arc\",\n    \"clockwise_path\",\n    \"counterclockwise_path\",\n]\n\n\nfrom typing import TYPE_CHECKING\n\nimport numpy as np\n\nfrom ..constants import OUT\nfrom ..utils.bezier import interpolate\nfrom ..utils.space_ops import rotation_matrix\n\nif TYPE_CHECKING:\n    from manim.typing import PathFuncType, Point3D_Array, Vector3D\n\n\nSTRAIGHT_PATH_THRESHOLD = 0.01\n\n\n\n[docs]\ndef straight_path() -> PathFuncType:\n    \"\"\"Simplest path function. Each point in a set goes in a straight path toward its destination.\n\n    Examples\n    --------\n\n    .. manim :: StraightPathExample\n\n        class StraightPathExample(Scene):\n            def construct(self):\n                colors = [RED, GREEN, BLUE]\n\n                starting_points = VGroup(\n                    *[\n                        Dot(LEFT + pos, color=color)\n                        for pos, color in zip([UP, DOWN, LEFT], colors)\n                    ]\n                )\n\n                finish_points = VGroup(\n                    *[\n                        Dot(RIGHT + pos, color=color)\n                        for pos, color in zip([ORIGIN, UP, DOWN], colors)\n                    ]\n                )\n\n                self.add(starting_points)\n                self.add(finish_points)\n                for dot in starting_points:\n                    self.add(TracedPath(dot.get_center, stroke_color=dot.get_color()))\n\n                self.wait()\n                self.play(\n                    Transform(\n                        starting_points,\n                        finish_points,\n                        path_func=utils.paths.straight_path(),\n                        run_time=2,\n                    )\n                )\n                self.wait()\n\n    \"\"\"\n    return interpolate\n\n\n\n\n[docs]\ndef path_along_circles(\n    arc_angle: float, circles_centers: np.ndarray, axis: Vector3D = OUT\n) -> PathFuncType:\n    \"\"\"This function transforms each point by moving it roughly along a circle, each with its own specified center.\n\n    The path may be seen as each point smoothly changing its orbit from its starting position to its destination.\n\n    Parameters\n    ----------\n    arc_angle\n        The angle each point traverses around the quasicircle.\n    circles_centers\n        The centers of each point's quasicircle to rotate around.\n    axis\n        The axis of rotation.\n\n    Examples\n    --------\n\n    .. manim :: PathAlongCirclesExample\n\n        class PathAlongCirclesExample(Scene):\n            def construct(self):\n                colors = [RED, GREEN, BLUE]\n\n                starting_points = VGroup(\n                    *[\n                        Dot(LEFT + pos, color=color)\n                        for pos, color in zip([UP, DOWN, LEFT], colors)\n                    ]\n                )\n\n                finish_points = VGroup(\n                    *[\n                        Dot(RIGHT + pos, color=color)\n                        for pos, color in zip([ORIGIN, UP, DOWN], colors)\n                    ]\n                )\n\n                self.add(starting_points)\n                self.add(finish_points)\n                for dot in starting_points:\n                    self.add(TracedPath(dot.get_center, stroke_color=dot.get_color()))\n\n                circle_center = Dot(3 * LEFT)\n                self.add(circle_center)\n\n                self.wait()\n                self.play(\n                    Transform(\n                        starting_points,\n                        finish_points,\n                        path_func=utils.paths.path_along_circles(\n                            2 * PI, circle_center.get_center()\n                        ),\n                        run_time=3,\n                    )\n                )\n                self.wait()\n\n    \"\"\"\n    if np.linalg.norm(axis) == 0:\n        axis = OUT\n    unit_axis = axis / np.linalg.norm(axis)\n\n    def path(\n        start_points: Point3D_Array, end_points: Point3D_Array, alpha: float\n    ) -> Point3D_Array:\n        detransformed_end_points = circles_centers + np.dot(\n            end_points - circles_centers, rotation_matrix(-arc_angle, unit_axis).T\n        )\n        rot_matrix = rotation_matrix(alpha * arc_angle, unit_axis)\n        return circles_centers + np.dot(\n            interpolate(start_points, detransformed_end_points, alpha)\n            - circles_centers,\n            rot_matrix.T,\n        )\n\n    return path\n\n\n\n\n[docs]\ndef path_along_arc(arc_angle: float, axis: Vector3D = OUT) -> PathFuncType:\n    \"\"\"This function transforms each point by moving it along a circular arc.\n\n    Parameters\n    ----------\n    arc_angle\n        The angle each point traverses around a circular arc.\n    axis\n        The axis of rotation.\n\n    Examples\n    --------\n\n    .. manim :: PathAlongArcExample\n\n        class PathAlongArcExample(Scene):\n            def construct(self):\n                colors = [RED, GREEN, BLUE]\n\n                starting_points = VGroup(\n                    *[\n                        Dot(LEFT + pos, color=color)\n                        for pos, color in zip([UP, DOWN, LEFT], colors)\n                    ]\n                )\n\n                finish_points = VGroup(\n                    *[\n                        Dot(RIGHT + pos, color=color)\n                        for pos, color in zip([ORIGIN, UP, DOWN], colors)\n                    ]\n                )\n\n                self.add(starting_points)\n                self.add(finish_points)\n                for dot in starting_points:\n                    self.add(TracedPath(dot.get_center, stroke_color=dot.get_color()))\n\n                self.wait()\n                self.play(\n                    Transform(\n                        starting_points,\n                        finish_points,\n                        path_func=utils.paths.path_along_arc(TAU * 2 / 3),\n                        run_time=3,\n                    )\n                )\n                self.wait()\n\n    \"\"\"\n    if abs(arc_angle) < STRAIGHT_PATH_THRESHOLD:\n        return straight_path()\n    if np.linalg.norm(axis) == 0:\n        axis = OUT\n    unit_axis = axis / np.linalg.norm(axis)\n\n    def path(\n        start_points: Point3D_Array, end_points: Point3D_Array, alpha: float\n    ) -> Point3D_Array:\n        vects = end_points - start_points\n        centers = start_points + 0.5 * vects\n        if arc_angle != np.pi:\n            centers += np.cross(unit_axis, vects / 2.0) / np.tan(arc_angle / 2)\n        rot_matrix = rotation_matrix(alpha * arc_angle, unit_axis)\n        return centers + np.dot(start_points - centers, rot_matrix.T)\n\n    return path\n\n\n\n\n[docs]\ndef clockwise_path() -> PathFuncType:\n    \"\"\"This function transforms each point by moving clockwise around a half circle.\n\n    Examples\n    --------\n\n    .. manim :: ClockwisePathExample\n\n        class ClockwisePathExample(Scene):\n            def construct(self):\n                colors = [RED, GREEN, BLUE]\n\n                starting_points = VGroup(\n                    *[\n                        Dot(LEFT + pos, color=color)\n                        for pos, color in zip([UP, DOWN, LEFT], colors)\n                    ]\n                )\n\n                finish_points = VGroup(\n                    *[\n                        Dot(RIGHT + pos, color=color)\n                        for pos, color in zip([ORIGIN, UP, DOWN], colors)\n                    ]\n                )\n\n                self.add(starting_points)\n                self.add(finish_points)\n                for dot in starting_points:\n                    self.add(TracedPath(dot.get_center, stroke_color=dot.get_color()))\n\n                self.wait()\n                self.play(\n                    Transform(\n                        starting_points,\n                        finish_points,\n                        path_func=utils.paths.clockwise_path(),\n                        run_time=2,\n                    )\n                )\n                self.wait()\n\n    \"\"\"\n    return path_along_arc(-np.pi)\n\n\n\n\n[docs]\ndef counterclockwise_path() -> PathFuncType:\n    \"\"\"This function transforms each point by moving counterclockwise around a half circle.\n\n    Examples\n    --------\n\n    .. manim :: CounterclockwisePathExample\n\n        class CounterclockwisePathExample(Scene):\n            def construct(self):\n                colors = [RED, GREEN, BLUE]\n\n                starting_points = VGroup(\n                    *[\n                        Dot(LEFT + pos, color=color)\n                        for pos, color in zip([UP, DOWN, LEFT], colors)\n                    ]\n                )\n\n                finish_points = VGroup(\n                    *[\n                        Dot(RIGHT + pos, color=color)\n                        for pos, color in zip([ORIGIN, UP, DOWN], colors)\n                    ]\n                )\n\n                self.add(starting_points)\n                self.add(finish_points)\n                for dot in starting_points:\n                    self.add(TracedPath(dot.get_center, stroke_color=dot.get_color()))\n\n                self.wait()\n                self.play(\n                    Transform(\n                        starting_points,\n                        finish_points,\n                        path_func=utils.paths.counterclockwise_path(),\n                        run_time=2,\n                    )\n                )\n                self.wait()\n\n    \"\"\"\n    return path_along_arc(np.pi)\n\n\n\n\n[docs]\ndef spiral_path(angle: float, axis: Vector3D = OUT) -> PathFuncType:\n    \"\"\"This function transforms each point by moving along a spiral to its destination.\n\n    Parameters\n    ----------\n    angle\n        The angle each point traverses around a spiral.\n    axis\n        The axis of rotation.\n\n    Examples\n    --------\n\n    .. manim :: SpiralPathExample\n\n        class SpiralPathExample(Scene):\n            def construct(self):\n                colors = [RED, GREEN, BLUE]\n\n                starting_points = VGroup(\n                    *[\n                        Dot(LEFT + pos, color=color)\n                        for pos, color in zip([UP, DOWN, LEFT], colors)\n                    ]\n                )\n\n                finish_points = VGroup(\n                    *[\n                        Dot(RIGHT + pos, color=color)\n                        for pos, color in zip([ORIGIN, UP, DOWN], colors)\n                    ]\n                )\n\n                self.add(starting_points)\n                self.add(finish_points)\n                for dot in starting_points:\n                    self.add(TracedPath(dot.get_center, stroke_color=dot.get_color()))\n\n                self.wait()\n                self.play(\n                    Transform(\n                        starting_points,\n                        finish_points,\n                        path_func=utils.paths.spiral_path(2 * TAU),\n                        run_time=5,\n                    )\n                )\n                self.wait()\n\n    \"\"\"\n    if abs(angle) < STRAIGHT_PATH_THRESHOLD:\n        return straight_path()\n    if np.linalg.norm(axis) == 0:\n        axis = OUT\n    unit_axis = axis / np.linalg.norm(axis)\n\n    def path(\n        start_points: Point3D_Array, end_points: Point3D_Array, alpha: float\n    ) -> Point3D_Array:\n        rot_matrix = rotation_matrix((alpha - 1) * angle, unit_axis)\n        return start_points + alpha * np.dot(end_points - start_points, rot_matrix.T)\n\n    return path", "code_sha1": "013e03ac4932837609c0dc7211c1311b3be2843f"}
{"url": "https://docs.manim.community/en/stable/_modules/manim/utils/rate_functions.html", "depth": 2, "instruction": "The scene displays three horizontal lines in red, green, and blue, labeled \"Ease In,\" \"Ease Out,\" and \"Ease In Out.\" Three dots move along these lines according to their respective easing functions over 7 seconds, with a fade-in effect for the lines and dots, and labels being written in.", "code": "\"\"\"A selection of rate functions, i.e., *speed curves* for animations.\nPlease find a standard list at https://easings.net/. Here is a picture\nfor the non-standard ones\n\n.. manim:: RateFuncExample\n    :save_last_frame:\n\n    class RateFuncExample(Scene):\n        def construct(self):\n            x = VGroup()\n            for k, v in rate_functions.__dict__.items():\n                if \"function\" in str(v):\n                    if (\n                        not k.startswith(\"__\")\n                        and not k.startswith(\"sqrt\")\n                        and not k.startswith(\"bezier\")\n                    ):\n                        try:\n                            rate_func = v\n                            plot = (\n                                ParametricFunction(\n                                    lambda x: [x, rate_func(x), 0],\n                                    t_range=[0, 1, .01],\n                                    use_smoothing=False,\n                                    color=YELLOW,\n                                )\n                                .stretch_to_fit_width(1.5)\n                                .stretch_to_fit_height(1)\n                            )\n                            plot_bg = SurroundingRectangle(plot).set_color(WHITE)\n                            plot_title = (\n                                Text(rate_func.__name__, weight=BOLD)\n                                .scale(0.5)\n                                .next_to(plot_bg, UP, buff=0.1)\n                            )\n                            x.add(VGroup(plot_bg, plot, plot_title))\n                        except: # because functions `not_quite_there`, `function squish_rate_func` are not working.\n                            pass\n            x.arrange_in_grid(cols=8)\n            x.height = config.frame_height\n            x.width = config.frame_width\n            x.move_to(ORIGIN).scale(0.95)\n            self.add(x)\n\n\nThere are primarily 3 kinds of standard easing functions:\n\n#. Ease In - The animation has a smooth start.\n#. Ease Out - The animation has a smooth end.\n#. Ease In Out - The animation has a smooth start as well as smooth end.\n\n.. note:: The standard functions are not exported, so to use them you do something like this:\n    rate_func=rate_functions.ease_in_sine\n    On the other hand, the non-standard functions, which are used more commonly, are exported and can be used directly.\n\n.. manim:: RateFunctions1Example\n\n    class RateFunctions1Example(Scene):\n        def construct(self):\n            line1 = Line(3*LEFT, 3*RIGHT).shift(UP).set_color(RED)\n            line2 = Line(3*LEFT, 3*RIGHT).set_color(GREEN)\n            line3 = Line(3*LEFT, 3*RIGHT).shift(DOWN).set_color(BLUE)\n\n            dot1 = Dot().move_to(line1.get_left())\n            dot2 = Dot().move_to(line2.get_left())\n            dot3 = Dot().move_to(line3.get_left())\n\n            label1 = Tex(\"Ease In\").next_to(line1, RIGHT)\n            label2 = Tex(\"Ease out\").next_to(line2, RIGHT)\n            label3 = Tex(\"Ease In Out\").next_to(line3, RIGHT)\n\n            self.play(\n                FadeIn(VGroup(line1, line2, line3)),\n                FadeIn(VGroup(dot1, dot2, dot3)),\n                Write(VGroup(label1, label2, label3)),\n            )\n            self.play(\n                MoveAlongPath(dot1, line1, rate_func=rate_functions.ease_in_sine),\n                MoveAlongPath(dot2, line2, rate_func=rate_functions.ease_out_sine),\n                MoveAlongPath(dot3, line3, rate_func=rate_functions.ease_in_out_sine),\n                run_time=7\n            )\n            self.wait()\n\"\"\"\n\nfrom __future__ import annotations\n\n__all__ = [\n    \"linear\",\n    \"smooth\",\n    \"smoothstep\",\n    \"smootherstep\",\n    \"smoothererstep\",\n    \"rush_into\",\n    \"rush_from\",\n    \"slow_into\",\n    \"double_smooth\",\n    \"there_and_back\",\n    \"there_and_back_with_pause\",\n    \"running_start\",\n    \"not_quite_there\",\n    \"wiggle\",\n    \"squish_rate_func\",\n    \"lingering\",\n    \"exponential_decay\",\n]\n\nfrom functools import wraps\nfrom math import sqrt\nfrom typing import Any, Protocol\n\nimport numpy as np\n\nfrom manim.utils.simple_functions import sigmoid\n\n\n# TODO: rewrite this to use ParamSpec when Python 3.9 is out of life\n\n[docs]\nclass RateFunction(Protocol):\n    def __call__(self, t: float, *args: Any, **kwargs: Any) -> float: ...\n\n\n\n# This is a decorator that makes sure any function it's used on will\n# return 0 if t<0 and 1 if t>1.\n\n[docs]\ndef unit_interval(function: RateFunction) -> RateFunction:\n    @wraps(function)\n    def wrapper(t: float, *args: Any, **kwargs: Any) -> float:\n        if 0 <= t <= 1:\n            return function(t, *args, **kwargs)\n        elif t < 0:\n            return 0\n        else:\n            return 1\n\n    return wrapper\n\n\n\n# This is a decorator that makes sure any function it's used on will\n# return 0 if t<0 or t>1.\n\n[docs]\ndef zero(function: RateFunction) -> RateFunction:\n    @wraps(function)\n    def wrapper(t: float, *args: Any, **kwargs: Any) -> float:\n        if 0 <= t <= 1:\n            return function(t, *args, **kwargs)\n        else:\n            return 0\n\n    return wrapper\n\n\n\n\n[docs]\n@unit_interval\ndef linear(t: float) -> float:\n    return t\n\n\n\n\n[docs]\n@unit_interval\ndef smooth(t: float, inflection: float = 10.0) -> float:\n    error = sigmoid(-inflection / 2)\n    return min(\n        max((sigmoid(inflection * (t - 0.5)) - error) / (1 - 2 * error), 0),\n        1,\n    )\n\n\n\n\n[docs]\ndef smoothstep(t: float) -> float:\n    \"\"\"Implementation of the 1st order SmoothStep sigmoid function.\n    The 1st derivative (speed) is zero at the endpoints.\n    https://en.wikipedia.org/wiki/Smoothstep\n    \"\"\"\n    return 0 if t <= 0 else 3 * t**2 - 2 * t**3 if t < 1 else 1\n\n\n\n\n[docs]\ndef smootherstep(t: float) -> float:\n    \"\"\"Implementation of the 2nd order SmoothStep sigmoid function.\n    The 1st and 2nd derivatives (speed and acceleration) are zero at the endpoints.\n    https://en.wikipedia.org/wiki/Smoothstep\n    \"\"\"\n    return 0 if t <= 0 else 6 * t**5 - 15 * t**4 + 10 * t**3 if t < 1 else 1\n\n\n\n\n[docs]\ndef smoothererstep(t: float) -> float:\n    \"\"\"Implementation of the 3rd order SmoothStep sigmoid function.\n    The 1st, 2nd and 3rd derivatives (speed, acceleration and jerk) are zero at the endpoints.\n    https://en.wikipedia.org/wiki/Smoothstep\n    \"\"\"\n    alpha: float = 0\n    if 0 < t < 1:\n        alpha = 35 * t**4 - 84 * t**5 + 70 * t**6 - 20 * t**7\n    elif t >= 1:\n        alpha = 1\n    return alpha\n\n\n\n\n[docs]\n@unit_interval\ndef rush_into(t: float, inflection: float = 10.0) -> float:\n    return 2 * smooth(t / 2.0, inflection)\n\n\n\n\n[docs]\n@unit_interval\ndef rush_from(t: float, inflection: float = 10.0) -> float:\n    return 2 * smooth(t / 2.0 + 0.5, inflection) - 1\n\n\n\n\n[docs]\n@unit_interval\ndef slow_into(t: float) -> float:\n    val: float = np.sqrt(1 - (1 - t) * (1 - t))\n    return val\n\n\n\n\n[docs]\n@unit_interval\ndef double_smooth(t: float) -> float:\n    if t < 0.5:\n        return 0.5 * smooth(2 * t)\n    else:\n        return 0.5 * (1 + smooth(2 * t - 1))\n\n\n\n\n[docs]\n@zero\ndef there_and_back(t: float, inflection: float = 10.0) -> float:\n    new_t = 2 * t if t < 0.5 else 2 * (1 - t)\n    return smooth(new_t, inflection)\n\n\n\n\n[docs]\n@zero\ndef there_and_back_with_pause(t: float, pause_ratio: float = 1.0 / 3) -> float:\n    a = 2.0 / (1.0 - pause_ratio)\n    if t < 0.5 - pause_ratio / 2:\n        return smooth(a * t)\n    elif t < 0.5 + pause_ratio / 2:\n        return 1\n    else:\n        return smooth(a - a * t)\n\n\n\n\n[docs]\n@unit_interval\ndef running_start(\n    t: float,\n    pull_factor: float = -0.5,\n) -> float:\n    t2 = t * t\n    t3 = t2 * t\n    t4 = t3 * t\n    t5 = t4 * t\n    t6 = t5 * t\n    mt = 1 - t\n    mt2 = mt * mt\n    mt3 = mt2 * mt\n    mt4 = mt3 * mt\n\n    # This is equivalent to creating a Bézier with [0, 0, pull_factor, pull_factor, 1, 1, 1]\n    # and evaluating it at t.\n    return (\n        15 * t2 * mt4 * pull_factor\n        + 20 * t3 * mt3 * pull_factor\n        + 15 * t4 * mt2\n        + 6 * t5 * mt\n        + t6\n    )\n\n\n\n\n[docs]\ndef not_quite_there(\n    func: RateFunction = smooth,\n    proportion: float = 0.7,\n) -> RateFunction:\n    def result(t: float, *args: Any, **kwargs: Any) -> float:\n        return proportion * func(t, *args, **kwargs)\n\n    return result\n\n\n\n\n[docs]\n@zero\ndef wiggle(t: float, wiggles: float = 2) -> float:\n    val: float = np.sin(wiggles * np.pi * t)\n    return there_and_back(t) * val\n\n\n\n\n[docs]\ndef squish_rate_func(\n    func: RateFunction,\n    a: float = 0.4,\n    b: float = 0.6,\n) -> RateFunction:\n    def result(t: float, *args: Any, **kwargs: Any) -> float:\n        if a == b:\n            return a\n\n        if t < a:\n            new_t = 0.0\n        elif t > b:\n            new_t = 1.0\n        else:\n            new_t = (t - a) / (b - a)\n        return func(new_t, *args, **kwargs)\n\n    return result\n\n\n\n# Stylistically, should this take parameters (with default values)?\n# Ultimately, the functionality is entirely subsumed by squish_rate_func,\n# but it may be useful to have a nice name for with nice default params for\n# \"lingering\", different from squish_rate_func's default params\n\n\n\n[docs]\n@unit_interval\ndef lingering(t: float) -> float:\n    def identity(t: float) -> float:\n        return t\n\n    # TODO: Isn't this just 0.8 * t?\n    return squish_rate_func(identity, 0, 0.8)(t)\n\n\n\n\n[docs]\n@unit_interval\ndef exponential_decay(t: float, half_life: float = 0.1) -> float:\n    # The half-life should be rather small to minimize\n    # the cut-off error at the end\n    val: float = 1 - np.exp(-t / half_life)\n    return val\n\n\n\n\n[docs]\n@unit_interval\ndef ease_in_sine(t: float) -> float:\n    val: float = 1 - np.cos((t * np.pi) / 2)\n    return val\n\n\n\n\n[docs]\n@unit_interval\ndef ease_out_sine(t: float) -> float:\n    val: float = np.sin((t * np.pi) / 2)\n    return val\n\n\n\n\n[docs]\n@unit_interval\ndef ease_in_out_sine(t: float) -> float:\n    val: float = -(np.cos(np.pi * t) - 1) / 2\n    return val\n\n\n\n\n[docs]\n@unit_interval\ndef ease_in_quad(t: float) -> float:\n    return t * t\n\n\n\n\n[docs]\n@unit_interval\ndef ease_out_quad(t: float) -> float:\n    return 1 - (1 - t) * (1 - t)\n\n\n\n\n[docs]\n@unit_interval\ndef ease_in_out_quad(t: float) -> float:\n    return 2 * t * t if t < 0.5 else 1 - pow(-2 * t + 2, 2) / 2\n\n\n\n\n[docs]\n@unit_interval\ndef ease_in_cubic(t: float) -> float:\n    return t * t * t\n\n\n\n\n[docs]\n@unit_interval\ndef ease_out_cubic(t: float) -> float:\n    return 1 - pow(1 - t, 3)\n\n\n\n\n[docs]\n@unit_interval\ndef ease_in_out_cubic(t: float) -> float:\n    return 4 * t * t * t if t < 0.5 else 1 - pow(-2 * t + 2, 3) / 2\n\n\n\n\n[docs]\n@unit_interval\ndef ease_in_quart(t: float) -> float:\n    return t * t * t * t\n\n\n\n\n[docs]\n@unit_interval\ndef ease_out_quart(t: float) -> float:\n    return 1 - pow(1 - t, 4)\n\n\n\n\n[docs]\n@unit_interval\ndef ease_in_out_quart(t: float) -> float:\n    return 8 * t * t * t * t if t < 0.5 else 1 - pow(-2 * t + 2, 4) / 2\n\n\n\n\n[docs]\n@unit_interval\ndef ease_in_quint(t: float) -> float:\n    return t * t * t * t * t\n\n\n\n\n[docs]\n@unit_interval\ndef ease_out_quint(t: float) -> float:\n    return 1 - pow(1 - t, 5)\n\n\n\n\n[docs]\n@unit_interval\ndef ease_in_out_quint(t: float) -> float:\n    return 16 * t * t * t * t * t if t < 0.5 else 1 - pow(-2 * t + 2, 5) / 2\n\n\n\n\n[docs]\n@unit_interval\ndef ease_in_expo(t: float) -> float:\n    return 0 if t == 0 else pow(2, 10 * t - 10)\n\n\n\n\n[docs]\n@unit_interval\ndef ease_out_expo(t: float) -> float:\n    return 1 if t == 1 else 1 - pow(2, -10 * t)\n\n\n\n\n[docs]\n@unit_interval\ndef ease_in_out_expo(t: float) -> float:\n    if t == 0:\n        return 0\n    elif t == 1:\n        return 1\n    elif t < 0.5:\n        return pow(2, 20 * t - 10) / 2\n    else:\n        return (2 - pow(2, -20 * t + 10)) / 2\n\n\n\n\n[docs]\n@unit_interval\ndef ease_in_circ(t: float) -> float:\n    return 1 - sqrt(1 - pow(t, 2))\n\n\n\n\n[docs]\n@unit_interval\ndef ease_out_circ(t: float) -> float:\n    return sqrt(1 - pow(t - 1, 2))\n\n\n\n\n[docs]\n@unit_interval\ndef ease_in_out_circ(t: float) -> float:\n    return (\n        (1 - sqrt(1 - pow(2 * t, 2))) / 2\n        if t < 0.5\n        else (sqrt(1 - pow(-2 * t + 2, 2)) + 1) / 2\n    )\n\n\n\n\n[docs]\n@unit_interval\ndef ease_in_back(t: float) -> float:\n    c1 = 1.70158\n    c3 = c1 + 1\n    return c3 * t * t * t - c1 * t * t\n\n\n\n\n[docs]\n@unit_interval\ndef ease_out_back(t: float) -> float:\n    c1 = 1.70158\n    c3 = c1 + 1\n    return 1 + c3 * pow(t - 1, 3) + c1 * pow(t - 1, 2)\n\n\n\n\n[docs]\n@unit_interval\ndef ease_in_out_back(t: float) -> float:\n    c1 = 1.70158\n    c2 = c1 * 1.525\n    return (\n        (pow(2 * t, 2) * ((c2 + 1) * 2 * t - c2)) / 2\n        if t < 0.5\n        else (pow(2 * t - 2, 2) * ((c2 + 1) * (t * 2 - 2) + c2) + 2) / 2\n    )\n\n\n\n\n[docs]\n@unit_interval\ndef ease_in_elastic(t: float) -> float:\n    c4 = (2 * np.pi) / 3\n    if t == 0:\n        return 0\n    elif t == 1:\n        return 1\n    else:\n        val: float = -pow(2, 10 * t - 10) * np.sin((t * 10 - 10.75) * c4)\n        return val\n\n\n\n\n[docs]\n@unit_interval\ndef ease_out_elastic(t: float) -> float:\n    c4 = (2 * np.pi) / 3\n    if t == 0:\n        return 0\n    elif t == 1:\n        return 1\n    else:\n        val: float = pow(2, -10 * t) * np.sin((t * 10 - 0.75) * c4) + 1\n        return val\n\n\n\n\n[docs]\n@unit_interval\ndef ease_in_out_elastic(t: float) -> float:\n    c5 = (2 * np.pi) / 4.5\n    if t == 0:\n        return 0\n    elif t == 1:\n        return 1\n    elif t < 0.5:\n        val: float = -(pow(2, 20 * t - 10) * np.sin((20 * t - 11.125) * c5)) / 2\n        return val\n    else:\n        val = (pow(2, -20 * t + 10) * np.sin((20 * t - 11.125) * c5)) / 2 + 1\n        return val\n\n\n\n\n[docs]\n@unit_interval\ndef ease_in_bounce(t: float) -> float:\n    return 1 - ease_out_bounce(1 - t)\n\n\n\n\n[docs]\n@unit_interval\ndef ease_out_bounce(t: float) -> float:\n    n1 = 7.5625\n    d1 = 2.75\n\n    if t < 1 / d1:\n        return n1 * t * t\n    elif t < 2 / d1:\n        return n1 * (t - 1.5 / d1) * (t - 1.5 / d1) + 0.75\n    elif t < 2.5 / d1:\n        return n1 * (t - 2.25 / d1) * (t - 2.25 / d1) + 0.9375\n    else:\n        return n1 * (t - 2.625 / d1) * (t - 2.625 / d1) + 0.984375\n\n\n\n\n[docs]\n@unit_interval\ndef ease_in_out_bounce(t: float) -> float:\n    if t < 0.5:\n        return (1 - ease_out_bounce(1 - 2 * t)) / 2\n    else:\n        return (1 + ease_out_bounce(2 * t - 1)) / 2", "code_sha1": "39f3e98f3672c8fdc3b489c4dbf298833ad52078"}
{"url": "https://docs.manim.community/en/stable/_modules/manim/utils/space_ops.html", "depth": 2, "instruction": "The code defines utility functions for vector operations in 2D and 3D, including quaternion manipulations, rotation matrices, and geometric calculations like intersections and area computations. It provides mathematical tools for manipulating and analyzing spatial relationships, useful in graphics and physics simulations.", "code": "\"\"\"Utility functions for two- and three-dimensional vectors.\"\"\"\n\nfrom __future__ import annotations\n\nimport itertools as it\nfrom collections.abc import Sequence\nfrom typing import TYPE_CHECKING, Callable\n\nimport numpy as np\nfrom mapbox_earcut import triangulate_float32 as earcut\nfrom scipy.spatial.transform import Rotation\n\nfrom manim.constants import DOWN, OUT, PI, RIGHT, TAU, UP\nfrom manim.utils.iterables import adjacent_pairs\n\nif TYPE_CHECKING:\n    import numpy.typing as npt\n\n    from manim.typing import (\n        ManimFloat,\n        MatrixMN,\n        Point2D_Array,\n        Point3D,\n        Point3DLike,\n        Point3DLike_Array,\n        PointND,\n        PointNDLike_Array,\n        Vector2D,\n        Vector2D_Array,\n        Vector3D,\n        Vector3D_Array,\n    )\n\n__all__ = [\n    \"quaternion_mult\",\n    \"quaternion_from_angle_axis\",\n    \"angle_axis_from_quaternion\",\n    \"quaternion_conjugate\",\n    \"rotate_vector\",\n    \"thick_diagonal\",\n    \"rotation_matrix\",\n    \"rotation_about_z\",\n    \"z_to_vector\",\n    \"angle_of_vector\",\n    \"angle_between_vectors\",\n    \"normalize\",\n    \"get_unit_normal\",\n    \"compass_directions\",\n    \"regular_vertices\",\n    \"complex_to_R3\",\n    \"R3_to_complex\",\n    \"complex_func_to_R3_func\",\n    \"center_of_mass\",\n    \"midpoint\",\n    \"find_intersection\",\n    \"line_intersection\",\n    \"get_winding_number\",\n    \"shoelace\",\n    \"shoelace_direction\",\n    \"cross2d\",\n    \"earclip_triangulation\",\n    \"cartesian_to_spherical\",\n    \"spherical_to_cartesian\",\n    \"perpendicular_bisector\",\n]\n\n\n\n[docs]\ndef norm_squared(v: float) -> float:\n    val: float = np.dot(v, v)\n    return val\n\n\n\n\n[docs]\ndef cross(v1: Vector3D, v2: Vector3D) -> Vector3D:\n    return np.array(\n        [\n            v1[1] * v2[2] - v1[2] * v2[1],\n            v1[2] * v2[0] - v1[0] * v2[2],\n            v1[0] * v2[1] - v1[1] * v2[0],\n        ]\n    )\n\n\n\n# Quaternions\n# TODO, implement quaternion type\n\n\n\n[docs]\ndef quaternion_mult(\n    *quats: Sequence[float],\n) -> np.ndarray | list[float | np.ndarray]:\n    \"\"\"Gets the Hamilton product of the quaternions provided.\n    For more information, check `this Wikipedia page\n    <https://en.wikipedia.org/wiki/Quaternion>`__.\n\n    Returns\n    -------\n    Union[np.ndarray, List[Union[float, np.ndarray]]]\n        Returns a list of product of two quaternions.\n    \"\"\"\n    if len(quats) == 0:\n        return [1, 0, 0, 0]\n    result = quats[0]\n    for next_quat in quats[1:]:\n        w1, x1, y1, z1 = result\n        w2, x2, y2, z2 = next_quat\n        result = [\n            w1 * w2 - x1 * x2 - y1 * y2 - z1 * z2,\n            w1 * x2 + x1 * w2 + y1 * z2 - z1 * y2,\n            w1 * y2 + y1 * w2 + z1 * x2 - x1 * z2,\n            w1 * z2 + z1 * w2 + x1 * y2 - y1 * x2,\n        ]\n    return result\n\n\n\n\n[docs]\ndef quaternion_from_angle_axis(\n    angle: float,\n    axis: np.ndarray,\n    axis_normalized: bool = False,\n) -> list[float]:\n    \"\"\"Gets a quaternion from an angle and an axis.\n    For more information, check `this Wikipedia page\n    <https://en.wikipedia.org/wiki/Conversion_between_quaternions_and_Euler_angles>`__.\n\n    Parameters\n    ----------\n    angle\n        The angle for the quaternion.\n    axis\n        The axis for the quaternion\n    axis_normalized\n        Checks whether the axis is normalized, by default False\n\n    Returns\n    -------\n    list[float]\n        Gives back a quaternion from the angle and axis\n    \"\"\"\n    if not axis_normalized:\n        axis = normalize(axis)\n    return [np.cos(angle / 2), *(np.sin(angle / 2) * axis)]\n\n\n\n\n[docs]\ndef angle_axis_from_quaternion(quaternion: Sequence[float]) -> Sequence[float]:\n    \"\"\"Gets angle and axis from a quaternion.\n\n    Parameters\n    ----------\n    quaternion\n        The quaternion from which we get the angle and axis.\n\n    Returns\n    -------\n    Sequence[float]\n        Gives the angle and axis\n    \"\"\"\n    axis = normalize(quaternion[1:], fall_back=np.array([1, 0, 0]))\n    angle = 2 * np.arccos(quaternion[0])\n    if angle > TAU / 2:\n        angle = TAU - angle\n    return angle, axis\n\n\n\n\n[docs]\ndef quaternion_conjugate(quaternion: Sequence[float]) -> np.ndarray:\n    \"\"\"Used for finding the conjugate of the quaternion\n\n    Parameters\n    ----------\n    quaternion\n        The quaternion for which you want to find the conjugate for.\n\n    Returns\n    -------\n    np.ndarray\n        The conjugate of the quaternion.\n    \"\"\"\n    result = np.array(quaternion)\n    result[1:] *= -1\n    return result\n\n\n\n\n[docs]\ndef rotate_vector(\n    vector: np.ndarray, angle: float, axis: np.ndarray = OUT\n) -> np.ndarray:\n    \"\"\"Function for rotating a vector.\n\n    Parameters\n    ----------\n    vector\n        The vector to be rotated.\n    angle\n        The angle to be rotated by.\n    axis\n        The axis to be rotated, by default OUT\n\n    Returns\n    -------\n    np.ndarray\n        The rotated vector with provided angle and axis.\n\n    Raises\n    ------\n    ValueError\n        If vector is not of dimension 2 or 3.\n    \"\"\"\n    if len(vector) > 3:\n        raise ValueError(\"Vector must have the correct dimensions.\")\n    if len(vector) == 2:\n        vector = np.append(vector, 0)\n    return rotation_matrix(angle, axis) @ vector\n\n\n\n\n[docs]\ndef thick_diagonal(dim: int, thickness: int = 2) -> MatrixMN:\n    row_indices = np.arange(dim).repeat(dim).reshape((dim, dim))\n    col_indices = np.transpose(row_indices)\n    return (np.abs(row_indices - col_indices) < thickness).astype(\"uint8\")\n\n\n\n\n[docs]\ndef rotation_matrix_transpose_from_quaternion(quat: np.ndarray) -> list[np.ndarray]:\n    \"\"\"Converts the quaternion, quat, to an equivalent rotation matrix representation.\n    For more information, check `this page\n    <https://in.mathworks.com/help/driving/ref/quaternion.rotmat.html>`_.\n\n    Parameters\n    ----------\n    quat\n        The quaternion which is to be converted.\n\n    Returns\n    -------\n    List[np.ndarray]\n        Gives back the Rotation matrix representation, returned as a 3-by-3\n        matrix or 3-by-3-by-N multidimensional array.\n    \"\"\"\n    quat_inv = quaternion_conjugate(quat)\n    return [\n        quaternion_mult(quat, [0, *basis], quat_inv)[1:]\n        for basis in [\n            [1, 0, 0],\n            [0, 1, 0],\n            [0, 0, 1],\n        ]\n    ]\n\n\n\n\n[docs]\ndef rotation_matrix_from_quaternion(quat: np.ndarray) -> np.ndarray:\n    return np.transpose(rotation_matrix_transpose_from_quaternion(quat))\n\n\n\n\n[docs]\ndef rotation_matrix_transpose(angle: float, axis: np.ndarray) -> np.ndarray:\n    if all(np.array(axis)[:2] == np.zeros(2)):\n        return rotation_about_z(angle * np.sign(axis[2])).T\n    return rotation_matrix(angle, axis).T\n\n\n\n\n[docs]\ndef rotation_matrix(\n    angle: float,\n    axis: np.ndarray,\n    homogeneous: bool = False,\n) -> np.ndarray:\n    \"\"\"Rotation in R^3 about a specified axis of rotation.\"\"\"\n    inhomogeneous_rotation_matrix = Rotation.from_rotvec(\n        angle * normalize(np.array(axis))\n    ).as_matrix()\n    if not homogeneous:\n        return inhomogeneous_rotation_matrix\n    else:\n        rotation_matrix = np.eye(4)\n        rotation_matrix[:3, :3] = inhomogeneous_rotation_matrix\n        return rotation_matrix\n\n\n\n\n[docs]\ndef rotation_about_z(angle: float) -> np.ndarray:\n    \"\"\"Returns a rotation matrix for a given angle.\n\n    Parameters\n    ----------\n    angle\n        Angle for the rotation matrix.\n\n    Returns\n    -------\n    np.ndarray\n        Gives back the rotated matrix.\n    \"\"\"\n    c, s = np.cos(angle), np.sin(angle)\n    return np.array(\n        [\n            [c, -s, 0],\n            [s, c, 0],\n            [0, 0, 1],\n        ]\n    )\n\n\n\n\n[docs]\ndef z_to_vector(vector: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns some matrix in SO(3) which takes the z-axis to the\n    (normalized) vector provided as an argument\n    \"\"\"\n    axis_z = normalize(vector)\n    axis_y = normalize(cross(axis_z, RIGHT))\n    axis_x = cross(axis_y, axis_z)\n    if np.linalg.norm(axis_y) == 0:\n        # the vector passed just so happened to be in the x direction.\n        axis_x = normalize(cross(UP, axis_z))\n        axis_y = -cross(axis_x, axis_z)\n\n    return np.array([axis_x, axis_y, axis_z]).T\n\n\n\n\n[docs]\ndef angle_of_vector(vector: Sequence[float] | np.ndarray) -> float:\n    \"\"\"Returns polar coordinate theta when vector is projected on xy plane.\n\n    Parameters\n    ----------\n    vector\n        The vector to find the angle for.\n\n    Returns\n    -------\n    float\n        The angle of the vector projected.\n    \"\"\"\n    if isinstance(vector, np.ndarray) and len(vector.shape) > 1:\n        if vector.shape[0] < 2:\n            raise ValueError(\"Vector must have the correct dimensions. (2, n)\")\n        c_vec = np.empty(vector.shape[1], dtype=np.complex128)\n        c_vec.real = vector[0]\n        c_vec.imag = vector[1]\n        val1: float = np.angle(c_vec)\n        return val1\n    val: float = np.angle(complex(*vector[:2]))\n    return val\n\n\n\n\n[docs]\ndef angle_between_vectors(v1: np.ndarray, v2: np.ndarray) -> float:\n    \"\"\"Returns the angle between two vectors.\n    This angle will always be between 0 and pi\n\n    Parameters\n    ----------\n    v1\n        The first vector.\n    v2\n        The second vector.\n\n    Returns\n    -------\n    float\n        The angle between the vectors.\n    \"\"\"\n    val: float = 2 * np.arctan2(\n        np.linalg.norm(normalize(v1) - normalize(v2)),\n        np.linalg.norm(normalize(v1) + normalize(v2)),\n    )\n\n    return val\n\n\n\n\n[docs]\ndef normalize(\n    vect: np.ndarray | tuple[float], fall_back: np.ndarray | None = None\n) -> np.ndarray:\n    norm = np.linalg.norm(vect)\n    if norm > 0:\n        return np.array(vect) / norm\n    else:\n        return fall_back or np.zeros(len(vect))\n\n\n\n\n[docs]\ndef normalize_along_axis(array: np.ndarray, axis: np.ndarray) -> np.ndarray:\n    \"\"\"Normalizes an array with the provided axis.\n\n    Parameters\n    ----------\n    array\n        The array which has to be normalized.\n    axis\n        The axis to be normalized to.\n\n    Returns\n    -------\n    np.ndarray\n        Array which has been normalized according to the axis.\n    \"\"\"\n    norms = np.sqrt((array * array).sum(axis))\n    norms[norms == 0] = 1\n    buffed_norms = np.repeat(norms, array.shape[axis]).reshape(array.shape)\n    array /= buffed_norms\n    return array\n\n\n\n\n[docs]\ndef get_unit_normal(v1: Vector3D, v2: Vector3D, tol: float = 1e-6) -> Vector3D:\n    \"\"\"Gets the unit normal of the vectors.\n\n    Parameters\n    ----------\n    v1\n        The first vector.\n    v2\n        The second vector\n    tol\n        [description], by default 1e-6\n\n    Returns\n    -------\n    np.ndarray\n        The normal of the two vectors.\n    \"\"\"\n    # Instead of normalizing v1 and v2, just divide by the greatest\n    # of all their absolute components, which is just enough\n    div1, div2 = max(np.abs(v1)), max(np.abs(v2))\n    if div1 == 0.0:\n        if div2 == 0.0:\n            return DOWN\n        u = v2 / div2\n    elif div2 == 0.0:\n        u = v1 / div1\n    else:\n        # Normal scenario: v1 and v2 are both non-null\n        u1, u2 = v1 / div1, v2 / div2\n        cp = cross(u1, u2)\n        cp_norm = np.sqrt(norm_squared(cp))\n        if cp_norm > tol:\n            return cp / cp_norm\n        # Otherwise, v1 and v2 were aligned\n        u = u1\n\n    # If you are here, you have an \"unique\", non-zero, unit-ish vector u\n    # If it's also too aligned to the Z axis, just return DOWN\n    if abs(u[0]) < tol and abs(u[1]) < tol:\n        return DOWN\n    # Otherwise rotate u in the plane it shares with the Z axis,\n    # 90° TOWARDS the Z axis. This is done via (u x [0, 0, 1]) x u,\n    # which gives [-xz, -yz, x²+y²] (slightly scaled as well)\n    cp = np.array([-u[0] * u[2], -u[1] * u[2], u[0] * u[0] + u[1] * u[1]])\n    cp_norm = np.sqrt(norm_squared(cp))\n    # Because the norm(u) == 0 case was filtered in the beginning,\n    # there is no need to check if the norm of cp is 0\n    return cp / cp_norm\n\n\n\n###\n\n\n\n[docs]\ndef compass_directions(n: int = 4, start_vect: np.ndarray = RIGHT) -> np.ndarray:\n    \"\"\"Finds the cardinal directions using tau.\n\n    Parameters\n    ----------\n    n\n        The amount to be rotated, by default 4\n    start_vect\n        The direction for the angle to start with, by default RIGHT\n\n    Returns\n    -------\n    np.ndarray\n        The angle which has been rotated.\n    \"\"\"\n    angle = TAU / n\n    return np.array([rotate_vector(start_vect, k * angle) for k in range(n)])\n\n\n\n\n[docs]\ndef regular_vertices(\n    n: int, *, radius: float = 1, start_angle: float | None = None\n) -> tuple[np.ndarray, float]:\n    \"\"\"Generates regularly spaced vertices around a circle centered at the origin.\n\n    Parameters\n    ----------\n    n\n        The number of vertices\n    radius\n        The radius of the circle that the vertices are placed on.\n    start_angle\n        The angle the vertices start at.\n\n        If unspecified, for even ``n`` values, ``0`` will be used.\n        For odd ``n`` values, 90 degrees is used.\n\n    Returns\n    -------\n    vertices : :class:`numpy.ndarray`\n        The regularly spaced vertices.\n    start_angle : :class:`float`\n        The angle the vertices start at.\n    \"\"\"\n    if start_angle is None:\n        start_angle = 0 if n % 2 == 0 else TAU / 4\n\n    start_vector = rotate_vector(RIGHT * radius, start_angle)\n    vertices = compass_directions(n, start_vector)\n\n    return vertices, start_angle\n\n\n\n\n[docs]\ndef complex_to_R3(complex_num: complex) -> np.ndarray:\n    return np.array((complex_num.real, complex_num.imag, 0))\n\n\n\n\n[docs]\ndef R3_to_complex(point: Sequence[float]) -> np.ndarray:\n    return complex(*point[:2])\n\n\n\n\n[docs]\ndef complex_func_to_R3_func(\n    complex_func: Callable[[complex], complex],\n) -> Callable[[Point3DLike], Point3D]:\n    return lambda p: complex_to_R3(complex_func(R3_to_complex(p)))\n\n\n\n\n[docs]\ndef center_of_mass(points: PointNDLike_Array) -> PointND:\n    \"\"\"Gets the center of mass of the points in space.\n\n    Parameters\n    ----------\n    points\n        The points to find the center of mass from.\n\n    Returns\n    -------\n    np.ndarray\n        The center of mass of the points.\n    \"\"\"\n    return np.average(points, 0, np.ones(len(points)))\n\n\n\n\n[docs]\ndef midpoint(\n    point1: Sequence[float],\n    point2: Sequence[float],\n) -> float | np.ndarray:\n    \"\"\"Gets the midpoint of two points.\n\n    Parameters\n    ----------\n    point1\n        The first point.\n    point2\n        The second point.\n\n    Returns\n    -------\n    Union[float, np.ndarray]\n        The midpoint of the points\n    \"\"\"\n    return center_of_mass([point1, point2])\n\n\n\n\n[docs]\ndef line_intersection(\n    line1: Sequence[np.ndarray], line2: Sequence[np.ndarray]\n) -> np.ndarray:\n    \"\"\"Returns the intersection point of two lines, each defined by\n    a pair of distinct points lying on the line.\n\n    Parameters\n    ----------\n    line1\n        A list of two points that determine the first line.\n    line2\n        A list of two points that determine the second line.\n\n    Returns\n    -------\n    np.ndarray\n        The intersection points of the two lines which are intersecting.\n\n    Raises\n    ------\n    ValueError\n        Error is produced if the two lines don't intersect with each other\n        or if the coordinates don't lie on the xy-plane.\n    \"\"\"\n    if any(np.array([line1, line2])[:, :, 2].reshape(-1)):\n        # checks for z coordinates != 0\n        raise ValueError(\"Coords must be in the xy-plane.\")\n\n    # algorithm from https://stackoverflow.com/a/42727584\n    padded = (\n        np.pad(np.array(i)[:, :2], ((0, 0), (0, 1)), constant_values=1)\n        for i in (line1, line2)\n    )\n    line1, line2 = (cross(*i) for i in padded)\n    x, y, z = cross(line1, line2)\n\n    if z == 0:\n        raise ValueError(\n            \"The lines are parallel, there is no unique intersection point.\"\n        )\n\n    return np.array([x / z, y / z, 0])\n\n\n\n\n[docs]\ndef find_intersection(\n    p0s: Point3DLike_Array,\n    v0s: Vector3D_Array,\n    p1s: Point3DLike_Array,\n    v1s: Vector3D_Array,\n    threshold: float = 1e-5,\n) -> list[Point3D]:\n    \"\"\"\n    Return the intersection of a line passing through p0 in direction v0\n    with one passing through p1 in direction v1 (or array of intersections\n    from arrays of such points/directions).\n    For 3d values, it returns the point on the ray p0 + v0 * t closest to the\n    ray p1 + v1 * t\n    \"\"\"\n    # algorithm from https://en.wikipedia.org/wiki/Skew_lines#Nearest_points\n    result = []\n\n    for p0, v0, p1, v1 in zip(*[p0s, v0s, p1s, v1s]):\n        normal = cross(v1, cross(v0, v1))\n        denom = max(np.dot(v0, normal), threshold)\n        result += [p0 + np.dot(p1 - p0, normal) / denom * v0]\n    return result\n\n\n\n\n[docs]\ndef get_winding_number(points: Sequence[np.ndarray]) -> float:\n    \"\"\"Determine the number of times a polygon winds around the origin.\n\n    The orientation is measured mathematically positively, i.e.,\n    counterclockwise.\n\n    Parameters\n    ----------\n    points\n        The vertices of the polygon being queried.\n\n    Examples\n    --------\nfrom manim import Square, get_winding_number\npolygon = Square()\nget_winding_number(polygon.get_vertices())\n    np.float64(1.0)\npolygon.shift(2 * UP)\n    Square\nget_winding_number(polygon.get_vertices())\n    np.float64(0.0)\n    \"\"\"\n    total_angle: float = 0\n    for p1, p2 in adjacent_pairs(points):\n        d_angle = angle_of_vector(p2) - angle_of_vector(p1)\n        d_angle = ((d_angle + PI) % TAU) - PI\n        total_angle += d_angle\n    val: float = total_angle / TAU\n    return val\n\n\n\n\n[docs]\ndef shoelace(x_y: Point2D_Array) -> float:\n    \"\"\"2D implementation of the shoelace formula.\n\n    Returns\n    -------\n    :class:`float`\n        Returns signed area.\n    \"\"\"\n    x = x_y[:, 0]\n    y = x_y[:, 1]\n    val: float = np.trapz(y, x)\n    return val\n\n\n\n\n[docs]\ndef shoelace_direction(x_y: Point2D_Array) -> str:\n    \"\"\"\n    Uses the area determined by the shoelace method to determine whether\n    the input set of points is directed clockwise or counterclockwise.\n\n    Returns\n    -------\n    :class:`str`\n        Either ``\"CW\"`` or ``\"CCW\"``.\n    \"\"\"\n    area = shoelace(x_y)\n    return \"CW\" if area > 0 else \"CCW\"\n\n\n\n\n[docs]\ndef cross2d(\n    a: Vector2D | Vector2D_Array,\n    b: Vector2D | Vector2D_Array,\n) -> ManimFloat | npt.NDArray[ManimFloat]:\n    \"\"\"Compute the determinant(s) of the passed\n    vector (sequences).\n\n    Parameters\n    ----------\n    a\n        A vector or a sequence of vectors.\n    b\n        A vector or a sequence of vectors.\n\n    Returns\n    -------\n    Sequence[float] | float\n        The determinant or sequence of determinants\n        of the first two components of the specified\n        vectors.\n\n    Examples\n    --------\n    .. code-block:: pycon\ncross2d(np.array([1, 2]), np.array([3, 4]))\n        np.int64(-2)\ncross2d(\n    np.array([[1, 2, 0], [1, 0, 0]]),\n    np.array([[3, 4, 0], [0, 1, 0]]),\n)\n        array([-2,  1])\n    \"\"\"\n    if len(a.shape) == 2:\n        return a[:, 0] * b[:, 1] - a[:, 1] * b[:, 0]\n    else:\n        return a[0] * b[1] - b[0] * a[1]\n\n\n\n\n[docs]\ndef earclip_triangulation(verts: np.ndarray, ring_ends: list) -> list:\n    \"\"\"Returns a list of indices giving a triangulation\n    of a polygon, potentially with holes.\n\n    Parameters\n    ----------\n    verts\n        verts is a numpy array of points.\n    ring_ends\n        ring_ends is a list of indices indicating where\n        the ends of new paths are.\n\n    Returns\n    -------\n    list\n        A list of indices giving a triangulation of a polygon.\n    \"\"\"\n    # First, connect all the rings so that the polygon\n    # with holes is instead treated as a (very convex)\n    # polygon with one edge.  Do this by drawing connections\n    # between rings close to each other\n    rings = [list(range(e0, e1)) for e0, e1 in zip([0, *ring_ends], ring_ends)]\n    attached_rings = rings[:1]\n    detached_rings = rings[1:]\n    loop_connections = {}\n\n    while detached_rings:\n        i_range, j_range = (\n            list(\n                filter(\n                    # Ignore indices that are already being\n                    # used to draw some connection\n                    lambda i: i not in loop_connections,\n                    it.chain(*ring_group),\n                ),\n            )\n            for ring_group in (attached_rings, detached_rings)\n        )\n\n        # Closest point on the attached rings to an estimated midpoint\n        # of the detached rings\n        tmp_j_vert = midpoint(verts[j_range[0]], verts[j_range[len(j_range) // 2]])\n        i = min(i_range, key=lambda i: norm_squared(verts[i] - tmp_j_vert))\n        # Closest point of the detached rings to the aforementioned\n        # point of the attached rings\n        j = min(j_range, key=lambda j: norm_squared(verts[i] - verts[j]))\n        # Recalculate i based on new j\n        i = min(i_range, key=lambda i: norm_squared(verts[i] - verts[j]))\n\n        # Remember to connect the polygon at these points\n        loop_connections[i] = j\n        loop_connections[j] = i\n\n        # Move the ring which j belongs to from the\n        # attached list to the detached list\n        new_ring = next(\n            (ring for ring in detached_rings if ring[0] <= j < ring[-1]), None\n        )\n        if new_ring is not None:\n            detached_rings.remove(new_ring)\n            attached_rings.append(new_ring)\n        else:\n            raise Exception(\"Could not find a ring to attach\")\n\n    # Setup linked list\n    after: list[int] = []\n    end0 = 0\n    for end1 in ring_ends:\n        after.extend(range(end0 + 1, end1))\n        after.append(end0)\n        end0 = end1\n\n    # Find an ordering of indices walking around the polygon\n    indices = []\n    i = 0\n    for _ in range(len(verts) + len(ring_ends) - 1):\n        # starting = False\n        if i in loop_connections:\n            j = loop_connections[i]\n            indices.extend([i, j])\n            i = after[j]\n        else:\n            indices.append(i)\n            i = after[i]\n        if i == 0:\n            break\n\n    meta_indices = earcut(verts[indices, :2], [len(indices)])\n    return [indices[mi] for mi in meta_indices]\n\n\n\n\n[docs]\ndef cartesian_to_spherical(vec: Sequence[float]) -> np.ndarray:\n    \"\"\"Returns an array of numbers corresponding to each\n    polar coordinate value (distance, phi, theta).\n\n    Parameters\n    ----------\n    vec\n        A numpy array ``[x, y, z]``.\n    \"\"\"\n    norm = np.linalg.norm(vec)\n    if norm == 0:\n        return 0, 0, 0\n    r = norm\n    phi = np.arccos(vec[2] / r)\n    theta = np.arctan2(vec[1], vec[0])\n    return np.array([r, theta, phi])\n\n\n\n\n[docs]\ndef spherical_to_cartesian(spherical: Sequence[float]) -> np.ndarray:\n    \"\"\"Returns a numpy array ``[x, y, z]`` based on the spherical\n    coordinates given.\n\n    Parameters\n    ----------\n    spherical\n        A list of three floats that correspond to the following:\n\n        r - The distance between the point and the origin.\n\n        theta - The azimuthal angle of the point to the positive x-axis.\n\n        phi - The vertical angle of the point to the positive z-axis.\n    \"\"\"\n    r, theta, phi = spherical\n    return np.array(\n        [\n            r * np.cos(theta) * np.sin(phi),\n            r * np.sin(theta) * np.sin(phi),\n            r * np.cos(phi),\n        ],\n    )\n\n\n\n\n[docs]\ndef perpendicular_bisector(\n    line: Sequence[np.ndarray],\n    norm_vector: Vector3D = OUT,\n) -> Sequence[np.ndarray]:\n    \"\"\"Returns a list of two points that correspond\n    to the ends of the perpendicular bisector of the\n    two points given.\n\n    Parameters\n    ----------\n    line\n        a list of two numpy array points (corresponding\n        to the ends of a line).\n    norm_vector\n        the vector perpendicular to both the line given\n        and the perpendicular bisector.\n\n    Returns\n    -------\n    list\n        A list of two numpy array points that correspond\n        to the ends of the perpendicular bisector\n    \"\"\"\n    p1 = line[0]\n    p2 = line[1]\n    direction = cross(p1 - p2, norm_vector)\n    m = midpoint(p1, p2)\n    return [m + direction, m - direction]", "code_sha1": "4b6d2f3b478ccb0072e0732f6fa6be4d67c8dfbc"}
{"url": "https://docs.manim.community/en/stable/_modules/manim/utils/tex_templates.html", "depth": 2, "instruction": "The code defines a library of LaTeX templates for typesetting in Manim, featuring various font styles and configurations. Each template includes specific LaTeX packages and settings, allowing for diverse typography in mathematical expressions. The templates can be used with `Tex` and `MathTex` objects to render text in different styles, depending on the installed fonts.", "code": "\"\"\"A library of LaTeX templates.\"\"\"\n\nfrom __future__ import annotations\n\n__all__ = [\n    \"TexTemplateLibrary\",\n    \"TexFontTemplates\",\n]\n\nfrom .tex import *\n\n# This file makes TexTemplateLibrary and TexFontTemplates available for use in manim Tex and MathTex objects.\n\n\ndef _new_ams_template() -> TexTemplate:\n    \"\"\"Returns a simple Tex Template with only basic AMS packages\"\"\"\n    preamble = r\"\"\"\n\\usepackage[english]{babel}\n\\usepackage{amsmath}\n\\usepackage{amssymb}\n\"\"\"\n    return TexTemplate(preamble=preamble)\n\n\n\"\"\" Tex Template preamble used by original upstream 3b1b \"\"\"\n_3b1b_preamble = r\"\"\"\n\\usepackage[english]{babel}\n\\usepackage[utf8]{inputenc}\n\\usepackage[T1]{fontenc}\n\\usepackage{lmodern}\n\\usepackage{amsmath}\n\\usepackage{amssymb}\n\\usepackage{dsfont}\n\\usepackage{setspace}\n\\usepackage{tipa}\n\\usepackage{relsize}\n\\usepackage{textcomp}\n\\usepackage{mathrsfs}\n\\usepackage{calligra}\n\\usepackage{wasysym}\n\\usepackage{ragged2e}\n\\usepackage{physics}\n\\usepackage{xcolor}\n\\usepackage{microtype}\n\\DisableLigatures{encoding = *, family = * }\n\\linespread{1}\n\"\"\"\n\n\n# TexTemplateLibrary\n#\n\n[docs]\nclass TexTemplateLibrary:\n    \"\"\"\n    A collection of basic TeX template objects\n\n    Examples\n    --------\n    Normal usage as a value for the keyword argument tex_template of Tex() and MathTex() mobjects::\n\n        ``Tex(\"My TeX code\", tex_template=TexTemplateLibrary.ctex)``\n\n    \"\"\"\n\n    default = TexTemplate(preamble=_3b1b_preamble)\n    \"\"\"An instance of the default TeX template in manim\"\"\"\n\n    threeb1b = TexTemplate(preamble=_3b1b_preamble)\n    \"\"\" An instance of the default TeX template used by 3b1b \"\"\"\n\n    ctex = TexTemplate(\n        tex_compiler=\"xelatex\",\n        output_format=\".xdv\",\n        preamble=_3b1b_preamble.replace(\n            r\"\\DisableLigatures{encoding = *, family = * }\",\n            r\"\\usepackage[UTF8]{ctex}\",\n        ),\n    )\n    \"\"\"An instance of the TeX template used by 3b1b when using the use_ctex flag\"\"\"\n\n    simple = _new_ams_template()\n    \"\"\"An instance of a simple TeX template with only basic AMS packages loaded\"\"\"\n\n\n\n# TexFontTemplates\n#\n# TexFontTemplates takes a font_id and returns the appropriate TexTemplate()\n# Usage:\n#       my_tex_template = TexFontTemplates.font_id\n#\n# Note: not all of these will work out-of-the-box.\n# They may require specific fonts to be installed on the local system.\n# For example TexFontTemplates.comic_sans will only work if the Microsoft font 'Comic Sans'\n# is installed on the local system.\n#\n# More information on these templates, along with example output can be found at\n# http://jf.burnol.free.fr/showcase.html\"\n#\n#\n# Choices for font_id are:\n#\n# american_typewriter       : \"American Typewriter\"\n# antykwa                   : \"Antykwa Półtawskiego (TX Fonts for Greek and math symbols)\"\n# apple_chancery            : \"Apple Chancery\"\n# auriocus_kalligraphicus   : \"Auriocus Kalligraphicus (Symbol Greek)\"\n# baskervald_adf_fourier    : \"Baskervald ADF with Fourier\"\n# baskerville_it            : \"Baskerville (Italic)\"\n# biolinum                  : \"Biolinum\"\n# brushscriptx              : \"BrushScriptX-Italic (PX math and Greek)\"\n# chalkboard_se             : \"Chalkboard SE\"\n# chalkduster               : \"Chalkduster\"\n# comfortaa                 : \"Comfortaa\"\n# comic_sans                : \"Comic Sans MS\"\n# droid_sans                : \"Droid Sans\"\n# droid_sans_it             : \"Droid Sans (Italic)\"\n# droid_serif               : \"Droid Serif\"\n# droid_serif_px_it         : \"Droid Serif (PX math symbols) (Italic)\"\n# ecf_augie                 : \"ECF Augie (Euler Greek)\"\n# ecf_jd                    : \"ECF JD (with TX fonts)\"\n# ecf_skeetch               : \"ECF Skeetch (CM Greek)\"\n# ecf_tall_paul             : \"ECF Tall Paul (with Symbol font)\"\n# ecf_webster               : \"ECF Webster (with TX fonts)\"\n# electrum_adf              : \"Electrum ADF (CM Greek)\"\n# epigrafica                : Epigrafica\n# fourier_utopia            : \"Fourier Utopia (Fourier upright Greek)\"\n# french_cursive            : \"French Cursive (Euler Greek)\"\n# gfs_bodoni                : \"GFS Bodoni\"\n# gfs_didot                 : \"GFS Didot (Italic)\"\n# gfs_neoHellenic           : \"GFS NeoHellenic\"\n# gnu_freesans_tx           : \"GNU FreeSerif (and TX fonts symbols)\"\n# gnu_freeserif_freesans    : \"GNU FreeSerif and FreeSans\"\n# helvetica_fourier_it      : \"Helvetica with Fourier (Italic)\"\n# latin_modern_tw_it        : \"Latin Modern Typewriter Proportional (CM Greek) (Italic)\"\n# latin_modern_tw           : \"Latin Modern Typewriter Proportional\"\n# libertine                 : \"Libertine\"\n# libris_adf_fourier        : \"Libris ADF with Fourier\"\n# minion_pro_myriad_pro     : \"Minion Pro and Myriad Pro (and TX fonts symbols)\"\n# minion_pro_tx             : \"Minion Pro (and TX fonts symbols)\"\n# new_century_schoolbook    : \"New Century Schoolbook (Symbol Greek)\"\n# new_century_schoolbook_px : \"New Century Schoolbook (Symbol Greek, PX math symbols)\"\n# noteworthy_light          : \"Noteworthy Light\"\n# palatino                  : \"Palatino (Symbol Greek)\"\n# papyrus                   : \"Papyrus\"\n# romande_adf_fourier_it    : \"Romande ADF with Fourier (Italic)\"\n# slitex                    : \"SliTeX (Euler Greek)\"\n# times_fourier_it          : \"Times with Fourier (Italic)\"\n# urw_avant_garde           : \"URW Avant Garde (Symbol Greek)\"\n# urw_zapf_chancery         : \"URW Zapf Chancery (CM Greek)\"\n# venturis_adf_fourier_it   : \"Venturis ADF with Fourier (Italic)\"\n# verdana_it                : \"Verdana (Italic)\"\n# vollkorn_fourier_it       : \"Vollkorn with Fourier (Italic)\"\n# vollkorn                  : \"Vollkorn (TX fonts for Greek and math symbols)\"\n# zapf_chancery             : \"Zapf Chancery\"\n# -----------------------------------------------------------------------------------------\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n\n# Latin Modern Typewriter Proportional\nlmtp = _new_ams_template()\nlmtp.description = \"Latin Modern Typewriter Proportional\"\nlmtp.add_to_preamble(\n    r\"\"\"\n\\usepackage[T1]{fontenc}\n\\usepackage[variablett]{lmodern}\n\\renewcommand{\\rmdefault}{\\ttdefault}\n\\usepackage[LGRgreek]{mathastext}\n\\MTgreekfont{lmtt} % no lgr lmvtt, so use lgr lmtt\n\\Mathastext\n\\let\\varepsilon\\epsilon % only \\varsigma in LGR\n\"\"\",\n)\n\n\n# Fourier Utopia (Fourier upright Greek)\nfufug = _new_ams_template()\nfufug.description = \"Fourier Utopia (Fourier upright Greek)\"\nfufug.add_to_preamble(\n    r\"\"\"\n\\usepackage[T1]{fontenc}\n\\usepackage[upright]{fourier}\n\\usepackage{mathastext}\n\"\"\",\n)\n\n\n# Droid Serif\ndroidserif = _new_ams_template()\ndroidserif.description = \"Droid Serif\"\ndroidserif.add_to_preamble(\n    r\"\"\"\n\\usepackage[T1]{fontenc}\n\\usepackage[default]{droidserif}\n\\usepackage[LGRgreek]{mathastext}\n\\let\\varepsilon\\epsilon\n\"\"\",\n)\n\n\n# Droid Sans\ndroidsans = _new_ams_template()\ndroidsans.description = \"Droid Sans\"\ndroidsans.add_to_preamble(\n    r\"\"\"\n\\usepackage[T1]{fontenc}\n\\usepackage[default]{droidsans}\n\\usepackage[LGRgreek]{mathastext}\n\\let\\varepsilon\\epsilon\n\"\"\",\n)\n\n\n# New Century Schoolbook (Symbol Greek)\nncssg = _new_ams_template()\nncssg.description = \"New Century Schoolbook (Symbol Greek)\"\nncssg.add_to_preamble(\n    r\"\"\"\n\\usepackage[T1]{fontenc}\n\\usepackage{newcent}\n\\usepackage[symbolgreek]{mathastext}\n\\linespread{1.1}\n\"\"\",\n)\n\n\n# French Cursive (Euler Greek)\nfceg = _new_ams_template()\nfceg.description = \"French Cursive (Euler Greek)\"\nfceg.add_to_preamble(\n    r\"\"\"\n\\usepackage[T1]{fontenc}\n\\usepackage[default]{frcursive}\n\\usepackage[eulergreek,noplusnominus,noequal,nohbar,%\nnolessnomore,noasterisk]{mathastext}\n\"\"\",\n)\n\n\n# Auriocus Kalligraphicus (Symbol Greek)\naksg = _new_ams_template()\naksg.description = \"Auriocus Kalligraphicus (Symbol Greek)\"\naksg.add_to_preamble(\n    r\"\"\"\n\\usepackage[T1]{fontenc}\n\\usepackage{aurical}\n\\renewcommand{\\rmdefault}{AuriocusKalligraphicus}\n\\usepackage[symbolgreek]{mathastext}\n\"\"\",\n)\n\n\n# Palatino (Symbol Greek)\npalatinosg = _new_ams_template()\npalatinosg.description = \"Palatino (Symbol Greek)\"\npalatinosg.add_to_preamble(\n    r\"\"\"\n\\usepackage[T1]{fontenc}\n\\usepackage{palatino}\n\\usepackage[symbolmax,defaultmathsizes]{mathastext}\n\"\"\",\n)\n\n\n# Comfortaa\ncomfortaa = _new_ams_template()\ncomfortaa.description = \"Comfortaa\"\ncomfortaa.add_to_preamble(\n    r\"\"\"\n\\usepackage[default]{comfortaa}\n\\usepackage[LGRgreek,defaultmathsizes,noasterisk]{mathastext}\n\\let\\varphi\\phi\n\\linespread{1.06}\n\"\"\",\n)\n\n\n# ECF Augie (Euler Greek)\necfaugieeg = _new_ams_template()\necfaugieeg.description = \"ECF Augie (Euler Greek)\"\necfaugieeg.add_to_preamble(\n    r\"\"\"\n\\renewcommand\\familydefault{fau} % emerald package\n\\usepackage[defaultmathsizes,eulergreek]{mathastext}\n\"\"\",\n)\n\n\n# Electrum ADF (CM Greek)\nelectrumadfcm = _new_ams_template()\nelectrumadfcm.description = \"Electrum ADF (CM Greek)\"\nelectrumadfcm.add_to_preamble(\n    r\"\"\"\n\\usepackage[T1]{fontenc}\n\\usepackage[LGRgreek,basic,defaultmathsizes]{mathastext}\n\\usepackage[lf]{electrum}\n\\Mathastext\n\\let\\varphi\\phi\n\"\"\",\n)\n\n\n# American Typewriter\namericantypewriter = _new_ams_template()\namericantypewriter.description = \"American Typewriter\"\namericantypewriter.add_to_preamble(\n    r\"\"\"\n\\usepackage[no-math]{fontspec}\n\\setmainfont[Mapping=tex-text]{American Typewriter}\n\\usepackage[defaultmathsizes]{mathastext}\n\"\"\",\n)\namericantypewriter.tex_compiler = \"xelatex\"\namericantypewriter.output_format = \".xdv\"\n\n# Minion Pro and Myriad Pro (and TX fonts symbols)\nmpmptx = _new_ams_template()\nmpmptx.description = \"Minion Pro and Myriad Pro (and TX fonts symbols)\"\nmpmptx.add_to_preamble(\n    r\"\"\"\n\\usepackage{txfonts}\n\\usepackage[upright]{txgreeks}\n\\usepackage[no-math]{fontspec}\n\\setmainfont[Mapping=tex-text]{Minion Pro}\n\\setsansfont[Mapping=tex-text,Scale=MatchUppercase]{Myriad Pro}\n\\renewcommand\\familydefault\\sfdefault\n\\usepackage[defaultmathsizes]{mathastext}\n\\renewcommand\\familydefault\\rmdefault\n\"\"\",\n)\nmpmptx.tex_compiler = \"xelatex\"\nmpmptx.output_format = \".xdv\"\n\n\n# New Century Schoolbook (Symbol Greek, PX math symbols)\nncssgpxm = _new_ams_template()\nncssgpxm.description = \"New Century Schoolbook (Symbol Greek, PX math symbols)\"\nncssgpxm.add_to_preamble(\n    r\"\"\"\n\\usepackage[T1]{fontenc}\n\\usepackage{pxfonts}\n\\usepackage{newcent}\n\\usepackage[symbolgreek,defaultmathsizes]{mathastext}\n\\linespread{1.06}\n\"\"\",\n)\n\n\n# Vollkorn (TX fonts for Greek and math symbols)\nvollkorntx = _new_ams_template()\nvollkorntx.description = \"Vollkorn (TX fonts for Greek and math symbols)\"\nvollkorntx.add_to_preamble(\n    r\"\"\"\n\\usepackage[T1]{fontenc}\n\\usepackage{txfonts}\n\\usepackage[upright]{txgreeks}\n\\usepackage{vollkorn}\n\\usepackage[defaultmathsizes]{mathastext}\n\"\"\",\n)\n\n\n# Libertine\nlibertine = _new_ams_template()\nlibertine.description = \"Libertine\"\nlibertine.add_to_preamble(\n    r\"\"\"\n\\usepackage[T1]{fontenc}\n\\usepackage{libertine}\n\\usepackage[greek=n]{libgreek}\n\\usepackage[noasterisk,defaultmathsizes]{mathastext}\n\"\"\",\n)\n\n\n# SliTeX (Euler Greek)\nslitexeg = _new_ams_template()\nslitexeg.description = \"SliTeX (Euler Greek)\"\nslitexeg.add_to_preamble(\n    r\"\"\"\n\\usepackage[T1]{fontenc}\n\\usepackage{tpslifonts}\n\\usepackage[eulergreek,defaultmathsizes]{mathastext}\n\\MTEulerScale{1.06}\n\\linespread{1.2}\n\"\"\",\n)\n\n\n# ECF Webster (with TX fonts)\necfwebstertx = _new_ams_template()\necfwebstertx.description = \"ECF Webster (with TX fonts)\"\necfwebstertx.add_to_preamble(\n    r\"\"\"\n\\usepackage{txfonts}\n\\usepackage[upright]{txgreeks}\n\\renewcommand\\familydefault{fwb} % emerald package\n\\usepackage{mathastext}\n\\renewcommand{\\int}{\\intop\\limits}\n\\linespread{1.5}\n\"\"\",\n)\necfwebstertx.add_to_document(\n    r\"\"\"\n\\mathversion{bold}\n\"\"\",\n)\n\n\n# Romande ADF with Fourier (Italic)\nitalicromandeadff = _new_ams_template()\nitalicromandeadff.description = \"Romande ADF with Fourier (Italic)\"\nitalicromandeadff.add_to_preamble(\n    r\"\"\"\n\\usepackage[T1]{fontenc}\n\\usepackage{fourier}\n\\usepackage{romande}\n\\usepackage[italic,defaultmathsizes,noasterisk]{mathastext}\n\\renewcommand{\\itshape}{\\swashstyle}\n\"\"\",\n)\n\n\n# Apple Chancery\napplechancery = _new_ams_template()\napplechancery.description = \"Apple Chancery\"\napplechancery.add_to_preamble(\n    r\"\"\"\n\\usepackage[no-math]{fontspec}\n\\setmainfont[Mapping=tex-text]{Apple Chancery}\n\\usepackage[defaultmathsizes]{mathastext}\n\"\"\",\n)\napplechancery.tex_compiler = \"xelatex\"\napplechancery.output_format = \".xdv\"\n\n\n# Zapf Chancery\nzapfchancery = _new_ams_template()\nzapfchancery.description = \"Zapf Chancery\"\nzapfchancery.add_to_preamble(\n    r\"\"\"\n\\DeclareFontFamily{T1}{pzc}{}\n\\DeclareFontShape{T1}{pzc}{mb}{it}{<->s*[1.2] pzcmi8t}{}\n\\DeclareFontShape{T1}{pzc}{m}{it}{<->ssub * pzc/mb/it}{}\n\\usepackage{chancery} % = \\renewcommand{\\rmdefault}{pzc}\n\\renewcommand\\shapedefault\\itdefault\n\\renewcommand\\bfdefault\\mddefault\n\\usepackage[defaultmathsizes]{mathastext}\n\\linespread{1.05}\n\"\"\",\n)\n\n\n# Verdana (Italic)\nitalicverdana = _new_ams_template()\nitalicverdana.description = \"Verdana (Italic)\"\nitalicverdana.add_to_preamble(\n    r\"\"\"\n\\usepackage[no-math]{fontspec}\n\\setmainfont[Mapping=tex-text]{Verdana}\n\\usepackage[defaultmathsizes,italic]{mathastext}\n\"\"\",\n)\nitalicverdana.tex_compiler = \"xelatex\"\nitalicverdana.output_format = \".xdv\"\n\n\n# URW Zapf Chancery (CM Greek)\nurwzccmg = _new_ams_template()\nurwzccmg.description = \"URW Zapf Chancery (CM Greek)\"\nurwzccmg.add_to_preamble(\n    r\"\"\"\n\\usepackage[T1]{fontenc}\n\\DeclareFontFamily{T1}{pzc}{}\n\\DeclareFontShape{T1}{pzc}{mb}{it}{<->s*[1.2] pzcmi8t}{}\n\\DeclareFontShape{T1}{pzc}{m}{it}{<->ssub * pzc/mb/it}{}\n\\DeclareFontShape{T1}{pzc}{mb}{sl}{<->ssub * pzc/mb/it}{}\n\\DeclareFontShape{T1}{pzc}{m}{sl}{<->ssub * pzc/mb/sl}{}\n\\DeclareFontShape{T1}{pzc}{m}{n}{<->ssub * pzc/mb/it}{}\n\\usepackage{chancery}\n\\usepackage{mathastext}\n\\linespread{1.05}\"\"\",\n)\nurwzccmg.add_to_document(\n    r\"\"\"\n\\boldmath\n\"\"\",\n)\n\n\n# Comic Sans MS\ncomicsansms = _new_ams_template()\ncomicsansms.description = \"Comic Sans MS\"\ncomicsansms.add_to_preamble(\n    r\"\"\"\n\\usepackage[no-math]{fontspec}\n\\setmainfont[Mapping=tex-text]{Comic Sans MS}\n\\usepackage[defaultmathsizes]{mathastext}\n\"\"\",\n)\ncomicsansms.tex_compiler = \"xelatex\"\ncomicsansms.output_format = \".xdv\"\n\n\n# GFS Didot (Italic)\nitalicgfsdidot = _new_ams_template()\nitalicgfsdidot.description = \"GFS Didot (Italic)\"\nitalicgfsdidot.add_to_preamble(\n    r\"\"\"\n\\usepackage[T1]{fontenc}\n\\renewcommand\\rmdefault{udidot}\n\\usepackage[LGRgreek,defaultmathsizes,italic]{mathastext}\n\\let\\varphi\\phi\n\"\"\",\n)\n\n\n# Chalkduster\nchalkduster = _new_ams_template()\nchalkduster.description = \"Chalkduster\"\nchalkduster.add_to_preamble(\n    r\"\"\"\n\\usepackage[no-math]{fontspec}\n\\setmainfont[Mapping=tex-text]{Chalkduster}\n\\usepackage[defaultmathsizes]{mathastext}\n\"\"\",\n)\nchalkduster.tex_compiler = \"lualatex\"\nchalkduster.output_format = \".pdf\"\n\n\n# Minion Pro (and TX fonts symbols)\nmptx = _new_ams_template()\nmptx.description = \"Minion Pro (and TX fonts symbols)\"\nmptx.add_to_preamble(\n    r\"\"\"\n\\usepackage{txfonts}\n\\usepackage[no-math]{fontspec}\n\\setmainfont[Mapping=tex-text]{Minion Pro}\n\\usepackage[defaultmathsizes]{mathastext}\n\"\"\",\n)\nmptx.tex_compiler = \"xelatex\"\nmptx.output_format = \".xdv\"\n\n\n# GNU FreeSerif and FreeSans\ngnufsfs = _new_ams_template()\ngnufsfs.description = \"GNU FreeSerif and FreeSans\"\ngnufsfs.add_to_preamble(\n    r\"\"\"\n\\usepackage[no-math]{fontspec}\n\\setmainfont[ExternalLocation,\n                Mapping=tex-text,\n                BoldFont=FreeSerifBold,\n                ItalicFont=FreeSerifItalic,\n                BoldItalicFont=FreeSerifBoldItalic]{FreeSerif}\n\\setsansfont[ExternalLocation,\n                Mapping=tex-text,\n                BoldFont=FreeSansBold,\n                ItalicFont=FreeSansOblique,\n                BoldItalicFont=FreeSansBoldOblique,\n                Scale=MatchLowercase]{FreeSans}\n\\renewcommand{\\familydefault}{lmss}\n\\usepackage[LGRgreek,defaultmathsizes,noasterisk]{mathastext}\n\\renewcommand{\\familydefault}{\\sfdefault}\n\\Mathastext\n\\let\\varphi\\phi % no `var' phi in LGR encoding\n\\renewcommand{\\familydefault}{\\rmdefault}\n\"\"\",\n)\ngnufsfs.tex_compiler = \"xelatex\"\ngnufsfs.output_format = \".xdv\"\n\n# GFS NeoHellenic\ngfsneohellenic = _new_ams_template()\ngfsneohellenic.description = \"GFS NeoHellenic\"\ngfsneohellenic.add_to_preamble(\n    r\"\"\"\n\\usepackage[T1]{fontenc}\n\\renewcommand{\\rmdefault}{neohellenic}\n\\usepackage[LGRgreek]{mathastext}\n\\let\\varphi\\phi\n\\linespread{1.06}\n\"\"\",\n)\n\n\n# ECF Tall Paul (with Symbol font)\necftallpaul = _new_ams_template()\necftallpaul.description = \"ECF Tall Paul (with Symbol font)\"\necftallpaul.add_to_preamble(\n    r\"\"\"\n\\DeclareFontFamily{T1}{ftp}{}\n\\DeclareFontShape{T1}{ftp}{m}{n}{\n    <->s*[1.4] ftpmw8t\n}{} % increase size by factor 1.4\n\\renewcommand\\familydefault{ftp} % emerald package\n\\usepackage[symbol]{mathastext}\n\\let\\infty\\inftypsy\n\"\"\",\n)\n\n\n# Droid Sans (Italic)\nitalicdroidsans = _new_ams_template()\nitalicdroidsans.description = \"Droid Sans (Italic)\"\nitalicdroidsans.add_to_preamble(\n    r\"\"\"\n\\usepackage[T1]{fontenc}\n\\usepackage[default]{droidsans}\n\\usepackage[LGRgreek,defaultmathsizes,italic]{mathastext}\n\\let\\varphi\\phi\n\"\"\",\n)\n\n\n# Baskerville (Italic)\nitalicbaskerville = _new_ams_template()\nitalicbaskerville.description = \"Baskerville (Italic)\"\nitalicbaskerville.add_to_preamble(\n    r\"\"\"\n\\usepackage[no-math]{fontspec}\n\\setmainfont[Mapping=tex-text]{Baskerville}\n\\usepackage[defaultmathsizes,italic]{mathastext}\n\"\"\",\n)\nitalicbaskerville.tex_compiler = \"xelatex\"\nitalicbaskerville.output_format = \".xdv\"\n\n\n# ECF JD (with TX fonts)\necfjdtx = _new_ams_template()\necfjdtx.description = \"ECF JD (with TX fonts)\"\necfjdtx.add_to_preamble(\n    r\"\"\"\n\\usepackage{txfonts}\n\\usepackage[upright]{txgreeks}\n\\renewcommand\\familydefault{fjd} % emerald package\n\\usepackage{mathastext}\n\"\"\",\n)\necfjdtx.add_to_document(\n    r\"\"\"\\mathversion{bold}\n\"\"\",\n)\n\n\n# Antykwa Półtawskiego (TX Fonts for Greek and math symbols)\naptxgm = _new_ams_template()\naptxgm.description = \"Antykwa Półtawskiego (TX Fonts for Greek and math symbols)\"\naptxgm.add_to_preamble(\n    r\"\"\"\n\\usepackage[OT4,OT1]{fontenc}\n\\usepackage{txfonts}\n\\usepackage[upright]{txgreeks}\n\\usepackage{antpolt}\n\\usepackage[defaultmathsizes,nolessnomore]{mathastext}\n\"\"\",\n)\n\n\n# Papyrus\npapyrus = _new_ams_template()\npapyrus.description = \"Papyrus\"\npapyrus.add_to_preamble(\n    r\"\"\"\n\\usepackage[no-math]{fontspec}\n\\setmainfont[Mapping=tex-text]{Papyrus}\n\\usepackage[defaultmathsizes]{mathastext}\n\"\"\",\n)\npapyrus.tex_compiler = \"xelatex\"\npapyrus.output_format = \".xdv\"\n\n\n# GNU FreeSerif (and TX fonts symbols)\ngnufstx = _new_ams_template()\ngnufstx.description = \"GNU FreeSerif (and TX fonts symbols)\"\ngnufstx.add_to_preamble(\n    r\"\"\"\n\\usepackage[no-math]{fontspec}\n\\usepackage{txfonts}  %\\let\\mathbb=\\varmathbb\n\\setmainfont[ExternalLocation,\n                Mapping=tex-text,\n                BoldFont=FreeSerifBold,\n                ItalicFont=FreeSerifItalic,\n                BoldItalicFont=FreeSerifBoldItalic]{FreeSerif}\n\\usepackage[defaultmathsizes]{mathastext}\n\"\"\",\n)\ngnufstx.tex_compiler = \"xelatex\"\ngnufstx.output_format = \".pdf\"\n\n\n# ECF Skeetch (CM Greek)\necfscmg = _new_ams_template()\necfscmg.description = \"ECF Skeetch (CM Greek)\"\necfscmg.add_to_preamble(\n    r\"\"\"\n\\usepackage[T1]{fontenc}\n\\usepackage[T1]{fontenc}\n\\DeclareFontFamily{T1}{fsk}{}\n\\DeclareFontShape{T1}{fsk}{m}{n}{<->s*[1.315] fskmw8t}{}\n\\renewcommand\\rmdefault{fsk}\n\\usepackage[noendash,defaultmathsizes,nohbar,defaultimath]{mathastext}\n\"\"\",\n)\n\n\n# Latin Modern Typewriter Proportional (CM Greek) (Italic)\nitaliclmtpcm = _new_ams_template()\nitaliclmtpcm.description = \"Latin Modern Typewriter Proportional (CM Greek) (Italic)\"\nitaliclmtpcm.add_to_preamble(\n    r\"\"\"\n\\usepackage[T1]{fontenc}\n\\usepackage[variablett,nomath]{lmodern}\n\\renewcommand{\\familydefault}{\\ttdefault}\n\\usepackage[frenchmath]{mathastext}\n\\linespread{1.08}\n\"\"\",\n)\n\n\n# Baskervald ADF with Fourier\nbaskervaldadff = _new_ams_template()\nbaskervaldadff.description = \"Baskervald ADF with Fourier\"\nbaskervaldadff.add_to_preamble(\n    r\"\"\"\n\\usepackage[upright]{fourier}\n\\usepackage{baskervald}\n\\usepackage[defaultmathsizes,noasterisk]{mathastext}\n\"\"\",\n)\n\n\n# Droid Serif (PX math symbols) (Italic)\nitalicdroidserifpx = _new_ams_template()\nitalicdroidserifpx.description = \"Droid Serif (PX math symbols) (Italic)\"\nitalicdroidserifpx.add_to_preamble(\n    r\"\"\"\n\\usepackage[T1]{fontenc}\n\\usepackage{pxfonts}\n\\usepackage[default]{droidserif}\n\\usepackage[LGRgreek,defaultmathsizes,italic,basic]{mathastext}\n\\let\\varphi\\phi\n\"\"\",\n)\n\n\n# Biolinum\nbiolinum = _new_ams_template()\nbiolinum.description = \"Biolinum\"\nbiolinum.add_to_preamble(\n    r\"\"\"\n\\usepackage[T1]{fontenc}\n\\usepackage{libertine}\n\\renewcommand{\\familydefault}{\\sfdefault}\n\\usepackage[greek=n,biolinum]{libgreek}\n\\usepackage[noasterisk,defaultmathsizes]{mathastext}\n\"\"\",\n)\n\n\n# Vollkorn with Fourier (Italic)\nitalicvollkornf = _new_ams_template()\nitalicvollkornf.description = \"Vollkorn with Fourier (Italic)\"\nitalicvollkornf.add_to_preamble(\n    r\"\"\"\n\\usepackage{fourier}\n\\usepackage{vollkorn}\n\\usepackage[italic,nohbar]{mathastext}\n\"\"\",\n)\n\n\n# Chalkboard SE\nchalkboardse = _new_ams_template()\nchalkboardse.description = \"Chalkboard SE\"\nchalkboardse.add_to_preamble(\n    r\"\"\"\n\\usepackage[no-math]{fontspec}\n\\setmainfont[Mapping=tex-text]{Chalkboard SE}\n\\usepackage[defaultmathsizes]{mathastext}\n\"\"\",\n)\nchalkboardse.tex_compiler = \"xelatex\"\nchalkboardse.output_format = \".xdv\"\n\n\n# Noteworthy Light\nnoteworthylight = _new_ams_template()\nnoteworthylight.description = \"Noteworthy Light\"\nnoteworthylight.add_to_preamble(\n    r\"\"\"\n\\usepackage[no-math]{fontspec}\n\\setmainfont[Mapping=tex-text]{Noteworthy Light}\n\\usepackage[defaultmathsizes]{mathastext}\n\"\"\",\n)\n\n\n# Epigrafica\nepigrafica = _new_ams_template()\nepigrafica.description = \"Epigrafica\"\nepigrafica.add_to_preamble(\n    r\"\"\"\n\\usepackage[LGR,OT1]{fontenc}\n\\usepackage{epigrafica}\n\\usepackage[basic,LGRgreek,defaultmathsizes]{mathastext}\n\\let\\varphi\\phi\n\\linespread{1.2}\n\"\"\",\n)\n\n\n# Libris ADF with Fourier\nlibrisadff = _new_ams_template()\nlibrisadff.description = \"Libris ADF with Fourier\"\nlibrisadff.add_to_preamble(\n    r\"\"\"\n\\usepackage[T1]{fontenc}\n\\usepackage[upright]{fourier}\n\\usepackage{libris}\n\\renewcommand{\\familydefault}{\\sfdefault}\n\\usepackage[noasterisk]{mathastext}\n\"\"\",\n)\n\n\n# Venturis ADF with Fourier (Italic)\nitalicvanturisadff = _new_ams_template()\nitalicvanturisadff.description = \"Venturis ADF with Fourier (Italic)\"\nitalicvanturisadff.add_to_preamble(\n    r\"\"\"\n\\usepackage{fourier}\n\\usepackage[lf]{venturis}\n\\usepackage[italic,defaultmathsizes,noasterisk]{mathastext}\n\"\"\",\n)\n\n\n# GFS Bodoni\ngfsbodoni = _new_ams_template()\ngfsbodoni.description = \"GFS Bodoni\"\ngfsbodoni.add_to_preamble(\n    r\"\"\"\n\\usepackage[T1]{fontenc}\n\\renewcommand{\\rmdefault}{bodoni}\n\\usepackage[LGRgreek]{mathastext}\n\\let\\varphi\\phi\n\\linespread{1.06}\n\"\"\",\n)\n\n\n# BrushScriptX-Italic (PX math and Greek)\nbrushscriptxpx = _new_ams_template()\nbrushscriptxpx.description = \"BrushScriptX-Italic (PX math and Greek)\"\nbrushscriptxpx.add_to_preamble(\n    r\"\"\"\n\\usepackage[T1]{fontenc}\n\\usepackage{pxfonts}\n%\\usepackage{pbsi}\n\\renewcommand{\\rmdefault}{pbsi}\n\\renewcommand{\\mddefault}{xl}\n\\renewcommand{\\bfdefault}{xl}\n\\usepackage[defaultmathsizes,noasterisk]{mathastext}\n\"\"\",\n)\nbrushscriptxpx.add_to_document(\n    r\"\"\"\\boldmath\n\"\"\",\n)\nbrushscriptxpx.tex_compiler = \"xelatex\"\nbrushscriptxpx.output_format = \".xdv\"\n\n\n# URW Avant Garde (Symbol Greek)\nurwagsg = _new_ams_template()\nurwagsg.description = \"URW Avant Garde (Symbol Greek)\"\nurwagsg.add_to_preamble(\n    r\"\"\"\n\\usepackage[T1]{fontenc}\n\\usepackage{avant}\n\\renewcommand{\\familydefault}{\\sfdefault}\n\\usepackage[symbolgreek,defaultmathsizes]{mathastext}\n\"\"\",\n)\n\n\n# Times with Fourier (Italic)\nitalictimesf = _new_ams_template()\nitalictimesf.description = \"Times with Fourier (Italic)\"\nitalictimesf.add_to_preamble(\n    r\"\"\"\n\\usepackage{fourier}\n\\renewcommand{\\rmdefault}{ptm}\n\\usepackage[italic,defaultmathsizes,noasterisk]{mathastext}\n\"\"\",\n)\n\n\n# Helvetica with Fourier (Italic)\nitalichelveticaf = _new_ams_template()\nitalichelveticaf.description = \"Helvetica with Fourier (Italic)\"\nitalichelveticaf.add_to_preamble(\n    r\"\"\"\n\\usepackage[T1]{fontenc}\n\\usepackage[scaled]{helvet}\n\\usepackage{fourier}\n\\renewcommand{\\rmdefault}{phv}\n\\usepackage[italic,defaultmathsizes,noasterisk]{mathastext}\n\"\"\",\n)\n\n\n\n[docs]\nclass TexFontTemplates:\n    \"\"\"\n    A collection of TeX templates for the fonts described at http://jf.burnol.free.fr/showcase.html\n\n    These templates are specifically designed to allow you to typeset formulae and mathematics using\n    different fonts. They are based on the mathastext LaTeX package.\n\n    Examples\n    ---------\n    Normal usage as a value for the keyword argument tex_template of Tex() and MathTex() mobjects::\n\n        ``Tex(\"My TeX code\", tex_template=TexFontTemplates.comic_sans)``\n\n    Notes\n    ------\n    Many of these templates require that specific fonts\n    are installed on your local machine.\n    For example, choosing the template TexFontTemplates.comic_sans will\n    not compile if the Comic Sans Microsoft font is not installed.\n\n    To experiment, try to render the TexFontTemplateLibrary example scene:\n         ``manim path/to/manim/example_scenes/advanced_tex_fonts.py TexFontTemplateLibrary -p -ql``\n    \"\"\"\n\n    american_typewriter = americantypewriter\n    \"\"\"American Typewriter\"\"\"\n    antykwa = aptxgm\n    \"\"\"Antykwa Półtawskiego (TX Fonts for Greek and math symbols)\"\"\"\n    apple_chancery = applechancery\n    \"\"\"Apple Chancery\"\"\"\n    auriocus_kalligraphicus = aksg\n    \"\"\"Auriocus Kalligraphicus (Symbol Greek)\"\"\"\n    baskervald_adf_fourier = baskervaldadff\n    \"\"\"Baskervald ADF with Fourier\"\"\"\n    baskerville_it = italicbaskerville\n    \"\"\"Baskerville (Italic)\"\"\"\n    biolinum = biolinum\n    \"\"\"Biolinum\"\"\"\n    brushscriptx = brushscriptxpx\n    \"\"\"BrushScriptX-Italic (PX math and Greek)\"\"\"\n    chalkboard_se = chalkboardse\n    \"\"\"Chalkboard SE\"\"\"\n    chalkduster = chalkduster\n    \"\"\"Chalkduster\"\"\"\n    comfortaa = comfortaa\n    \"\"\"Comfortaa\"\"\"\n    comic_sans = comicsansms\n    \"\"\"Comic Sans MS\"\"\"\n    droid_sans = droidsans\n    \"\"\"Droid Sans\"\"\"\n    droid_sans_it = italicdroidsans\n    \"\"\"Droid Sans (Italic)\"\"\"\n    droid_serif = droidserif\n    \"\"\"Droid Serif\"\"\"\n    droid_serif_px_it = italicdroidserifpx\n    \"\"\"Droid Serif (PX math symbols) (Italic)\"\"\"\n    ecf_augie = ecfaugieeg\n    \"\"\"ECF Augie (Euler Greek)\"\"\"\n    ecf_jd = ecfjdtx\n    \"\"\"ECF JD (with TX fonts)\"\"\"\n    ecf_skeetch = ecfscmg\n    \"\"\"ECF Skeetch (CM Greek)\"\"\"\n    ecf_tall_paul = ecftallpaul\n    \"\"\"ECF Tall Paul (with Symbol font)\"\"\"\n    ecf_webster = ecfwebstertx\n    \"\"\"ECF Webster (with TX fonts)\"\"\"\n    electrum_adf = electrumadfcm\n    \"\"\"Electrum ADF (CM Greek)\"\"\"\n    epigrafica = epigrafica\n    \"\"\" Epigrafica \"\"\"\n    fourier_utopia = fufug\n    \"\"\"Fourier Utopia (Fourier upright Greek)\"\"\"\n    french_cursive = fceg\n    \"\"\"French Cursive (Euler Greek)\"\"\"\n    gfs_bodoni = gfsbodoni\n    \"\"\"GFS Bodoni\"\"\"\n    gfs_didot = italicgfsdidot\n    \"\"\"GFS Didot (Italic)\"\"\"\n    gfs_neoHellenic = gfsneohellenic\n    \"\"\"GFS NeoHellenic\"\"\"\n    gnu_freesans_tx = gnufstx\n    \"\"\"GNU FreeSerif (and TX fonts symbols)\"\"\"\n    gnu_freeserif_freesans = gnufsfs\n    \"\"\"GNU FreeSerif and FreeSans\"\"\"\n    helvetica_fourier_it = italichelveticaf\n    \"\"\"Helvetica with Fourier (Italic)\"\"\"\n    latin_modern_tw_it = italiclmtpcm\n    \"\"\"Latin Modern Typewriter Proportional (CM Greek) (Italic)\"\"\"\n    latin_modern_tw = lmtp\n    \"\"\"Latin Modern Typewriter Proportional\"\"\"\n    libertine = libertine\n    \"\"\"Libertine\"\"\"\n    libris_adf_fourier = librisadff\n    \"\"\"Libris ADF with Fourier\"\"\"\n    minion_pro_myriad_pro = mpmptx\n    \"\"\"Minion Pro and Myriad Pro (and TX fonts symbols)\"\"\"\n    minion_pro_tx = mptx\n    \"\"\"Minion Pro (and TX fonts symbols)\"\"\"\n    new_century_schoolbook = ncssg\n    \"\"\"New Century Schoolbook (Symbol Greek)\"\"\"\n    new_century_schoolbook_px = ncssgpxm\n    \"\"\"New Century Schoolbook (Symbol Greek, PX math symbols)\"\"\"\n    noteworthy_light = noteworthylight\n    \"\"\"Noteworthy Light\"\"\"\n    palatino = palatinosg\n    \"\"\"Palatino (Symbol Greek)\"\"\"\n    papyrus = papyrus\n    \"\"\"Papyrus\"\"\"\n    romande_adf_fourier_it = italicromandeadff\n    \"\"\"Romande ADF with Fourier (Italic)\"\"\"\n    slitex = slitexeg\n    \"\"\"SliTeX (Euler Greek)\"\"\"\n    times_fourier_it = italictimesf\n    \"\"\"Times with Fourier (Italic)\"\"\"\n    urw_avant_garde = urwagsg\n    \"\"\"URW Avant Garde (Symbol Greek)\"\"\"\n    urw_zapf_chancery = urwzccmg\n    \"\"\"URW Zapf Chancery (CM Greek)\"\"\"\n    venturis_adf_fourier_it = italicvanturisadff\n    \"\"\"Venturis ADF with Fourier (Italic)\"\"\"\n    verdana_it = italicverdana\n    \"\"\"Verdana (Italic)\"\"\"\n    vollkorn_fourier_it = italicvollkornf\n    \"\"\"Vollkorn with Fourier (Italic)\"\"\"\n    vollkorn = vollkorntx\n    \"\"\"Vollkorn (TX fonts for Greek and math symbols)\"\"\"\n    zapf_chancery = zapfchancery\n    \"\"\"Zapf Chancery\"\"\"", "code_sha1": "cd769cf5e5f7220eb048ef4b2f2c7399eb79dec4"}
